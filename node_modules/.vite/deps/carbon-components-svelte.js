import {
  esm_default
} from "./chunk-FRJD3XQL.js";
import "./chunk-AYNHEKRI.js";
import {
  derived,
  readable,
  readonly,
  writable
} from "./chunk-6H45NDCP.js";
import {
  fade,
  slide
} from "./chunk-UMBOJVHX.js";
import "./chunk-ETWSND26.js";
import "./chunk-X7HCJ7ZS.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_flush_callback,
  add_location,
  add_render_callback,
  afterUpdate,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  beforeUpdate,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_block,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  get_svelte_dataset,
  globals,
  group_outros,
  head_selector,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  onMount,
  outro_and_destroy_block,
  prevent_default,
  prop_dev,
  run_all,
  safe_not_equal,
  select_option,
  setContext,
  set_attributes,
  set_data_dev,
  set_data_maybe_contenteditable_dev,
  set_input_value,
  set_store_value,
  set_style,
  set_svg_attributes,
  space,
  src_url_equal,
  stop_propagation,
  svg_element,
  text,
  tick,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-SR5HS6CC.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-L6OFPWCY.js";

// node_modules/carbon-components-svelte/src/icons/ChevronRight.svelte
var file = "node_modules/carbon-components-svelte/src/icons/ChevronRight.svelte";
function create_if_block(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 16L12 26 10.6 24.6 19.2 16 10.6 7.4 12 6z");
      add_location(path, file, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronRight", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var ChevronRight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronRight",
      options,
      id: create_fragment.name
    });
  }
  get size() {
    throw new Error("<ChevronRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChevronRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ChevronRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ChevronRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChevronRight_default = ChevronRight;

// node_modules/carbon-components-svelte/src/SkeletonText/SkeletonText.svelte
var file2 = "node_modules/carbon-components-svelte/src/SkeletonText/SkeletonText.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let p;
  let mounted;
  let dispose;
  let p_levels = [
    /*$$restProps*/
    ctx[7]
  ];
  let p_data = {};
  for (let i = 0; i < p_levels.length; i += 1) {
    p_data = assign(p_data, p_levels[i]);
  }
  const block = {
    c: function create() {
      p = element("p");
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      children(p).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(p, p_data);
      toggle_class(p, "bx--skeleton__text", true);
      toggle_class(
        p,
        "bx--skeleton__heading",
        /*heading*/
        ctx[1]
      );
      set_style(
        p,
        "width",
        /*width*/
        ctx[3]
      );
      add_location(p, file2, 39, 2, 1212);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            p,
            "click",
            /*click_handler_1*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            p,
            "mouseover",
            /*mouseover_handler_1*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            p,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            p,
            "mouseleave",
            /*mouseleave_handler_1*/
            ctx[15],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(p, p_data = get_spread_update(p_levels, [dirty & /*$$restProps*/
      128 && /*$$restProps*/
      ctx2[7]]));
      toggle_class(p, "bx--skeleton__text", true);
      toggle_class(
        p,
        "bx--skeleton__heading",
        /*heading*/
        ctx2[1]
      );
      set_style(
        p,
        "width",
        /*width*/
        ctx2[3]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(38:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(Array.from({ length: (
    /*lines*/
    ctx[0]
  ) }).map(
    /*func*/
    ctx[16]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let div_levels = [
    /*$$restProps*/
    ctx[7]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file2, 22, 2, 598);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*heading, Array, lines, widthPx, widthNum, Math, RANDOM, width*/
      123) {
        each_value = ensure_array_like_dev(Array.from({ length: (
          /*lines*/
          ctx2[0]
        ) }).map(
          /*func*/
          ctx2[16]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      128 && /*$$restProps*/
      ctx2[7]]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(21:0) {#if paragraph}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element("p");
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      children(p).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(p, "bx--skeleton__text", true);
      toggle_class(
        p,
        "bx--skeleton__heading",
        /*heading*/
        ctx[1]
      );
      set_style(
        p,
        "width",
        /*width*/
        ctx[3]
      );
      add_location(p, file2, 30, 6, 977);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*heading*/
      2) {
        toggle_class(
          p,
          "bx--skeleton__heading",
          /*heading*/
          ctx2[1]
        );
      }
      if (dirty & /*lines, widthPx, widthNum, width*/
      57) {
        set_style(
          p,
          "width",
          /*width*/
          ctx2[3]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: '(24:4) {#each Array.from({ length: lines }).map((_, i) => {       const min = widthPx ? widthNum - 75 : 0;       const max = widthPx ? widthNum : 75;       const rand = Math.floor(RANDOM[i % 3] * (max - min + 1)) + min + \\"px\\";        return widthPx ? rand : `calc(${width} - ${rand})`;     }) as width}',
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*paragraph*/
      ctx2[2]
    ) return create_if_block2;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let widthNum;
  let widthPx;
  const omit_props_names = ["lines", "heading", "paragraph", "width"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SkeletonText", slots, []);
  let { lines = 3 } = $$props;
  let { heading = false } = $$props;
  let { paragraph = false } = $$props;
  let { width = "100%" } = $$props;
  const RANDOM = [0.973, 0.153, 0.567];
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  const func9 = (_, i) => {
    const min = widthPx ? widthNum - 75 : 0;
    const max = widthPx ? widthNum : 75;
    const rand = Math.floor(RANDOM[i % 3] * (max - min + 1)) + min + "px";
    return widthPx ? rand : `calc(${width} - ${rand})`;
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("lines" in $$new_props) $$invalidate(0, lines = $$new_props.lines);
    if ("heading" in $$new_props) $$invalidate(1, heading = $$new_props.heading);
    if ("paragraph" in $$new_props) $$invalidate(2, paragraph = $$new_props.paragraph);
    if ("width" in $$new_props) $$invalidate(3, width = $$new_props.width);
  };
  $$self.$capture_state = () => ({
    lines,
    heading,
    paragraph,
    width,
    RANDOM,
    widthPx,
    widthNum
  });
  $$self.$inject_state = ($$new_props) => {
    if ("lines" in $$props) $$invalidate(0, lines = $$new_props.lines);
    if ("heading" in $$props) $$invalidate(1, heading = $$new_props.heading);
    if ("paragraph" in $$props) $$invalidate(2, paragraph = $$new_props.paragraph);
    if ("width" in $$props) $$invalidate(3, width = $$new_props.width);
    if ("widthPx" in $$props) $$invalidate(4, widthPx = $$new_props.widthPx);
    if ("widthNum" in $$props) $$invalidate(5, widthNum = $$new_props.widthNum);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*width*/
    8) {
      $: $$invalidate(5, widthNum = parseInt(width, 10));
    }
    if ($$self.$$.dirty & /*width*/
    8) {
      $: $$invalidate(4, widthPx = width.includes("px"));
    }
  };
  return [
    lines,
    heading,
    paragraph,
    width,
    widthPx,
    widthNum,
    RANDOM,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    func9
  ];
}
var SkeletonText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      lines: 0,
      heading: 1,
      paragraph: 2,
      width: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SkeletonText",
      options,
      id: create_fragment2.name
    });
  }
  get lines() {
    throw new Error("<SkeletonText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lines(value) {
    throw new Error("<SkeletonText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get heading() {
    throw new Error("<SkeletonText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set heading(value) {
    throw new Error("<SkeletonText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get paragraph() {
    throw new Error("<SkeletonText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set paragraph(value) {
    throw new Error("<SkeletonText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<SkeletonText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<SkeletonText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SkeletonText_default = SkeletonText;

// node_modules/carbon-components-svelte/src/Accordion/AccordionSkeleton.svelte
var file3 = "node_modules/carbon-components-svelte/src/Accordion/AccordionSkeleton.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_if_block3(ctx) {
  let li;
  let span;
  let chevronright;
  let t0;
  let skeletontext0;
  let t1;
  let div;
  let skeletontext1;
  let t2;
  let skeletontext2;
  let t3;
  let skeletontext3;
  let current;
  chevronright = new ChevronRight_default({
    props: { class: "bx--accordion__arrow" },
    $$inline: true
  });
  skeletontext0 = new SkeletonText_default({
    props: { class: "bx--accordion__title" },
    $$inline: true
  });
  skeletontext1 = new SkeletonText_default({ props: { width: "90%" }, $$inline: true });
  skeletontext2 = new SkeletonText_default({ props: { width: "80%" }, $$inline: true });
  skeletontext3 = new SkeletonText_default({ props: { width: "95%" }, $$inline: true });
  const block = {
    c: function create() {
      li = element("li");
      span = element("span");
      create_component(chevronright.$$.fragment);
      t0 = space();
      create_component(skeletontext0.$$.fragment);
      t1 = space();
      div = element("div");
      create_component(skeletontext1.$$.fragment);
      t2 = space();
      create_component(skeletontext2.$$.fragment);
      t3 = space();
      create_component(skeletontext3.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      span = claim_element(li_nodes, "SPAN", {});
      var span_nodes = children(span);
      claim_component(chevronright.$$.fragment, span_nodes);
      t0 = claim_space(span_nodes);
      claim_component(skeletontext0.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(li_nodes);
      div = claim_element(li_nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(skeletontext1.$$.fragment, div_nodes);
      t2 = claim_space(div_nodes);
      claim_component(skeletontext2.$$.fragment, div_nodes);
      t3 = claim_space(div_nodes);
      claim_component(skeletontext3.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--accordion__heading", true);
      add_location(span, file3, 43, 6, 1121);
      toggle_class(div, "bx--accordion__content", true);
      add_location(div, file3, 47, 6, 1294);
      toggle_class(li, "bx--accordion__item", true);
      toggle_class(li, "bx--accordion__item--active", true);
      add_location(li, file3, 39, 4, 1015);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, span);
      mount_component(chevronright, span, null);
      append_hydration_dev(span, t0);
      mount_component(skeletontext0, span, null);
      append_hydration_dev(li, t1);
      append_hydration_dev(li, div);
      mount_component(skeletontext1, div, null);
      append_hydration_dev(div, t2);
      mount_component(skeletontext2, div, null);
      append_hydration_dev(div, t3);
      mount_component(skeletontext3, div, null);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(chevronright.$$.fragment, local);
      transition_in(skeletontext0.$$.fragment, local);
      transition_in(skeletontext1.$$.fragment, local);
      transition_in(skeletontext2.$$.fragment, local);
      transition_in(skeletontext3.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronright.$$.fragment, local);
      transition_out(skeletontext0.$$.fragment, local);
      transition_out(skeletontext1.$$.fragment, local);
      transition_out(skeletontext2.$$.fragment, local);
      transition_out(skeletontext3.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      destroy_component(chevronright);
      destroy_component(skeletontext0);
      destroy_component(skeletontext1);
      destroy_component(skeletontext2);
      destroy_component(skeletontext3);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(39:2) {#if open}",
    ctx
  });
  return block;
}
function create_each_block2(key_1, ctx) {
  let li;
  let span;
  let chevronright;
  let t0;
  let skeletontext;
  let t1;
  let current;
  chevronright = new ChevronRight_default({
    props: { class: "bx--accordion__arrow" },
    $$inline: true
  });
  skeletontext = new SkeletonText_default({
    props: { class: "bx--accordion__title" },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      li = element("li");
      span = element("span");
      create_component(chevronright.$$.fragment);
      t0 = space();
      create_component(skeletontext.$$.fragment);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      span = claim_element(li_nodes, "SPAN", {});
      var span_nodes = children(span);
      claim_component(chevronright.$$.fragment, span_nodes);
      t0 = claim_space(span_nodes);
      claim_component(skeletontext.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--accordion__heading", true);
      add_location(span, file3, 56, 6, 1617);
      toggle_class(li, "bx--accordion__item", true);
      add_location(li, file3, 55, 4, 1571);
      this.first = li;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, span);
      mount_component(chevronright, span, null);
      append_hydration_dev(span, t0);
      mount_component(skeletontext, span, null);
      append_hydration_dev(li, t1);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(chevronright.$$.fragment, local);
      transition_in(skeletontext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronright.$$.fragment, local);
      transition_out(skeletontext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      destroy_component(chevronright);
      destroy_component(skeletontext);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(55:2) {#each Array.from({ length: open ? count - 1 : count }, (_, i) => i) as item (item)}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let ul;
  let t;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*open*/
    ctx[3] && create_if_block3(ctx)
  );
  let each_value = ensure_array_like_dev(Array.from(
    {
      length: (
        /*open*/
        ctx[3] ? (
          /*count*/
          ctx[0] - 1
        ) : (
          /*count*/
          ctx[0]
        )
      )
    },
    func
  ));
  const get_key = (ctx2) => (
    /*item*/
    ctx2[9]
  );
  validate_each_keys(ctx, each_value, get_each_context2, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  let ul_levels = [
    /*$$restProps*/
    ctx[4]
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (if_block) if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {});
      var ul_nodes = children(ul);
      if (if_block) if_block.l(ul_nodes);
      t = claim_space(ul_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--skeleton", true);
      toggle_class(ul, "bx--accordion", true);
      toggle_class(
        ul,
        "bx--accordion--start",
        /*align*/
        ctx[1] === "start"
      );
      toggle_class(
        ul,
        "bx--accordion--end",
        /*align*/
        ctx[1] === "end"
      );
      toggle_class(
        ul,
        "bx--accordion--sm",
        /*size*/
        ctx[2] === "sm"
      );
      toggle_class(
        ul,
        "bx--accordion--xl",
        /*size*/
        ctx[2] === "xl"
      );
      add_location(ul, file3, 25, 0, 668);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      if (if_block) if_block.m(ul, null);
      append_hydration_dev(ul, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            ul,
            "click",
            /*click_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseover",
            /*mouseover_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*open*/
        ctx2[3]
      ) {
        if (if_block) {
          if (dirty & /*open*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(ul, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & /*open, count*/
      9) {
        each_value = ensure_array_like_dev(Array.from(
          {
            length: (
              /*open*/
              ctx2[3] ? (
                /*count*/
                ctx2[0] - 1
              ) : (
                /*count*/
                ctx2[0]
              )
            )
          },
          func
        ));
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & /*$$restProps*/
      16 && /*$$restProps*/
      ctx2[4]]));
      toggle_class(ul, "bx--skeleton", true);
      toggle_class(ul, "bx--accordion", true);
      toggle_class(
        ul,
        "bx--accordion--start",
        /*align*/
        ctx2[1] === "start"
      );
      toggle_class(
        ul,
        "bx--accordion--end",
        /*align*/
        ctx2[1] === "end"
      );
      toggle_class(
        ul,
        "bx--accordion--sm",
        /*size*/
        ctx2[2] === "sm"
      );
      toggle_class(
        ul,
        "bx--accordion--xl",
        /*size*/
        ctx2[2] === "xl"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      if (if_block) if_block.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = (_, i) => i;
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["count", "align", "size", "open"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionSkeleton", slots, []);
  let { count = 4 } = $$props;
  let { align = "end" } = $$props;
  let { size = void 0 } = $$props;
  let { open = true } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("count" in $$new_props) $$invalidate(0, count = $$new_props.count);
    if ("align" in $$new_props) $$invalidate(1, align = $$new_props.align);
    if ("size" in $$new_props) $$invalidate(2, size = $$new_props.size);
    if ("open" in $$new_props) $$invalidate(3, open = $$new_props.open);
  };
  $$self.$capture_state = () => ({
    count,
    align,
    size,
    open,
    ChevronRight: ChevronRight_default,
    SkeletonText: SkeletonText_default
  });
  $$self.$inject_state = ($$new_props) => {
    if ("count" in $$props) $$invalidate(0, count = $$new_props.count);
    if ("align" in $$props) $$invalidate(1, align = $$new_props.align);
    if ("size" in $$props) $$invalidate(2, size = $$new_props.size);
    if ("open" in $$props) $$invalidate(3, open = $$new_props.open);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    count,
    align,
    size,
    open,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var AccordionSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { count: 0, align: 1, size: 2, open: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionSkeleton",
      options,
      id: create_fragment3.name
    });
  }
  get count() {
    throw new Error("<AccordionSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<AccordionSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<AccordionSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<AccordionSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<AccordionSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<AccordionSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<AccordionSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<AccordionSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionSkeleton_default = AccordionSkeleton;

// node_modules/carbon-components-svelte/src/Accordion/Accordion.svelte
var file4 = "node_modules/carbon-components-svelte/src/Accordion/Accordion.svelte";
function create_else_block2(ctx) {
  let ul;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let ul_levels = [
    /*$$restProps*/
    ctx[3]
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {});
      var ul_nodes = children(ul);
      if (default_slot) default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--accordion", true);
      toggle_class(
        ul,
        "bx--accordion--start",
        /*align*/
        ctx[0] === "start"
      );
      toggle_class(
        ul,
        "bx--accordion--end",
        /*align*/
        ctx[0] === "end"
      );
      toggle_class(
        ul,
        "bx--accordion--sm",
        /*size*/
        ctx[1] === "sm"
      );
      toggle_class(
        ul,
        "bx--accordion--xl",
        /*size*/
        ctx[1] === "xl"
      );
      add_location(ul, file4, 45, 2, 1060);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            ul,
            "click",
            /*click_handler_1*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseover",
            /*mouseover_handler_1*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseleave",
            /*mouseleave_handler_1*/
            ctx[10],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & /*$$restProps*/
      8 && /*$$restProps*/
      ctx2[3]]));
      toggle_class(ul, "bx--accordion", true);
      toggle_class(
        ul,
        "bx--accordion--start",
        /*align*/
        ctx2[0] === "start"
      );
      toggle_class(
        ul,
        "bx--accordion--end",
        /*align*/
        ctx2[0] === "end"
      );
      toggle_class(
        ul,
        "bx--accordion--sm",
        /*size*/
        ctx2[1] === "sm"
      );
      toggle_class(
        ul,
        "bx--accordion--xl",
        /*size*/
        ctx2[1] === "xl"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(44:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let accordionskeleton;
  let current;
  const accordionskeleton_spread_levels = [
    /*$$restProps*/
    ctx[3],
    { align: (
      /*align*/
      ctx[0]
    ) },
    { size: (
      /*size*/
      ctx[1]
    ) }
  ];
  let accordionskeleton_props = {};
  for (let i = 0; i < accordionskeleton_spread_levels.length; i += 1) {
    accordionskeleton_props = assign(accordionskeleton_props, accordionskeleton_spread_levels[i]);
  }
  accordionskeleton = new AccordionSkeleton_default({
    props: accordionskeleton_props,
    $$inline: true
  });
  accordionskeleton.$on(
    "click",
    /*click_handler*/
    ctx[11]
  );
  accordionskeleton.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[12]
  );
  accordionskeleton.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx[13]
  );
  accordionskeleton.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx[14]
  );
  const block = {
    c: function create() {
      create_component(accordionskeleton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(accordionskeleton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(accordionskeleton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const accordionskeleton_changes = dirty & /*$$restProps, align, size*/
      11 ? get_spread_update(accordionskeleton_spread_levels, [
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        ),
        dirty & /*align*/
        1 && { align: (
          /*align*/
          ctx2[0]
        ) },
        dirty & /*size*/
        2 && { size: (
          /*size*/
          ctx2[1]
        ) }
      ]) : {};
      accordionskeleton.$set(accordionskeleton_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(accordionskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(accordionskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(accordionskeleton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(34:0) {#if skeleton}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block4, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*skeleton*/
      ctx2[2]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["align", "size", "disabled", "skeleton"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion", slots, ["default"]);
  let { align = "end" } = $$props;
  let { size = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { skeleton = false } = $$props;
  const disableItems = writable(disabled);
  setContext("Accordion", { disableItems });
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("align" in $$new_props) $$invalidate(0, align = $$new_props.align);
    if ("size" in $$new_props) $$invalidate(1, size = $$new_props.size);
    if ("disabled" in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
    if ("skeleton" in $$new_props) $$invalidate(2, skeleton = $$new_props.skeleton);
    if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    align,
    size,
    disabled,
    skeleton,
    setContext,
    writable,
    AccordionSkeleton: AccordionSkeleton_default,
    disableItems
  });
  $$self.$inject_state = ($$new_props) => {
    if ("align" in $$props) $$invalidate(0, align = $$new_props.align);
    if ("size" in $$props) $$invalidate(1, size = $$new_props.size);
    if ("disabled" in $$props) $$invalidate(4, disabled = $$new_props.disabled);
    if ("skeleton" in $$props) $$invalidate(2, skeleton = $$new_props.skeleton);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*disabled*/
    16) {
      $: disableItems.set(disabled);
    }
  };
  return [
    align,
    size,
    skeleton,
    $$restProps,
    disabled,
    $$scope,
    slots,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var Accordion = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      align: 0,
      size: 1,
      disabled: 4,
      skeleton: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion",
      options,
      id: create_fragment4.name
    });
  }
  get align() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skeleton() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skeleton(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Accordion_default = Accordion;

// node_modules/carbon-components-svelte/src/Accordion/AccordionItem.svelte
var file5 = "node_modules/carbon-components-svelte/src/Accordion/AccordionItem.svelte";
var get_title_slot_changes = (dirty) => ({});
var get_title_slot_context = (ctx) => ({});
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*title*/
        ctx[2]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*title*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      4) set_data_dev(
        t,
        /*title*/
        ctx2[2]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(73:25) {title}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let li;
  let button;
  let chevronright;
  let t0;
  let div0;
  let t1;
  let div1;
  let current;
  let mounted;
  let dispose;
  chevronright = new ChevronRight_default({
    props: {
      class: "bx--accordion__arrow",
      "aria-label": (
        /*iconDescription*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const title_slot_template = (
    /*#slots*/
    ctx[7].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_title_slot_context
  );
  const title_slot_or_fallback = title_slot || fallback_block(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let li_levels = [
    /*$$restProps*/
    ctx[5]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      button = element("button");
      create_component(chevronright.$$.fragment);
      t0 = space();
      div0 = element("div");
      if (title_slot_or_fallback) title_slot_or_fallback.c();
      t1 = space();
      div1 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      button = claim_element(li_nodes, "BUTTON", {
        type: true,
        title: true,
        "aria-expanded": true
      });
      var button_nodes = children(button);
      claim_component(chevronright.$$.fragment, button_nodes);
      t0 = claim_space(button_nodes);
      div0 = claim_element(button_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (title_slot_or_fallback) title_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      t1 = claim_space(li_nodes);
      div1 = claim_element(li_nodes, "DIV", {});
      var div1_nodes = children(div1);
      if (default_slot) default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--accordion__title", true);
      add_location(div0, file5, 71, 4, 1870);
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "title",
        /*iconDescription*/
        ctx[3]
      );
      attr_dev(
        button,
        "aria-expanded",
        /*open*/
        ctx[0]
      );
      button.disabled = /*disabled*/
      ctx[1];
      toggle_class(button, "bx--accordion__heading", true);
      add_location(button, file5, 49, 2, 1337);
      toggle_class(div1, "bx--accordion__content", true);
      add_location(div1, file5, 75, 2, 1977);
      set_attributes(li, li_data);
      toggle_class(li, "bx--accordion__item", true);
      toggle_class(
        li,
        "bx--accordion__item--active",
        /*open*/
        ctx[0]
      );
      toggle_class(
        li,
        "bx--accordion__item--disabled",
        /*disabled*/
        ctx[1]
      );
      toggle_class(
        li,
        "bx--accordion__item--expanding",
        /*animation*/
        ctx[4] === "expanding"
      );
      toggle_class(
        li,
        "bx--accordion__item--collapsing",
        /*animation*/
        ctx[4] === "collapsing"
      );
      add_location(li, file5, 37, 0, 958);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, button);
      mount_component(chevronright, button, null);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, div0);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(li, t1);
      append_hydration_dev(li, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler_1*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseover",
            /*mouseover_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler_1*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "animationend",
            /*animationend_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "animationend",
            /*animationend_handler_1*/
            ctx[16],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const chevronright_changes = {};
      if (dirty & /*iconDescription*/
      8) chevronright_changes["aria-label"] = /*iconDescription*/
      ctx2[3];
      chevronright.$set(chevronright_changes);
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_title_slot_changes
            ),
            get_title_slot_context
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & /*title*/
        4)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*iconDescription*/
      8) {
        attr_dev(
          button,
          "title",
          /*iconDescription*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*open*/
      1) {
        attr_dev(
          button,
          "aria-expanded",
          /*open*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*disabled*/
      2) {
        prop_dev(
          button,
          "disabled",
          /*disabled*/
          ctx2[1]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [dirty & /*$$restProps*/
      32 && /*$$restProps*/
      ctx2[5]]));
      toggle_class(li, "bx--accordion__item", true);
      toggle_class(
        li,
        "bx--accordion__item--active",
        /*open*/
        ctx2[0]
      );
      toggle_class(
        li,
        "bx--accordion__item--disabled",
        /*disabled*/
        ctx2[1]
      );
      toggle_class(
        li,
        "bx--accordion__item--expanding",
        /*animation*/
        ctx2[4] === "expanding"
      );
      toggle_class(
        li,
        "bx--accordion__item--collapsing",
        /*animation*/
        ctx2[4] === "collapsing"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(chevronright.$$.fragment, local);
      transition_in(title_slot_or_fallback, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronright.$$.fragment, local);
      transition_out(title_slot_or_fallback, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      destroy_component(chevronright);
      if (title_slot_or_fallback) title_slot_or_fallback.d(detaching);
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = ["title", "open", "disabled", "iconDescription"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionItem", slots, ["title", "default"]);
  let { title = "title" } = $$props;
  let { open = false } = $$props;
  let { disabled = false } = $$props;
  let { iconDescription = "Expand/Collapse" } = $$props;
  let initialDisabled = disabled;
  const ctx = getContext("Accordion");
  const unsubscribe = ctx.disableItems.subscribe((value) => {
    if (!value && initialDisabled) return;
    $$invalidate(1, disabled = value);
  });
  let animation = void 0;
  onMount(() => {
    return () => {
      unsubscribe();
    };
  });
  function animationend_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = () => {
    $$invalidate(0, open = !open);
    $$invalidate(4, animation = open ? "expanding" : "collapsing");
  };
  const keydown_handler_12 = ({ key }) => {
    if (open && key === "Escape") {
      $$invalidate(0, open = false);
    }
  };
  const animationend_handler_1 = () => {
    $$invalidate(4, animation = void 0);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    if ("open" in $$new_props) $$invalidate(0, open = $$new_props.open);
    if ("disabled" in $$new_props) $$invalidate(1, disabled = $$new_props.disabled);
    if ("iconDescription" in $$new_props) $$invalidate(3, iconDescription = $$new_props.iconDescription);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    title,
    open,
    disabled,
    iconDescription,
    onMount,
    getContext,
    ChevronRight: ChevronRight_default,
    initialDisabled,
    ctx,
    unsubscribe,
    animation
  });
  $$self.$inject_state = ($$new_props) => {
    if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    if ("open" in $$props) $$invalidate(0, open = $$new_props.open);
    if ("disabled" in $$props) $$invalidate(1, disabled = $$new_props.disabled);
    if ("iconDescription" in $$props) $$invalidate(3, iconDescription = $$new_props.iconDescription);
    if ("initialDisabled" in $$props) initialDisabled = $$new_props.initialDisabled;
    if ("animation" in $$props) $$invalidate(4, animation = $$new_props.animation);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    open,
    disabled,
    title,
    iconDescription,
    animation,
    $$restProps,
    $$scope,
    slots,
    animationend_handler,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    click_handler_13,
    keydown_handler_12,
    animationend_handler_1
  ];
}
var AccordionItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      title: 2,
      open: 0,
      disabled: 1,
      iconDescription: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionItem",
      options,
      id: create_fragment5.name
    });
  }
  get title() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionItem_default = AccordionItem;

// node_modules/carbon-components-svelte/src/AspectRatio/AspectRatio.svelte
var file6 = "node_modules/carbon-components-svelte/src/AspectRatio/AspectRatio.svelte";
function create_fragment6(ctx) {
  let div1;
  let div0;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div1_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (default_slot) default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--aspect-ratio--object", true);
      add_location(div0, file6, 21, 2, 691);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--aspect-ratio", true);
      toggle_class(
        div1,
        "bx--aspect-ratio--2x1",
        /*ratio*/
        ctx[0] === "2x1"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--2x3",
        /*ratio*/
        ctx[0] === "2x3"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--16x9",
        /*ratio*/
        ctx[0] === "16x9"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--4x3",
        /*ratio*/
        ctx[0] === "4x3"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--1x1",
        /*ratio*/
        ctx[0] === "1x1"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--3x4",
        /*ratio*/
        ctx[0] === "3x4"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--3x2",
        /*ratio*/
        ctx[0] === "3x2"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--9x16",
        /*ratio*/
        ctx[0] === "9x16"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--1x2",
        /*ratio*/
        ctx[0] === "1x2"
      );
      add_location(div1, file6, 8, 0, 175);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(div1, "bx--aspect-ratio", true);
      toggle_class(
        div1,
        "bx--aspect-ratio--2x1",
        /*ratio*/
        ctx2[0] === "2x1"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--2x3",
        /*ratio*/
        ctx2[0] === "2x3"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--16x9",
        /*ratio*/
        ctx2[0] === "16x9"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--4x3",
        /*ratio*/
        ctx2[0] === "4x3"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--1x1",
        /*ratio*/
        ctx2[0] === "1x1"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--3x4",
        /*ratio*/
        ctx2[0] === "3x4"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--3x2",
        /*ratio*/
        ctx2[0] === "3x2"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--9x16",
        /*ratio*/
        ctx2[0] === "9x16"
      );
      toggle_class(
        div1,
        "bx--aspect-ratio--1x2",
        /*ratio*/
        ctx2[0] === "1x2"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  const omit_props_names = ["ratio"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AspectRatio", slots, ["default"]);
  let { ratio = "2x1" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ratio" in $$new_props) $$invalidate(0, ratio = $$new_props.ratio);
    if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ ratio });
  $$self.$inject_state = ($$new_props) => {
    if ("ratio" in $$props) $$invalidate(0, ratio = $$new_props.ratio);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ratio, $$restProps, $$scope, slots];
}
var AspectRatio = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { ratio: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AspectRatio",
      options,
      id: create_fragment6.name
    });
  }
  get ratio() {
    throw new Error("<AspectRatio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ratio(value) {
    throw new Error("<AspectRatio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AspectRatio_default = AspectRatio;

// node_modules/carbon-components-svelte/src/Breadcrumb/BreadcrumbSkeleton.svelte
var file7 = "node_modules/carbon-components-svelte/src/Breadcrumb/BreadcrumbSkeleton.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_each_block3(key_1, ctx) {
  let div;
  let span;
  let textContent = " ";
  let t1;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div = element("div");
      span = element("span");
      span.textContent = textContent;
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-134o0jf") span.textContent = textContent;
      t1 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--link", true);
      add_location(span, file7, 22, 6, 645);
      toggle_class(div, "bx--breadcrumb-item", true);
      add_location(div, file7, 21, 4, 598);
      this.first = div;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      append_hydration_dev(div, t1);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(21:2) {#each Array.from({ length: count }, (_, i) => i) as item (item)}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(Array.from({ length: (
    /*count*/
    ctx[1]
  ) }, func2));
  const get_key = (ctx2) => (
    /*item*/
    ctx2[7]
  );
  validate_each_keys(ctx, each_value, get_each_context3, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
  }
  let div_levels = [
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--breadcrumb", true);
      toggle_class(
        div,
        "bx--breadcrumb--no-trailing-slash",
        /*noTrailingSlash*/
        ctx[0]
      );
      add_location(div, file7, 10, 0, 318);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*count*/
      2) {
        each_value = ensure_array_like_dev(Array.from({ length: (
          /*count*/
          ctx2[1]
        ) }, func2));
        validate_each_keys(ctx2, each_value, get_each_context3, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block3, null, get_each_context3);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      4 && /*$$restProps*/
      ctx2[2]]));
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--breadcrumb", true);
      toggle_class(
        div,
        "bx--breadcrumb--no-trailing-slash",
        /*noTrailingSlash*/
        ctx2[0]
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func2 = (_, i) => i;
function instance7($$self, $$props, $$invalidate) {
  const omit_props_names = ["noTrailingSlash", "count"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BreadcrumbSkeleton", slots, []);
  let { noTrailingSlash = false } = $$props;
  let { count = 3 } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("noTrailingSlash" in $$new_props) $$invalidate(0, noTrailingSlash = $$new_props.noTrailingSlash);
    if ("count" in $$new_props) $$invalidate(1, count = $$new_props.count);
  };
  $$self.$capture_state = () => ({ noTrailingSlash, count });
  $$self.$inject_state = ($$new_props) => {
    if ("noTrailingSlash" in $$props) $$invalidate(0, noTrailingSlash = $$new_props.noTrailingSlash);
    if ("count" in $$props) $$invalidate(1, count = $$new_props.count);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    noTrailingSlash,
    count,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var BreadcrumbSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { noTrailingSlash: 0, count: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BreadcrumbSkeleton",
      options,
      id: create_fragment7.name
    });
  }
  get noTrailingSlash() {
    throw new Error("<BreadcrumbSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noTrailingSlash(value) {
    throw new Error("<BreadcrumbSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get count() {
    throw new Error("<BreadcrumbSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<BreadcrumbSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BreadcrumbSkeleton_default = BreadcrumbSkeleton;

// node_modules/carbon-components-svelte/src/Breadcrumb/Breadcrumb.svelte
var file8 = "node_modules/carbon-components-svelte/src/Breadcrumb/Breadcrumb.svelte";
function create_else_block3(ctx) {
  let nav;
  let ol;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let nav_levels = [
    { "aria-label": "Breadcrumb" },
    /*$$restProps*/
    ctx[2]
  ];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      ol = element("ol");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { "aria-label": true });
      var nav_nodes = children(nav);
      ol = claim_element(nav_nodes, "OL", {});
      var ol_nodes = children(ol);
      if (default_slot) default_slot.l(ol_nodes);
      ol_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(ol, "bx--breadcrumb", true);
      toggle_class(
        ol,
        "bx--breadcrumb--no-trailing-slash",
        /*noTrailingSlash*/
        ctx[0]
      );
      add_location(ol, file8, 32, 4, 773);
      set_attributes(nav, nav_data);
      add_location(nav, file8, 24, 2, 645);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      append_hydration_dev(nav, ol);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            nav,
            "click",
            /*click_handler_1*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            nav,
            "mouseover",
            /*mouseover_handler_1*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            nav,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            nav,
            "mouseleave",
            /*mouseleave_handler_1*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*noTrailingSlash*/
      1) {
        toggle_class(
          ol,
          "bx--breadcrumb--no-trailing-slash",
          /*noTrailingSlash*/
          ctx2[0]
        );
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        { "aria-label": "Breadcrumb" },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(nav);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(23:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let breadcrumbskeleton;
  let current;
  const breadcrumbskeleton_spread_levels = [
    {
      noTrailingSlash: (
        /*noTrailingSlash*/
        ctx[0]
      )
    },
    /*$$restProps*/
    ctx[2]
  ];
  let breadcrumbskeleton_props = {};
  for (let i = 0; i < breadcrumbskeleton_spread_levels.length; i += 1) {
    breadcrumbskeleton_props = assign(breadcrumbskeleton_props, breadcrumbskeleton_spread_levels[i]);
  }
  breadcrumbskeleton = new BreadcrumbSkeleton_default({
    props: breadcrumbskeleton_props,
    $$inline: true
  });
  breadcrumbskeleton.$on(
    "click",
    /*click_handler*/
    ctx[9]
  );
  breadcrumbskeleton.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[10]
  );
  breadcrumbskeleton.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx[11]
  );
  breadcrumbskeleton.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx[12]
  );
  const block = {
    c: function create() {
      create_component(breadcrumbskeleton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(breadcrumbskeleton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(breadcrumbskeleton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const breadcrumbskeleton_changes = dirty & /*noTrailingSlash, $$restProps*/
      5 ? get_spread_update(breadcrumbskeleton_spread_levels, [
        dirty & /*noTrailingSlash*/
        1 && {
          noTrailingSlash: (
            /*noTrailingSlash*/
            ctx2[0]
          )
        },
        dirty & /*$$restProps*/
        4 && get_spread_object(
          /*$$restProps*/
          ctx2[2]
        )
      ]) : {};
      breadcrumbskeleton.$set(breadcrumbskeleton_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(breadcrumbskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(breadcrumbskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(breadcrumbskeleton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(14:0) {#if skeleton}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block5, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*skeleton*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  const omit_props_names = ["noTrailingSlash", "skeleton"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breadcrumb", slots, ["default"]);
  let { noTrailingSlash = false } = $$props;
  let { skeleton = false } = $$props;
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("noTrailingSlash" in $$new_props) $$invalidate(0, noTrailingSlash = $$new_props.noTrailingSlash);
    if ("skeleton" in $$new_props) $$invalidate(1, skeleton = $$new_props.skeleton);
    if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    noTrailingSlash,
    skeleton,
    BreadcrumbSkeleton: BreadcrumbSkeleton_default
  });
  $$self.$inject_state = ($$new_props) => {
    if ("noTrailingSlash" in $$props) $$invalidate(0, noTrailingSlash = $$new_props.noTrailingSlash);
    if ("skeleton" in $$props) $$invalidate(1, skeleton = $$new_props.skeleton);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    noTrailingSlash,
    skeleton,
    $$restProps,
    $$scope,
    slots,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var Breadcrumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { noTrailingSlash: 0, skeleton: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breadcrumb",
      options,
      id: create_fragment8.name
    });
  }
  get noTrailingSlash() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noTrailingSlash(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skeleton() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skeleton(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Breadcrumb_default = Breadcrumb;

// node_modules/carbon-components-svelte/src/Link/Link.svelte
var file9 = "node_modules/carbon-components-svelte/src/Link/Link.svelte";
var get_icon_slot_changes_1 = (dirty) => ({});
var get_icon_slot_context_1 = (ctx) => ({});
var get_icon_slot_changes = (dirty) => ({});
var get_icon_slot_context = (ctx) => ({});
function create_else_block4(ctx) {
  let a;
  let t;
  let a_rel_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let if_block = !/*inline*/
  ctx[3] && /*$$slots*/
  (ctx[8].icon || /*icon*/
  ctx[4]) && create_if_block_2(ctx);
  let a_levels = [
    {
      rel: a_rel_value = /*$$restProps*/
      ctx[7].target === "_blank" ? "noopener noreferrer" : void 0
    },
    { href: (
      /*href*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot) default_slot.c();
      t = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { rel: true, href: true });
      var a_nodes = children(a);
      if (default_slot) default_slot.l(a_nodes);
      t = claim_space(a_nodes);
      if (if_block) if_block.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      toggle_class(a, "bx--link", true);
      toggle_class(
        a,
        "bx--link--disabled",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        a,
        "bx--link--inline",
        /*inline*/
        ctx[3]
      );
      toggle_class(
        a,
        "bx--link--visited",
        /*visited*/
        ctx[6]
      );
      toggle_class(
        a,
        "bx--link--sm",
        /*size*/
        ctx[1] === "sm"
      );
      toggle_class(
        a,
        "bx--link--lg",
        /*size*/
        ctx[1] === "lg"
      );
      add_location(a, file9, 63, 2, 1521);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      append_hydration_dev(a, t);
      if (if_block) if_block.m(a, null);
      ctx[20](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*click_handler_1*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseover",
            /*mouseover_handler_1*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseleave",
            /*mouseleave_handler_1*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!/*inline*/
      ctx2[3] && /*$$slots*/
      (ctx2[8].icon || /*icon*/
      ctx2[4])) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*inline, $$slots, icon*/
          280) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(a, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*$$restProps*/
        128 && a_rel_value !== (a_rel_value = /*$$restProps*/
        ctx2[7].target === "_blank" ? "noopener noreferrer" : void 0)) && { rel: a_rel_value },
        (!current || dirty & /*href*/
        4) && { href: (
          /*href*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      toggle_class(a, "bx--link", true);
      toggle_class(
        a,
        "bx--link--disabled",
        /*disabled*/
        ctx2[5]
      );
      toggle_class(
        a,
        "bx--link--inline",
        /*inline*/
        ctx2[3]
      );
      toggle_class(
        a,
        "bx--link--visited",
        /*visited*/
        ctx2[6]
      );
      toggle_class(
        a,
        "bx--link--sm",
        /*size*/
        ctx2[1] === "sm"
      );
      toggle_class(
        a,
        "bx--link--lg",
        /*size*/
        ctx2[1] === "lg"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot) default_slot.d(detaching);
      if (if_block) if_block.d();
      ctx[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(63:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let a;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let if_block = !/*inline*/
  ctx[3] && /*$$slots*/
  (ctx[8].icon || /*icon*/
  ctx[4]) && create_if_block_1(ctx);
  let a_levels = [
    { role: "link" },
    { "aria-disabled": "true" },
    /*$$restProps*/
    ctx[7]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot) default_slot.c();
      t = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { role: true, "aria-disabled": true });
      var a_nodes = children(a);
      if (default_slot) default_slot.l(a_nodes);
      t = claim_space(a_nodes);
      if (if_block) if_block.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      toggle_class(a, "bx--link", true);
      toggle_class(
        a,
        "bx--link--disabled",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        a,
        "bx--link--inline",
        /*inline*/
        ctx[3]
      );
      toggle_class(
        a,
        "bx--link--visited",
        /*visited*/
        ctx[6]
      );
      add_location(a, file9, 39, 2, 989);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      append_hydration_dev(a, t);
      if (if_block) if_block.m(a, null);
      ctx[19](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseover",
            /*mouseover_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!/*inline*/
      ctx2[3] && /*$$slots*/
      (ctx2[8].icon || /*icon*/
      ctx2[4])) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*inline, $$slots, icon*/
          280) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(a, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        { role: "link" },
        { "aria-disabled": "true" },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      toggle_class(a, "bx--link", true);
      toggle_class(
        a,
        "bx--link--disabled",
        /*disabled*/
        ctx2[5]
      );
      toggle_class(
        a,
        "bx--link--inline",
        /*inline*/
        ctx2[3]
      );
      toggle_class(
        a,
        "bx--link--visited",
        /*visited*/
        ctx2[6]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot) default_slot.d(detaching);
      if (if_block) if_block.d();
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(38:0) {#if disabled}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[10].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_icon_slot_context_1
  );
  const icon_slot_or_fallback = icon_slot || fallback_block_1(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback) icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (icon_slot_or_fallback) icon_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--link__icon", true);
      add_location(div, file9, 81, 6, 2028);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_icon_slot_changes_1
            ),
            get_icon_slot_context_1
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*icon*/
        16)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(81:4) {#if !inline && ($$slots.icon || icon)}",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[4]
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*icon*/
      16 && switch_value !== (switch_value = /*icon*/
      ctx2[4])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(83:26)            ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[10].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_icon_slot_context
  );
  const icon_slot_or_fallback = icon_slot || fallback_block2(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback) icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (icon_slot_or_fallback) icon_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--link__icon", true);
      add_location(div, file9, 55, 6, 1357);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_icon_slot_changes
            ),
            get_icon_slot_context
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*icon*/
        16)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(55:4) {#if !inline && ($$slots.icon || icon)}",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[4]
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*icon*/
      16 && switch_value !== (switch_value = /*icon*/
      ctx2[4])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(57:26)            ",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block6, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*disabled*/
      ctx2[5]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  const omit_props_names = ["size", "href", "inline", "icon", "disabled", "visited", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Link", slots, ["default", "icon"]);
  const $$slots = compute_slots(slots);
  let { size = void 0 } = $$props;
  let { href = void 0 } = $$props;
  let { inline = false } = $$props;
  let { icon = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { visited = false } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  function a_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(1, size = $$new_props.size);
    if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
    if ("inline" in $$new_props) $$invalidate(3, inline = $$new_props.inline);
    if ("icon" in $$new_props) $$invalidate(4, icon = $$new_props.icon);
    if ("disabled" in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
    if ("visited" in $$new_props) $$invalidate(6, visited = $$new_props.visited);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    href,
    inline,
    icon,
    disabled,
    visited,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props) $$invalidate(1, size = $$new_props.size);
    if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
    if ("inline" in $$props) $$invalidate(3, inline = $$new_props.inline);
    if ("icon" in $$props) $$invalidate(4, icon = $$new_props.icon);
    if ("disabled" in $$props) $$invalidate(5, disabled = $$new_props.disabled);
    if ("visited" in $$props) $$invalidate(6, visited = $$new_props.visited);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    size,
    href,
    inline,
    icon,
    disabled,
    visited,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    a_binding,
    a_binding_1
  ];
}
var Link = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      size: 1,
      href: 2,
      inline: 3,
      icon: 4,
      disabled: 5,
      visited: 6,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Link",
      options,
      id: create_fragment9.name
    });
  }
  get size() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visited() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visited(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Link_default = Link;

// node_modules/carbon-components-svelte/src/Breadcrumb/BreadcrumbItem.svelte
var file10 = "node_modules/carbon-components-svelte/src/Breadcrumb/BreadcrumbItem.svelte";
var get_default_slot_changes = (dirty) => ({ props: dirty & /*$$restProps*/
4 });
var get_default_slot_context = (ctx) => ({
  props: {
    "aria-current": (
      /*$$restProps*/
      ctx[2]["aria-current"]
    ),
    class: "bx--link"
  }
});
function create_else_block5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $$restProps*/
        260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(38:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let link;
  let current;
  link = new Link_default({
    props: {
      href: (
        /*href*/
        ctx[0]
      ),
      "aria-current": (
        /*$$restProps*/
        ctx[2]["aria-current"]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(link.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(link.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(link, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const link_changes = {};
      if (dirty & /*href*/
      1) link_changes.href = /*href*/
      ctx2[0];
      if (dirty & /*$$restProps*/
      4) link_changes["aria-current"] = /*$$restProps*/
      ctx2[2]["aria-current"];
      if (dirty & /*$$scope*/
      256) {
        link_changes.$$scope = { dirty, ctx: ctx2 };
      }
      link.$set(link_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(link.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(link.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(link, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(34:2) {#if href}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: `(35:4) <Link href=\\"{href}\\" aria-current=\\"{$$restProps['aria-current']}\\">`,
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let li;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block7, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*href*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let li_levels = [
    /*$$restProps*/
    ctx[2]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      if_block.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(li, li_data);
      toggle_class(li, "bx--breadcrumb-item", true);
      toggle_class(
        li,
        "bx--breadcrumb-item--current",
        /*isCurrentPage*/
        ctx[1] && /*$$restProps*/
        ctx[2]["aria-current"] !== "page"
      );
      add_location(li, file10, 23, 0, 566);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            li,
            "click",
            /*click_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseover",
            /*mouseover_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li, null);
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [dirty & /*$$restProps*/
      4 && /*$$restProps*/
      ctx2[2]]));
      toggle_class(li, "bx--breadcrumb-item", true);
      toggle_class(
        li,
        "bx--breadcrumb-item--current",
        /*isCurrentPage*/
        ctx2[1] && /*$$restProps*/
        ctx2[2]["aria-current"] !== "page"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  const omit_props_names = ["href", "isCurrentPage"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BreadcrumbItem", slots, ["default"]);
  let { href = void 0 } = $$props;
  let { isCurrentPage = false } = $$props;
  setContext("BreadcrumbItem", {});
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props) $$invalidate(0, href = $$new_props.href);
    if ("isCurrentPage" in $$new_props) $$invalidate(1, isCurrentPage = $$new_props.isCurrentPage);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ href, isCurrentPage, Link: Link_default, setContext });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props) $$invalidate(0, href = $$new_props.href);
    if ("isCurrentPage" in $$props) $$invalidate(1, isCurrentPage = $$new_props.isCurrentPage);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    href,
    isCurrentPage,
    $$restProps,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    $$scope
  ];
}
var BreadcrumbItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { href: 0, isCurrentPage: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BreadcrumbItem",
      options,
      id: create_fragment10.name
    });
  }
  get href() {
    throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCurrentPage() {
    throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCurrentPage(value) {
    throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BreadcrumbItem_default = BreadcrumbItem;

// node_modules/carbon-components-svelte/src/Breakpoint/breakpoints.js
var breakpoints = Object.freeze({
  sm: 320,
  md: 672,
  lg: 1056,
  xlg: 1312,
  max: 1584
});
var breakpoints_default = breakpoints;

// node_modules/carbon-components-svelte/src/Breakpoint/breakpointObserver.js
function breakpointObserver() {
  const store = writable(void 0);
  onMount(() => {
    const match = {
      sm: window.matchMedia(`(max-width: ${breakpoints.md}px)`),
      md: window.matchMedia(
        `(min-width: ${breakpoints.md}px) and (max-width: ${breakpoints.lg}px)`
      ),
      lg: window.matchMedia(
        `(min-width: ${breakpoints.lg}px) and (max-width: ${breakpoints.xlg}px)`
      ),
      xlg: window.matchMedia(
        `(min-width: ${breakpoints.xlg}px) and (max-width: ${breakpoints.max}px)`
      ),
      max: window.matchMedia(`(min-width: ${breakpoints.max}px)`)
    };
    const matchers = Object.entries(match);
    const sizeByMedia = Object.fromEntries(
      matchers.map(([size2, queryList]) => [queryList.media, size2])
    );
    const size = matchers.find(([size2, queryList]) => queryList.matches)[0];
    store.set(size);
    function handleChange({ matches, media }) {
      const size2 = sizeByMedia[media];
      if (matches) store.set(size2);
    }
    matchers.forEach(
      ([size2, queryList]) => queryList.addEventListener("change", handleChange)
    );
    return () => {
      matchers.forEach(
        ([size2, queryList]) => queryList.removeEventListener("change", handleChange)
      );
    };
  });
  return {
    subscribe: store.subscribe,
    /**
     * Returns a store readable store that returns whether the current
     * breakpoint is smaller than {@link size}.
     * @param {import("./breakpoints").BreakpointSize} size Size to compare against.
     */
    smallerThan: (size) => {
      checkSizeValid(size);
      return derived(store, ($size) => breakpoints[$size] < breakpoints[size]);
    },
    /**
     * Returns a store readable store that returns whether the current
     * breakpoint is larger than {@link size}.
     * @param {import("./breakpoints").BreakpointSize} size Size to compare against.
     */
    largerThan: (size) => {
      checkSizeValid(size);
      return derived(store, ($size) => breakpoints[$size] > breakpoints[size]);
    }
  };
}
function checkSizeValid(size) {
  if (size in breakpoints == false)
    throw new Error(`"${size}" is not a valid breakpoint size.`);
}
var breakpointObserver_default = breakpointObserver;

// node_modules/carbon-components-svelte/src/Breakpoint/Breakpoint.svelte
var get_default_slot_changes2 = (dirty) => ({
  size: dirty & /*size*/
  1,
  sizes: dirty & /*sizes*/
  2
});
var get_default_slot_context2 = (ctx) => ({
  size: (
    /*size*/
    ctx[0]
  ),
  sizes: (
    /*sizes*/
    ctx[1]
  )
});
function create_fragment11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, size, sizes*/
        19)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let $observer;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breakpoint", slots, ["default"]);
  let { size = void 0 } = $$props;
  let { sizes = {
    sm: false,
    md: false,
    lg: false,
    xlg: false,
    max: false
  } } = $$props;
  const dispatch = createEventDispatcher();
  const observer = breakpointObserver();
  validate_store(observer, "observer");
  component_subscribe($$self, observer, (value) => $$invalidate(3, $observer = value));
  const writable_props = ["size", "sizes"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Breakpoint> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2) $$invalidate(0, size = $$props2.size);
    if ("sizes" in $$props2) $$invalidate(1, sizes = $$props2.sizes);
    if ("$$scope" in $$props2) $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    sizes,
    createEventDispatcher,
    breakpointObserver,
    breakpoints,
    dispatch,
    observer,
    $observer
  });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2) $$invalidate(0, size = $$props2.size);
    if ("sizes" in $$props2) $$invalidate(1, sizes = $$props2.sizes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$observer*/
    8) {
      $: $$invalidate(0, size = $observer);
    }
    if ($$self.$$.dirty & /*size*/
    1) {
      $: $$invalidate(1, sizes = {
        sm: size == "sm",
        md: size == "md",
        lg: size == "lg",
        xlg: size == "xlg",
        max: size == "max"
      });
    }
    if ($$self.$$.dirty & /*size*/
    1) {
      $: if (size != void 0) dispatch("change", { size, breakpointValue: breakpoints[size] });
    }
  };
  return [size, sizes, observer, $observer, $$scope, slots];
}
var Breakpoint = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { size: 0, sizes: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breakpoint",
      options,
      id: create_fragment11.name
    });
  }
  get size() {
    throw new Error("<Breakpoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Breakpoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sizes() {
    throw new Error("<Breakpoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sizes(value) {
    throw new Error("<Breakpoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Breakpoint_default = Breakpoint;

// node_modules/carbon-components-svelte/src/Button/ButtonSkeleton.svelte
var file11 = "node_modules/carbon-components-svelte/src/Button/ButtonSkeleton.svelte";
function create_else_block6(ctx) {
  let div;
  let mounted;
  let dispose;
  let div_levels = [
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--btn", true);
      toggle_class(
        div,
        "bx--btn--field",
        /*size*/
        ctx[1] === "field"
      );
      toggle_class(
        div,
        "bx--btn--sm",
        /*size*/
        ctx[1] === "small"
      );
      toggle_class(
        div,
        "bx--btn--lg",
        /*size*/
        ctx[1] === "lg"
      );
      toggle_class(
        div,
        "bx--btn--xl",
        /*size*/
        ctx[1] === "xl"
      );
      add_location(div, file11, 38, 2, 887);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler_1*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "focus",
            /*focus_handler_1*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "blur",
            /*blur_handler_1*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler_1*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler_1*/
            ctx[14],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      4 && /*$$restProps*/
      ctx2[2]]));
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--btn", true);
      toggle_class(
        div,
        "bx--btn--field",
        /*size*/
        ctx2[1] === "field"
      );
      toggle_class(
        div,
        "bx--btn--sm",
        /*size*/
        ctx2[1] === "small"
      );
      toggle_class(
        div,
        "bx--btn--lg",
        /*size*/
        ctx2[1] === "lg"
      );
      toggle_class(
        div,
        "bx--btn--xl",
        /*size*/
        ctx2[1] === "xl"
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(37:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let a;
  let t_value = "";
  let t;
  let a_rel_value;
  let mounted;
  let dispose;
  let a_levels = [
    { href: (
      /*href*/
      ctx[0]
    ) },
    {
      rel: a_rel_value = /*$$restProps*/
      ctx[2].target === "_blank" ? "noopener noreferrer" : void 0
    },
    { role: "button" },
    /*$$restProps*/
    ctx[2]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, rel: true, role: true });
      var a_nodes = children(a);
      t = claim_text(a_nodes, t_value);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      toggle_class(a, "bx--skeleton", true);
      toggle_class(a, "bx--btn", true);
      toggle_class(
        a,
        "bx--btn--field",
        /*size*/
        ctx[1] === "field"
      );
      toggle_class(
        a,
        "bx--btn--sm",
        /*size*/
        ctx[1] === "small"
      );
      toggle_class(
        a,
        "bx--btn--lg",
        /*size*/
        ctx[1] === "lg"
      );
      toggle_class(
        a,
        "bx--btn--xl",
        /*size*/
        ctx[1] === "xl"
      );
      add_location(a, file11, 16, 2, 337);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t);
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "focus",
            /*focus_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "blur",
            /*blur_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseover",
            /*mouseover_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*href*/
        1 && { href: (
          /*href*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        4 && a_rel_value !== (a_rel_value = /*$$restProps*/
        ctx2[2].target === "_blank" ? "noopener noreferrer" : void 0) && { rel: a_rel_value },
        { role: "button" },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      toggle_class(a, "bx--skeleton", true);
      toggle_class(a, "bx--btn", true);
      toggle_class(
        a,
        "bx--btn--field",
        /*size*/
        ctx2[1] === "field"
      );
      toggle_class(
        a,
        "bx--btn--sm",
        /*size*/
        ctx2[1] === "small"
      );
      toggle_class(
        a,
        "bx--btn--lg",
        /*size*/
        ctx2[1] === "lg"
      );
      toggle_class(
        a,
        "bx--btn--xl",
        /*size*/
        ctx2[1] === "xl"
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(16:0) {#if href}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*href*/
      ctx2[0]
    ) return create_if_block8;
    return create_else_block6;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  const omit_props_names = ["href", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ButtonSkeleton", slots, []);
  let { href = void 0 } = $$props;
  let { size = "default" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props) $$invalidate(0, href = $$new_props.href);
    if ("size" in $$new_props) $$invalidate(1, size = $$new_props.size);
  };
  $$self.$capture_state = () => ({ href, size });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props) $$invalidate(0, href = $$new_props.href);
    if ("size" in $$props) $$invalidate(1, size = $$new_props.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    href,
    size,
    $$restProps,
    click_handler,
    focus_handler,
    blur_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler_13,
    focus_handler_1,
    blur_handler_1,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1
  ];
}
var ButtonSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { href: 0, size: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonSkeleton",
      options,
      id: create_fragment12.name
    });
  }
  get href() {
    throw new Error("<ButtonSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<ButtonSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ButtonSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ButtonSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ButtonSkeleton_default = ButtonSkeleton;

// node_modules/carbon-components-svelte/src/Button/Button.svelte
var file12 = "node_modules/carbon-components-svelte/src/Button/Button.svelte";
var get_icon_slot_spread_changes_1 = (dirty) => dirty[0] & /*iconProps*/
1024;
var get_icon_slot_changes_12 = (dirty) => ({ style: dirty[0] & /*hasIconOnly*/
256 });
var get_icon_slot_context_12 = (ctx) => ({
  style: (
    /*hasIconOnly*/
    ctx[8] ? "margin-left: 0" : void 0
  ),
  .../*iconProps*/
  ctx[10]
});
var get_icon_slot_spread_changes = (dirty) => dirty[0] & /*iconProps*/
1024;
var get_icon_slot_changes2 = (dirty) => ({ style: dirty[0] & /*hasIconOnly*/
256 });
var get_icon_slot_context2 = (ctx) => ({
  style: (
    /*hasIconOnly*/
    ctx[8] ? "margin-left: 0" : void 0
  ),
  .../*iconProps*/
  ctx[10]
});
var get_default_slot_changes3 = (dirty) => ({ props: dirty[0] & /*buttonProps*/
512 });
var get_default_slot_context3 = (ctx) => ({ props: (
  /*buttonProps*/
  ctx[9]
) });
function create_else_block7(ctx) {
  let button;
  let t0;
  let t1;
  let current_block_type_index;
  let if_block1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*hasIconOnly*/
    ctx[8] && create_if_block_8(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const if_block_creators = [create_if_block_6, create_if_block_7];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[12].icon
    ) return 0;
    if (
      /*icon*/
      ctx2[2]
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_2(ctx, [-1, -1]))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let button_levels = [
    /*buttonProps*/
    ctx[9]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (if_block0) if_block0.c();
      t0 = space();
      if (default_slot) default_slot.c();
      t1 = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {});
      var button_nodes = children(button);
      if (if_block0) if_block0.l(button_nodes);
      t0 = claim_space(button_nodes);
      if (default_slot) default_slot.l(button_nodes);
      t1 = claim_space(button_nodes);
      if (if_block1) if_block1.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file12, 183, 2, 4954);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (if_block0) if_block0.m(button, null);
      append_hydration_dev(button, t0);
      if (default_slot) {
        default_slot.m(button, null);
      }
      append_hydration_dev(button, t1);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(button, null);
      }
      if (button.autofocus) button.focus();
      ctx[41](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler_2*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "focus",
            /*focus_handler_2*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "blur",
            /*blur_handler_2*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseover",
            /*mouseover_handler_2*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseenter",
            /*mouseenter_handler_2*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseleave",
            /*mouseleave_handler_2*/
            ctx[33],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasIconOnly*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          if_block0.m(button, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(button, null);
        } else {
          if_block1 = null;
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [dirty[0] & /*buttonProps*/
      512 && /*buttonProps*/
      ctx2[9]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (if_block0) if_block0.d();
      if (default_slot) default_slot.d(detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      ctx[41](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(183:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let a;
  let t0;
  let t1;
  let current_block_type_index;
  let if_block1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*hasIconOnly*/
    ctx[8] && create_if_block_5(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const if_block_creators = [create_if_block_3, create_if_block_4];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[12].icon
    ) return 0;
    if (
      /*icon*/
      ctx2[2]
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx, [-1, -1]))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let a_levels = [
    /*buttonProps*/
    ctx[9]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (if_block0) if_block0.c();
      t0 = space();
      if (default_slot) default_slot.c();
      t1 = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {});
      var a_nodes = children(a);
      if (if_block0) if_block0.l(a_nodes);
      t0 = claim_space(a_nodes);
      if (default_slot) default_slot.l(a_nodes);
      t1 = claim_space(a_nodes);
      if (if_block1) if_block1.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file12, 154, 2, 4363);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (if_block0) if_block0.m(a, null);
      append_hydration_dev(a, t0);
      if (default_slot) {
        default_slot.m(a, null);
      }
      append_hydration_dev(a, t1);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(a, null);
      }
      ctx[40](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*click_handler_1*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "focus",
            /*focus_handler_1*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "blur",
            /*blur_handler_1*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseover",
            /*mouseover_handler_1*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseleave",
            /*mouseleave_handler_1*/
            ctx[27],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasIconOnly*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          if_block0.m(a, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(a, null);
        } else {
          if_block1 = null;
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [dirty[0] & /*buttonProps*/
      512 && /*buttonProps*/
      ctx2[9]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (if_block0) if_block0.d();
      if (default_slot) default_slot.d(detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      ctx[40](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(152:28) ",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_default_slot_context3
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, buttonProps*/
        1049088)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(150:13) ",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let buttonskeleton;
  let current;
  const buttonskeleton_spread_levels = [
    { href: (
      /*href*/
      ctx[7]
    ) },
    { size: (
      /*size*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[11],
    {
      style: (
        /*hasIconOnly*/
        ctx[8] && "width: 3rem;"
      )
    }
  ];
  let buttonskeleton_props = {};
  for (let i = 0; i < buttonskeleton_spread_levels.length; i += 1) {
    buttonskeleton_props = assign(buttonskeleton_props, buttonskeleton_spread_levels[i]);
  }
  buttonskeleton = new ButtonSkeleton_default({
    props: buttonskeleton_props,
    $$inline: true
  });
  buttonskeleton.$on(
    "click",
    /*click_handler*/
    ctx[34]
  );
  buttonskeleton.$on(
    "focus",
    /*focus_handler*/
    ctx[35]
  );
  buttonskeleton.$on(
    "blur",
    /*blur_handler*/
    ctx[36]
  );
  buttonskeleton.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[37]
  );
  buttonskeleton.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx[38]
  );
  buttonskeleton.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx[39]
  );
  const block = {
    c: function create() {
      create_component(buttonskeleton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(buttonskeleton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(buttonskeleton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const buttonskeleton_changes = dirty[0] & /*href, size, $$restProps, hasIconOnly*/
      2434 ? get_spread_update(buttonskeleton_spread_levels, [
        dirty[0] & /*href*/
        128 && { href: (
          /*href*/
          ctx2[7]
        ) },
        dirty[0] & /*size*/
        2 && { size: (
          /*size*/
          ctx2[1]
        ) },
        dirty[0] & /*$$restProps*/
        2048 && get_spread_object(
          /*$$restProps*/
          ctx2[11]
        ),
        dirty[0] & /*hasIconOnly*/
        256 && {
          style: (
            /*hasIconOnly*/
            ctx2[8] && "width: 3rem;"
          )
        }
      ]) : {};
      buttonskeleton.$set(buttonskeleton_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(buttonskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttonskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(buttonskeleton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(137:0) {#if skeleton}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*iconDescription*/
        ctx[3]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*iconDescription*/
        ctx[3]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--assistive-text", true);
      add_location(span, file12, 194, 6, 5128);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*iconDescription*/
      8) set_data_dev(
        t,
        /*iconDescription*/
        ctx2[3]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(194:4) {#if hasIconOnly}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      style: (
        /*hasIconOnly*/
        ctx[8] ? "margin-left: 0" : void 0
      )
    },
    /*iconProps*/
    ctx[10]
  ];
  var switch_value = (
    /*icon*/
    ctx[2]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty[0] & /*hasIconOnly, iconProps*/
    1280) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*hasIconOnly*/
        256 && {
          style: (
            /*hasIconOnly*/
            ctx2[8] ? "margin-left: 0" : void 0
          )
        },
        dirty[0] & /*iconProps*/
        1024 && get_spread_object(
          /*iconProps*/
          ctx2[10]
        )
      ]));
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*icon*/
      4 && switch_value !== (switch_value = /*icon*/
      ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*hasIconOnly, iconProps*/
        1280 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & /*hasIconOnly*/
          256 && {
            style: (
              /*hasIconOnly*/
              ctx2[8] ? "margin-left: 0" : void 0
            )
          },
          dirty[0] & /*iconProps*/
          1024 && get_spread_object(
            /*iconProps*/
            ctx2[10]
          )
        ]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(204:19) ",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[21].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_icon_slot_context_12
  );
  const block = {
    c: function create() {
      if (icon_slot) icon_slot.c();
    },
    l: function claim(nodes) {
      if (icon_slot) icon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[0] & /*$$scope, hasIconOnly, iconProps*/
        1049856)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            get_icon_slot_spread_changes_1(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_icon_slot_changes_12
            ),
            get_icon_slot_context_12
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (icon_slot) icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(198:4) {#if $$slots.icon}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*iconDescription*/
        ctx[3]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*iconDescription*/
        ctx[3]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--assistive-text", true);
      add_location(span, file12, 165, 6, 4532);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*iconDescription*/
      8) set_data_dev(
        t,
        /*iconDescription*/
        ctx2[3]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(165:4) {#if hasIconOnly}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      style: (
        /*hasIconOnly*/
        ctx[8] ? "margin-left: 0" : void 0
      )
    },
    /*iconProps*/
    ctx[10]
  ];
  var switch_value = (
    /*icon*/
    ctx[2]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty[0] & /*hasIconOnly, iconProps*/
    1280) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*hasIconOnly*/
        256 && {
          style: (
            /*hasIconOnly*/
            ctx2[8] ? "margin-left: 0" : void 0
          )
        },
        dirty[0] & /*iconProps*/
        1024 && get_spread_object(
          /*iconProps*/
          ctx2[10]
        )
      ]));
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*icon*/
      4 && switch_value !== (switch_value = /*icon*/
      ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*hasIconOnly, iconProps*/
        1280 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & /*hasIconOnly*/
          256 && {
            style: (
              /*hasIconOnly*/
              ctx2[8] ? "margin-left: 0" : void 0
            )
          },
          dirty[0] & /*iconProps*/
          1024 && get_spread_object(
            /*iconProps*/
            ctx2[10]
          )
        ]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(175:19) ",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[21].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_icon_slot_context2
  );
  const block = {
    c: function create() {
      if (icon_slot) icon_slot.c();
    },
    l: function claim(nodes) {
      if (icon_slot) icon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[0] & /*$$scope, hasIconOnly, iconProps*/
        1049856)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            get_icon_slot_spread_changes(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_icon_slot_changes2
            ),
            get_icon_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (icon_slot) icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(169:4) {#if $$slots.icon}",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block9, create_if_block_12, create_if_block_22, create_else_block7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*skeleton*/
      ctx2[5]
    ) return 0;
    if (
      /*as*/
      ctx2[4]
    ) return 1;
    if (
      /*href*/
      ctx2[7] && !/*disabled*/
      ctx2[6]
    ) return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let hasIconOnly;
  let iconProps;
  let buttonProps;
  const omit_props_names = [
    "kind",
    "size",
    "expressive",
    "isSelected",
    "icon",
    "iconDescription",
    "tooltipAlignment",
    "tooltipPosition",
    "as",
    "skeleton",
    "disabled",
    "href",
    "tabindex",
    "type",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default", "icon"]);
  const $$slots = compute_slots(slots);
  let { kind = "primary" } = $$props;
  let { size = "default" } = $$props;
  let { expressive = false } = $$props;
  let { isSelected = false } = $$props;
  let { icon = void 0 } = $$props;
  let { iconDescription = void 0 } = $$props;
  let { tooltipAlignment = "center" } = $$props;
  let { tooltipPosition = "bottom" } = $$props;
  let { as = false } = $$props;
  let { skeleton = false } = $$props;
  let { disabled = false } = $$props;
  let { href = void 0 } = $$props;
  let { tabindex = "0" } = $$props;
  let { type = "button" } = $$props;
  let { ref = null } = $$props;
  const ctx = getContext("ComposedModal");
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("kind" in $$new_props) $$invalidate(13, kind = $$new_props.kind);
    if ("size" in $$new_props) $$invalidate(1, size = $$new_props.size);
    if ("expressive" in $$new_props) $$invalidate(14, expressive = $$new_props.expressive);
    if ("isSelected" in $$new_props) $$invalidate(15, isSelected = $$new_props.isSelected);
    if ("icon" in $$new_props) $$invalidate(2, icon = $$new_props.icon);
    if ("iconDescription" in $$new_props) $$invalidate(3, iconDescription = $$new_props.iconDescription);
    if ("tooltipAlignment" in $$new_props) $$invalidate(16, tooltipAlignment = $$new_props.tooltipAlignment);
    if ("tooltipPosition" in $$new_props) $$invalidate(17, tooltipPosition = $$new_props.tooltipPosition);
    if ("as" in $$new_props) $$invalidate(4, as = $$new_props.as);
    if ("skeleton" in $$new_props) $$invalidate(5, skeleton = $$new_props.skeleton);
    if ("disabled" in $$new_props) $$invalidate(6, disabled = $$new_props.disabled);
    if ("href" in $$new_props) $$invalidate(7, href = $$new_props.href);
    if ("tabindex" in $$new_props) $$invalidate(18, tabindex = $$new_props.tabindex);
    if ("type" in $$new_props) $$invalidate(19, type = $$new_props.type);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    kind,
    size,
    expressive,
    isSelected,
    icon,
    iconDescription,
    tooltipAlignment,
    tooltipPosition,
    as,
    skeleton,
    disabled,
    href,
    tabindex,
    type,
    ref,
    getContext,
    ButtonSkeleton: ButtonSkeleton_default,
    ctx,
    hasIconOnly,
    buttonProps,
    iconProps
  });
  $$self.$inject_state = ($$new_props) => {
    if ("kind" in $$props) $$invalidate(13, kind = $$new_props.kind);
    if ("size" in $$props) $$invalidate(1, size = $$new_props.size);
    if ("expressive" in $$props) $$invalidate(14, expressive = $$new_props.expressive);
    if ("isSelected" in $$props) $$invalidate(15, isSelected = $$new_props.isSelected);
    if ("icon" in $$props) $$invalidate(2, icon = $$new_props.icon);
    if ("iconDescription" in $$props) $$invalidate(3, iconDescription = $$new_props.iconDescription);
    if ("tooltipAlignment" in $$props) $$invalidate(16, tooltipAlignment = $$new_props.tooltipAlignment);
    if ("tooltipPosition" in $$props) $$invalidate(17, tooltipPosition = $$new_props.tooltipPosition);
    if ("as" in $$props) $$invalidate(4, as = $$new_props.as);
    if ("skeleton" in $$props) $$invalidate(5, skeleton = $$new_props.skeleton);
    if ("disabled" in $$props) $$invalidate(6, disabled = $$new_props.disabled);
    if ("href" in $$props) $$invalidate(7, href = $$new_props.href);
    if ("tabindex" in $$props) $$invalidate(18, tabindex = $$new_props.tabindex);
    if ("type" in $$props) $$invalidate(19, type = $$new_props.type);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    if ("hasIconOnly" in $$props) $$invalidate(8, hasIconOnly = $$new_props.hasIconOnly);
    if ("buttonProps" in $$props) $$invalidate(9, buttonProps = $$new_props.buttonProps);
    if ("iconProps" in $$props) $$invalidate(10, iconProps = $$new_props.iconProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*ref*/
    1) {
      $: if (ctx && ref) {
        ctx.declareRef(ref);
      }
    }
    if ($$self.$$.dirty[0] & /*icon*/
    4) {
      $: $$invalidate(8, hasIconOnly = (icon || $$slots.icon) && !$$slots.default);
    }
    if ($$self.$$.dirty[0] & /*iconDescription*/
    8) {
      $: $$invalidate(10, iconProps = {
        "aria-hidden": "true",
        class: "bx--btn__icon",
        "aria-label": iconDescription
      });
    }
    $: $$invalidate(9, buttonProps = {
      type: href && !disabled ? void 0 : type,
      tabindex,
      disabled: disabled === true ? true : void 0,
      href,
      "aria-pressed": hasIconOnly && kind === "ghost" && !href ? isSelected : void 0,
      ...$$restProps,
      class: [
        "bx--btn",
        expressive && "bx--btn--expressive",
        (size === "small" && !expressive || size === "sm" && !expressive || size === "small" && !expressive) && "bx--btn--sm",
        size === "field" && !expressive || size === "md" && !expressive && "bx--btn--md",
        size === "field" && "bx--btn--field",
        size === "small" && "bx--btn--sm",
        size === "lg" && "bx--btn--lg",
        size === "xl" && "bx--btn--xl",
        kind && `bx--btn--${kind}`,
        disabled && "bx--btn--disabled",
        hasIconOnly && "bx--btn--icon-only",
        hasIconOnly && "bx--tooltip__trigger",
        hasIconOnly && "bx--tooltip--a11y",
        hasIconOnly && tooltipPosition && `bx--btn--icon-only--${tooltipPosition}`,
        hasIconOnly && tooltipAlignment && `bx--tooltip--align-${tooltipAlignment}`,
        hasIconOnly && isSelected && kind === "ghost" && "bx--btn--selected",
        $$restProps.class
      ].filter(Boolean).join(" ")
    });
  };
  return [
    ref,
    size,
    icon,
    iconDescription,
    as,
    skeleton,
    disabled,
    href,
    hasIconOnly,
    buttonProps,
    iconProps,
    $$restProps,
    $$slots,
    kind,
    expressive,
    isSelected,
    tooltipAlignment,
    tooltipPosition,
    tabindex,
    type,
    $$scope,
    slots,
    click_handler_13,
    focus_handler_1,
    blur_handler_1,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    click_handler_2,
    focus_handler_2,
    blur_handler_2,
    mouseover_handler_2,
    mouseenter_handler_2,
    mouseleave_handler_2,
    click_handler,
    focus_handler,
    blur_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    a_binding,
    button_binding
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance13,
      create_fragment13,
      safe_not_equal,
      {
        kind: 13,
        size: 1,
        expressive: 14,
        isSelected: 15,
        icon: 2,
        iconDescription: 3,
        tooltipAlignment: 16,
        tooltipPosition: 17,
        as: 4,
        skeleton: 5,
        disabled: 6,
        href: 7,
        tabindex: 18,
        type: 19,
        ref: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment13.name
    });
  }
  get kind() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expressive() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expressive(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isSelected() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSelected(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipAlignment() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipAlignment(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipPosition() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipPosition(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get as() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skeleton() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skeleton(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/carbon-components-svelte/src/Button/ButtonSet.svelte
var file13 = "node_modules/carbon-components-svelte/src/Button/ButtonSet.svelte";
function create_fragment14(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--btn-set", true);
      toggle_class(
        div,
        "bx--btn-set--stacked",
        /*stacked*/
        ctx[0]
      );
      add_location(div, file13, 5, 0, 105);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(div, "bx--btn-set", true);
      toggle_class(
        div,
        "bx--btn-set--stacked",
        /*stacked*/
        ctx2[0]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  const omit_props_names = ["stacked"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ButtonSet", slots, ["default"]);
  let { stacked = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("stacked" in $$new_props) $$invalidate(0, stacked = $$new_props.stacked);
    if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ stacked });
  $$self.$inject_state = ($$new_props) => {
    if ("stacked" in $$props) $$invalidate(0, stacked = $$new_props.stacked);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [stacked, $$restProps, $$scope, slots];
}
var ButtonSet = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { stacked: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonSet",
      options,
      id: create_fragment14.name
    });
  }
  get stacked() {
    throw new Error("<ButtonSet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stacked(value) {
    throw new Error("<ButtonSet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ButtonSet_default = ButtonSet;

// node_modules/carbon-components-svelte/src/Checkbox/CheckboxSkeleton.svelte
var file14 = "node_modules/carbon-components-svelte/src/Checkbox/CheckboxSkeleton.svelte";
function create_fragment15(ctx) {
  let div;
  let span;
  let mounted;
  let dispose;
  let div_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--checkbox-label-text", true);
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file14, 12, 2, 307);
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      toggle_class(div, "bx--checkbox-wrapper", true);
      toggle_class(div, "bx--checkbox-label", true);
      add_location(div, file14, 2, 0, 116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[1],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
      toggle_class(div, "bx--form-item", true);
      toggle_class(div, "bx--checkbox-wrapper", true);
      toggle_class(div, "bx--checkbox-label", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckboxSkeleton", slots, []);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var CheckboxSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckboxSkeleton",
      options,
      id: create_fragment15.name
    });
  }
};
var CheckboxSkeleton_default = CheckboxSkeleton;

// node_modules/carbon-components-svelte/src/Checkbox/Checkbox.svelte
var file15 = "node_modules/carbon-components-svelte/src/Checkbox/Checkbox.svelte";
var get_labelText_slot_changes = (dirty) => ({});
var get_labelText_slot_context = (ctx) => ({});
function create_else_block8(ctx) {
  let div;
  let input;
  let t;
  let label;
  let span;
  let current;
  let mounted;
  let dispose;
  const labelText_slot_template = (
    /*#slots*/
    ctx[19].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_labelText_slot_context
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block3(ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[16]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t = space();
      label = element("label");
      span = element("span");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", { type: true, id: true, name: true });
      t = claim_space(div_nodes);
      label = claim_element(div_nodes, "LABEL", { for: true, title: true });
      var label_nodes = children(label);
      span = claim_element(label_nodes, "SPAN", {});
      var span_nodes = children(span);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      input.value = /*value*/
      ctx[4];
      input.checked = /*checked*/
      ctx[0];
      input.disabled = /*disabled*/
      ctx[9];
      attr_dev(
        input,
        "id",
        /*id*/
        ctx[13]
      );
      input.indeterminate = /*indeterminate*/
      ctx[5];
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[12]
      );
      input.required = /*required*/
      ctx[7];
      input.readOnly = /*readonly*/
      ctx[8];
      toggle_class(input, "bx--checkbox", true);
      add_location(input, file15, 92, 4, 2175);
      toggle_class(span, "bx--checkbox-label-text", true);
      toggle_class(
        span,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[11]
      );
      add_location(span, file15, 118, 6, 2846);
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[13]
      );
      attr_dev(
        label,
        "title",
        /*title*/
        ctx[2]
      );
      toggle_class(label, "bx--checkbox-label", true);
      add_location(label, file15, 117, 4, 2771);
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      toggle_class(div, "bx--checkbox-wrapper", true);
      add_location(div, file15, 83, 2, 2002);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      ctx[31](input);
      append_hydration_dev(div, t);
      append_hydration_dev(div, label);
      append_hydration_dev(label, span);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span, null);
      }
      ctx[33](span);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*change_handler_1*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "click",
            /*click_handler_1*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler_1*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler_1*/
            ctx[23],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*value*/
      16) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*checked*/
      1) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      512) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*id*/
      8192) {
        attr_dev(
          input,
          "id",
          /*id*/
          ctx2[13]
        );
      }
      if (!current || dirty[0] & /*indeterminate*/
      32) {
        prop_dev(
          input,
          "indeterminate",
          /*indeterminate*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*name*/
      4096) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[12]
        );
      }
      if (!current || dirty[0] & /*required*/
      128) {
        prop_dev(
          input,
          "required",
          /*required*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*readonly*/
      256) {
        prop_dev(
          input,
          "readOnly",
          /*readonly*/
          ctx2[8]
        );
      }
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & /*$$scope*/
        262144)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_labelText_slot_changes
            ),
            get_labelText_slot_context
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & /*labelText*/
        1024)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*hideLabel*/
      2048) {
        toggle_class(
          span,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*id*/
      8192) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[13]
        );
      }
      if (!current || dirty[0] & /*title*/
      4) {
        attr_dev(
          label,
          "title",
          /*title*/
          ctx2[2]
        );
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty[0] & /*$$restProps*/
      65536 && /*$$restProps*/
      ctx2[16]]));
      toggle_class(div, "bx--form-item", true);
      toggle_class(div, "bx--checkbox-wrapper", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[31](null);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
      ctx[33](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(82:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let checkboxskeleton;
  let current;
  const checkboxskeleton_spread_levels = [
    /*$$restProps*/
    ctx[16]
  ];
  let checkboxskeleton_props = {};
  for (let i = 0; i < checkboxskeleton_spread_levels.length; i += 1) {
    checkboxskeleton_props = assign(checkboxskeleton_props, checkboxskeleton_spread_levels[i]);
  }
  checkboxskeleton = new CheckboxSkeleton_default({
    props: checkboxskeleton_props,
    $$inline: true
  });
  checkboxskeleton.$on(
    "click",
    /*click_handler*/
    ctx[27]
  );
  checkboxskeleton.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[28]
  );
  checkboxskeleton.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx[29]
  );
  checkboxskeleton.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx[30]
  );
  const block = {
    c: function create() {
      create_component(checkboxskeleton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(checkboxskeleton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(checkboxskeleton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkboxskeleton_changes = dirty[0] & /*$$restProps*/
      65536 ? get_spread_update(checkboxskeleton_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[16]
      )]) : {};
      checkboxskeleton.$set(checkboxskeleton_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(checkboxskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkboxskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkboxskeleton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(74:0) {#if skeleton}",
    ctx
  });
  return block;
}
function fallback_block3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[10]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[10]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelText*/
      1024) set_data_dev(
        t,
        /*labelText*/
        ctx2[10]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block3.name,
    type: "fallback",
    source: "(124:31)            ",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block10, create_else_block8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*skeleton*/
      ctx2[6]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let useGroup;
  let isTruncated;
  const omit_props_names = [
    "value",
    "checked",
    "group",
    "indeterminate",
    "skeleton",
    "required",
    "readonly",
    "disabled",
    "labelText",
    "hideLabel",
    "name",
    "title",
    "id",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Checkbox", slots, ["labelText"]);
  let { value = "" } = $$props;
  let { checked = false } = $$props;
  let { group = void 0 } = $$props;
  let { indeterminate = false } = $$props;
  let { skeleton = false } = $$props;
  let { required = false } = $$props;
  let { readonly: readonly2 = false } = $$props;
  let { disabled = false } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { name = "" } = $$props;
  let { title = void 0 } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let refLabel = null;
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  const change_handler_1 = () => {
    if (useGroup) {
      $$invalidate(1, group = group.includes(value) ? group.filter((_value) => _value !== value) : [...group, value]);
    } else {
      $$invalidate(0, checked = !checked);
    }
  };
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refLabel = $$value;
      $$invalidate(14, refLabel);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(4, value = $$new_props.value);
    if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
    if ("group" in $$new_props) $$invalidate(1, group = $$new_props.group);
    if ("indeterminate" in $$new_props) $$invalidate(5, indeterminate = $$new_props.indeterminate);
    if ("skeleton" in $$new_props) $$invalidate(6, skeleton = $$new_props.skeleton);
    if ("required" in $$new_props) $$invalidate(7, required = $$new_props.required);
    if ("readonly" in $$new_props) $$invalidate(8, readonly2 = $$new_props.readonly);
    if ("disabled" in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
    if ("labelText" in $$new_props) $$invalidate(10, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props) $$invalidate(11, hideLabel = $$new_props.hideLabel);
    if ("name" in $$new_props) $$invalidate(12, name = $$new_props.name);
    if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    if ("id" in $$new_props) $$invalidate(13, id = $$new_props.id);
    if ("ref" in $$new_props) $$invalidate(3, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    checked,
    group,
    indeterminate,
    skeleton,
    required,
    readonly: readonly2,
    disabled,
    labelText,
    hideLabel,
    name,
    title,
    id,
    ref,
    createEventDispatcher,
    CheckboxSkeleton: CheckboxSkeleton_default,
    dispatch,
    refLabel,
    isTruncated,
    useGroup
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(4, value = $$new_props.value);
    if ("checked" in $$props) $$invalidate(0, checked = $$new_props.checked);
    if ("group" in $$props) $$invalidate(1, group = $$new_props.group);
    if ("indeterminate" in $$props) $$invalidate(5, indeterminate = $$new_props.indeterminate);
    if ("skeleton" in $$props) $$invalidate(6, skeleton = $$new_props.skeleton);
    if ("required" in $$props) $$invalidate(7, required = $$new_props.required);
    if ("readonly" in $$props) $$invalidate(8, readonly2 = $$new_props.readonly);
    if ("disabled" in $$props) $$invalidate(9, disabled = $$new_props.disabled);
    if ("labelText" in $$props) $$invalidate(10, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props) $$invalidate(11, hideLabel = $$new_props.hideLabel);
    if ("name" in $$props) $$invalidate(12, name = $$new_props.name);
    if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    if ("id" in $$props) $$invalidate(13, id = $$new_props.id);
    if ("ref" in $$props) $$invalidate(3, ref = $$new_props.ref);
    if ("refLabel" in $$props) $$invalidate(14, refLabel = $$new_props.refLabel);
    if ("isTruncated" in $$props) $$invalidate(17, isTruncated = $$new_props.isTruncated);
    if ("useGroup" in $$props) $$invalidate(15, useGroup = $$new_props.useGroup);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*group*/
    2) {
      $: $$invalidate(15, useGroup = Array.isArray(group));
    }
    if ($$self.$$.dirty[0] & /*useGroup, group, value, checked*/
    32787) {
      $: $$invalidate(0, checked = useGroup ? group.includes(value) : checked);
    }
    if ($$self.$$.dirty[0] & /*checked*/
    1) {
      $: dispatch("check", checked);
    }
    if ($$self.$$.dirty[0] & /*refLabel*/
    16384) {
      $: $$invalidate(17, isTruncated = (refLabel == null ? void 0 : refLabel.offsetWidth) < (refLabel == null ? void 0 : refLabel.scrollWidth));
    }
    if ($$self.$$.dirty[0] & /*title, isTruncated, refLabel*/
    147460) {
      $: $$invalidate(2, title = !title && isTruncated ? refLabel == null ? void 0 : refLabel.innerText : title);
    }
  };
  return [
    checked,
    group,
    title,
    ref,
    value,
    indeterminate,
    skeleton,
    required,
    readonly2,
    disabled,
    labelText,
    hideLabel,
    name,
    id,
    refLabel,
    useGroup,
    $$restProps,
    isTruncated,
    $$scope,
    slots,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    change_handler,
    focus_handler,
    blur_handler,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    input_binding,
    change_handler_1,
    span_binding
  ];
}
var Checkbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance16,
      create_fragment16,
      safe_not_equal,
      {
        value: 4,
        checked: 0,
        group: 1,
        indeterminate: 5,
        skeleton: 6,
        required: 7,
        readonly: 8,
        disabled: 9,
        labelText: 10,
        hideLabel: 11,
        name: 12,
        title: 2,
        id: 13,
        ref: 3
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkbox",
      options,
      id: create_fragment16.name
    });
  }
  get value() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminate() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminate(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skeleton() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skeleton(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Checkbox_default = Checkbox;

// node_modules/carbon-components-svelte/src/Checkbox/InlineCheckbox.svelte
var file16 = "node_modules/carbon-components-svelte/src/Checkbox/InlineCheckbox.svelte";
function create_fragment17(ctx) {
  let div;
  let input;
  let input_checked_value;
  let input_aria_checked_value;
  let t;
  let label;
  let label_aria_label_value;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "checkbox" },
    {
      checked: input_checked_value = /*indeterminate*/
      ctx[2] ? false : (
        /*checked*/
        ctx[1]
      )
    },
    { indeterminate: (
      /*indeterminate*/
      ctx[2]
    ) },
    { id: (
      /*id*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[5],
    {
      "aria-checked": input_aria_checked_value = /*indeterminate*/
      ctx[2] ? void 0 : (
        /*checked*/
        ctx[1]
      )
    }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t = space();
      label = element("label");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", {
        type: true,
        id: true,
        "aria-checked": true
      });
      t = claim_space(div_nodes);
      label = claim_element(div_nodes, "LABEL", {
        for: true,
        title: true,
        "aria-label": true
      });
      children(label).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "bx--checkbox", true);
      add_location(input, file16, 21, 2, 530);
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[4]
      );
      attr_dev(
        label,
        "title",
        /*title*/
        ctx[3]
      );
      attr_dev(label, "aria-label", label_aria_label_value = /*$$props*/
      ctx[6]["aria-label"]);
      toggle_class(label, "bx--checkbox-label", true);
      add_location(label, file16, 34, 2, 833);
      toggle_class(div, "bx--checkbox--inline", true);
      add_location(div, file16, 20, 0, 486);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      if (input.autofocus) input.focus();
      ctx[10](input);
      append_hydration_dev(div, t);
      append_hydration_dev(div, label);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "checkbox" },
        dirty & /*indeterminate, checked*/
        6 && input_checked_value !== (input_checked_value = /*indeterminate*/
        ctx2[2] ? false : (
          /*checked*/
          ctx2[1]
        )) && { checked: input_checked_value },
        dirty & /*indeterminate*/
        4 && { indeterminate: (
          /*indeterminate*/
          ctx2[2]
        ) },
        dirty & /*id*/
        16 && { id: (
          /*id*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        dirty & /*indeterminate, checked*/
        6 && input_aria_checked_value !== (input_aria_checked_value = /*indeterminate*/
        ctx2[2] ? void 0 : (
          /*checked*/
          ctx2[1]
        )) && { "aria-checked": input_aria_checked_value }
      ]));
      toggle_class(input, "bx--checkbox", true);
      if (dirty & /*id*/
      16) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[4]
        );
      }
      if (dirty & /*title*/
      8) {
        attr_dev(
          label,
          "title",
          /*title*/
          ctx2[3]
        );
      }
      if (dirty & /*$$props*/
      64 && label_aria_label_value !== (label_aria_label_value = /*$$props*/
      ctx2[6]["aria-label"])) {
        attr_dev(label, "aria-label", label_aria_label_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[10](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  const omit_props_names = ["checked", "indeterminate", "title", "id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InlineCheckbox", slots, []);
  let { checked = false } = $$props;
  let { indeterminate = false } = $$props;
  let { title = void 0 } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props) $$invalidate(1, checked = $$new_props.checked);
    if ("indeterminate" in $$new_props) $$invalidate(2, indeterminate = $$new_props.indeterminate);
    if ("title" in $$new_props) $$invalidate(3, title = $$new_props.title);
    if ("id" in $$new_props) $$invalidate(4, id = $$new_props.id);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({ checked, indeterminate, title, id, ref });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("checked" in $$props) $$invalidate(1, checked = $$new_props.checked);
    if ("indeterminate" in $$props) $$invalidate(2, indeterminate = $$new_props.indeterminate);
    if ("title" in $$props) $$invalidate(3, title = $$new_props.title);
    if ("id" in $$props) $$invalidate(4, id = $$new_props.id);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    ref,
    checked,
    indeterminate,
    title,
    id,
    $$restProps,
    $$props,
    change_handler,
    focus_handler,
    blur_handler,
    input_binding
  ];
}
var InlineCheckbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, {
      checked: 1,
      indeterminate: 2,
      title: 3,
      id: 4,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InlineCheckbox",
      options,
      id: create_fragment17.name
    });
  }
  get checked() {
    throw new Error("<InlineCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<InlineCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminate() {
    throw new Error("<InlineCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminate(value) {
    throw new Error("<InlineCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<InlineCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<InlineCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InlineCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<InlineCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<InlineCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<InlineCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InlineCheckbox_default = InlineCheckbox;

// node_modules/carbon-components-svelte/src/ContentSwitcher/ContentSwitcher.svelte
var file17 = "node_modules/carbon-components-svelte/src/ContentSwitcher/ContentSwitcher.svelte";
function create_fragment18(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    { role: "tablist" },
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { role: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--content-switcher", true);
      toggle_class(
        div,
        "bx--content-switcher--sm",
        /*size*/
        ctx[0] === "sm"
      );
      toggle_class(
        div,
        "bx--content-switcher--xl",
        /*size*/
        ctx[0] === "xl"
      );
      add_location(div, file17, 61, 0, 1418);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [{ role: "tablist" }, dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(div, "bx--content-switcher", true);
      toggle_class(
        div,
        "bx--content-switcher--sm",
        /*size*/
        ctx2[0] === "sm"
      );
      toggle_class(
        div,
        "bx--content-switcher--xl",
        /*size*/
        ctx2[0] === "xl"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let currentIndex;
  let switches;
  const omit_props_names = ["selectedIndex", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContentSwitcher", slots, ["default"]);
  let { selectedIndex = 0 } = $$props;
  let { size = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  const currentId = writable(null);
  setContext("ContentSwitcher", {
    currentId,
    add: ({ id, text: text2, selected }) => {
      if (selected) {
        $$invalidate(2, selectedIndex = switches.length);
      }
      $$invalidate(4, switches = [...switches, { id, text: text2, selected }]);
    },
    update: (id) => {
      $$invalidate(2, selectedIndex = switches.map(({ id: id2 }) => id2).indexOf(id));
    },
    change: (direction) => {
      let index = currentIndex + direction;
      if (index < 0) {
        index = switches.length - 1;
      } else if (index >= switches.length) {
        index = 0;
      }
      $$invalidate(2, selectedIndex = index);
    }
  });
  afterUpdate(() => {
    if (selectedIndex !== currentIndex) {
      $$invalidate(3, currentIndex = selectedIndex);
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selectedIndex" in $$new_props) $$invalidate(2, selectedIndex = $$new_props.selectedIndex);
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selectedIndex,
    size,
    afterUpdate,
    createEventDispatcher,
    setContext,
    writable,
    dispatch,
    currentId,
    currentIndex,
    switches
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selectedIndex" in $$props) $$invalidate(2, selectedIndex = $$new_props.selectedIndex);
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("currentIndex" in $$props) $$invalidate(3, currentIndex = $$new_props.currentIndex);
    if ("switches" in $$props) $$invalidate(4, switches = $$new_props.switches);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*switches, currentIndex*/
    24) {
      $: if (switches[currentIndex]) {
        dispatch("change", currentIndex);
        currentId.set(switches[currentIndex].id);
      }
    }
  };
  $: $$invalidate(3, currentIndex = -1);
  $: $$invalidate(4, switches = []);
  return [
    size,
    $$restProps,
    selectedIndex,
    currentIndex,
    switches,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var ContentSwitcher = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { selectedIndex: 2, size: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContentSwitcher",
      options,
      id: create_fragment18.name
    });
  }
  get selectedIndex() {
    throw new Error("<ContentSwitcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedIndex(value) {
    throw new Error("<ContentSwitcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ContentSwitcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ContentSwitcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContentSwitcher_default = ContentSwitcher;

// node_modules/carbon-components-svelte/src/ContentSwitcher/Switch.svelte
var file18 = "node_modules/carbon-components-svelte/src/ContentSwitcher/Switch.svelte";
function fallback_block4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*text*/
        ctx[2]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*text*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text*/
      4) set_data_dev(
        t,
        /*text*/
        ctx2[2]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block4.name,
    type: "fallback",
    source: "(70:10) {text}",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let button;
  let span;
  let button_tabindex_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block4(ctx);
  let button_levels = [
    { type: "button" },
    { role: "tab" },
    {
      tabindex: button_tabindex_value = /*selected*/
      ctx[0] ? "0" : "-1"
    },
    { "aria-selected": (
      /*selected*/
      ctx[0]
    ) },
    { disabled: (
      /*disabled*/
      ctx[3]
    ) },
    { id: (
      /*id*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      span = element("span");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        role: true,
        tabindex: true,
        "aria-selected": true,
        id: true
      });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot_or_fallback) default_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--content-switcher__label", true);
      add_location(span, file18, 68, 2, 1518);
      set_attributes(button, button_data);
      toggle_class(button, "bx--content-switcher-btn", true);
      toggle_class(
        button,
        "bx--content-switcher--selected",
        /*selected*/
        ctx[0]
      );
      add_location(button, file18, 41, 0, 954);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, span);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      if (button.autofocus) button.focus();
      ctx[14](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(button, "click", prevent_default(
            /*click_handler_1*/
            ctx[15]
          ), false, true, false, false),
          listen_dev(
            button,
            "mouseover",
            /*mouseover_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler_1*/
            ctx[16],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*text*/
        4)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        { role: "tab" },
        (!current || dirty & /*selected*/
        1 && button_tabindex_value !== (button_tabindex_value = /*selected*/
        ctx2[0] ? "0" : "-1")) && { tabindex: button_tabindex_value },
        (!current || dirty & /*selected*/
        1) && { "aria-selected": (
          /*selected*/
          ctx2[0]
        ) },
        (!current || dirty & /*disabled*/
        8) && { disabled: (
          /*disabled*/
          ctx2[3]
        ) },
        (!current || dirty & /*id*/
        16) && { id: (
          /*id*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
      toggle_class(button, "bx--content-switcher-btn", true);
      toggle_class(
        button,
        "bx--content-switcher--selected",
        /*selected*/
        ctx2[0]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  const omit_props_names = ["text", "selected", "disabled", "id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Switch", slots, ["default"]);
  let { text: text2 = "Provide text" } = $$props;
  let { selected = false } = $$props;
  let { disabled = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const ctx = getContext("ContentSwitcher");
  ctx.add({ id, text: text2, selected });
  const unsubscribe = ctx.currentId.subscribe((currentId) => {
    $$invalidate(0, selected = currentId === id);
  });
  afterUpdate(() => {
    if (selected) {
      ref.focus();
    }
  });
  onMount(() => {
    return () => unsubscribe();
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const click_handler_13 = () => {
    ctx.update(id);
  };
  const keydown_handler_12 = ({ key }) => {
    if (key === "ArrowRight") {
      ctx.change(1);
    } else if (key === "ArrowLeft") {
      ctx.change(-1);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("text" in $$new_props) $$invalidate(2, text2 = $$new_props.text);
    if ("selected" in $$new_props) $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
    if ("id" in $$new_props) $$invalidate(4, id = $$new_props.id);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    text: text2,
    selected,
    disabled,
    id,
    ref,
    afterUpdate,
    getContext,
    onMount,
    ctx,
    unsubscribe
  });
  $$self.$inject_state = ($$new_props) => {
    if ("text" in $$props) $$invalidate(2, text2 = $$new_props.text);
    if ("selected" in $$props) $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$props) $$invalidate(3, disabled = $$new_props.disabled);
    if ("id" in $$props) $$invalidate(4, id = $$new_props.id);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    selected,
    ref,
    text2,
    disabled,
    id,
    ctx,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    button_binding,
    click_handler_13,
    keydown_handler_12
  ];
}
var Switch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {
      text: 2,
      selected: 0,
      disabled: 3,
      id: 4,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Switch",
      options,
      id: create_fragment19.name
    });
  }
  get text() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Switch_default = Switch;

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenu.svelte
var { window: window_1 } = globals;
var file19 = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenu.svelte";
function create_fragment20(ctx) {
  let ul;
  let style_left = `${/*x*/
  ctx[1]}px`;
  let style_top = `${/*y*/
  ctx[2]}px`;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  let ul_levels = [
    { role: "menu" },
    { tabindex: "-1" },
    { "data-direction": (
      /*direction*/
      ctx[10]
    ) },
    { "data-level": (
      /*level*/
      ctx[7]
    ) },
    /*$$restProps*/
    ctx[13]
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {
        role: true,
        tabindex: true,
        "data-direction": true,
        "data-level": true
      });
      var ul_nodes = children(ul);
      if (default_slot) default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--menu", true);
      toggle_class(
        ul,
        "bx--menu--open",
        /*open*/
        ctx[0]
      );
      toggle_class(
        ul,
        "bx--menu--invisible",
        /*open*/
        ctx[0] && /*x*/
        ctx[1] === 0 && /*y*/
        ctx[2] === 0
      );
      toggle_class(
        ul,
        "bx--menu--root",
        /*level*/
        ctx[7] === 1
      );
      set_style(ul, "left", style_left);
      set_style(ul, "top", style_top);
      add_location(ul, file19, 157, 0, 3389);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[21](ul);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window_1,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "click",
            /*click_handler_1*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "keydown",
            /*keydown_handler_1*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "click",
            /*click_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "click",
            /*click_handler_2*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "keydown",
            /*keydown_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "keydown",
            /*keydown_handler_2*/
            ctx[23],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        { role: "menu" },
        { tabindex: "-1" },
        { "data-direction": (
          /*direction*/
          ctx2[10]
        ) },
        (!current || dirty[0] & /*level*/
        128) && { "data-level": (
          /*level*/
          ctx2[7]
        ) },
        dirty[0] & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx2[13]
      ]));
      toggle_class(ul, "bx--menu", true);
      toggle_class(
        ul,
        "bx--menu--open",
        /*open*/
        ctx2[0]
      );
      toggle_class(
        ul,
        "bx--menu--invisible",
        /*open*/
        ctx2[0] && /*x*/
        ctx2[1] === 0 && /*y*/
        ctx2[2] === 0
      );
      toggle_class(
        ul,
        "bx--menu--root",
        /*level*/
        ctx2[7] === 1
      );
      if (dirty[0] & /*x*/
      2) {
        style_left = `${/*x*/
        ctx2[1]}px`;
      }
      set_style(ul, "left", style_left);
      if (dirty[0] & /*y*/
      4) {
        style_top = `${/*y*/
        ctx2[2]}px`;
      }
      set_style(ul, "top", style_top);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let level;
  const omit_props_names = ["target", "open", "x", "y", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $hasPopup;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenu", slots, ["default"]);
  let { target = null } = $$props;
  let { open = false } = $$props;
  let { x = 0 } = $$props;
  let { y = 0 } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  const position = writable([x, y]);
  const currentIndex = writable(-1);
  const hasPopup = writable(false);
  validate_store(hasPopup, "hasPopup");
  component_subscribe($$self, hasPopup, (value) => $$invalidate(8, $hasPopup = value));
  const menuOffsetX = writable(0);
  const ctx = getContext("ContextMenu");
  let options = [];
  let direction = 1;
  let prevX = 0;
  let prevY = 0;
  let focusIndex = -1;
  let openDetail = null;
  function close() {
    $$invalidate(0, open = false);
    $$invalidate(1, x = 0);
    $$invalidate(2, y = 0);
    prevX = 0;
    prevY = 0;
    $$invalidate(5, focusIndex = -1);
  }
  function openMenu(e) {
    e.preventDefault();
    const { height, width } = ref.getBoundingClientRect();
    if (open || x === 0) {
      if (window.innerWidth - width < e.x) {
        $$invalidate(1, x = e.x - width);
      } else {
        $$invalidate(1, x = e.x);
      }
    }
    if (open || y === 0) {
      menuOffsetX.set(e.x);
      if (window.innerHeight - height < e.y) {
        $$invalidate(2, y = e.y - height);
      } else {
        $$invalidate(2, y = e.y);
      }
    }
    position.set([x, y]);
    $$invalidate(0, open = true);
    openDetail = e.target;
  }
  onMount(() => {
    return () => {
      if (target != null) {
        if (Array.isArray(target)) {
          target.forEach((node) => node == null ? void 0 : node.removeEventListener("contextmenu", openMenu));
        } else {
          target.removeEventListener("contextmenu", openMenu);
        }
      }
    };
  });
  setContext("ContextMenu", {
    menuOffsetX,
    currentIndex,
    position,
    close,
    setPopup: (popup) => {
      hasPopup.set(popup);
    }
  });
  afterUpdate(() => {
    if (open) {
      $$invalidate(6, options = [...ref.querySelectorAll("li[data-nested='false']")]);
      if (level === 1) {
        if (prevX !== x || prevY !== y) ref.focus();
        prevX = x;
        prevY = y;
      }
      dispatch("open", openDetail);
    } else {
      dispatch("close");
    }
    if (!$hasPopup && options[focusIndex]) options[focusIndex].focus();
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const contextmenu_handler = (e) => {
    if (target != null) return;
    if (level > 1) return;
    if (!ref) return;
    openMenu(e);
  };
  const click_handler_13 = (e) => {
    if (!open) return;
    close();
  };
  const keydown_handler_12 = (e) => {
    if (open && e.key === "Escape") close();
  };
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  const click_handler_2 = ({ target: target2 }) => {
    const closestOption = target2.closest("[tabindex]");
    if (closestOption && closestOption.getAttribute("role") !== "menuitem") {
      close();
    }
  };
  const keydown_handler_2 = (e) => {
    if (open) e.preventDefault();
    if ($hasPopup) return;
    if (e.key === "ArrowDown") {
      if (focusIndex < options.length - 1) $$invalidate(5, focusIndex++, focusIndex);
    } else if (e.key === "ArrowUp") {
      if (focusIndex === -1) {
        $$invalidate(5, focusIndex = options.length - 1);
      } else {
        if (focusIndex > 0) $$invalidate(5, focusIndex--, focusIndex);
      }
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("target" in $$new_props) $$invalidate(4, target = $$new_props.target);
    if ("open" in $$new_props) $$invalidate(0, open = $$new_props.open);
    if ("x" in $$new_props) $$invalidate(1, x = $$new_props.x);
    if ("y" in $$new_props) $$invalidate(2, y = $$new_props.y);
    if ("ref" in $$new_props) $$invalidate(3, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    target,
    open,
    x,
    y,
    ref,
    onMount,
    setContext,
    getContext,
    afterUpdate,
    createEventDispatcher,
    writable,
    dispatch,
    position,
    currentIndex,
    hasPopup,
    menuOffsetX,
    ctx,
    options,
    direction,
    prevX,
    prevY,
    focusIndex,
    openDetail,
    close,
    openMenu,
    level,
    $hasPopup
  });
  $$self.$inject_state = ($$new_props) => {
    if ("target" in $$props) $$invalidate(4, target = $$new_props.target);
    if ("open" in $$props) $$invalidate(0, open = $$new_props.open);
    if ("x" in $$props) $$invalidate(1, x = $$new_props.x);
    if ("y" in $$props) $$invalidate(2, y = $$new_props.y);
    if ("ref" in $$props) $$invalidate(3, ref = $$new_props.ref);
    if ("options" in $$props) $$invalidate(6, options = $$new_props.options);
    if ("direction" in $$props) $$invalidate(10, direction = $$new_props.direction);
    if ("prevX" in $$props) prevX = $$new_props.prevX;
    if ("prevY" in $$props) prevY = $$new_props.prevY;
    if ("focusIndex" in $$props) $$invalidate(5, focusIndex = $$new_props.focusIndex);
    if ("openDetail" in $$props) openDetail = $$new_props.openDetail;
    if ("level" in $$props) $$invalidate(7, level = $$new_props.level);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*target*/
    16) {
      $: if (target != null) {
        if (Array.isArray(target)) {
          target.forEach((node) => node == null ? void 0 : node.addEventListener("contextmenu", openMenu));
        } else {
          target.addEventListener("contextmenu", openMenu);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*focusIndex*/
    32) {
      $: currentIndex.set(focusIndex);
    }
  };
  $: $$invalidate(7, level = !ctx ? 1 : 2);
  return [
    open,
    x,
    y,
    ref,
    target,
    focusIndex,
    options,
    level,
    $hasPopup,
    hasPopup,
    direction,
    close,
    openMenu,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    contextmenu_handler,
    click_handler_13,
    keydown_handler_12,
    ul_binding,
    click_handler_2,
    keydown_handler_2
  ];
}
var ContextMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { target: 4, open: 0, x: 1, y: 2, ref: 3 }, null, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenu",
      options,
      id: create_fragment20.name
    });
  }
  get target() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenu_default = ContextMenu;

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuDivider.svelte
var file20 = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuDivider.svelte";
function create_fragment21(ctx) {
  let li;
  const block = {
    c: function create() {
      li = element("li");
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { role: true });
      children(li).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "role", "separator");
      toggle_class(li, "bx--menu-divider", true);
      add_location(li, file20, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuDivider", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ContextMenuDivider> was created with unknown prop '${key}'`);
  });
  return [];
}
var ContextMenuDivider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuDivider",
      options,
      id: create_fragment21.name
    });
  }
};
var ContextMenuDivider_default = ContextMenuDivider;

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuGroup.svelte
var file21 = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuGroup.svelte";
function create_fragment22(ctx) {
  let li;
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      li = element("li");
      ul = element("ul");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { role: true });
      var li_nodes = children(li);
      ul = claim_element(li_nodes, "UL", { role: true, "aria-label": true });
      var ul_nodes = children(ul);
      if (default_slot) default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "role", "group");
      attr_dev(
        ul,
        "aria-label",
        /*labelText*/
        ctx[0]
      );
      add_location(ul, file21, 32, 2, 714);
      attr_dev(li, "role", "none");
      add_location(li, file21, 31, 0, 695);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*labelText*/
      1) {
        attr_dev(
          ul,
          "aria-label",
          /*labelText*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuGroup", slots, ["default"]);
  let { selectedIds = [] } = $$props;
  let { labelText = "" } = $$props;
  const currentIds = writable([]);
  setContext("ContextMenuGroup", {
    currentIds,
    addOption: ({ id }) => {
      if (!selectedIds.includes(id)) {
        $$invalidate(1, selectedIds = [...selectedIds, id]);
      }
    },
    toggleOption: ({ id }) => {
      if (!selectedIds.includes(id)) {
        $$invalidate(1, selectedIds = [...selectedIds, id]);
      } else {
        $$invalidate(1, selectedIds = selectedIds.filter((_) => _ !== id));
      }
    }
  });
  const writable_props = ["selectedIds", "labelText"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ContextMenuGroup> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("selectedIds" in $$props2) $$invalidate(1, selectedIds = $$props2.selectedIds);
    if ("labelText" in $$props2) $$invalidate(0, labelText = $$props2.labelText);
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    selectedIds,
    labelText,
    setContext,
    writable,
    currentIds
  });
  $$self.$inject_state = ($$props2) => {
    if ("selectedIds" in $$props2) $$invalidate(1, selectedIds = $$props2.selectedIds);
    if ("labelText" in $$props2) $$invalidate(0, labelText = $$props2.labelText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selectedIds*/
    2) {
      $: currentIds.set(selectedIds);
    }
  };
  return [labelText, selectedIds, $$scope, slots];
}
var ContextMenuGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { selectedIds: 1, labelText: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuGroup",
      options,
      id: create_fragment22.name
    });
  }
  get selectedIds() {
    throw new Error("<ContextMenuGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedIds(value) {
    throw new Error("<ContextMenuGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<ContextMenuGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<ContextMenuGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuGroup_default = ContextMenuGroup;

// node_modules/carbon-components-svelte/src/icons/Checkmark.svelte
var file22 = "node_modules/carbon-components-svelte/src/icons/Checkmark.svelte";
function create_if_block11(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file22, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block11(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 24L4 15 5.414 13.586 13 21.171 26.586 7.586 28 9 13 24z");
      add_location(path, file22, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file22, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block11(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Checkmark", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Checkmark = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkmark",
      options,
      id: create_fragment23.name
    });
  }
  get size() {
    throw new Error("<Checkmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Checkmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Checkmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Checkmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Checkmark_default = Checkmark;

// node_modules/carbon-components-svelte/src/icons/CaretRight.svelte
var file23 = "node_modules/carbon-components-svelte/src/icons/CaretRight.svelte";
function create_if_block12(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file23, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block12(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 8L22 16 12 24z");
      add_location(path, file23, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file23, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block12(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CaretRight", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var CaretRight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CaretRight",
      options,
      id: create_fragment24.name
    });
  }
  get size() {
    throw new Error("<CaretRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CaretRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CaretRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CaretRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CaretRight_default = CaretRight;

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuOption.svelte
var file24 = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuOption.svelte";
var get_shortcutText_slot_changes = (dirty) => ({});
var get_shortcutText_slot_context = (ctx) => ({});
var get_labelText_slot_changes_1 = (dirty) => ({});
var get_labelText_slot_context_1 = (ctx) => ({});
var get_icon_slot_changes_13 = (dirty) => ({});
var get_icon_slot_context_13 = (ctx) => ({});
var get_labelText_slot_changes2 = (dirty) => ({});
var get_labelText_slot_context2 = (ctx) => ({});
var get_icon_slot_changes3 = (dirty) => ({});
var get_icon_slot_context3 = (ctx) => ({});
function create_else_block9(ctx) {
  let div1;
  let t0;
  let span;
  let t1;
  let div0;
  let current;
  let if_block = (
    /*indented*/
    ctx[2] && create_if_block_23(ctx)
  );
  const labelText_slot_template = (
    /*#slots*/
    ctx[23].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    get_labelText_slot_context_1
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block_3(ctx);
  const shortcutText_slot_template = (
    /*#slots*/
    ctx[23].shortcutText
  );
  const shortcutText_slot = create_slot(
    shortcutText_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    get_shortcutText_slot_context
  );
  const shortcutText_slot_or_fallback = shortcutText_slot || fallback_block_2(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block) if_block.c();
      t0 = space();
      span = element("span");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      t1 = space();
      div0 = element("div");
      if (shortcutText_slot_or_fallback) shortcutText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      if (if_block) if_block.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      span = claim_element(div1_nodes, "SPAN", { title: true });
      var span_nodes = children(span);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (shortcutText_slot_or_fallback) shortcutText_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        span,
        "title",
        /*labelText*/
        ctx[6]
      );
      toggle_class(span, "bx--menu-option__label", true);
      add_location(span, file24, 277, 6, 7355);
      toggle_class(div0, "bx--menu-option__info", true);
      add_location(div0, file24, 280, 6, 7490);
      toggle_class(div1, "bx--menu-option__content", true);
      toggle_class(
        div1,
        "bx--menu-option__content--disabled",
        /*disabled*/
        ctx[5]
      );
      add_location(div1, file24, 266, 4, 7039);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block) if_block.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, span);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span, null);
      }
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      if (shortcutText_slot_or_fallback) {
        shortcutText_slot_or_fallback.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*indented*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*indented*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_23(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              get_labelText_slot_changes_1
            ),
            get_labelText_slot_context_1
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & /*labelText*/
        64)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*labelText*/
      64) {
        attr_dev(
          span,
          "title",
          /*labelText*/
          ctx2[6]
        );
      }
      if (shortcutText_slot) {
        if (shortcutText_slot.p && (!current || dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            shortcutText_slot,
            shortcutText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              shortcutText_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              get_shortcutText_slot_changes
            ),
            get_shortcutText_slot_context
          );
        }
      } else {
        if (shortcutText_slot_or_fallback && shortcutText_slot_or_fallback.p && (!current || dirty[0] & /*shortcutText*/
        128)) {
          shortcutText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*disabled*/
      32) {
        toggle_class(
          div1,
          "bx--menu-option__content--disabled",
          /*disabled*/
          ctx2[5]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(labelText_slot_or_fallback, local);
      transition_in(shortcutText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(labelText_slot_or_fallback, local);
      transition_out(shortcutText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block) if_block.d();
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
      if (shortcutText_slot_or_fallback) shortcutText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block9.name,
    type: "else",
    source: "(266:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block13(ctx) {
  let div1;
  let t0;
  let span;
  let t1;
  let div0;
  let caretright;
  let t2;
  let contextmenu;
  let current;
  let if_block = (
    /*indented*/
    ctx[2] && create_if_block_13(ctx)
  );
  const labelText_slot_template = (
    /*#slots*/
    ctx[23].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    get_labelText_slot_context2
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block5(ctx);
  caretright = new CaretRight_default({ $$inline: true });
  contextmenu = new ContextMenu_default({
    props: {
      open: (
        /*submenuOpen*/
        ctx[9]
      ),
      x: (
        /*submenuPosition*/
        ctx[16][0]
      ),
      y: (
        /*submenuPosition*/
        ctx[16][1]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block) if_block.c();
      t0 = space();
      span = element("span");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      t1 = space();
      div0 = element("div");
      create_component(caretright.$$.fragment);
      t2 = space();
      create_component(contextmenu.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      if (if_block) if_block.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      span = claim_element(div1_nodes, "SPAN", { title: true });
      var span_nodes = children(span);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      claim_component(caretright.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(nodes);
      claim_component(contextmenu.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        span,
        "title",
        /*labelText*/
        ctx[6]
      );
      toggle_class(span, "bx--menu-option__label", true);
      add_location(span, file24, 252, 6, 6669);
      toggle_class(div0, "bx--menu-option__info", true);
      add_location(div0, file24, 255, 6, 6804);
      toggle_class(div1, "bx--menu-option__content", true);
      toggle_class(
        div1,
        "bx--menu-option__content--disabled",
        /*disabled*/
        ctx[5]
      );
      add_location(div1, file24, 241, 4, 6353);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block) if_block.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, span);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span, null);
      }
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      mount_component(caretright, div0, null);
      insert_hydration_dev(target, t2, anchor);
      mount_component(contextmenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*indented*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*indented*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              get_labelText_slot_changes2
            ),
            get_labelText_slot_context2
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & /*labelText*/
        64)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*labelText*/
      64) {
        attr_dev(
          span,
          "title",
          /*labelText*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      32) {
        toggle_class(
          div1,
          "bx--menu-option__content--disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      const contextmenu_changes = {};
      if (dirty[0] & /*submenuOpen*/
      512) contextmenu_changes.open = /*submenuOpen*/
      ctx2[9];
      if (dirty[0] & /*submenuPosition*/
      65536) contextmenu_changes.x = /*submenuPosition*/
      ctx2[16][0];
      if (dirty[0] & /*submenuPosition*/
      65536) contextmenu_changes.y = /*submenuPosition*/
      ctx2[16][1];
      if (dirty[1] & /*$$scope*/
      1) {
        contextmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextmenu.$set(contextmenu_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(labelText_slot_or_fallback, local);
      transition_in(caretright.$$.fragment, local);
      transition_in(contextmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(labelText_slot_or_fallback, local);
      transition_out(caretright.$$.fragment, local);
      transition_out(contextmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
        detach_dev(t2);
      }
      if (if_block) if_block.d();
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
      destroy_component(caretright);
      destroy_component(contextmenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(241:2) {#if subOptions}",
    ctx
  });
  return block;
}
function create_if_block_23(ctx) {
  let div;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[23].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    get_icon_slot_context_13
  );
  const icon_slot_or_fallback = icon_slot || fallback_block_4(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback) icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (icon_slot_or_fallback) icon_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--menu-option__icon", true);
      add_location(div, file24, 271, 8, 7185);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              get_icon_slot_changes_13
            ),
            get_icon_slot_context_13
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty[0] & /*icon*/
        8)) {
          icon_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(271:6) {#if indented}",
    ctx
  });
  return block;
}
function fallback_block_4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[3]
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*icon*/
      8 && switch_value !== (switch_value = /*icon*/
      ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_4.name,
    type: "fallback",
    source: "(273:28)              ",
    ctx
  });
  return block;
}
function fallback_block_3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[6]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[6]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelText*/
      64) set_data_dev(
        t,
        /*labelText*/
        ctx2[6]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_3.name,
    type: "fallback",
    source: "(279:31) {labelText}",
    ctx
  });
  return block;
}
function fallback_block_2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*shortcutText*/
        ctx[7]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*shortcutText*/
        ctx[7]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*shortcutText*/
      128) set_data_dev(
        t,
        /*shortcutText*/
        ctx2[7]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(282:34) {shortcutText}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let div;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[23].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    get_icon_slot_context3
  );
  const icon_slot_or_fallback = icon_slot || fallback_block_12(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback) icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (icon_slot_or_fallback) icon_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--menu-option__icon", true);
      add_location(div, file24, 246, 8, 6499);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              get_icon_slot_changes3
            ),
            get_icon_slot_context3
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty[0] & /*icon*/
        8)) {
          icon_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(246:6) {#if indented}",
    ctx
  });
  return block;
}
function fallback_block_12(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[3]
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*icon*/
      8 && switch_value !== (switch_value = /*icon*/
      ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_12.name,
    type: "fallback",
    source: "(248:28)              ",
    ctx
  });
  return block;
}
function fallback_block5(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[6]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[6]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelText*/
      64) set_data_dev(
        t,
        /*labelText*/
        ctx2[6]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block5.name,
    type: "fallback",
    source: "(254:31) {labelText}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: '(259:4) <ContextMenu       open=\\"{submenuOpen}\\"       x=\\"{submenuPosition[0]}\\"       y=\\"{submenuPosition[1]}\\"     >',
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let li;
  let current_block_type_index;
  let if_block;
  let li_aria_disabled_value;
  let li_aria_haspopup_value;
  let li_aria_expanded_value;
  let li_aria_checked_value;
  let li_data_nested_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block13, create_else_block9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*subOptions*/
      ctx2[17]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let li_levels = [
    { role: (
      /*role*/
      ctx[15]
    ) },
    { tabindex: "-1" },
    {
      "aria-disabled": li_aria_disabled_value = !/*subOptions*/
      ctx[17] && /*disabled*/
      ctx[5]
    },
    {
      "aria-haspopup": li_aria_haspopup_value = /*subOptions*/
      ctx[17] ? true : void 0
    },
    {
      "aria-expanded": li_aria_expanded_value = /*subOptions*/
      ctx[17] ? (
        /*submenuOpen*/
        ctx[9]
      ) : void 0
    },
    { indented: (
      /*indented*/
      ctx[2]
    ) },
    {
      "aria-checked": li_aria_checked_value = /*isSelectable*/
      ctx[11] || /*isRadio*/
      ctx[10] ? (
        /*selected*/
        ctx[0]
      ) : void 0
    },
    {
      "data-nested": li_data_nested_value = /*ref*/
      ctx[1] && /*ref*/
      ctx[1].closest(".bx--menu").getAttribute("data-level") === "2"
    },
    { "data-sub": (
      /*subOptions*/
      ctx[17]
    ) },
    { "data-id": (
      /*id*/
      ctx[8]
    ) },
    /*$$restProps*/
    ctx[19]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        role: true,
        tabindex: true,
        "aria-disabled": true,
        "aria-haspopup": true,
        "aria-expanded": true,
        indented: true,
        "aria-checked": true,
        "data-nested": true,
        "data-sub": true,
        "data-id": true
      });
      var li_nodes = children(li);
      if_block.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(li, li_data);
      toggle_class(li, "bx--menu-option", true);
      toggle_class(li, "bx--menu-option--disabled", true);
      toggle_class(
        li,
        "bx--menu-option--active",
        /*subOptions*/
        ctx[17] && /*submenuOpen*/
        ctx[9]
      );
      toggle_class(li, "bx--menu-option--danger", !/*subOptions*/
      ctx[17] && /*kind*/
      ctx[4] === "danger");
      add_location(li, file24, 168, 0, 4341);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      ctx[27](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            li,
            "keydown",
            /*keydown_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keydown",
            /*keydown_handler_1*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseleave",
            /*mouseleave_handler_1*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "click",
            /*handleClick*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li, null);
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty[0] & /*role*/
        32768) && { role: (
          /*role*/
          ctx2[15]
        ) },
        { tabindex: "-1" },
        (!current || dirty[0] & /*subOptions, disabled*/
        131104 && li_aria_disabled_value !== (li_aria_disabled_value = !/*subOptions*/
        ctx2[17] && /*disabled*/
        ctx2[5])) && { "aria-disabled": li_aria_disabled_value },
        (!current || dirty[0] & /*subOptions*/
        131072 && li_aria_haspopup_value !== (li_aria_haspopup_value = /*subOptions*/
        ctx2[17] ? true : void 0)) && { "aria-haspopup": li_aria_haspopup_value },
        (!current || dirty[0] & /*subOptions, submenuOpen*/
        131584 && li_aria_expanded_value !== (li_aria_expanded_value = /*subOptions*/
        ctx2[17] ? (
          /*submenuOpen*/
          ctx2[9]
        ) : void 0)) && { "aria-expanded": li_aria_expanded_value },
        (!current || dirty[0] & /*indented*/
        4) && { indented: (
          /*indented*/
          ctx2[2]
        ) },
        (!current || dirty[0] & /*isSelectable, isRadio, selected*/
        3073 && li_aria_checked_value !== (li_aria_checked_value = /*isSelectable*/
        ctx2[11] || /*isRadio*/
        ctx2[10] ? (
          /*selected*/
          ctx2[0]
        ) : void 0)) && { "aria-checked": li_aria_checked_value },
        (!current || dirty[0] & /*ref*/
        2 && li_data_nested_value !== (li_data_nested_value = /*ref*/
        ctx2[1] && /*ref*/
        ctx2[1].closest(".bx--menu").getAttribute("data-level") === "2")) && { "data-nested": li_data_nested_value },
        (!current || dirty[0] & /*subOptions*/
        131072) && { "data-sub": (
          /*subOptions*/
          ctx2[17]
        ) },
        (!current || dirty[0] & /*id*/
        256) && { "data-id": (
          /*id*/
          ctx2[8]
        ) },
        dirty[0] & /*$$restProps*/
        524288 && /*$$restProps*/
        ctx2[19]
      ]));
      toggle_class(li, "bx--menu-option", true);
      toggle_class(li, "bx--menu-option--disabled", true);
      toggle_class(
        li,
        "bx--menu-option--active",
        /*subOptions*/
        ctx2[17] && /*submenuOpen*/
        ctx2[9]
      );
      toggle_class(li, "bx--menu-option--danger", !/*subOptions*/
      ctx2[17] && /*kind*/
      ctx2[4] === "danger");
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if_blocks[current_block_type_index].d();
      ctx[27](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var moderate01 = 150;
function instance25($$self, $$props, $$invalidate) {
  let isSelectable;
  let isRadio;
  let subOptions;
  const omit_props_names = [
    "kind",
    "disabled",
    "indented",
    "icon",
    "labelText",
    "selected",
    "selectable",
    "shortcutText",
    "id",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuOption", slots, ["icon", "labelText", "default", "shortcutText"]);
  const $$slots = compute_slots(slots);
  let { kind = "default" } = $$props;
  let { disabled = false } = $$props;
  let { indented = false } = $$props;
  let { icon = void 0 } = $$props;
  let { labelText = "" } = $$props;
  let { selected = false } = $$props;
  let { selectable = false } = $$props;
  let { shortcutText = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  const ctx = getContext("ContextMenu");
  const ctxGroup = getContext("ContextMenuGroup");
  const ctxRadioGroup = getContext("ContextMenuRadioGroup");
  let unsubCurrentIds = void 0;
  let unsubCurrentId = void 0;
  let timeoutHover = void 0;
  let rootMenuPosition = [0, 0];
  let focusIndex = 0;
  let options = [];
  let role = "menuitem";
  let submenuOpen = false;
  let submenuPosition = [0, 0];
  let menuOffsetX = 0;
  const unsubPosition = ctx.position.subscribe((position) => {
    $$invalidate(21, rootMenuPosition = position);
  });
  const unsubMenuOffsetX = ctx.menuOffsetX.subscribe((_menuOffsetX) => {
    $$invalidate(22, menuOffsetX = _menuOffsetX);
  });
  function handleClick(opts = {}) {
    if (disabled) return ctx.close();
    if (subOptions) return;
    if (!!ctxGroup) {
      ctxGroup.toggleOption({ id });
    } else if (!!ctxRadioGroup) {
      if (opts.fromKeyboard) {
        ctxRadioGroup.setOption({ id: opts.id });
      } else {
        ctxRadioGroup.setOption({ id });
      }
    } else {
      $$invalidate(0, selected = !selected);
    }
    ctx.close();
    dispatch("click");
  }
  onMount(() => {
    if (selected === true) $$invalidate(20, selectable = true);
    if (ctxGroup) {
      unsubCurrentIds = ctxGroup.currentIds.subscribe((_currentIds) => {
        $$invalidate(0, selected = _currentIds.includes(id));
      });
    }
    if (ctxRadioGroup) {
      unsubCurrentId = ctxRadioGroup.currentId.subscribe((_id) => {
        $$invalidate(0, selected = id === _id);
      });
    }
    return () => {
      unsubPosition();
      unsubMenuOffsetX();
      if (unsubCurrentIds) unsubCurrentIds();
      if (unsubCurrentId) unsubCurrentId();
      if (typeof timeoutHover === "number") clearTimeout(timeoutHover);
    };
  });
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const keydown_handler_12 = async ({ key, target }) => {
    if (subOptions && (key === "ArrowRight" || key === " " || key === "Enter")) {
      $$invalidate(9, submenuOpen = true);
      await tick();
      $$invalidate(14, options = [...ref.querySelectorAll("li[tabindex]")]);
      if (options[focusIndex]) options[focusIndex].focus();
      return;
    }
    if (submenuOpen) {
      if (key === "ArrowLeft") {
        $$invalidate(9, submenuOpen = false);
        $$invalidate(13, focusIndex = 0);
        return;
      }
      if (key === "ArrowDown") {
        if (focusIndex < options.length - 1) $$invalidate(13, focusIndex++, focusIndex);
      } else if (key === "ArrowUp") {
        if (focusIndex === -1) {
          $$invalidate(13, focusIndex = options.length - 1);
        } else {
          if (focusIndex > 0) $$invalidate(13, focusIndex--, focusIndex);
        }
      }
      if (options[focusIndex]) options[focusIndex].focus();
    }
    if (key === " " || key === "Enter") {
      handleClick({
        fromKeyboard: true,
        id: target.getAttribute("data-id")
      });
    }
  };
  const mouseenter_handler_1 = () => {
    if (subOptions) {
      $$invalidate(12, timeoutHover = setTimeout(
        () => {
          $$invalidate(9, submenuOpen = true);
        },
        moderate01
      ));
    }
  };
  const mouseleave_handler_1 = (e) => {
    if (subOptions) {
      if (typeof timeoutHover === "number") clearTimeout(timeoutHover);
      $$invalidate(9, submenuOpen = false);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("kind" in $$new_props) $$invalidate(4, kind = $$new_props.kind);
    if ("disabled" in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
    if ("indented" in $$new_props) $$invalidate(2, indented = $$new_props.indented);
    if ("icon" in $$new_props) $$invalidate(3, icon = $$new_props.icon);
    if ("labelText" in $$new_props) $$invalidate(6, labelText = $$new_props.labelText);
    if ("selected" in $$new_props) $$invalidate(0, selected = $$new_props.selected);
    if ("selectable" in $$new_props) $$invalidate(20, selectable = $$new_props.selectable);
    if ("shortcutText" in $$new_props) $$invalidate(7, shortcutText = $$new_props.shortcutText);
    if ("id" in $$new_props) $$invalidate(8, id = $$new_props.id);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(31, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    kind,
    disabled,
    indented,
    icon,
    labelText,
    selected,
    selectable,
    shortcutText,
    id,
    ref,
    onMount,
    getContext,
    createEventDispatcher,
    tick,
    ContextMenu: ContextMenu_default,
    Checkmark: Checkmark_default,
    CaretRight: CaretRight_default,
    dispatch,
    ctx,
    ctxGroup,
    ctxRadioGroup,
    moderate01,
    unsubCurrentIds,
    unsubCurrentId,
    timeoutHover,
    rootMenuPosition,
    focusIndex,
    options,
    role,
    submenuOpen,
    submenuPosition,
    menuOffsetX,
    unsubPosition,
    unsubMenuOffsetX,
    handleClick,
    isRadio,
    isSelectable,
    subOptions
  });
  $$self.$inject_state = ($$new_props) => {
    if ("kind" in $$props) $$invalidate(4, kind = $$new_props.kind);
    if ("disabled" in $$props) $$invalidate(5, disabled = $$new_props.disabled);
    if ("indented" in $$props) $$invalidate(2, indented = $$new_props.indented);
    if ("icon" in $$props) $$invalidate(3, icon = $$new_props.icon);
    if ("labelText" in $$props) $$invalidate(6, labelText = $$new_props.labelText);
    if ("selected" in $$props) $$invalidate(0, selected = $$new_props.selected);
    if ("selectable" in $$props) $$invalidate(20, selectable = $$new_props.selectable);
    if ("shortcutText" in $$props) $$invalidate(7, shortcutText = $$new_props.shortcutText);
    if ("id" in $$props) $$invalidate(8, id = $$new_props.id);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("unsubCurrentIds" in $$props) unsubCurrentIds = $$new_props.unsubCurrentIds;
    if ("unsubCurrentId" in $$props) unsubCurrentId = $$new_props.unsubCurrentId;
    if ("timeoutHover" in $$props) $$invalidate(12, timeoutHover = $$new_props.timeoutHover);
    if ("rootMenuPosition" in $$props) $$invalidate(21, rootMenuPosition = $$new_props.rootMenuPosition);
    if ("focusIndex" in $$props) $$invalidate(13, focusIndex = $$new_props.focusIndex);
    if ("options" in $$props) $$invalidate(14, options = $$new_props.options);
    if ("role" in $$props) $$invalidate(15, role = $$new_props.role);
    if ("submenuOpen" in $$props) $$invalidate(9, submenuOpen = $$new_props.submenuOpen);
    if ("submenuPosition" in $$props) $$invalidate(16, submenuPosition = $$new_props.submenuPosition);
    if ("menuOffsetX" in $$props) $$invalidate(22, menuOffsetX = $$new_props.menuOffsetX);
    if ("isRadio" in $$props) $$invalidate(10, isRadio = $$new_props.isRadio);
    if ("isSelectable" in $$props) $$invalidate(11, isSelectable = $$new_props.isSelectable);
    if ("subOptions" in $$props) $$invalidate(17, subOptions = $$new_props.subOptions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*selectable*/
    1048576) {
      $: $$invalidate(11, isSelectable = !!ctxGroup || selectable);
    }
    if ($$self.$$.dirty[0] & /*submenuOpen*/
    512) {
      $: ctx.setPopup(submenuOpen);
    }
    if ($$self.$$.dirty[0] & /*submenuOpen, ref, rootMenuPosition, menuOffsetX*/
    6291970) {
      $: if (submenuOpen) {
        const { width, y } = ref.getBoundingClientRect();
        let x = rootMenuPosition[0] + width;
        if (window.innerWidth - menuOffsetX < width) {
          x = rootMenuPosition[0] - width;
        }
        $$invalidate(16, submenuPosition = [x, y]);
      }
    }
    if ($$self.$$.dirty[0] & /*isSelectable, selected, id, isRadio*/
    3329) {
      $: {
        if (isSelectable) {
          $$invalidate(2, indented = true);
          $$invalidate(15, role = "menuitemcheckbox");
          if (selected) {
            if (ctxGroup) ctxGroup.addOption({ id });
            $$invalidate(3, icon = Checkmark_default);
          } else {
            $$invalidate(3, icon = void 0);
          }
        }
        if (isRadio) {
          $$invalidate(2, indented = true);
          $$invalidate(15, role = "menuitemradio");
          ctxRadioGroup.addOption({ id });
          if (selected) {
            if (ctxRadioGroup) ctxRadioGroup.setOption({ id });
            $$invalidate(3, icon = Checkmark_default);
          } else {
            $$invalidate(3, icon = void 0);
          }
        }
      }
    }
  };
  $: $$invalidate(10, isRadio = !!ctxRadioGroup);
  $: $$invalidate(17, subOptions = $$slots.default);
  return [
    selected,
    ref,
    indented,
    icon,
    kind,
    disabled,
    labelText,
    shortcutText,
    id,
    submenuOpen,
    isRadio,
    isSelectable,
    timeoutHover,
    focusIndex,
    options,
    role,
    submenuPosition,
    subOptions,
    handleClick,
    $$restProps,
    selectable,
    rootMenuPosition,
    menuOffsetX,
    slots,
    keydown_handler,
    mouseenter_handler,
    mouseleave_handler,
    li_binding,
    keydown_handler_12,
    mouseenter_handler_1,
    mouseleave_handler_1,
    $$scope
  ];
}
var ContextMenuOption = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance25,
      create_fragment25,
      safe_not_equal,
      {
        kind: 4,
        disabled: 5,
        indented: 2,
        icon: 3,
        labelText: 6,
        selected: 0,
        selectable: 20,
        shortcutText: 7,
        id: 8,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuOption",
      options,
      id: create_fragment25.name
    });
  }
  get kind() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indented() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indented(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectable() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectable(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shortcutText() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shortcutText(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuOption_default = ContextMenuOption;

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuRadioGroup.svelte
var file25 = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuRadioGroup.svelte";
function create_fragment26(ctx) {
  let li;
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      li = element("li");
      ul = element("ul");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { role: true });
      var li_nodes = children(li);
      ul = claim_element(li_nodes, "UL", { role: true, "aria-label": true });
      var ul_nodes = children(ul);
      if (default_slot) default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "role", "group");
      attr_dev(
        ul,
        "aria-label",
        /*labelText*/
        ctx[0]
      );
      add_location(ul, file25, 30, 2, 616);
      attr_dev(li, "role", "none");
      add_location(li, file25, 29, 0, 597);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*labelText*/
      1) {
        attr_dev(
          ul,
          "aria-label",
          /*labelText*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let $radioIds;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuRadioGroup", slots, ["default"]);
  let { selectedId = "" } = $$props;
  let { labelText = "" } = $$props;
  const currentId = writable("");
  const radioIds = writable([]);
  validate_store(radioIds, "radioIds");
  component_subscribe($$self, radioIds, (value) => $$invalidate(5, $radioIds = value));
  setContext("ContextMenuRadioGroup", {
    currentId,
    radioIds,
    addOption: ({ id }) => {
      if (!$radioIds.includes(id)) {
        radioIds.update((_) => [..._, id]);
      }
    },
    setOption: ({ id }) => {
      $$invalidate(2, selectedId = id);
    }
  });
  const writable_props = ["selectedId", "labelText"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ContextMenuRadioGroup> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("selectedId" in $$props2) $$invalidate(2, selectedId = $$props2.selectedId);
    if ("labelText" in $$props2) $$invalidate(0, labelText = $$props2.labelText);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    selectedId,
    labelText,
    setContext,
    writable,
    currentId,
    radioIds,
    $radioIds
  });
  $$self.$inject_state = ($$props2) => {
    if ("selectedId" in $$props2) $$invalidate(2, selectedId = $$props2.selectedId);
    if ("labelText" in $$props2) $$invalidate(0, labelText = $$props2.labelText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selectedId*/
    4) {
      $: currentId.set(selectedId);
    }
  };
  return [labelText, radioIds, selectedId, $$scope, slots];
}
var ContextMenuRadioGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { selectedId: 2, labelText: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuRadioGroup",
      options,
      id: create_fragment26.name
    });
  }
  get selectedId() {
    throw new Error("<ContextMenuRadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedId(value) {
    throw new Error("<ContextMenuRadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<ContextMenuRadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<ContextMenuRadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuRadioGroup_default = ContextMenuRadioGroup;

// node_modules/carbon-components-svelte/src/icons/Copy.svelte
var file26 = "node_modules/carbon-components-svelte/src/icons/Copy.svelte";
function create_if_block14(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file26, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block14(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M28,10V28H10V10H28m0-2H10a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2Z");
      add_location(path0, file26, 24, 2, 579);
      attr_dev(path1, "d", "M4,18H2V4A2,2,0,0,1,4,2H18V4H4Z");
      add_location(path1, file26, 26, 10, 695);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file26, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Copy", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Copy = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Copy",
      options,
      id: create_fragment27.name
    });
  }
  get size() {
    throw new Error("<Copy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Copy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Copy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Copy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Copy_default = Copy;

// node_modules/carbon-components-svelte/src/CopyButton/CopyButton.svelte
var { console: console_1 } = globals;
var file27 = "node_modules/carbon-components-svelte/src/CopyButton/CopyButton.svelte";
function create_fragment28(ctx) {
  let button;
  let copy_1;
  let t0;
  let span;
  let t1;
  let current;
  let mounted;
  let dispose;
  copy_1 = new Copy_default({
    props: { class: "bx--snippet__icon" },
    $$inline: true
  });
  let button_levels = [
    { type: "button" },
    { "aria-live": "polite" },
    { "aria-label": (
      /*iconDescription*/
      ctx[2]
    ) },
    { title: (
      /*iconDescription*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[8]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      create_component(copy_1.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(
        /*feedback*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-live": true,
        "aria-label": true,
        title: true
      });
      var button_nodes = children(button);
      claim_component(copy_1.$$.fragment, button_nodes);
      t0 = claim_space(button_nodes);
      span = claim_element(button_nodes, "SPAN", { "aria-hidden": true });
      var span_nodes = children(span);
      t1 = claim_text(
        span_nodes,
        /*feedback*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "aria-hidden", "true");
      toggle_class(span, "bx--assistive-text", true);
      toggle_class(span, "bx--copy-btn__feedback", true);
      add_location(span, file27, 74, 2, 1828);
      set_attributes(button, button_data);
      toggle_class(button, "bx--copy-btn", true);
      toggle_class(button, "bx--copy", true);
      toggle_class(
        button,
        "bx--copy-btn--animating",
        /*animation*/
        ctx[5]
      );
      toggle_class(
        button,
        "bx--copy-btn--fade-in",
        /*animation*/
        ctx[5] === "fade-in"
      );
      toggle_class(
        button,
        "bx--copy-btn--fade-out",
        /*animation*/
        ctx[5] === "fade-out"
      );
      add_location(button, file27, 42, 0, 1020);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(copy_1, button, null);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, span);
      append_hydration_dev(span, t1);
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler_1*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "animationend",
            /*animationend_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "animationend",
            /*animationend_handler_1*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*feedback*/
      1) set_data_dev(
        t1,
        /*feedback*/
        ctx2[0]
      );
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        { "aria-live": "polite" },
        (!current || dirty & /*iconDescription*/
        4) && { "aria-label": (
          /*iconDescription*/
          ctx2[2]
        ) },
        (!current || dirty & /*iconDescription*/
        4) && { title: (
          /*iconDescription*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8]
      ]));
      toggle_class(button, "bx--copy-btn", true);
      toggle_class(button, "bx--copy", true);
      toggle_class(
        button,
        "bx--copy-btn--animating",
        /*animation*/
        ctx2[5]
      );
      toggle_class(
        button,
        "bx--copy-btn--fade-in",
        /*animation*/
        ctx2[5] === "fade-in"
      );
      toggle_class(
        button,
        "bx--copy-btn--fade-out",
        /*animation*/
        ctx2[5] === "fade-out"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(copy_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(copy_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      destroy_component(copy_1);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  const omit_props_names = ["feedback", "feedbackTimeout", "iconDescription", "text", "copy"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CopyButton", slots, []);
  let { feedback = "Copied!" } = $$props;
  let { feedbackTimeout = 2e3 } = $$props;
  let { iconDescription = "Copy to clipboard" } = $$props;
  let { text: text2 } = $$props;
  let { copy = async (text3) => {
    try {
      await navigator.clipboard.writeText(text3);
    } catch (e) {
      console.log(e);
    }
  } } = $$props;
  const dispatch = createEventDispatcher();
  let animation = void 0;
  let timeout = void 0;
  onMount(() => {
    return () => clearTimeout(timeout);
  });
  $$self.$$.on_mount.push(function() {
    if (text2 === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console_1.warn("<CopyButton> was created without expected prop 'text'");
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function animationend_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = () => {
    if (text2 !== void 0) {
      copy(text2);
      dispatch("copy");
    }
    if (animation === "fade-in") return;
    $$invalidate(5, animation = "fade-in");
    $$invalidate(6, timeout = setTimeout(
      () => {
        $$invalidate(5, animation = "fade-out");
      },
      feedbackTimeout
    ));
  };
  const animationend_handler_1 = ({ animationName }) => {
    if (animationName === "hide-feedback") {
      $$invalidate(5, animation = void 0);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("feedback" in $$new_props) $$invalidate(0, feedback = $$new_props.feedback);
    if ("feedbackTimeout" in $$new_props) $$invalidate(1, feedbackTimeout = $$new_props.feedbackTimeout);
    if ("iconDescription" in $$new_props) $$invalidate(2, iconDescription = $$new_props.iconDescription);
    if ("text" in $$new_props) $$invalidate(3, text2 = $$new_props.text);
    if ("copy" in $$new_props) $$invalidate(4, copy = $$new_props.copy);
  };
  $$self.$capture_state = () => ({
    feedback,
    feedbackTimeout,
    iconDescription,
    text: text2,
    copy,
    createEventDispatcher,
    onMount,
    Copy: Copy_default,
    dispatch,
    animation,
    timeout
  });
  $$self.$inject_state = ($$new_props) => {
    if ("feedback" in $$props) $$invalidate(0, feedback = $$new_props.feedback);
    if ("feedbackTimeout" in $$props) $$invalidate(1, feedbackTimeout = $$new_props.feedbackTimeout);
    if ("iconDescription" in $$props) $$invalidate(2, iconDescription = $$new_props.iconDescription);
    if ("text" in $$props) $$invalidate(3, text2 = $$new_props.text);
    if ("copy" in $$props) $$invalidate(4, copy = $$new_props.copy);
    if ("animation" in $$props) $$invalidate(5, animation = $$new_props.animation);
    if ("timeout" in $$props) $$invalidate(6, timeout = $$new_props.timeout);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    feedback,
    feedbackTimeout,
    iconDescription,
    text2,
    copy,
    animation,
    timeout,
    dispatch,
    $$restProps,
    click_handler,
    animationend_handler,
    click_handler_13,
    animationend_handler_1
  ];
}
var CopyButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {
      feedback: 0,
      feedbackTimeout: 1,
      iconDescription: 2,
      text: 3,
      copy: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CopyButton",
      options,
      id: create_fragment28.name
    });
  }
  get feedback() {
    throw new Error("<CopyButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set feedback(value) {
    throw new Error("<CopyButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get feedbackTimeout() {
    throw new Error("<CopyButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set feedbackTimeout(value) {
    throw new Error("<CopyButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<CopyButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<CopyButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<CopyButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<CopyButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get copy() {
    throw new Error("<CopyButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set copy(value) {
    throw new Error("<CopyButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CopyButton_default = CopyButton;

// node_modules/carbon-components-svelte/src/icons/WarningFilled.svelte
var file28 = "node_modules/carbon-components-svelte/src/icons/WarningFilled.svelte";
function create_if_block15(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file28, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block15(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", {
        fill: true,
        d: true,
        "data-icon-path": true,
        opacity: true
      });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M16,2C8.3,2,2,8.3,2,16s6.3,14,14,14s14-6.3,14-14C30,8.3,23.7,2,16,2z M14.9,8h2.2v11h-2.2V8z M16,25	c-0.8,0-1.5-0.7-1.5-1.5S15.2,22,16,22c0.8,0,1.5,0.7,1.5,1.5S16.8,25,16,25z");
      add_location(path0, file28, 24, 2, 579);
      attr_dev(path1, "fill", "none");
      attr_dev(path1, "d", "M17.5,23.5c0,0.8-0.7,1.5-1.5,1.5c-0.8,0-1.5-0.7-1.5-1.5S15.2,22,16,22	C16.8,22,17.5,22.7,17.5,23.5z M17.1,8h-2.2v11h2.2V8z");
      attr_dev(path1, "data-icon-path", "inner-path");
      attr_dev(path1, "opacity", "0");
      add_location(path1, file28, 26, 10, 777);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file28, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block15(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("WarningFilled", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var WarningFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "WarningFilled",
      options,
      id: create_fragment29.name
    });
  }
  get size() {
    throw new Error("<WarningFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<WarningFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<WarningFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<WarningFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var WarningFilled_default = WarningFilled;

// node_modules/carbon-components-svelte/src/icons/WarningAltFilled.svelte
var file29 = "node_modules/carbon-components-svelte/src/icons/WarningAltFilled.svelte";
function create_if_block16(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file29, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block16(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", {
        fill: true,
        d: true,
        "data-icon-path": true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "fill", "none");
      attr_dev(path0, "d", "M16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Zm-1.125-5h2.25V12h-2.25Z");
      attr_dev(path0, "data-icon-path", "inner-path");
      add_location(path0, file29, 24, 2, 579);
      attr_dev(path1, "d", "M16.002,6.1714h-.004L4.6487,27.9966,4.6506,28H27.3494l.0019-.0034ZM14.875,12h2.25v9h-2.25ZM16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Z");
      add_location(path1, file29, 27, 39, 722);
      attr_dev(path2, "d", "M29,30H3a1,1,0,0,1-.8872-1.4614l13-25a1,1,0,0,1,1.7744,0l13,25A1,1,0,0,1,29,30ZM4.6507,28H27.3493l.002-.0033L16.002,6.1714h-.004L4.6487,27.9967Z");
      add_location(path2, file29, 29, 10, 886);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file29, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block16(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("WarningAltFilled", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var WarningAltFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "WarningAltFilled",
      options,
      id: create_fragment30.name
    });
  }
  get size() {
    throw new Error("<WarningAltFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<WarningAltFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<WarningAltFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<WarningAltFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var WarningAltFilled_default = WarningAltFilled;

// node_modules/carbon-components-svelte/src/ListBox/ListBox.svelte
var file30 = "node_modules/carbon-components-svelte/src/ListBox/ListBox.svelte";
function create_if_block_14(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*invalidText*/
        ctx[6]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*invalidText*/
        ctx[6]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file30, 59, 2, 1374);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*invalidText*/
      64) set_data_dev(
        t,
        /*invalidText*/
        ctx2[6]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(59:0) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block17(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*warnText*/
        ctx[8]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*warnText*/
        ctx[8]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file30, 62, 2, 1466);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*warnText*/
      256) set_data_dev(
        t,
        /*warnText*/
        ctx2[8]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(62:0) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let div;
  let div_data_invalid_value;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let div_levels = [
    { role: "listbox" },
    { tabindex: "-1" },
    {
      "data-invalid": div_data_invalid_value = /*invalid*/
      ctx[5] || void 0
    },
    /*$$restProps*/
    ctx[9]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  let if_block0 = (
    /*invalid*/
    ctx[5] && create_if_block_14(ctx)
  );
  let if_block1 = !/*invalid*/
  ctx[5] && /*warn*/
  ctx[7] && create_if_block17(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        role: true,
        tabindex: true,
        "data-invalid": true
      });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      if (if_block0) if_block0.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      if_block1_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--list-box", true);
      toggle_class(
        div,
        "bx--list-box--sm",
        /*size*/
        ctx[0] === "sm"
      );
      toggle_class(
        div,
        "bx--list-box--xl",
        /*size*/
        ctx[0] === "xl"
      );
      toggle_class(
        div,
        "bx--list-box--inline",
        /*type*/
        ctx[1] === "inline"
      );
      toggle_class(
        div,
        "bx--list-box--disabled",
        /*disabled*/
        ctx[4]
      );
      toggle_class(
        div,
        "bx--list-box--expanded",
        /*open*/
        ctx[2]
      );
      toggle_class(
        div,
        "bx--list-box--light",
        /*light*/
        ctx[3]
      );
      toggle_class(div, "bx--list-box--warning", !/*invalid*/
      ctx[5] && /*warn*/
      ctx[7]);
      add_location(div, file30, 35, 0, 769);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      insert_hydration_dev(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "keydown",
            /*keydown_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(div, "keydown", keydown_handler_1, false, false, false, false),
          listen_dev(div, "click", prevent_default(
            /*click_handler*/
            ctx[13]
          ), false, true, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "listbox" },
        { tabindex: "-1" },
        (!current || dirty & /*invalid*/
        32 && div_data_invalid_value !== (div_data_invalid_value = /*invalid*/
        ctx2[5] || void 0)) && { "data-invalid": div_data_invalid_value },
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9]
      ]));
      toggle_class(div, "bx--list-box", true);
      toggle_class(
        div,
        "bx--list-box--sm",
        /*size*/
        ctx2[0] === "sm"
      );
      toggle_class(
        div,
        "bx--list-box--xl",
        /*size*/
        ctx2[0] === "xl"
      );
      toggle_class(
        div,
        "bx--list-box--inline",
        /*type*/
        ctx2[1] === "inline"
      );
      toggle_class(
        div,
        "bx--list-box--disabled",
        /*disabled*/
        ctx2[4]
      );
      toggle_class(
        div,
        "bx--list-box--expanded",
        /*open*/
        ctx2[2]
      );
      toggle_class(
        div,
        "bx--list-box--light",
        /*light*/
        ctx2[3]
      );
      toggle_class(div, "bx--list-box--warning", !/*invalid*/
      ctx2[5] && /*warn*/
      ctx2[7]);
      if (
        /*invalid*/
        ctx2[5]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*invalid*/
      ctx2[5] && /*warn*/
      ctx2[7]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block17(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(if_block1_anchor);
      }
      if (default_slot) default_slot.d(detaching);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var keydown_handler_1 = (e) => {
  if (e.key === "Escape") {
    e.stopPropagation();
  }
};
function instance31($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "size",
    "type",
    "open",
    "light",
    "disabled",
    "invalid",
    "invalidText",
    "warn",
    "warnText"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBox", slots, ["default"]);
  let { size = void 0 } = $$props;
  let { type = "default" } = $$props;
  let { open = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("type" in $$new_props) $$invalidate(1, type = $$new_props.type);
    if ("open" in $$new_props) $$invalidate(2, open = $$new_props.open);
    if ("light" in $$new_props) $$invalidate(3, light = $$new_props.light);
    if ("disabled" in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
    if ("invalid" in $$new_props) $$invalidate(5, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props) $$invalidate(6, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props) $$invalidate(7, warn = $$new_props.warn);
    if ("warnText" in $$new_props) $$invalidate(8, warnText = $$new_props.warnText);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    type,
    open,
    light,
    disabled,
    invalid,
    invalidText,
    warn,
    warnText
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("type" in $$props) $$invalidate(1, type = $$new_props.type);
    if ("open" in $$props) $$invalidate(2, open = $$new_props.open);
    if ("light" in $$props) $$invalidate(3, light = $$new_props.light);
    if ("disabled" in $$props) $$invalidate(4, disabled = $$new_props.disabled);
    if ("invalid" in $$props) $$invalidate(5, invalid = $$new_props.invalid);
    if ("invalidText" in $$props) $$invalidate(6, invalidText = $$new_props.invalidText);
    if ("warn" in $$props) $$invalidate(7, warn = $$new_props.warn);
    if ("warnText" in $$props) $$invalidate(8, warnText = $$new_props.warnText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    size,
    type,
    open,
    light,
    disabled,
    invalid,
    invalidText,
    warn,
    warnText,
    $$restProps,
    $$scope,
    slots,
    keydown_handler,
    click_handler
  ];
}
var ListBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, {
      size: 0,
      type: 1,
      open: 2,
      light: 3,
      disabled: 4,
      invalid: 5,
      invalidText: 6,
      warn: 7,
      warnText: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBox",
      options,
      id: create_fragment31.name
    });
  }
  get size() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBox_default = ListBox;

// node_modules/carbon-components-svelte/src/ListBox/ListBoxField.svelte
var file31 = "node_modules/carbon-components-svelte/src/ListBox/ListBoxField.svelte";
function create_fragment32(ctx) {
  let div;
  let div_aria_owns_value;
  let div_aria_controls_value;
  let div_aria_label_value;
  let div_tabindex_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let div_levels = [
    { role: (
      /*role*/
      ctx[2]
    ) },
    { "aria-expanded": (
      /*ariaExpanded*/
      ctx[6]
    ) },
    {
      "aria-owns": div_aria_owns_value = /*ariaExpanded*/
      ctx[6] && /*menuId*/
      ctx[5] || void 0
    },
    {
      "aria-controls": div_aria_controls_value = /*ariaExpanded*/
      ctx[6] && /*menuId*/
      ctx[5] || void 0
    },
    { "aria-disabled": (
      /*disabled*/
      ctx[1]
    ) },
    {
      "aria-label": div_aria_label_value = /*ariaExpanded*/
      ctx[6] ? (
        /*translateWithId*/
        ctx[4]("close")
      ) : (
        /*translateWithId*/
        ctx[4]("open")
      )
    },
    {
      tabindex: div_tabindex_value = /*disabled*/
      ctx[1] ? "-1" : (
        /*tabindex*/
        ctx[3]
      )
    },
    /*$$restProps*/
    ctx[7]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        role: true,
        "aria-expanded": true,
        "aria-owns": true,
        "aria-controls": true,
        "aria-disabled": true,
        "aria-label": true,
        tabindex: true
      });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--list-box__field", true);
      add_location(div, file31, 46, 0, 1167);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[19](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(div, "keydown", stop_propagation(
            /*keydown_handler*/
            ctx[16]
          ), false, false, true, false),
          listen_dev(
            div,
            "focus",
            /*focus_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "blur",
            /*blur_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*role*/
        4) && { role: (
          /*role*/
          ctx2[2]
        ) },
        (!current || dirty & /*ariaExpanded*/
        64) && { "aria-expanded": (
          /*ariaExpanded*/
          ctx2[6]
        ) },
        (!current || dirty & /*ariaExpanded, menuId*/
        96 && div_aria_owns_value !== (div_aria_owns_value = /*ariaExpanded*/
        ctx2[6] && /*menuId*/
        ctx2[5] || void 0)) && { "aria-owns": div_aria_owns_value },
        (!current || dirty & /*ariaExpanded, menuId*/
        96 && div_aria_controls_value !== (div_aria_controls_value = /*ariaExpanded*/
        ctx2[6] && /*menuId*/
        ctx2[5] || void 0)) && { "aria-controls": div_aria_controls_value },
        (!current || dirty & /*disabled*/
        2) && { "aria-disabled": (
          /*disabled*/
          ctx2[1]
        ) },
        (!current || dirty & /*ariaExpanded, translateWithId*/
        80 && div_aria_label_value !== (div_aria_label_value = /*ariaExpanded*/
        ctx2[6] ? (
          /*translateWithId*/
          ctx2[4]("close")
        ) : (
          /*translateWithId*/
          ctx2[4]("open")
        ))) && { "aria-label": div_aria_label_value },
        (!current || dirty & /*disabled, tabindex*/
        10 && div_tabindex_value !== (div_tabindex_value = /*disabled*/
        ctx2[1] ? "-1" : (
          /*tabindex*/
          ctx2[3]
        ))) && { tabindex: div_tabindex_value },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      toggle_class(div, "bx--list-box__field", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let ariaExpanded;
  let menuId;
  const omit_props_names = ["disabled", "role", "tabindex", "translationIds", "translateWithId", "id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBoxField", slots, ["default"]);
  let { disabled = false } = $$props;
  let { role = "combobox" } = $$props;
  let { tabindex = "-1" } = $$props;
  const translationIds = { close: "close", open: "open" };
  let { translateWithId = (id2) => defaultTranslations[id2] } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const defaultTranslations = {
    [translationIds.close]: "Close menu",
    [translationIds.open]: "Open menu"
  };
  const ctx = getContext("MultiSelect");
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("disabled" in $$new_props) $$invalidate(1, disabled = $$new_props.disabled);
    if ("role" in $$new_props) $$invalidate(2, role = $$new_props.role);
    if ("tabindex" in $$new_props) $$invalidate(3, tabindex = $$new_props.tabindex);
    if ("translateWithId" in $$new_props) $$invalidate(4, translateWithId = $$new_props.translateWithId);
    if ("id" in $$new_props) $$invalidate(9, id = $$new_props.id);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    disabled,
    role,
    tabindex,
    translationIds,
    translateWithId,
    id,
    ref,
    getContext,
    defaultTranslations,
    ctx,
    menuId,
    ariaExpanded
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("disabled" in $$props) $$invalidate(1, disabled = $$new_props.disabled);
    if ("role" in $$props) $$invalidate(2, role = $$new_props.role);
    if ("tabindex" in $$props) $$invalidate(3, tabindex = $$new_props.tabindex);
    if ("translateWithId" in $$props) $$invalidate(4, translateWithId = $$new_props.translateWithId);
    if ("id" in $$props) $$invalidate(9, id = $$new_props.id);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    if ("menuId" in $$props) $$invalidate(5, menuId = $$new_props.menuId);
    if ("ariaExpanded" in $$props) $$invalidate(6, ariaExpanded = $$new_props.ariaExpanded);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*ref*/
    1) {
      $: if (ctx && ref) {
        ctx.declareRef({ key: "field", ref });
      }
    }
    $: $$invalidate(6, ariaExpanded = $$props["aria-expanded"]);
    if ($$self.$$.dirty & /*id*/
    512) {
      $: $$invalidate(5, menuId = `menu-${id}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    ref,
    disabled,
    role,
    tabindex,
    translateWithId,
    menuId,
    ariaExpanded,
    $$restProps,
    translationIds,
    id,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    focus_handler,
    blur_handler,
    div_binding
  ];
}
var ListBoxField = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, {
      disabled: 1,
      role: 2,
      tabindex: 3,
      translationIds: 8,
      translateWithId: 4,
      id: 9,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBoxField",
      options,
      id: create_fragment32.name
    });
  }
  get disabled() {
    throw new Error("<ListBoxField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ListBoxField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<ListBoxField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<ListBoxField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<ListBoxField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<ListBoxField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translationIds() {
    return this.$$.ctx[8];
  }
  set translationIds(value) {
    throw new Error("<ListBoxField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<ListBoxField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<ListBoxField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ListBoxField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ListBoxField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ListBoxField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ListBoxField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBoxField_default = ListBoxField;

// node_modules/carbon-components-svelte/src/ListBox/ListBoxMenu.svelte
var file32 = "node_modules/carbon-components-svelte/src/ListBox/ListBoxMenu.svelte";
function create_fragment33(ctx) {
  let div;
  let div_id_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    { role: "listbox" },
    {
      id: div_id_value = "menu-" + /*id*/
      ctx[1]
    },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { role: true, id: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--list-box__menu", true);
      add_location(div, file32, 8, 0, 194);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[6](div);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "scroll",
          /*scroll_handler*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "listbox" },
        (!current || dirty & /*id*/
        2 && div_id_value !== (div_id_value = "menu-" + /*id*/
        ctx2[1])) && { id: div_id_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      toggle_class(div, "bx--list-box__menu", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBoxMenu", slots, ["default"]);
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  function scroll_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ id, ref });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ref, id, $$restProps, $$scope, slots, scroll_handler, div_binding];
}
var ListBoxMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, { id: 1, ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBoxMenu",
      options,
      id: create_fragment33.name
    });
  }
  get id() {
    throw new Error("<ListBoxMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ListBoxMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ListBoxMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ListBoxMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBoxMenu_default = ListBoxMenu;

// node_modules/carbon-components-svelte/src/icons/ChevronDown.svelte
var file33 = "node_modules/carbon-components-svelte/src/icons/ChevronDown.svelte";
function create_if_block18(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file33, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block18(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 22L6 12 7.4 10.6 16 19.2 24.6 10.6 26 12z");
      add_location(path, file33, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file33, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block18(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronDown", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var ChevronDown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronDown",
      options,
      id: create_fragment34.name
    });
  }
  get size() {
    throw new Error("<ChevronDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChevronDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ChevronDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ChevronDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChevronDown_default = ChevronDown;

// node_modules/carbon-components-svelte/src/ListBox/ListBoxMenuIcon.svelte
var file34 = "node_modules/carbon-components-svelte/src/ListBox/ListBoxMenuIcon.svelte";
function create_fragment35(ctx) {
  let div;
  let chevrondown;
  let current;
  let mounted;
  let dispose;
  chevrondown = new ChevronDown_default({
    props: {
      "aria-label": (
        /*description*/
        ctx[1]
      ),
      title: (
        /*description*/
        ctx[1]
      )
    },
    $$inline: true
  });
  let div_levels = [
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      create_component(chevrondown.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(chevrondown.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--list-box__menu-icon", true);
      toggle_class(
        div,
        "bx--list-box__menu-icon--open",
        /*open*/
        ctx[0]
      );
      add_location(div, file34, 30, 0, 858);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(chevrondown, div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(div, "click", prevent_default(
          /*click_handler*/
          ctx[6]
        ), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const chevrondown_changes = {};
      if (dirty & /*description*/
      2) chevrondown_changes["aria-label"] = /*description*/
      ctx2[1];
      if (dirty & /*description*/
      2) chevrondown_changes.title = /*description*/
      ctx2[1];
      chevrondown.$set(chevrondown_changes);
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      4 && /*$$restProps*/
      ctx2[2]]));
      toggle_class(div, "bx--list-box__menu-icon", true);
      toggle_class(
        div,
        "bx--list-box__menu-icon--open",
        /*open*/
        ctx2[0]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(chevrondown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevrondown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(chevrondown);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let translationId;
  let description;
  const omit_props_names = ["open", "translationIds", "translateWithId"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBoxMenuIcon", slots, []);
  let { open = false } = $$props;
  const translationIds = { close: "close", open: "open" };
  let { translateWithId = (id) => defaultTranslations[id] } = $$props;
  const defaultTranslations = {
    [translationIds.close]: "Close menu",
    [translationIds.open]: "Open menu"
  };
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("open" in $$new_props) $$invalidate(0, open = $$new_props.open);
    if ("translateWithId" in $$new_props) $$invalidate(4, translateWithId = $$new_props.translateWithId);
  };
  $$self.$capture_state = () => ({
    open,
    translationIds,
    translateWithId,
    ChevronDown: ChevronDown_default,
    defaultTranslations,
    translationId,
    description
  });
  $$self.$inject_state = ($$new_props) => {
    if ("open" in $$props) $$invalidate(0, open = $$new_props.open);
    if ("translateWithId" in $$props) $$invalidate(4, translateWithId = $$new_props.translateWithId);
    if ("translationId" in $$props) $$invalidate(5, translationId = $$new_props.translationId);
    if ("description" in $$props) $$invalidate(1, description = $$new_props.description);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    1) {
      $: $$invalidate(5, translationId = open ? translationIds.close : translationIds.open);
    }
    if ($$self.$$.dirty & /*translateWithId, translationId*/
    48) {
      $: $$invalidate(1, description = (translateWithId == null ? void 0 : translateWithId(translationId)) ?? defaultTranslations[translationId]);
    }
  };
  return [
    open,
    description,
    $$restProps,
    translationIds,
    translateWithId,
    translationId,
    click_handler
  ];
}
var ListBoxMenuIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, {
      open: 0,
      translationIds: 3,
      translateWithId: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBoxMenuIcon",
      options,
      id: create_fragment35.name
    });
  }
  get open() {
    throw new Error("<ListBoxMenuIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<ListBoxMenuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translationIds() {
    return this.$$.ctx[3];
  }
  set translationIds(value) {
    throw new Error("<ListBoxMenuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<ListBoxMenuIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<ListBoxMenuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBoxMenuIcon_default = ListBoxMenuIcon;

// node_modules/carbon-components-svelte/src/ListBox/ListBoxMenuItem.svelte
var file35 = "node_modules/carbon-components-svelte/src/ListBox/ListBoxMenuItem.svelte";
function create_fragment36(ctx) {
  let div1;
  let div0;
  let div1_disabled_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div1_levels = [
    { role: "option" },
    { tabindex: "-1" },
    { "aria-selected": (
      /*active*/
      ctx[0]
    ) },
    {
      disabled: div1_disabled_value = /*disabled*/
      ctx[2] ? true : void 0
    },
    /*$$restProps*/
    ctx[5]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        role: true,
        tabindex: true,
        "aria-selected": true,
        disabled: true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { title: true });
      var div0_nodes = children(div0);
      if (default_slot) default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div0,
        "title",
        /*title*/
        ctx[4]
      );
      toggle_class(div0, "bx--list-box__menu-item__option", true);
      add_location(div0, file35, 33, 2, 913);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--list-box__menu-item", true);
      toggle_class(
        div1,
        "bx--list-box__menu-item--active",
        /*active*/
        ctx[0]
      );
      toggle_class(
        div1,
        "bx--list-box__menu-item--highlighted",
        /*highlighted*/
        ctx[1] || /*active*/
        ctx[0]
      );
      add_location(div1, file35, 20, 0, 577);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[12](div0);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*title*/
      16) {
        attr_dev(
          div0,
          "title",
          /*title*/
          ctx2[4]
        );
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        { role: "option" },
        { tabindex: "-1" },
        (!current || dirty & /*active*/
        1) && { "aria-selected": (
          /*active*/
          ctx2[0]
        ) },
        (!current || dirty & /*disabled*/
        4 && div1_disabled_value !== (div1_disabled_value = /*disabled*/
        ctx2[2] ? true : void 0)) && { disabled: div1_disabled_value },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      toggle_class(div1, "bx--list-box__menu-item", true);
      toggle_class(
        div1,
        "bx--list-box__menu-item--active",
        /*active*/
        ctx2[0]
      );
      toggle_class(
        div1,
        "bx--list-box__menu-item--highlighted",
        /*highlighted*/
        ctx2[1] || /*active*/
        ctx2[0]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let isTruncated;
  let title;
  const omit_props_names = ["active", "highlighted", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBoxMenuItem", slots, ["default"]);
  let { active = false } = $$props;
  let { highlighted = false } = $$props;
  let { disabled = false } = $$props;
  let ref = null;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("active" in $$new_props) $$invalidate(0, active = $$new_props.active);
    if ("highlighted" in $$new_props) $$invalidate(1, highlighted = $$new_props.highlighted);
    if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    active,
    highlighted,
    disabled,
    ref,
    isTruncated,
    title
  });
  $$self.$inject_state = ($$new_props) => {
    if ("active" in $$props) $$invalidate(0, active = $$new_props.active);
    if ("highlighted" in $$props) $$invalidate(1, highlighted = $$new_props.highlighted);
    if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("ref" in $$props) $$invalidate(3, ref = $$new_props.ref);
    if ("isTruncated" in $$props) $$invalidate(6, isTruncated = $$new_props.isTruncated);
    if ("title" in $$props) $$invalidate(4, title = $$new_props.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*ref*/
    8) {
      $: $$invalidate(6, isTruncated = (ref == null ? void 0 : ref.offsetWidth) < (ref == null ? void 0 : ref.scrollWidth));
    }
    if ($$self.$$.dirty & /*isTruncated, ref*/
    72) {
      $: $$invalidate(4, title = isTruncated ? ref == null ? void 0 : ref.innerText : void 0);
    }
    if ($$self.$$.dirty & /*highlighted, ref*/
    10) {
      $: if (highlighted && ref && !ref.matches(":hover")) {
        ref.scrollIntoView({ block: "nearest" });
      }
    }
  };
  return [
    active,
    highlighted,
    disabled,
    ref,
    title,
    $$restProps,
    isTruncated,
    $$scope,
    slots,
    click_handler,
    mouseenter_handler,
    mouseleave_handler,
    div0_binding
  ];
}
var ListBoxMenuItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, { active: 0, highlighted: 1, disabled: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBoxMenuItem",
      options,
      id: create_fragment36.name
    });
  }
  get active() {
    throw new Error("<ListBoxMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<ListBoxMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get highlighted() {
    throw new Error("<ListBoxMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highlighted(value) {
    throw new Error("<ListBoxMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ListBoxMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ListBoxMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBoxMenuItem_default = ListBoxMenuItem;

// node_modules/carbon-components-svelte/src/icons/Close.svelte
var file36 = "node_modules/carbon-components-svelte/src/icons/Close.svelte";
function create_if_block19(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file36, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment37(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block19(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z");
      add_location(path, file36, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file36, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block19(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Close", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Close = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Close",
      options,
      id: create_fragment37.name
    });
  }
  get size() {
    throw new Error("<Close>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Close>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Close>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Close>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Close_default = Close;

// node_modules/carbon-components-svelte/src/ListBox/ListBoxSelection.svelte
var file37 = "node_modules/carbon-components-svelte/src/ListBox/ListBoxSelection.svelte";
function create_else_block10(ctx) {
  let div;
  let t;
  let close;
  let div_tabindex_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*selectionCount*/
    ctx[1] !== void 0 && create_if_block_15(ctx)
  );
  close = new Close_default({ $$inline: true });
  let div_levels = [
    { role: "button" },
    { "aria-label": (
      /*description*/
      ctx[4]
    ) },
    { title: (
      /*description*/
      ctx[4]
    ) },
    {
      tabindex: div_tabindex_value = /*disabled*/
      ctx[2] ? "-1" : "0"
    },
    /*$$restProps*/
    ctx[6]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block) if_block.c();
      t = space();
      create_component(close.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        role: true,
        "aria-label": true,
        title: true,
        tabindex: true
      });
      var div_nodes = children(div);
      if (if_block) if_block.l(div_nodes);
      t = claim_space(div_nodes);
      claim_component(close.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--list-box__selection", true);
      toggle_class(
        div,
        "bx--tag--filter",
        /*selectionCount*/
        ctx[1]
      );
      toggle_class(
        div,
        "bx--list-box__selection--multi",
        /*selectionCount*/
        ctx[1]
      );
      add_location(div, file37, 88, 2, 2249);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append_hydration_dev(div, t);
      mount_component(close, div, null);
      ctx[12](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", stop_propagation(prevent_default(
            /*click_handler_1*/
            ctx[13]
          )), false, true, true, false),
          listen_dev(div, "keydown", stop_propagation(
            /*keydown_handler_1*/
            ctx[14]
          ), false, false, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*selectionCount*/
        ctx2[1] !== void 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_15(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "button" },
        (!current || dirty & /*description*/
        16) && { "aria-label": (
          /*description*/
          ctx2[4]
        ) },
        (!current || dirty & /*description*/
        16) && { title: (
          /*description*/
          ctx2[4]
        ) },
        (!current || dirty & /*disabled*/
        4 && div_tabindex_value !== (div_tabindex_value = /*disabled*/
        ctx2[2] ? "-1" : "0")) && { tabindex: div_tabindex_value },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
      toggle_class(div, "bx--list-box__selection", true);
      toggle_class(
        div,
        "bx--tag--filter",
        /*selectionCount*/
        ctx2[1]
      );
      toggle_class(
        div,
        "bx--list-box__selection--multi",
        /*selectionCount*/
        ctx2[1]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block) if_block.d();
      destroy_component(close);
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block10.name,
    type: "else",
    source: "(88:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block20(ctx) {
  let div1;
  let span;
  let t0;
  let t1;
  let div0;
  let close;
  let div0_tabindex_value;
  let div0_aria_label_value;
  let current;
  let mounted;
  let dispose;
  close = new Close_default({ $$inline: true });
  const block = {
    c: function create() {
      div1 = element("div");
      span = element("span");
      t0 = text(
        /*selectionCount*/
        ctx[1]
      );
      t1 = space();
      div0 = element("div");
      create_component(close.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      span = claim_element(div1_nodes, "SPAN", { title: true });
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*selectionCount*/
        ctx[1]
      );
      span_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {
        role: true,
        tabindex: true,
        disabled: true,
        "aria-label": true,
        title: true
      });
      var div0_nodes = children(div0);
      claim_component(close.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        span,
        "title",
        /*selectionCount*/
        ctx[1]
      );
      toggle_class(span, "bx--tag__label", true);
      add_location(span, file37, 62, 4, 1592);
      attr_dev(div0, "role", "button");
      attr_dev(div0, "tabindex", div0_tabindex_value = /*disabled*/
      ctx[2] ? -1 : 0);
      attr_dev(
        div0,
        "disabled",
        /*disabled*/
        ctx[2]
      );
      attr_dev(div0, "aria-label", div0_aria_label_value = /*translationIds*/
      ctx[3].clearAll);
      attr_dev(
        div0,
        "title",
        /*description*/
        ctx[4]
      );
      toggle_class(div0, "bx--tag__close-icon", true);
      add_location(div0, file37, 65, 4, 1693);
      toggle_class(div1, "bx--tag", true);
      toggle_class(div1, "bx--tag--filter", true);
      toggle_class(div1, "bx--tag--high-contrast", true);
      toggle_class(
        div1,
        "bx--tag--disabled",
        /*disabled*/
        ctx[2]
      );
      add_location(div1, file37, 56, 2, 1434);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      mount_component(close, div0, null);
      ctx[9](div0);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div0, "click", stop_propagation(prevent_default(
            /*click_handler*/
            ctx[10]
          )), false, true, true, false),
          listen_dev(div0, "keydown", stop_propagation(
            /*keydown_handler*/
            ctx[11]
          ), false, false, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*selectionCount*/
      2) set_data_dev(
        t0,
        /*selectionCount*/
        ctx2[1]
      );
      if (!current || dirty & /*selectionCount*/
      2) {
        attr_dev(
          span,
          "title",
          /*selectionCount*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*disabled*/
      4 && div0_tabindex_value !== (div0_tabindex_value = /*disabled*/
      ctx2[2] ? -1 : 0)) {
        attr_dev(div0, "tabindex", div0_tabindex_value);
      }
      if (!current || dirty & /*disabled*/
      4) {
        attr_dev(
          div0,
          "disabled",
          /*disabled*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*description*/
      16) {
        attr_dev(
          div0,
          "title",
          /*description*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*disabled*/
      4) {
        toggle_class(
          div1,
          "bx--tag--disabled",
          /*disabled*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_component(close);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(56:0) {#if selectionCount !== undefined}",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*selectionCount*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*selectionCount*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*selectionCount*/
      2) set_data_dev(
        t,
        /*selectionCount*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(110:4) {#if selectionCount !== undefined}",
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block20, create_else_block10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*selectionCount*/
      ctx2[1] !== void 0
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  let translationId;
  let description;
  const omit_props_names = ["selectionCount", "disabled", "translationIds", "translateWithId", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBoxSelection", slots, []);
  let { selectionCount = void 0 } = $$props;
  let { disabled = false } = $$props;
  const translationIds = {
    clearAll: "clearAll",
    clearSelection: "clearSelection"
  };
  let { translateWithId = (id) => defaultTranslations[id] } = $$props;
  let { ref = null } = $$props;
  const defaultTranslations = {
    [translationIds.clearAll]: "Clear all selected items",
    [translationIds.clearSelection]: "Clear selected item"
  };
  const dispatch = createEventDispatcher();
  const ctx = getContext("MultiSelect");
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const click_handler = (e) => {
    if (!disabled) {
      dispatch("clear", e);
    }
  };
  const keydown_handler = (e) => {
    if (!disabled && e.key === "Enter") {
      dispatch("clear", e);
    }
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const click_handler_13 = (e) => {
    if (!disabled) {
      dispatch("clear", e);
    }
  };
  const keydown_handler_12 = (e) => {
    if (!disabled && e.key === "Enter") {
      dispatch("clear", e);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selectionCount" in $$new_props) $$invalidate(1, selectionCount = $$new_props.selectionCount);
    if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("translateWithId" in $$new_props) $$invalidate(7, translateWithId = $$new_props.translateWithId);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    selectionCount,
    disabled,
    translationIds,
    translateWithId,
    ref,
    createEventDispatcher,
    getContext,
    Close: Close_default,
    defaultTranslations,
    dispatch,
    ctx,
    translationId,
    description
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selectionCount" in $$props) $$invalidate(1, selectionCount = $$new_props.selectionCount);
    if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("translateWithId" in $$props) $$invalidate(7, translateWithId = $$new_props.translateWithId);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    if ("translationId" in $$props) $$invalidate(8, translationId = $$new_props.translationId);
    if ("description" in $$props) $$invalidate(4, description = $$new_props.description);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*ref*/
    1) {
      $: if (ctx && ref) {
        ctx.declareRef({ key: "selection", ref });
      }
    }
    if ($$self.$$.dirty & /*selectionCount*/
    2) {
      $: $$invalidate(8, translationId = selectionCount ? translationIds.clearAll : translationIds.clearSelection);
    }
    if ($$self.$$.dirty & /*translateWithId, translationId*/
    384) {
      $: $$invalidate(4, description = (translateWithId == null ? void 0 : translateWithId(translationId)) ?? defaultTranslations[translationId]);
    }
  };
  return [
    ref,
    selectionCount,
    disabled,
    translationIds,
    description,
    dispatch,
    $$restProps,
    translateWithId,
    translationId,
    div0_binding,
    click_handler,
    keydown_handler,
    div_binding,
    click_handler_13,
    keydown_handler_12
  ];
}
var ListBoxSelection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {
      selectionCount: 1,
      disabled: 2,
      translationIds: 3,
      translateWithId: 7,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBoxSelection",
      options,
      id: create_fragment38.name
    });
  }
  get selectionCount() {
    throw new Error("<ListBoxSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionCount(value) {
    throw new Error("<ListBoxSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ListBoxSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ListBoxSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translationIds() {
    return this.$$.ctx[3];
  }
  set translationIds(value) {
    throw new Error("<ListBoxSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<ListBoxSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<ListBoxSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ListBoxSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ListBoxSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBoxSelection_default = ListBoxSelection;

// node_modules/carbon-components-svelte/src/ComboBox/ComboBox.svelte
var file38 = "node_modules/carbon-components-svelte/src/ComboBox/ComboBox.svelte";
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[57] = list[i];
  child_ctx[59] = i;
  return child_ctx;
}
var get_default_slot_changes4 = (dirty) => ({
  item: dirty[0] & /*filteredItems*/
  16777216,
  index: dirty[0] & /*filteredItems*/
  16777216
});
var get_default_slot_context4 = (ctx) => ({
  item: (
    /*item*/
    ctx[57]
  ),
  index: (
    /*i*/
    ctx[59]
  )
});
var get_titleText_slot_changes = (dirty) => ({});
var get_titleText_slot_context = (ctx) => ({});
function create_if_block_62(ctx) {
  let label;
  let current;
  const titleText_slot_template = (
    /*#slots*/
    ctx[35].titleText
  );
  const titleText_slot = create_slot(
    titleText_slot_template,
    ctx,
    /*$$scope*/
    ctx[54],
    get_titleText_slot_context
  );
  const titleText_slot_or_fallback = titleText_slot || fallback_block_13(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (titleText_slot_or_fallback) titleText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      if (titleText_slot_or_fallback) titleText_slot_or_fallback.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[19]
      );
      toggle_class(label, "bx--label", true);
      toggle_class(
        label,
        "bx--label--disabled",
        /*disabled*/
        ctx[8]
      );
      add_location(label, file38, 221, 4, 6136);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (titleText_slot_or_fallback) {
        titleText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (titleText_slot) {
        if (titleText_slot.p && (!current || dirty[1] & /*$$scope*/
        8388608)) {
          update_slot_base(
            titleText_slot,
            titleText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[54],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[54]
            ) : get_slot_changes(
              titleText_slot_template,
              /*$$scope*/
              ctx2[54],
              dirty,
              get_titleText_slot_changes
            ),
            get_titleText_slot_context
          );
        }
      } else {
        if (titleText_slot_or_fallback && titleText_slot_or_fallback.p && (!current || dirty[0] & /*titleText*/
        512)) {
          titleText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      524288) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[19]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      256) {
        toggle_class(
          label,
          "bx--label--disabled",
          /*disabled*/
          ctx2[8]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(titleText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(titleText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (titleText_slot_or_fallback) titleText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_62.name,
    type: "if",
    source: "(221:2) {#if titleText || $$slots.titleText}",
    ctx
  });
  return block;
}
function fallback_block_13(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*titleText*/
        ctx[9]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*titleText*/
        ctx[9]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*titleText*/
      512) set_data_dev(
        t,
        /*titleText*/
        ctx2[9]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_13.name,
    type: "fallback",
    source: "(227:29)          ",
    ctx
  });
  return block;
}
function create_if_block_52(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--list-box__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(349:6) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--list-box__invalid-icon bx--list-box__invalid-icon--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningaltfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(352:6) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let listboxselection;
  let current;
  listboxselection = new ListBoxSelection_default({
    props: {
      translateWithId: (
        /*translateWithIdSelection*/
        ctx[18]
      ),
      disabled: (
        /*disabled*/
        ctx[8]
      ),
      open: (
        /*open*/
        ctx[2]
      )
    },
    $$inline: true
  });
  listboxselection.$on(
    "clear",
    /*clear_handler*/
    ctx[47]
  );
  listboxselection.$on(
    "clear",
    /*clear*/
    ctx[21]
  );
  const block = {
    c: function create() {
      create_component(listboxselection.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(listboxselection.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(listboxselection, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const listboxselection_changes = {};
      if (dirty[0] & /*translateWithIdSelection*/
      262144) listboxselection_changes.translateWithId = /*translateWithIdSelection*/
      ctx2[18];
      if (dirty[0] & /*disabled*/
      256) listboxselection_changes.disabled = /*disabled*/
      ctx2[8];
      if (dirty[0] & /*open*/
      4) listboxselection_changes.open = /*open*/
      ctx2[2];
      listboxselection.$set(listboxselection_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(listboxselection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxselection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listboxselection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(357:6) {#if value}",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let input;
  let input_aria_controls_value;
  let input_aria_owns_value;
  let t0;
  let t1;
  let t2;
  let t3;
  let listboxmenuicon;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { tabindex: "0" },
    { autocomplete: "off" },
    { "aria-autocomplete": "list" },
    { "aria-expanded": (
      /*open*/
      ctx[2]
    ) },
    {
      "aria-activedescendant": (
        /*highlightedId*/
        ctx[25]
      )
    },
    { "aria-labelledby": (
      /*comboId*/
      ctx[26]
    ) },
    { "aria-disabled": (
      /*disabled*/
      ctx[8]
    ) },
    {
      "aria-controls": input_aria_controls_value = /*open*/
      ctx[2] ? (
        /*menuId*/
        ctx[27]
      ) : void 0
    },
    {
      "aria-owns": input_aria_owns_value = /*open*/
      ctx[2] ? (
        /*menuId*/
        ctx[27]
      ) : void 0
    },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[10]
    ) },
    { id: (
      /*id*/
      ctx[19]
    ) },
    { name: (
      /*name*/
      ctx[20]
    ) },
    /*$$restProps*/
    ctx[31]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block0 = (
    /*invalid*/
    ctx[13] && create_if_block_52(ctx)
  );
  let if_block1 = !/*invalid*/
  ctx[13] && /*warn*/
  ctx[14] && create_if_block_42(ctx);
  let if_block2 = (
    /*value*/
    ctx[1] && create_if_block_32(ctx)
  );
  listboxmenuicon = new ListBoxMenuIcon_default({
    props: {
      translateWithId: (
        /*translateWithId*/
        ctx[17]
      ),
      open: (
        /*open*/
        ctx[2]
      )
    },
    $$inline: true
  });
  listboxmenuicon.$on(
    "click",
    /*click_handler_1*/
    ctx[48]
  );
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      t3 = space();
      create_component(listboxmenuicon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        tabindex: true,
        autocomplete: true,
        "aria-autocomplete": true,
        "aria-expanded": true,
        "aria-activedescendant": true,
        "aria-labelledby": true,
        "aria-disabled": true,
        "aria-controls": true,
        "aria-owns": true,
        placeholder: true,
        id: true,
        name: true
      });
      t0 = claim_space(nodes);
      if (if_block0) if_block0.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      t2 = claim_space(nodes);
      if (if_block2) if_block2.l(nodes);
      t3 = claim_space(nodes);
      claim_component(listboxmenuicon.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "bx--text-input", true);
      toggle_class(
        input,
        "bx--text-input--light",
        /*light*/
        ctx[16]
      );
      toggle_class(
        input,
        "bx--text-input--empty",
        /*value*/
        ctx[1] === ""
      );
      add_location(input, file38, 258, 6, 6995);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus) input.focus();
      ctx[42](input);
      set_input_value(
        input,
        /*value*/
        ctx[1]
      );
      insert_hydration_dev(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(listboxmenuicon, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[43]
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[44],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[36],
            false,
            false,
            false,
            false
          ),
          listen_dev(input, "keydown", stop_propagation(
            /*keydown_handler_1*/
            ctx[45]
          ), false, false, true, false),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[38],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[39],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler_1*/
            ctx[46],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "paste",
            /*paste_handler*/
            ctx[40],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { tabindex: "0" },
        { autocomplete: "off" },
        { "aria-autocomplete": "list" },
        (!current || dirty[0] & /*open*/
        4) && { "aria-expanded": (
          /*open*/
          ctx2[2]
        ) },
        (!current || dirty[0] & /*highlightedId*/
        33554432) && {
          "aria-activedescendant": (
            /*highlightedId*/
            ctx2[25]
          )
        },
        (!current || dirty[0] & /*comboId*/
        67108864) && { "aria-labelledby": (
          /*comboId*/
          ctx2[26]
        ) },
        (!current || dirty[0] & /*disabled*/
        256) && { "aria-disabled": (
          /*disabled*/
          ctx2[8]
        ) },
        (!current || dirty[0] & /*open, menuId*/
        134217732 && input_aria_controls_value !== (input_aria_controls_value = /*open*/
        ctx2[2] ? (
          /*menuId*/
          ctx2[27]
        ) : void 0)) && {
          "aria-controls": input_aria_controls_value
        },
        (!current || dirty[0] & /*open, menuId*/
        134217732 && input_aria_owns_value !== (input_aria_owns_value = /*open*/
        ctx2[2] ? (
          /*menuId*/
          ctx2[27]
        ) : void 0)) && { "aria-owns": input_aria_owns_value },
        (!current || dirty[0] & /*disabled*/
        256) && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        (!current || dirty[0] & /*placeholder*/
        1024) && { placeholder: (
          /*placeholder*/
          ctx2[10]
        ) },
        (!current || dirty[0] & /*id*/
        524288) && { id: (
          /*id*/
          ctx2[19]
        ) },
        (!current || dirty[0] & /*name*/
        1048576) && { name: (
          /*name*/
          ctx2[20]
        ) },
        dirty[1] & /*$$restProps*/
        1 && /*$$restProps*/
        ctx2[31]
      ]));
      if (dirty[0] & /*value*/
      2 && input.value !== /*value*/
      ctx2[1]) {
        set_input_value(
          input,
          /*value*/
          ctx2[1]
        );
      }
      toggle_class(input, "bx--text-input", true);
      toggle_class(
        input,
        "bx--text-input--light",
        /*light*/
        ctx2[16]
      );
      toggle_class(
        input,
        "bx--text-input--empty",
        /*value*/
        ctx2[1] === ""
      );
      if (
        /*invalid*/
        ctx2[13]
      ) {
        if (if_block0) {
          if (dirty[0] & /*invalid*/
          8192) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_52(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*invalid*/
      ctx2[13] && /*warn*/
      ctx2[14]) {
        if (if_block1) {
          if (dirty[0] & /*invalid, warn*/
          24576) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_42(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*value*/
        ctx2[1]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*value*/
          2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_32(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const listboxmenuicon_changes = {};
      if (dirty[0] & /*translateWithId*/
      131072) listboxmenuicon_changes.translateWithId = /*translateWithId*/
      ctx2[17];
      if (dirty[0] & /*open*/
      4) listboxmenuicon_changes.open = /*open*/
      ctx2[2];
      listboxmenuicon.$set(listboxmenuicon_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(listboxmenuicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(listboxmenuicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
      }
      ctx[42](null);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
      destroy_component(listboxmenuicon, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: '(246:4) <ListBoxField       role=\\"button\\"       aria-expanded=\\"{open}\\"       on:click=\\"{async () => {         if (disabled) return;         open = true;         await tick();         ref.focus();       }}\\"       id=\\"{id}\\"       disabled=\\"{disabled}\\"       translateWithId=\\"{translateWithId}\\"     >',
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let listboxmenu;
  let updating_ref;
  let current;
  function listboxmenu_ref_binding(value) {
    ctx[52](value);
  }
  let listboxmenu_props = {
    "aria-label": (
      /*ariaLabel*/
      ctx[28]
    ),
    id: (
      /*id*/
      ctx[19]
    ),
    $$slots: { default: [create_default_slot_1] },
    $$scope: { ctx }
  };
  if (
    /*listRef*/
    ctx[4] !== void 0
  ) {
    listboxmenu_props.ref = /*listRef*/
    ctx[4];
  }
  listboxmenu = new ListBoxMenu_default({ props: listboxmenu_props, $$inline: true });
  binding_callbacks.push(() => bind(listboxmenu, "ref", listboxmenu_ref_binding));
  listboxmenu.$on(
    "scroll",
    /*scroll_handler*/
    ctx[53]
  );
  const block = {
    c: function create() {
      create_component(listboxmenu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(listboxmenu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(listboxmenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const listboxmenu_changes = {};
      if (dirty[0] & /*ariaLabel*/
      268435456) listboxmenu_changes["aria-label"] = /*ariaLabel*/
      ctx2[28];
      if (dirty[0] & /*id*/
      524288) listboxmenu_changes.id = /*id*/
      ctx2[19];
      if (dirty[0] & /*filteredItems, selectedId, highlightedIndex, open, value, itemToString, selectedItem*/
      29360167 | dirty[1] & /*$$scope*/
      8388608) {
        listboxmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref && dirty[0] & /*listRef*/
      16) {
        updating_ref = true;
        listboxmenu_changes.ref = /*listRef*/
        ctx2[4];
        add_flush_callback(() => updating_ref = false);
      }
      listboxmenu.$set(listboxmenu_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(listboxmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listboxmenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(376:4) {#if open}",
    ctx
  });
  return block;
}
function fallback_block6(ctx) {
  let t_value = (
    /*itemToString*/
    ctx[5](
      /*item*/
      ctx[57]
    ) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*itemToString, filteredItems*/
      16777248 && t_value !== (t_value = /*itemToString*/
      ctx2[5](
        /*item*/
        ctx2[57]
      ) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block6.name,
    type: "fallback",
    source: "(406:44)                ",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let checkmark;
  let current;
  checkmark = new Checkmark_default({
    props: {
      class: "bx--list-box__menu-item__selected-icon"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(checkmark.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(checkmark.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(checkmark, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(checkmark.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmark.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkmark, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(409:12) {#if selectedItem && selectedItem.id === item.id}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let t0;
  let t1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[35].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[54],
    get_default_slot_context4
  );
  const default_slot_or_fallback = default_slot || fallback_block6(ctx);
  let if_block = (
    /*selectedItem*/
    ctx[22] && /*selectedItem*/
    ctx[22].id === /*item*/
    ctx[57].id && create_if_block_24(ctx)
  );
  const block = {
    c: function create() {
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback) default_slot_or_fallback.l(nodes);
      t0 = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      t1 = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      insert_hydration_dev(target, t0, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*filteredItems*/
        16777216 | dirty[1] & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[54],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[54]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[54],
              dirty,
              get_default_slot_changes4
            ),
            get_default_slot_context4
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*itemToString, filteredItems*/
        16777248)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (
        /*selectedItem*/
        ctx2[22] && /*selectedItem*/
        ctx2[22].id === /*item*/
        ctx2[57].id
      ) {
        if (if_block) {
          if (dirty[0] & /*selectedItem, filteredItems*/
          20971520) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_24(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: '(384:10) <ListBoxMenuItem             id=\\"{item.id}\\"             active=\\"{selectedId === item.id}\\"             highlighted=\\"{highlightedIndex === i}\\"             disabled=\\"{item.disabled}\\"             on:click=\\"{(e) => {               if (item.disabled) {                 e.stopPropagation();                 return;               }               selectedId = item.id;               open = false;                if (filteredItems[i]) {                 value = itemToString(filteredItems[i]);               }             }}\\"             on:mouseenter=\\"{() => {               if (item.disabled) return;               highlightedIndex = i;             }}\\"           >',
    ctx
  });
  return block;
}
function create_each_block4(key_1, ctx) {
  let first;
  let listboxmenuitem;
  let current;
  function click_handler_3(...args) {
    return (
      /*click_handler_3*/
      ctx[50](
        /*item*/
        ctx[57],
        /*i*/
        ctx[59],
        ...args
      )
    );
  }
  function mouseenter_handler() {
    return (
      /*mouseenter_handler*/
      ctx[51](
        /*item*/
        ctx[57],
        /*i*/
        ctx[59]
      )
    );
  }
  listboxmenuitem = new ListBoxMenuItem_default({
    props: {
      id: (
        /*item*/
        ctx[57].id
      ),
      active: (
        /*selectedId*/
        ctx[0] === /*item*/
        ctx[57].id
      ),
      highlighted: (
        /*highlightedIndex*/
        ctx[23] === /*i*/
        ctx[59]
      ),
      disabled: (
        /*item*/
        ctx[57].disabled
      ),
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  listboxmenuitem.$on("click", click_handler_3);
  listboxmenuitem.$on("mouseenter", mouseenter_handler);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(listboxmenuitem.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(listboxmenuitem.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(listboxmenuitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const listboxmenuitem_changes = {};
      if (dirty[0] & /*filteredItems*/
      16777216) listboxmenuitem_changes.id = /*item*/
      ctx[57].id;
      if (dirty[0] & /*selectedId, filteredItems*/
      16777217) listboxmenuitem_changes.active = /*selectedId*/
      ctx[0] === /*item*/
      ctx[57].id;
      if (dirty[0] & /*highlightedIndex, filteredItems*/
      25165824) listboxmenuitem_changes.highlighted = /*highlightedIndex*/
      ctx[23] === /*i*/
      ctx[59];
      if (dirty[0] & /*filteredItems*/
      16777216) listboxmenuitem_changes.disabled = /*item*/
      ctx[57].disabled;
      if (dirty[0] & /*selectedItem, filteredItems, itemToString*/
      20971552 | dirty[1] & /*$$scope*/
      8388608) {
        listboxmenuitem_changes.$$scope = { dirty, ctx };
      }
      listboxmenuitem.$set(listboxmenuitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(listboxmenuitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxmenuitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(listboxmenuitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(383:8) {#each filteredItems as item, i (item.id)}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*filteredItems*/
    ctx[24]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[57].id
  );
  validate_each_keys(ctx, each_value, get_each_context4, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block4(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*filteredItems, selectedId, highlightedIndex, open, value, itemToString, selectedItem*/
      29360167 | dirty[1] & /*$$scope*/
      8388608) {
        each_value = ensure_array_like_dev(
          /*filteredItems*/
          ctx2[24]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context4, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block4, each_1_anchor, get_each_context4);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: '(377:6) <ListBoxMenu         aria-label=\\"{ariaLabel}\\"         id=\\"{id}\\"         on:scroll         bind:ref=\\"{listRef}\\"       >',
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let listboxfield;
  let t;
  let if_block_anchor;
  let current;
  listboxfield = new ListBoxField_default({
    props: {
      role: "button",
      "aria-expanded": (
        /*open*/
        ctx[2]
      ),
      id: (
        /*id*/
        ctx[19]
      ),
      disabled: (
        /*disabled*/
        ctx[8]
      ),
      translateWithId: (
        /*translateWithId*/
        ctx[17]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  listboxfield.$on(
    "click",
    /*click_handler_2*/
    ctx[49]
  );
  let if_block = (
    /*open*/
    ctx[2] && create_if_block_16(ctx)
  );
  const block = {
    c: function create() {
      create_component(listboxfield.$$.fragment);
      t = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(listboxfield.$$.fragment, nodes);
      t = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(listboxfield, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const listboxfield_changes = {};
      if (dirty[0] & /*open*/
      4) listboxfield_changes["aria-expanded"] = /*open*/
      ctx2[2];
      if (dirty[0] & /*id*/
      524288) listboxfield_changes.id = /*id*/
      ctx2[19];
      if (dirty[0] & /*disabled*/
      256) listboxfield_changes.disabled = /*disabled*/
      ctx2[8];
      if (dirty[0] & /*translateWithId*/
      131072) listboxfield_changes.translateWithId = /*translateWithId*/
      ctx2[17];
      if (dirty[0] & /*translateWithId, open, disabled, translateWithIdSelection, value, invalid, warn, highlightedId, comboId, menuId, placeholder, id, name, ref, light, highlightedIndex, filteredItems, selectedId, itemToString, selectedItem*/
      266298671 | dirty[1] & /*$$scope, $$restProps*/
      8388609) {
        listboxfield_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listboxfield.$set(listboxfield_changes);
      if (
        /*open*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*open*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_16(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(listboxfield.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxfield.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      destroy_component(listboxfield, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: `(232:2) <ListBox     class=\\"bx--combo-box {direction === 'top' &&       'bx--list-box--up'} {!invalid && warn && 'bx--combo-box--warning'}\\"     id=\\"{comboId}\\"     aria-label=\\"{ariaLabel}\\"     disabled=\\"{disabled}\\"     invalid=\\"{invalid}\\"     invalidText=\\"{invalidText}\\"     open=\\"{open}\\"     light=\\"{light}\\"     size=\\"{size}\\"     warn=\\"{warn}\\"     warnText=\\"{warnText}\\"   >`,
    ctx
  });
  return block;
}
function create_if_block21(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[11]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[11]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(
        div,
        "bx--form__helper-text--disabled",
        /*disabled*/
        ctx[8]
      );
      add_location(div, file38, 417, 4, 11975);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*helperText*/
      2048) set_data_dev(
        t,
        /*helperText*/
        ctx2[11]
      );
      if (dirty[0] & /*disabled*/
      256) {
        toggle_class(
          div,
          "bx--form__helper-text--disabled",
          /*disabled*/
          ctx2[8]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(417:2) {#if !invalid && helperText && !warn}",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let div;
  let t0;
  let listbox;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*titleText*/
    (ctx[9] || /*$$slots*/
    ctx[30].titleText) && create_if_block_62(ctx)
  );
  listbox = new ListBox_default({
    props: {
      class: "bx--combo-box " + /*direction*/
      (ctx[6] === "top" && "bx--list-box--up") + " " + (!/*invalid*/
      ctx[13] && /*warn*/
      ctx[14] && "bx--combo-box--warning"),
      id: (
        /*comboId*/
        ctx[26]
      ),
      "aria-label": (
        /*ariaLabel*/
        ctx[28]
      ),
      disabled: (
        /*disabled*/
        ctx[8]
      ),
      invalid: (
        /*invalid*/
        ctx[13]
      ),
      invalidText: (
        /*invalidText*/
        ctx[12]
      ),
      open: (
        /*open*/
        ctx[2]
      ),
      light: (
        /*light*/
        ctx[16]
      ),
      size: (
        /*size*/
        ctx[7]
      ),
      warn: (
        /*warn*/
        ctx[14]
      ),
      warnText: (
        /*warnText*/
        ctx[15]
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block1 = !/*invalid*/
  ctx[13] && /*helperText*/
  ctx[11] && !/*warn*/
  ctx[14] && create_if_block21(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      create_component(listbox.$$.fragment);
      t1 = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block0) if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      claim_component(listbox.$$.fragment, div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block1) if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--list-box__wrapper", true);
      add_location(div, file38, 219, 0, 6050);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append_hydration_dev(div, t0);
      mount_component(listbox, div, null);
      append_hydration_dev(div, t1);
      if (if_block1) if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "click",
          /*click_handler*/
          ctx[41],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*titleText*/
        ctx2[9] || /*$$slots*/
        ctx2[30].titleText
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*titleText, $$slots*/
          1073742336) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_62(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const listbox_changes = {};
      if (dirty[0] & /*direction, invalid, warn*/
      24640) listbox_changes.class = "bx--combo-box " + /*direction*/
      (ctx2[6] === "top" && "bx--list-box--up") + " " + (!/*invalid*/
      ctx2[13] && /*warn*/
      ctx2[14] && "bx--combo-box--warning");
      if (dirty[0] & /*comboId*/
      67108864) listbox_changes.id = /*comboId*/
      ctx2[26];
      if (dirty[0] & /*ariaLabel*/
      268435456) listbox_changes["aria-label"] = /*ariaLabel*/
      ctx2[28];
      if (dirty[0] & /*disabled*/
      256) listbox_changes.disabled = /*disabled*/
      ctx2[8];
      if (dirty[0] & /*invalid*/
      8192) listbox_changes.invalid = /*invalid*/
      ctx2[13];
      if (dirty[0] & /*invalidText*/
      4096) listbox_changes.invalidText = /*invalidText*/
      ctx2[12];
      if (dirty[0] & /*open*/
      4) listbox_changes.open = /*open*/
      ctx2[2];
      if (dirty[0] & /*light*/
      65536) listbox_changes.light = /*light*/
      ctx2[16];
      if (dirty[0] & /*size*/
      128) listbox_changes.size = /*size*/
      ctx2[7];
      if (dirty[0] & /*warn*/
      16384) listbox_changes.warn = /*warn*/
      ctx2[14];
      if (dirty[0] & /*warnText*/
      32768) listbox_changes.warnText = /*warnText*/
      ctx2[15];
      if (dirty[0] & /*ariaLabel, id, listRef, filteredItems, selectedId, highlightedIndex, open, value, itemToString, selectedItem, disabled, translateWithId, ref, translateWithIdSelection, invalid, warn, highlightedId, comboId, menuId, placeholder, name, light*/
      534734143 | dirty[1] & /*$$scope, $$restProps*/
      8388609) {
        listbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listbox.$set(listbox_changes);
      if (!/*invalid*/
      ctx2[13] && /*helperText*/
      ctx2[11] && !/*warn*/
      ctx2[14]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block21(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(listbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(listbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0) if_block0.d();
      destroy_component(listbox);
      if (if_block1) if_block1.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let ariaLabel;
  let menuId;
  let comboId;
  let highlightedId;
  let filteredItems;
  const omit_props_names = [
    "items",
    "itemToString",
    "selectedId",
    "value",
    "direction",
    "size",
    "disabled",
    "titleText",
    "placeholder",
    "helperText",
    "invalidText",
    "invalid",
    "warn",
    "warnText",
    "light",
    "open",
    "shouldFilterItem",
    "translateWithId",
    "translateWithIdSelection",
    "id",
    "name",
    "ref",
    "listRef",
    "clear"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ComboBox", slots, ["titleText", "default"]);
  const $$slots = compute_slots(slots);
  let { items = [] } = $$props;
  let { itemToString = (item) => item.text || item.id } = $$props;
  let { selectedId = void 0 } = $$props;
  let { value = "" } = $$props;
  let { direction = "bottom" } = $$props;
  let { size = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { titleText = "" } = $$props;
  let { placeholder = "" } = $$props;
  let { helperText = "" } = $$props;
  let { invalidText = "" } = $$props;
  let { invalid = false } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { light = false } = $$props;
  let { open = false } = $$props;
  let { shouldFilterItem = () => true } = $$props;
  let { translateWithId = void 0 } = $$props;
  let { translateWithIdSelection = void 0 } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  let { listRef = null } = $$props;
  const dispatch = createEventDispatcher();
  let selectedItem = void 0;
  let prevSelectedId = null;
  let highlightedIndex = -1;
  function change(dir) {
    let index = highlightedIndex + dir;
    let _items = !(filteredItems == null ? void 0 : filteredItems.length) ? items : filteredItems;
    if (_items.length === 0) return;
    if (index < 0) {
      index = _items.length - 1;
    } else if (index >= _items.length) {
      index = 0;
    }
    let disabled2 = items[index].disabled;
    while (disabled2) {
      index = index + dir;
      if (index < 0) {
        index = items.length - 1;
      } else if (index >= items.length) {
        index = 0;
      }
      disabled2 = items[index].disabled;
    }
    $$invalidate(23, highlightedIndex = index);
  }
  function clear(options = {}) {
    $$invalidate(34, prevSelectedId = null);
    $$invalidate(23, highlightedIndex = -1);
    $$invalidate(25, highlightedId = void 0);
    $$invalidate(0, selectedId = void 0);
    $$invalidate(22, selectedItem = void 0);
    $$invalidate(2, open = false);
    $$invalidate(1, value = "");
    if ((options == null ? void 0 : options.focus) !== false) ref == null ? void 0 : ref.focus();
  }
  afterUpdate(() => {
    if (open) {
      ref.focus();
      $$invalidate(24, filteredItems = items.filter((item) => shouldFilterItem(item, value)));
    } else {
      $$invalidate(23, highlightedIndex = -1);
      $$invalidate(24, filteredItems = []);
      if (!selectedItem) {
        $$invalidate(0, selectedId = void 0);
        $$invalidate(1, value = "");
        $$invalidate(23, highlightedIndex = -1);
        $$invalidate(25, highlightedId = void 0);
      } else {
        $$invalidate(1, value = itemToString(selectedItem));
      }
    }
  });
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler = ({ target }) => {
    if (open && ref && !ref.contains(target)) {
      $$invalidate(2, open = false);
    }
  };
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(1, value);
  }
  const input_handler = ({ target }) => {
    if (!open && target.value.length > 0) {
      $$invalidate(2, open = true);
    }
    if (!value.length) {
      clear();
      $$invalidate(2, open = true);
    }
  };
  const keydown_handler_12 = (e) => {
    var _a;
    const { key } = e;
    if (["Enter", "ArrowDown", "ArrowUp"].includes(key)) {
      e.preventDefault();
    }
    if (key === "Enter") {
      $$invalidate(2, open = !open);
      if (highlightedIndex > -1 && ((_a = filteredItems[highlightedIndex]) == null ? void 0 : _a.id) !== selectedId) {
        $$invalidate(2, open = false);
        if (filteredItems[highlightedIndex]) {
          $$invalidate(1, value = itemToString(filteredItems[highlightedIndex]));
          $$invalidate(22, selectedItem = filteredItems[highlightedIndex]);
          $$invalidate(0, selectedId = filteredItems[highlightedIndex].id);
        }
      } else {
        const matchedItem = filteredItems.find((e2) => e2.text.toLowerCase() === (value == null ? void 0 : value.toLowerCase()) && !e2.disabled) ?? filteredItems.find((e2) => !e2.disabled);
        if (matchedItem) {
          $$invalidate(2, open = false);
          $$invalidate(22, selectedItem = matchedItem);
          $$invalidate(1, value = itemToString(selectedItem));
          $$invalidate(0, selectedId = selectedItem.id);
        }
      }
      $$invalidate(23, highlightedIndex = -1);
    } else if (key === "Tab") {
      $$invalidate(2, open = false);
    } else if (key === "ArrowDown") {
      change(1);
    } else if (key === "ArrowUp") {
      change(-1);
    } else if (key === "Escape") {
      $$invalidate(2, open = false);
    }
  };
  const blur_handler_1 = ({ relatedTarget }) => {
    if (!open || !relatedTarget) return;
    if (relatedTarget && !["INPUT", "SELECT", "TEXTAREA"].includes(relatedTarget.tagName) && relatedTarget.getAttribute("role") !== "button" && relatedTarget.getAttribute("role") !== "searchbox") {
      ref.focus();
    }
  };
  function clear_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = (e) => {
    if (disabled) return;
    e.stopPropagation();
    $$invalidate(2, open = !open);
  };
  const click_handler_2 = async () => {
    if (disabled) return;
    $$invalidate(2, open = true);
    await tick();
    ref.focus();
  };
  const click_handler_3 = (item, i, e) => {
    if (item.disabled) {
      e.stopPropagation();
      return;
    }
    $$invalidate(0, selectedId = item.id);
    $$invalidate(2, open = false);
    if (filteredItems[i]) {
      $$invalidate(1, value = itemToString(filteredItems[i]));
    }
  };
  const mouseenter_handler = (item, i) => {
    if (item.disabled) return;
    $$invalidate(23, highlightedIndex = i);
  };
  function listboxmenu_ref_binding(value2) {
    listRef = value2;
    $$invalidate(4, listRef);
  }
  function scroll_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(56, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(31, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("items" in $$new_props) $$invalidate(32, items = $$new_props.items);
    if ("itemToString" in $$new_props) $$invalidate(5, itemToString = $$new_props.itemToString);
    if ("selectedId" in $$new_props) $$invalidate(0, selectedId = $$new_props.selectedId);
    if ("value" in $$new_props) $$invalidate(1, value = $$new_props.value);
    if ("direction" in $$new_props) $$invalidate(6, direction = $$new_props.direction);
    if ("size" in $$new_props) $$invalidate(7, size = $$new_props.size);
    if ("disabled" in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
    if ("titleText" in $$new_props) $$invalidate(9, titleText = $$new_props.titleText);
    if ("placeholder" in $$new_props) $$invalidate(10, placeholder = $$new_props.placeholder);
    if ("helperText" in $$new_props) $$invalidate(11, helperText = $$new_props.helperText);
    if ("invalidText" in $$new_props) $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("invalid" in $$new_props) $$invalidate(13, invalid = $$new_props.invalid);
    if ("warn" in $$new_props) $$invalidate(14, warn = $$new_props.warn);
    if ("warnText" in $$new_props) $$invalidate(15, warnText = $$new_props.warnText);
    if ("light" in $$new_props) $$invalidate(16, light = $$new_props.light);
    if ("open" in $$new_props) $$invalidate(2, open = $$new_props.open);
    if ("shouldFilterItem" in $$new_props) $$invalidate(33, shouldFilterItem = $$new_props.shouldFilterItem);
    if ("translateWithId" in $$new_props) $$invalidate(17, translateWithId = $$new_props.translateWithId);
    if ("translateWithIdSelection" in $$new_props) $$invalidate(18, translateWithIdSelection = $$new_props.translateWithIdSelection);
    if ("id" in $$new_props) $$invalidate(19, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(20, name = $$new_props.name);
    if ("ref" in $$new_props) $$invalidate(3, ref = $$new_props.ref);
    if ("listRef" in $$new_props) $$invalidate(4, listRef = $$new_props.listRef);
    if ("$$scope" in $$new_props) $$invalidate(54, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    items,
    itemToString,
    selectedId,
    value,
    direction,
    size,
    disabled,
    titleText,
    placeholder,
    helperText,
    invalidText,
    invalid,
    warn,
    warnText,
    light,
    open,
    shouldFilterItem,
    translateWithId,
    translateWithIdSelection,
    id,
    name,
    ref,
    listRef,
    createEventDispatcher,
    afterUpdate,
    tick,
    Checkmark: Checkmark_default,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    ListBox: ListBox_default,
    ListBoxField: ListBoxField_default,
    ListBoxMenu: ListBoxMenu_default,
    ListBoxMenuIcon: ListBoxMenuIcon_default,
    ListBoxMenuItem: ListBoxMenuItem_default,
    ListBoxSelection: ListBoxSelection_default,
    dispatch,
    selectedItem,
    prevSelectedId,
    highlightedIndex,
    change,
    clear,
    filteredItems,
    highlightedId,
    comboId,
    menuId,
    ariaLabel
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(56, $$props = assign(assign({}, $$props), $$new_props));
    if ("items" in $$props) $$invalidate(32, items = $$new_props.items);
    if ("itemToString" in $$props) $$invalidate(5, itemToString = $$new_props.itemToString);
    if ("selectedId" in $$props) $$invalidate(0, selectedId = $$new_props.selectedId);
    if ("value" in $$props) $$invalidate(1, value = $$new_props.value);
    if ("direction" in $$props) $$invalidate(6, direction = $$new_props.direction);
    if ("size" in $$props) $$invalidate(7, size = $$new_props.size);
    if ("disabled" in $$props) $$invalidate(8, disabled = $$new_props.disabled);
    if ("titleText" in $$props) $$invalidate(9, titleText = $$new_props.titleText);
    if ("placeholder" in $$props) $$invalidate(10, placeholder = $$new_props.placeholder);
    if ("helperText" in $$props) $$invalidate(11, helperText = $$new_props.helperText);
    if ("invalidText" in $$props) $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("invalid" in $$props) $$invalidate(13, invalid = $$new_props.invalid);
    if ("warn" in $$props) $$invalidate(14, warn = $$new_props.warn);
    if ("warnText" in $$props) $$invalidate(15, warnText = $$new_props.warnText);
    if ("light" in $$props) $$invalidate(16, light = $$new_props.light);
    if ("open" in $$props) $$invalidate(2, open = $$new_props.open);
    if ("shouldFilterItem" in $$props) $$invalidate(33, shouldFilterItem = $$new_props.shouldFilterItem);
    if ("translateWithId" in $$props) $$invalidate(17, translateWithId = $$new_props.translateWithId);
    if ("translateWithIdSelection" in $$props) $$invalidate(18, translateWithIdSelection = $$new_props.translateWithIdSelection);
    if ("id" in $$props) $$invalidate(19, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(20, name = $$new_props.name);
    if ("ref" in $$props) $$invalidate(3, ref = $$new_props.ref);
    if ("listRef" in $$props) $$invalidate(4, listRef = $$new_props.listRef);
    if ("selectedItem" in $$props) $$invalidate(22, selectedItem = $$new_props.selectedItem);
    if ("prevSelectedId" in $$props) $$invalidate(34, prevSelectedId = $$new_props.prevSelectedId);
    if ("highlightedIndex" in $$props) $$invalidate(23, highlightedIndex = $$new_props.highlightedIndex);
    if ("filteredItems" in $$props) $$invalidate(24, filteredItems = $$new_props.filteredItems);
    if ("highlightedId" in $$props) $$invalidate(25, highlightedId = $$new_props.highlightedId);
    if ("comboId" in $$props) $$invalidate(26, comboId = $$new_props.comboId);
    if ("menuId" in $$props) $$invalidate(27, menuId = $$new_props.menuId);
    if ("ariaLabel" in $$props) $$invalidate(28, ariaLabel = $$new_props.ariaLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value*/
    2 | $$self.$$.dirty[1] & /*items, shouldFilterItem*/
    6) {
      $: $$invalidate(24, filteredItems = items.filter((item) => shouldFilterItem(item, value)));
    }
    if ($$self.$$.dirty[0] & /*selectedId, filteredItems, open, selectedItem*/
    20971525 | $$self.$$.dirty[1] & /*prevSelectedId, items*/
    10) {
      $: if (selectedId !== void 0) {
        if (prevSelectedId !== selectedId) {
          $$invalidate(34, prevSelectedId = selectedId);
          if ((filteredItems == null ? void 0 : filteredItems.length) === 1 && open) {
            $$invalidate(0, selectedId = filteredItems[0].id);
            $$invalidate(22, selectedItem = filteredItems[0]);
            $$invalidate(23, highlightedIndex = -1);
            $$invalidate(25, highlightedId = void 0);
          } else {
            $$invalidate(22, selectedItem = items.find((item) => item.id === selectedId));
          }
          dispatch("select", { selectedId, selectedItem });
        }
      } else {
        $$invalidate(34, prevSelectedId = selectedId);
        $$invalidate(22, selectedItem = void 0);
      }
    }
    $: $$invalidate(28, ariaLabel = $$props["aria-label"] || "Choose an item");
    if ($$self.$$.dirty[0] & /*id*/
    524288) {
      $: $$invalidate(27, menuId = `menu-${id}`);
    }
    if ($$self.$$.dirty[0] & /*id*/
    524288) {
      $: $$invalidate(26, comboId = `combo-${id}`);
    }
    if ($$self.$$.dirty[0] & /*highlightedIndex*/
    8388608 | $$self.$$.dirty[1] & /*items*/
    2) {
      $: $$invalidate(25, highlightedId = items[highlightedIndex] ? items[highlightedIndex].id : 0);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    selectedId,
    value,
    open,
    ref,
    listRef,
    itemToString,
    direction,
    size,
    disabled,
    titleText,
    placeholder,
    helperText,
    invalidText,
    invalid,
    warn,
    warnText,
    light,
    translateWithId,
    translateWithIdSelection,
    id,
    name,
    clear,
    selectedItem,
    highlightedIndex,
    filteredItems,
    highlightedId,
    comboId,
    menuId,
    ariaLabel,
    change,
    $$slots,
    $$restProps,
    items,
    shouldFilterItem,
    prevSelectedId,
    slots,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    paste_handler,
    click_handler,
    input_binding,
    input_input_handler,
    input_handler,
    keydown_handler_12,
    blur_handler_1,
    clear_handler,
    click_handler_13,
    click_handler_2,
    click_handler_3,
    mouseenter_handler,
    listboxmenu_ref_binding,
    scroll_handler,
    $$scope
  ];
}
var ComboBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance39,
      create_fragment39,
      safe_not_equal,
      {
        items: 32,
        itemToString: 5,
        selectedId: 0,
        value: 1,
        direction: 6,
        size: 7,
        disabled: 8,
        titleText: 9,
        placeholder: 10,
        helperText: 11,
        invalidText: 12,
        invalid: 13,
        warn: 14,
        warnText: 15,
        light: 16,
        open: 2,
        shouldFilterItem: 33,
        translateWithId: 17,
        translateWithIdSelection: 18,
        id: 19,
        name: 20,
        ref: 3,
        listRef: 4,
        clear: 21
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ComboBox",
      options,
      id: create_fragment39.name
    });
  }
  get items() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemToString() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemToString(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedId() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedId(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleText() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleText(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldFilterItem() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldFilterItem(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithIdSelection() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithIdSelection(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listRef() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listRef(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clear() {
    return this.$$.ctx[21];
  }
  set clear(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ComboBox_default = ComboBox;

// node_modules/carbon-components-svelte/src/Modal/modalStore.js
var stores = /* @__PURE__ */ new Set();
var modalsOpen = writable(0);
var updateModalsOpen = () => modalsOpen.set([...stores].filter((open) => get_store_value(open)).length);
var trackModal = (openStore) => onMount(() => {
  stores.add(openStore);
  const unsubscribe = openStore.subscribe(updateModalsOpen);
  return () => {
    unsubscribe();
    stores.delete(openStore);
    updateModalsOpen();
  };
});
modalsOpen.subscribe((openCount) => {
  if (typeof document !== "undefined")
    document.body.classList.toggle("bx--body--with-modal-open", openCount > 0);
});

// node_modules/carbon-components-svelte/src/ComposedModal/ComposedModal.svelte
var file39 = "node_modules/carbon-components-svelte/src/ComposedModal/ComposedModal.svelte";
function create_fragment40(ctx) {
  let div1;
  let div0;
  let div0_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  let div1_levels = [
    { role: "presentation" },
    /*$$restProps*/
    ctx[14]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { role: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        role: true,
        "aria-modal": true,
        "aria-label": true,
        class: true
      });
      var div0_nodes = children(div0);
      if (default_slot) default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "role", "dialog");
      attr_dev(div0, "aria-modal", "true");
      attr_dev(div0, "aria-label", div0_aria_label_value = /*$$props*/
      ctx[15]["aria-label"] || /*$label*/
      ctx[9] || void 0);
      attr_dev(
        div0,
        "class",
        /*containerClass*/
        ctx[5]
      );
      toggle_class(div0, "bx--modal-container", true);
      toggle_class(
        div0,
        "bx--modal-container--xs",
        /*size*/
        ctx[2] === "xs"
      );
      toggle_class(
        div0,
        "bx--modal-container--sm",
        /*size*/
        ctx[2] === "sm"
      );
      toggle_class(
        div0,
        "bx--modal-container--lg",
        /*size*/
        ctx[2] === "lg"
      );
      add_location(div0, file39, 154, 2, 3830);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--modal", true);
      toggle_class(
        div1,
        "is-visible",
        /*open*/
        ctx[0]
      );
      toggle_class(
        div1,
        "bx--modal--danger",
        /*danger*/
        ctx[3]
      );
      add_location(div1, file39, 99, 0, 2151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[24](div0);
      ctx[26](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div0,
            "click",
            /*click_handler_1*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keydown",
            /*keydown_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keydown",
            /*keydown_handler_1*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "click",
            /*click_handler_2*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseover",
            /*mouseover_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "transitionend",
            /*transitionend_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*$$props, $label*/
      33280 && div0_aria_label_value !== (div0_aria_label_value = /*$$props*/
      ctx2[15]["aria-label"] || /*$label*/
      ctx2[9] || void 0)) {
        attr_dev(div0, "aria-label", div0_aria_label_value);
      }
      if (!current || dirty[0] & /*containerClass*/
      32) {
        attr_dev(
          div0,
          "class",
          /*containerClass*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*containerClass*/
      32) {
        toggle_class(div0, "bx--modal-container", true);
      }
      if (!current || dirty[0] & /*containerClass, size*/
      36) {
        toggle_class(
          div0,
          "bx--modal-container--xs",
          /*size*/
          ctx2[2] === "xs"
        );
      }
      if (!current || dirty[0] & /*containerClass, size*/
      36) {
        toggle_class(
          div0,
          "bx--modal-container--sm",
          /*size*/
          ctx2[2] === "sm"
        );
      }
      if (!current || dirty[0] & /*containerClass, size*/
      36) {
        toggle_class(
          div0,
          "bx--modal-container--lg",
          /*size*/
          ctx2[2] === "lg"
        );
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        { role: "presentation" },
        dirty[0] & /*$$restProps*/
        16384 && /*$$restProps*/
        ctx2[14]
      ]));
      toggle_class(div1, "bx--modal", true);
      toggle_class(
        div1,
        "is-visible",
        /*open*/
        ctx2[0]
      );
      toggle_class(
        div1,
        "bx--modal--danger",
        /*danger*/
        ctx2[3]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[24](null);
      ctx[26](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let didOpen;
  const omit_props_names = [
    "size",
    "open",
    "danger",
    "preventCloseOnClickOutside",
    "containerClass",
    "selectorPrimaryFocus",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $openStore;
  let $label;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ComposedModal", slots, ["default"]);
  let { size = void 0 } = $$props;
  let { open = false } = $$props;
  let { danger = false } = $$props;
  let { preventCloseOnClickOutside = false } = $$props;
  let { containerClass = "" } = $$props;
  let { selectorPrimaryFocus = "[data-modal-primary-focus]" } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  const label = writable(void 0);
  validate_store(label, "label");
  component_subscribe($$self, label, (value) => $$invalidate(9, $label = value));
  let buttonRef = null;
  let innerModal = null;
  let didClickInnerModal = false;
  setContext("ComposedModal", {
    closeModal: () => {
      $$invalidate(0, open = false);
    },
    submit: () => {
      dispatch("submit");
      dispatch("click:button--primary");
    },
    declareRef: (ref2) => {
      buttonRef = ref2;
    },
    updateLabel: (value) => {
      label.set(value);
    }
  });
  function focus(element2) {
    var _a;
    if (selectorPrimaryFocus == null) return;
    const node = ((_a = element2 || innerModal) == null ? void 0 : _a.querySelector(selectorPrimaryFocus)) || buttonRef;
    if (node != null) node.focus();
  }
  let opened = false;
  const openStore = writable(open);
  validate_store(openStore, "openStore");
  component_subscribe($$self, openStore, (value) => $$invalidate(32, $openStore = value));
  trackModal(openStore);
  onMount(() => {
    tick().then(() => {
      focus();
    });
  });
  afterUpdate(() => {
    if (opened) {
      if (!open) {
        opened = false;
        dispatch("close");
      }
    } else if (open) {
      opened = true;
      dispatch("open");
    }
  });
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerModal = $$value;
      $$invalidate(6, innerModal);
    });
  }
  const click_handler_13 = () => {
    $$invalidate(7, didClickInnerModal = true);
  };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const keydown_handler_12 = (e) => {
    if (open) {
      if (e.key === "Escape") {
        $$invalidate(0, open = false);
      } else if (e.key === "Tab") {
        const selectorTabbable = `
  a[href], area[href], input:not([disabled]):not([tabindex='-1']),
  button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),
  textarea:not([disabled]):not([tabindex='-1']),
  iframe, object, embed, *[tabindex]:not([tabindex='-1']):not([disabled]), *[contenteditable=true]
`;
        const tabbable = Array.from(ref.querySelectorAll(selectorTabbable));
        let index = tabbable.indexOf(document.activeElement);
        if (index === -1 && e.shiftKey) index = 0;
        index += tabbable.length + (e.shiftKey ? -1 : 1);
        index %= tabbable.length;
        tabbable[index].focus();
        e.preventDefault();
      }
    }
  };
  const click_handler_2 = () => {
    if (!didClickInnerModal && !preventCloseOnClickOutside) $$invalidate(0, open = false);
    $$invalidate(7, didClickInnerModal = false);
  };
  const transitionend_handler = ({ propertyName, currentTarget }) => {
    if (propertyName === "transform") {
      dispatch("transitionend", { open });
    }
    if (didOpen) {
      focus(currentTarget);
      $$invalidate(8, didOpen = false);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(2, size = $$new_props.size);
    if ("open" in $$new_props) $$invalidate(0, open = $$new_props.open);
    if ("danger" in $$new_props) $$invalidate(3, danger = $$new_props.danger);
    if ("preventCloseOnClickOutside" in $$new_props) $$invalidate(4, preventCloseOnClickOutside = $$new_props.preventCloseOnClickOutside);
    if ("containerClass" in $$new_props) $$invalidate(5, containerClass = $$new_props.containerClass);
    if ("selectorPrimaryFocus" in $$new_props) $$invalidate(16, selectorPrimaryFocus = $$new_props.selectorPrimaryFocus);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    open,
    danger,
    preventCloseOnClickOutside,
    containerClass,
    selectorPrimaryFocus,
    ref,
    createEventDispatcher,
    tick,
    setContext,
    onMount,
    afterUpdate,
    writable,
    trackModal,
    dispatch,
    label,
    buttonRef,
    innerModal,
    didClickInnerModal,
    focus,
    opened,
    openStore,
    didOpen,
    $openStore,
    $label
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(2, size = $$new_props.size);
    if ("open" in $$props) $$invalidate(0, open = $$new_props.open);
    if ("danger" in $$props) $$invalidate(3, danger = $$new_props.danger);
    if ("preventCloseOnClickOutside" in $$props) $$invalidate(4, preventCloseOnClickOutside = $$new_props.preventCloseOnClickOutside);
    if ("containerClass" in $$props) $$invalidate(5, containerClass = $$new_props.containerClass);
    if ("selectorPrimaryFocus" in $$props) $$invalidate(16, selectorPrimaryFocus = $$new_props.selectorPrimaryFocus);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("buttonRef" in $$props) buttonRef = $$new_props.buttonRef;
    if ("innerModal" in $$props) $$invalidate(6, innerModal = $$new_props.innerModal);
    if ("didClickInnerModal" in $$props) $$invalidate(7, didClickInnerModal = $$new_props.didClickInnerModal);
    if ("opened" in $$props) opened = $$new_props.opened;
    if ("didOpen" in $$props) $$invalidate(8, didOpen = $$new_props.didOpen);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*open*/
    1) {
      $: $$invalidate(8, didOpen = open);
    }
    if ($$self.$$.dirty[0] & /*open*/
    1) {
      $: set_store_value(openStore, $openStore = open, $openStore);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    open,
    ref,
    size,
    danger,
    preventCloseOnClickOutside,
    containerClass,
    innerModal,
    didClickInnerModal,
    didOpen,
    $label,
    dispatch,
    label,
    focus,
    openStore,
    $$restProps,
    $$props,
    selectorPrimaryFocus,
    $$scope,
    slots,
    keydown_handler,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    div0_binding,
    click_handler_13,
    div1_binding,
    keydown_handler_12,
    click_handler_2,
    transitionend_handler
  ];
}
var ComposedModal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance40,
      create_fragment40,
      safe_not_equal,
      {
        size: 2,
        open: 0,
        danger: 3,
        preventCloseOnClickOutside: 4,
        containerClass: 5,
        selectorPrimaryFocus: 16,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ComposedModal",
      options,
      id: create_fragment40.name
    });
  }
  get size() {
    throw new Error("<ComposedModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ComposedModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<ComposedModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<ComposedModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get danger() {
    throw new Error("<ComposedModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set danger(value) {
    throw new Error("<ComposedModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventCloseOnClickOutside() {
    throw new Error("<ComposedModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventCloseOnClickOutside(value) {
    throw new Error("<ComposedModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerClass() {
    throw new Error("<ComposedModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerClass(value) {
    throw new Error("<ComposedModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectorPrimaryFocus() {
    throw new Error("<ComposedModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectorPrimaryFocus(value) {
    throw new Error("<ComposedModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ComposedModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ComposedModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ComposedModal_default = ComposedModal;

// node_modules/carbon-components-svelte/src/ComposedModal/ModalHeader.svelte
var file40 = "node_modules/carbon-components-svelte/src/ComposedModal/ModalHeader.svelte";
function create_if_block_17(ctx) {
  let h2;
  let t;
  const block = {
    c: function create() {
      h2 = element("h2");
      t = text(
        /*label*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      h2 = claim_element(nodes, "H2", { class: true });
      var h2_nodes = children(h2);
      t = claim_text(
        h2_nodes,
        /*label*/
        ctx[1]
      );
      h2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        h2,
        "class",
        /*labelClass*/
        ctx[2]
      );
      toggle_class(h2, "bx--modal-header__label", true);
      toggle_class(h2, "bx--type-delta", true);
      add_location(h2, file40, 32, 4, 746);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h2, anchor);
      append_hydration_dev(h2, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*label*/
      2) set_data_dev(
        t,
        /*label*/
        ctx2[1]
      );
      if (dirty & /*labelClass*/
      4) {
        attr_dev(
          h2,
          "class",
          /*labelClass*/
          ctx2[2]
        );
      }
      if (dirty & /*labelClass*/
      4) {
        toggle_class(h2, "bx--modal-header__label", true);
      }
      if (dirty & /*labelClass*/
      4) {
        toggle_class(h2, "bx--type-delta", true);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(32:2) {#if label}",
    ctx
  });
  return block;
}
function create_if_block22(ctx) {
  let h3;
  let t;
  const block = {
    c: function create() {
      h3 = element("h3");
      t = text(
        /*title*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      h3 = claim_element(nodes, "H3", { class: true });
      var h3_nodes = children(h3);
      t = claim_text(
        h3_nodes,
        /*title*/
        ctx[0]
      );
      h3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        h3,
        "class",
        /*titleClass*/
        ctx[3]
      );
      toggle_class(h3, "bx--modal-header__heading", true);
      toggle_class(h3, "bx--type-beta", true);
      add_location(h3, file40, 41, 4, 914);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h3, anchor);
      append_hydration_dev(h3, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      1) set_data_dev(
        t,
        /*title*/
        ctx2[0]
      );
      if (dirty & /*titleClass*/
      8) {
        attr_dev(
          h3,
          "class",
          /*titleClass*/
          ctx2[3]
        );
      }
      if (dirty & /*titleClass*/
      8) {
        toggle_class(h3, "bx--modal-header__heading", true);
      }
      if (dirty & /*titleClass*/
      8) {
        toggle_class(h3, "bx--type-beta", true);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h3);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(41:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment41(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let button;
  let close;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*label*/
    ctx[1] && create_if_block_17(ctx)
  );
  let if_block1 = (
    /*title*/
    ctx[0] && create_if_block22(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  close = new Close_default({
    props: {
      size: 20,
      class: "bx--modal-close__icon " + /*closeIconClass*/
      ctx[5],
      "aria-hidden": "true"
    },
    $$inline: true
  });
  let div_levels = [
    /*$$restProps*/
    ctx[8]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (default_slot) default_slot.c();
      t2 = space();
      button = element("button");
      create_component(close.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block0) if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1) if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (default_slot) default_slot.l(div_nodes);
      t2 = claim_space(div_nodes);
      button = claim_element(div_nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button_nodes = children(button);
      claim_component(close.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "aria-label",
        /*iconDescription*/
        ctx[6]
      );
      attr_dev(
        button,
        "class",
        /*closeClass*/
        ctx[4]
      );
      toggle_class(button, "bx--modal-close", true);
      add_location(button, file40, 50, 2, 1078);
      set_attributes(div, div_data);
      toggle_class(div, "bx--modal-header", true);
      add_location(div, file40, 30, 0, 673);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if (if_block1) if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(div, t2);
      append_hydration_dev(div, button);
      mount_component(close, button, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*closeModal*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*label*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_17(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*title*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block22(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      const close_changes = {};
      if (dirty & /*closeIconClass*/
      32) close_changes.class = "bx--modal-close__icon " + /*closeIconClass*/
      ctx2[5];
      close.$set(close_changes);
      if (!current || dirty & /*iconDescription*/
      64) {
        attr_dev(
          button,
          "aria-label",
          /*iconDescription*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*closeClass*/
      16) {
        attr_dev(
          button,
          "class",
          /*closeClass*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*closeClass*/
      16) {
        toggle_class(button, "bx--modal-close", true);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      256 && /*$$restProps*/
      ctx2[8]]));
      toggle_class(div, "bx--modal-header", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (default_slot) default_slot.d(detaching);
      destroy_component(close);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "title",
    "label",
    "labelClass",
    "titleClass",
    "closeClass",
    "closeIconClass",
    "iconDescription"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalHeader", slots, ["default"]);
  let { title = "" } = $$props;
  let { label = "" } = $$props;
  let { labelClass = "" } = $$props;
  let { titleClass = "" } = $$props;
  let { closeClass = "" } = $$props;
  let { closeIconClass = "" } = $$props;
  let { iconDescription = "Close" } = $$props;
  const { closeModal, updateLabel } = getContext("ComposedModal");
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("title" in $$new_props) $$invalidate(0, title = $$new_props.title);
    if ("label" in $$new_props) $$invalidate(1, label = $$new_props.label);
    if ("labelClass" in $$new_props) $$invalidate(2, labelClass = $$new_props.labelClass);
    if ("titleClass" in $$new_props) $$invalidate(3, titleClass = $$new_props.titleClass);
    if ("closeClass" in $$new_props) $$invalidate(4, closeClass = $$new_props.closeClass);
    if ("closeIconClass" in $$new_props) $$invalidate(5, closeIconClass = $$new_props.closeIconClass);
    if ("iconDescription" in $$new_props) $$invalidate(6, iconDescription = $$new_props.iconDescription);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    title,
    label,
    labelClass,
    titleClass,
    closeClass,
    closeIconClass,
    iconDescription,
    getContext,
    Close: Close_default,
    closeModal,
    updateLabel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("title" in $$props) $$invalidate(0, title = $$new_props.title);
    if ("label" in $$props) $$invalidate(1, label = $$new_props.label);
    if ("labelClass" in $$props) $$invalidate(2, labelClass = $$new_props.labelClass);
    if ("titleClass" in $$props) $$invalidate(3, titleClass = $$new_props.titleClass);
    if ("closeClass" in $$props) $$invalidate(4, closeClass = $$new_props.closeClass);
    if ("closeIconClass" in $$props) $$invalidate(5, closeIconClass = $$new_props.closeIconClass);
    if ("iconDescription" in $$props) $$invalidate(6, iconDescription = $$new_props.iconDescription);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*label*/
    2) {
      $: updateLabel(label);
    }
  };
  return [
    title,
    label,
    labelClass,
    titleClass,
    closeClass,
    closeIconClass,
    iconDescription,
    closeModal,
    $$restProps,
    $$scope,
    slots,
    click_handler
  ];
}
var ModalHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, {
      title: 0,
      label: 1,
      labelClass: 2,
      titleClass: 3,
      closeClass: 4,
      closeIconClass: 5,
      iconDescription: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalHeader",
      options,
      id: create_fragment41.name
    });
  }
  get title() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelClass() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelClass(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleClass() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleClass(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeClass() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeClass(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeIconClass() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeIconClass(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalHeader_default = ModalHeader;

// node_modules/carbon-components-svelte/src/ComposedModal/ModalBody.svelte
var file41 = "node_modules/carbon-components-svelte/src/ComposedModal/ModalBody.svelte";
function create_if_block23(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--modal-content--overflow-indicator", true);
      add_location(div, file41, 20, 2, 590);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(20:0) {#if hasScrollingContent}",
    ctx
  });
  return block;
}
function create_fragment42(ctx) {
  let div;
  let div_tabindex_value;
  let div_role_value;
  let t;
  let if_block_anchor;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    {
      tabindex: div_tabindex_value = /*hasScrollingContent*/
      ctx[1] ? "0" : void 0
    },
    {
      role: div_role_value = /*hasScrollingContent*/
      ctx[1] ? "region" : void 0
    },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  let if_block = (
    /*hasScrollingContent*/
    ctx[1] && create_if_block23(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      t = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { tabindex: true, role: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--modal-content", true);
      toggle_class(
        div,
        "bx--modal-content--with-form",
        /*hasForm*/
        ctx[0]
      );
      toggle_class(
        div,
        "bx--modal-scroll-content",
        /*hasScrollingContent*/
        ctx[1]
      );
      add_location(div, file41, 9, 0, 270);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      insert_hydration_dev(target, t, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*hasScrollingContent*/
        2 && div_tabindex_value !== (div_tabindex_value = /*hasScrollingContent*/
        ctx2[1] ? "0" : void 0)) && { tabindex: div_tabindex_value },
        (!current || dirty & /*hasScrollingContent*/
        2 && div_role_value !== (div_role_value = /*hasScrollingContent*/
        ctx2[1] ? "region" : void 0)) && { role: div_role_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      toggle_class(div, "bx--modal-content", true);
      toggle_class(
        div,
        "bx--modal-content--with-form",
        /*hasForm*/
        ctx2[0]
      );
      toggle_class(
        div,
        "bx--modal-scroll-content",
        /*hasScrollingContent*/
        ctx2[1]
      );
      if (
        /*hasScrollingContent*/
        ctx2[1]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block23(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      if (default_slot) default_slot.d(detaching);
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  const omit_props_names = ["hasForm", "hasScrollingContent"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalBody", slots, ["default"]);
  let { hasForm = false } = $$props;
  let { hasScrollingContent = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("hasForm" in $$new_props) $$invalidate(0, hasForm = $$new_props.hasForm);
    if ("hasScrollingContent" in $$new_props) $$invalidate(1, hasScrollingContent = $$new_props.hasScrollingContent);
    if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ hasForm, hasScrollingContent });
  $$self.$inject_state = ($$new_props) => {
    if ("hasForm" in $$props) $$invalidate(0, hasForm = $$new_props.hasForm);
    if ("hasScrollingContent" in $$props) $$invalidate(1, hasScrollingContent = $$new_props.hasScrollingContent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [hasForm, hasScrollingContent, $$restProps, $$scope, slots];
}
var ModalBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, { hasForm: 0, hasScrollingContent: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalBody",
      options,
      id: create_fragment42.name
    });
  }
  get hasForm() {
    throw new Error("<ModalBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasForm(value) {
    throw new Error("<ModalBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasScrollingContent() {
    throw new Error("<ModalBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasScrollingContent(value) {
    throw new Error("<ModalBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalBody_default = ModalBody;

// node_modules/carbon-components-svelte/src/ComposedModal/ModalFooter.svelte
var file42 = "node_modules/carbon-components-svelte/src/ComposedModal/ModalFooter.svelte";
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function create_if_block_25(ctx) {
  let button_1;
  let current;
  button_1 = new Button_default({
    props: {
      kind: "secondary",
      class: (
        /*secondaryClass*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button_1.$on(
    "click",
    /*click_handler_1*/
    ctx[14]
  );
  const block = {
    c: function create() {
      create_component(button_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_1_changes = {};
      if (dirty & /*secondaryClass*/
      64) button_1_changes.class = /*secondaryClass*/
      ctx2[6];
      if (dirty & /*$$scope, secondaryButtonText*/
      32784) {
        button_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button_1.$set(button_1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(button_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(66:32) ",
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*secondaryButtons*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*dispatch, secondaryButtons*/
      288) {
        each_value = ensure_array_like_dev(
          /*secondaryButtons*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(55:2) {#if secondaryButtons.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*secondaryButtonText*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*secondaryButtonText*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*secondaryButtonText*/
      16) set_data_dev(
        t,
        /*secondaryButtonText*/
        ctx2[4]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: `(67:4) <Button       kind=\\"secondary\\"       class=\\"{secondaryClass}\\"       on:click=\\"{() => {         closeModal();         dispatch('click:button--secondary', { text: secondaryButtonText });       }}\\"     >`,
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let t0_value = (
    /*button*/
    ctx[16].text + ""
  );
  let t0;
  let t1;
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*secondaryButtons*/
      32 && t0_value !== (t0_value = /*button*/
      ctx2[16].text + "")) set_data_dev(t0, t0_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: `(57:6) <Button         kind=\\"secondary\\"         on:click=\\"{() => {           dispatch('click:button--secondary', { text: button.text });         }}\\"       >`,
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let button_1;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[13](
        /*button*/
        ctx[16]
      )
    );
  }
  button_1 = new Button_default({
    props: {
      kind: "secondary",
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button_1.$on("click", click_handler);
  const block = {
    c: function create() {
      create_component(button_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button_1, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const button_1_changes = {};
      if (dirty & /*$$scope, secondaryButtons*/
      32800) {
        button_1_changes.$$scope = { dirty, ctx };
      }
      button_1.$set(button_1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(button_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(56:4) {#each secondaryButtons as button}",
    ctx
  });
  return block;
}
function create_if_block24(ctx) {
  let button_1;
  let current;
  button_1 = new Button_default({
    props: {
      kind: (
        /*danger*/
        ctx[7] ? "danger" : "primary"
      ),
      disabled: (
        /*primaryButtonDisabled*/
        ctx[2]
      ),
      class: (
        /*primaryClass*/
        ctx[3]
      ),
      icon: (
        /*primaryButtonIcon*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button_1.$on(
    "click",
    /*submit*/
    ctx[10]
  );
  const block = {
    c: function create() {
      create_component(button_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_1_changes = {};
      if (dirty & /*danger*/
      128) button_1_changes.kind = /*danger*/
      ctx2[7] ? "danger" : "primary";
      if (dirty & /*primaryButtonDisabled*/
      4) button_1_changes.disabled = /*primaryButtonDisabled*/
      ctx2[2];
      if (dirty & /*primaryClass*/
      8) button_1_changes.class = /*primaryClass*/
      ctx2[3];
      if (dirty & /*primaryButtonIcon*/
      2) button_1_changes.icon = /*primaryButtonIcon*/
      ctx2[1];
      if (dirty & /*$$scope, primaryButtonText*/
      32769) {
        button_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button_1.$set(button_1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(button_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(78:2) {#if primaryButtonText}",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*primaryButtonText*/
        ctx[0]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*primaryButtonText*/
        ctx[0]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*primaryButtonText*/
      1) set_data_dev(
        t,
        /*primaryButtonText*/
        ctx2[0]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: `(79:4) <Button       kind=\\"{danger ? 'danger' : 'primary'}\\"       disabled=\\"{primaryButtonDisabled}\\"       class=\\"{primaryClass}\\"       icon=\\"{primaryButtonIcon}\\"       on:click=\\"{submit}\\"     >`,
    ctx
  });
  return block;
}
function create_fragment43(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let current;
  const if_block_creators = [create_if_block_18, create_if_block_25];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*secondaryButtons*/
      ctx2[5].length > 0
    ) return 0;
    if (
      /*secondaryButtonText*/
      ctx2[4]
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = (
    /*primaryButtonText*/
    ctx[0] && create_if_block24(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[11]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block0) if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1) if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--modal-footer", true);
      toggle_class(
        div,
        "bx--modal-footer--three-button",
        /*secondaryButtons*/
        ctx[5].length === 2
      );
      add_location(div, file42, 49, 0, 1243);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append_hydration_dev(div, t0);
      if (if_block1) if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        } else {
          if_block0 = null;
        }
      }
      if (
        /*primaryButtonText*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*primaryButtonText*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block24(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      2048 && /*$$restProps*/
      ctx2[11]]));
      toggle_class(div, "bx--modal-footer", true);
      toggle_class(
        div,
        "bx--modal-footer--three-button",
        /*secondaryButtons*/
        ctx2[5].length === 2
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block1) if_block1.d();
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "primaryButtonText",
    "primaryButtonIcon",
    "primaryButtonDisabled",
    "primaryClass",
    "secondaryButtonText",
    "secondaryButtons",
    "secondaryClass",
    "danger"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalFooter", slots, ["default"]);
  let { primaryButtonText = "" } = $$props;
  let { primaryButtonIcon = void 0 } = $$props;
  let { primaryButtonDisabled = false } = $$props;
  let { primaryClass = void 0 } = $$props;
  let { secondaryButtonText = "" } = $$props;
  let { secondaryButtons = [] } = $$props;
  let { secondaryClass = void 0 } = $$props;
  let { danger = false } = $$props;
  const dispatch = createEventDispatcher();
  const { closeModal, submit } = getContext("ComposedModal");
  const click_handler = (button) => {
    dispatch("click:button--secondary", { text: button.text });
  };
  const click_handler_13 = () => {
    closeModal();
    dispatch("click:button--secondary", { text: secondaryButtonText });
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("primaryButtonText" in $$new_props) $$invalidate(0, primaryButtonText = $$new_props.primaryButtonText);
    if ("primaryButtonIcon" in $$new_props) $$invalidate(1, primaryButtonIcon = $$new_props.primaryButtonIcon);
    if ("primaryButtonDisabled" in $$new_props) $$invalidate(2, primaryButtonDisabled = $$new_props.primaryButtonDisabled);
    if ("primaryClass" in $$new_props) $$invalidate(3, primaryClass = $$new_props.primaryClass);
    if ("secondaryButtonText" in $$new_props) $$invalidate(4, secondaryButtonText = $$new_props.secondaryButtonText);
    if ("secondaryButtons" in $$new_props) $$invalidate(5, secondaryButtons = $$new_props.secondaryButtons);
    if ("secondaryClass" in $$new_props) $$invalidate(6, secondaryClass = $$new_props.secondaryClass);
    if ("danger" in $$new_props) $$invalidate(7, danger = $$new_props.danger);
    if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    primaryButtonText,
    primaryButtonIcon,
    primaryButtonDisabled,
    primaryClass,
    secondaryButtonText,
    secondaryButtons,
    secondaryClass,
    danger,
    getContext,
    createEventDispatcher,
    Button: Button_default,
    dispatch,
    closeModal,
    submit
  });
  $$self.$inject_state = ($$new_props) => {
    if ("primaryButtonText" in $$props) $$invalidate(0, primaryButtonText = $$new_props.primaryButtonText);
    if ("primaryButtonIcon" in $$props) $$invalidate(1, primaryButtonIcon = $$new_props.primaryButtonIcon);
    if ("primaryButtonDisabled" in $$props) $$invalidate(2, primaryButtonDisabled = $$new_props.primaryButtonDisabled);
    if ("primaryClass" in $$props) $$invalidate(3, primaryClass = $$new_props.primaryClass);
    if ("secondaryButtonText" in $$props) $$invalidate(4, secondaryButtonText = $$new_props.secondaryButtonText);
    if ("secondaryButtons" in $$props) $$invalidate(5, secondaryButtons = $$new_props.secondaryButtons);
    if ("secondaryClass" in $$props) $$invalidate(6, secondaryClass = $$new_props.secondaryClass);
    if ("danger" in $$props) $$invalidate(7, danger = $$new_props.danger);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    primaryButtonText,
    primaryButtonIcon,
    primaryButtonDisabled,
    primaryClass,
    secondaryButtonText,
    secondaryButtons,
    secondaryClass,
    danger,
    dispatch,
    closeModal,
    submit,
    $$restProps,
    slots,
    click_handler,
    click_handler_13,
    $$scope
  ];
}
var ModalFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, {
      primaryButtonText: 0,
      primaryButtonIcon: 1,
      primaryButtonDisabled: 2,
      primaryClass: 3,
      secondaryButtonText: 4,
      secondaryButtons: 5,
      secondaryClass: 6,
      danger: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalFooter",
      options,
      id: create_fragment43.name
    });
  }
  get primaryButtonText() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryButtonText(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryButtonIcon() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryButtonIcon(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryButtonDisabled() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryButtonDisabled(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryClass() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryClass(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryButtonText() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryButtonText(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryButtons() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryButtons(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryClass() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryClass(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get danger() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set danger(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalFooter_default = ModalFooter;

// node_modules/carbon-components-svelte/src/CodeSnippet/CodeSnippetSkeleton.svelte
var file43 = "node_modules/carbon-components-svelte/src/CodeSnippet/CodeSnippetSkeleton.svelte";
function create_if_block_19(ctx) {
  let span0;
  let t0;
  let span1;
  let t1;
  let span2;
  const block = {
    c: function create() {
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = space();
      span2 = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", {});
      children(span0).forEach(detach_dev);
      t0 = claim_space(nodes);
      span1 = claim_element(nodes, "SPAN", {});
      children(span1).forEach(detach_dev);
      t1 = claim_space(nodes);
      span2 = claim_element(nodes, "SPAN", {});
      children(span2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span0, file43, 24, 31, 609);
      add_location(span1, file43, 24, 45, 623);
      add_location(span2, file43, 24, 59, 637);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, span1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, span2, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span0);
        detach_dev(t0);
        detach_dev(span1);
        detach_dev(t1);
        detach_dev(span2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(25:31) ",
    ctx
  });
  return block;
}
function create_if_block25(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file43, 23, 6, 564);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block25.name,
    type: "if",
    source: '(23:4) {#if type === \\"single\\"}',
    ctx
  });
  return block;
}
function create_fragment44(ctx) {
  let div1;
  let div0;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*type*/
      ctx2[0] === "single"
    ) return create_if_block25;
    if (
      /*type*/
      ctx2[0] === "multi"
    ) return create_if_block_19;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  let div1_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (if_block) if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--snippet-container", true);
      add_location(div0, file43, 21, 2, 487);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--skeleton", true);
      toggle_class(div1, "bx--snippet", true);
      toggle_class(
        div1,
        "bx--snippet--single",
        /*type*/
        ctx[0] === "single"
      );
      toggle_class(
        div1,
        "bx--snippet--multi",
        /*type*/
        ctx[0] === "multi"
      );
      add_location(div1, file43, 10, 0, 244);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (if_block) if_block.m(div0, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseover",
            /*mouseover_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if (if_block) if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div0, null);
        }
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(div1, "bx--skeleton", true);
      toggle_class(div1, "bx--snippet", true);
      toggle_class(
        div1,
        "bx--snippet--single",
        /*type*/
        ctx2[0] === "single"
      );
      toggle_class(
        div1,
        "bx--snippet--multi",
        /*type*/
        ctx2[0] === "multi"
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block) {
        if_block.d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  const omit_props_names = ["type"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodeSnippetSkeleton", slots, []);
  let { type = "single" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props) $$invalidate(0, type = $$new_props.type);
  };
  $$self.$capture_state = () => ({ type });
  $$self.$inject_state = ($$new_props) => {
    if ("type" in $$props) $$invalidate(0, type = $$new_props.type);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    type,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var CodeSnippetSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, { type: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeSnippetSkeleton",
      options,
      id: create_fragment44.name
    });
  }
  get type() {
    throw new Error("<CodeSnippetSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<CodeSnippetSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeSnippetSkeleton_default = CodeSnippetSkeleton;

// node_modules/carbon-components-svelte/src/CodeSnippet/CodeSnippet.svelte
var file44 = "node_modules/carbon-components-svelte/src/CodeSnippet/CodeSnippet.svelte";
function create_else_block_1(ctx) {
  let div1;
  let div0;
  let pre;
  let code_1;
  let div0_role_value;
  let div0_tabindex_value;
  let div0_aria_label_value;
  let style_min_height = `${/*minHeight*/
  ctx[19]}px`;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_22(ctx);
  let if_block0 = !/*hideCopyButton*/
  ctx[6] && create_if_block_43(ctx);
  let if_block1 = (
    /*showMoreLess*/
    ctx[1] && create_if_block_33(ctx)
  );
  let div1_levels = [
    /*$$restProps*/
    ctx[22]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      pre = element("pre");
      code_1 = element("code");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        role: true,
        tabindex: true,
        "aria-label": true
      });
      var div0_nodes = children(div0);
      pre = claim_element(div0_nodes, "PRE", {});
      var pre_nodes = children(pre);
      code_1 = claim_element(pre_nodes, "CODE", {});
      var code_1_nodes = children(code_1);
      if (default_slot_or_fallback) default_slot_or_fallback.l(code_1_nodes);
      code_1_nodes.forEach(detach_dev);
      pre_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      if (if_block0) if_block0.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      if (if_block1) if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(code_1, file44, 246, 29, 6991);
      add_location(pre, file44, 246, 6, 6968);
      attr_dev(div0, "role", div0_role_value = /*type*/
      ctx[3] === "single" ? "textbox" : void 0);
      attr_dev(div0, "tabindex", div0_tabindex_value = /*type*/
      ctx[3] === "single" && !/*disabled*/
      ctx[7] ? "0" : void 0);
      attr_dev(div0, "aria-label", div0_aria_label_value = /*$$restProps*/
      ctx[22]["aria-label"] || /*copyLabel*/
      ctx[12] || "code-snippet");
      toggle_class(div0, "bx--snippet-container", true);
      set_style(div0, "width", `100%`);
      set_style(div0, "min-height", style_min_height);
      set_style(
        div0,
        "max-height",
        /*maxHeight*/
        ctx[18]
      );
      add_location(div0, file44, 237, 4, 6604);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--snippet", true);
      toggle_class(
        div1,
        "bx--snippet--expand",
        /*expanded*/
        ctx[0]
      );
      toggle_class(
        div1,
        "bx--snippet--light",
        /*light*/
        ctx[9]
      );
      toggle_class(
        div1,
        "bx--snippet--no-copy",
        /*hideCopyButton*/
        ctx[6]
      );
      toggle_class(
        div1,
        "bx--snippet--wraptext",
        /*wrapText*/
        ctx[8]
      );
      toggle_class(
        div1,
        "bx--snippet--single",
        /*type*/
        ctx[3] === "single"
      );
      toggle_class(
        div1,
        "bx--snippet--inline",
        /*type*/
        ctx[3] === "inline"
      );
      toggle_class(
        div1,
        "bx--snippet--multi",
        /*type*/
        ctx[3] === "multi"
      );
      toggle_class(
        div1,
        "bx--snippet--disabled",
        /*type*/
        ctx[3] !== "inline" && /*disabled*/
        ctx[7]
      );
      add_location(div1, file44, 221, 2, 6030);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, pre);
      append_hydration_dev(pre, code_1);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(code_1, null);
      }
      ctx[39](pre);
      append_hydration_dev(div1, t0);
      if (if_block0) if_block0.m(div1, null);
      append_hydration_dev(div1, t1);
      if (if_block1) if_block1.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "mouseover",
            /*mouseover_handler_2*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler_2*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler_2*/
            ctx[32],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*code*/
        16)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*type*/
      8 && div0_role_value !== (div0_role_value = /*type*/
      ctx2[3] === "single" ? "textbox" : void 0)) {
        attr_dev(div0, "role", div0_role_value);
      }
      if (!current || dirty[0] & /*type, disabled*/
      136 && div0_tabindex_value !== (div0_tabindex_value = /*type*/
      ctx2[3] === "single" && !/*disabled*/
      ctx2[7] ? "0" : void 0)) {
        attr_dev(div0, "tabindex", div0_tabindex_value);
      }
      if (!current || dirty[0] & /*$$restProps, copyLabel*/
      4198400 && div0_aria_label_value !== (div0_aria_label_value = /*$$restProps*/
      ctx2[22]["aria-label"] || /*copyLabel*/
      ctx2[12] || "code-snippet")) {
        attr_dev(div0, "aria-label", div0_aria_label_value);
      }
      if (dirty[0] & /*minHeight*/
      524288 && style_min_height !== (style_min_height = `${/*minHeight*/
      ctx2[19]}px`)) {
        set_style(div0, "min-height", style_min_height);
      }
      if (dirty[0] & /*maxHeight*/
      262144) {
        set_style(
          div0,
          "max-height",
          /*maxHeight*/
          ctx2[18]
        );
      }
      if (!/*hideCopyButton*/
      ctx2[6]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*hideCopyButton*/
          64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_43(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*showMoreLess*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*showMoreLess*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_33(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty[0] & /*$$restProps*/
      4194304 && /*$$restProps*/
      ctx2[22]]));
      toggle_class(div1, "bx--snippet", true);
      toggle_class(
        div1,
        "bx--snippet--expand",
        /*expanded*/
        ctx2[0]
      );
      toggle_class(
        div1,
        "bx--snippet--light",
        /*light*/
        ctx2[9]
      );
      toggle_class(
        div1,
        "bx--snippet--no-copy",
        /*hideCopyButton*/
        ctx2[6]
      );
      toggle_class(
        div1,
        "bx--snippet--wraptext",
        /*wrapText*/
        ctx2[8]
      );
      toggle_class(
        div1,
        "bx--snippet--single",
        /*type*/
        ctx2[3] === "single"
      );
      toggle_class(
        div1,
        "bx--snippet--inline",
        /*type*/
        ctx2[3] === "inline"
      );
      toggle_class(
        div1,
        "bx--snippet--multi",
        /*type*/
        ctx2[3] === "multi"
      );
      toggle_class(
        div1,
        "bx--snippet--disabled",
        /*type*/
        ctx2[3] !== "inline" && /*disabled*/
        ctx2[7]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      ctx[39](null);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(220:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_26, create_else_block11];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*hideCopyButton*/
      ctx2[6]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(156:28) ",
    ctx
  });
  return block;
}
function create_if_block26(ctx) {
  let codesnippetskeleton;
  let current;
  const codesnippetskeleton_spread_levels = [
    { type: (
      /*type*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[22]
  ];
  let codesnippetskeleton_props = {};
  for (let i = 0; i < codesnippetskeleton_spread_levels.length; i += 1) {
    codesnippetskeleton_props = assign(codesnippetskeleton_props, codesnippetskeleton_spread_levels[i]);
  }
  codesnippetskeleton = new CodeSnippetSkeleton_default({
    props: codesnippetskeleton_props,
    $$inline: true
  });
  codesnippetskeleton.$on(
    "click",
    /*click_handler*/
    ctx[33]
  );
  codesnippetskeleton.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[34]
  );
  codesnippetskeleton.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx[35]
  );
  codesnippetskeleton.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx[36]
  );
  const block = {
    c: function create() {
      create_component(codesnippetskeleton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(codesnippetskeleton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(codesnippetskeleton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const codesnippetskeleton_changes = dirty[0] & /*type, $$restProps*/
      4194312 ? get_spread_update(codesnippetskeleton_spread_levels, [
        dirty[0] & /*type*/
        8 && { type: (
          /*type*/
          ctx2[3]
        ) },
        dirty[0] & /*$$restProps*/
        4194304 && get_spread_object(
          /*$$restProps*/
          ctx2[22]
        )
      ]) : {};
      codesnippetskeleton.$set(codesnippetskeleton_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(codesnippetskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(codesnippetskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(codesnippetskeleton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block26.name,
    type: "if",
    source: "(147:0) {#if skeleton}",
    ctx
  });
  return block;
}
function fallback_block_22(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*code*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*code*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*code*/
      16) set_data_dev(
        t,
        /*code*/
        ctx2[4]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_22.name,
    type: "fallback",
    source: "(247:41) {code}",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let copybutton;
  let current;
  copybutton = new CopyButton_default({
    props: {
      text: (
        /*code*/
        ctx[4]
      ),
      copy: (
        /*copy*/
        ctx[5]
      ),
      disabled: (
        /*disabled*/
        ctx[7]
      ),
      feedback: (
        /*feedback*/
        ctx[13]
      ),
      feedbackTimeout: (
        /*feedbackTimeout*/
        ctx[14]
      ),
      iconDescription: (
        /*copyButtonDescription*/
        ctx[11]
      )
    },
    $$inline: true
  });
  copybutton.$on(
    "click",
    /*click_handler_2*/
    ctx[40]
  );
  copybutton.$on(
    "copy",
    /*copy_handler*/
    ctx[41]
  );
  copybutton.$on(
    "animationend",
    /*animationend_handler*/
    ctx[42]
  );
  const block = {
    c: function create() {
      create_component(copybutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(copybutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(copybutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const copybutton_changes = {};
      if (dirty[0] & /*code*/
      16) copybutton_changes.text = /*code*/
      ctx2[4];
      if (dirty[0] & /*copy*/
      32) copybutton_changes.copy = /*copy*/
      ctx2[5];
      if (dirty[0] & /*disabled*/
      128) copybutton_changes.disabled = /*disabled*/
      ctx2[7];
      if (dirty[0] & /*feedback*/
      8192) copybutton_changes.feedback = /*feedback*/
      ctx2[13];
      if (dirty[0] & /*feedbackTimeout*/
      16384) copybutton_changes.feedbackTimeout = /*feedbackTimeout*/
      ctx2[14];
      if (dirty[0] & /*copyButtonDescription*/
      2048) copybutton_changes.iconDescription = /*copyButtonDescription*/
      ctx2[11];
      copybutton.$set(copybutton_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(copybutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(copybutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(copybutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(249:4) {#if !hideCopyButton}",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      kind: "ghost",
      size: "small",
      class: "bx--snippet-btn--expand",
      disabled: (
        /*disabled*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on(
    "click",
    /*click_handler_4*/
    ctx[43]
  );
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty[0] & /*disabled*/
      128) button_changes.disabled = /*disabled*/
      ctx2[7];
      if (dirty[0] & /*expandText*/
      1048576 | dirty[1] & /*$$scope*/
      8192) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(262:4) {#if showMoreLess}",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let span;
  let t0;
  let t1;
  let chevrondown;
  let current;
  chevrondown = new ChevronDown_default({
    props: {
      class: "bx--icon-chevron--down bx--snippet__icon",
      "aria-label": (
        /*expandText*/
        ctx[20]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span = element("span");
      t0 = text(
        /*expandText*/
        ctx[20]
      );
      t1 = space();
      create_component(chevrondown.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*expandText*/
        ctx[20]
      );
      span_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      claim_component(chevrondown.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--snippet-btn--text", true);
      add_location(span, file44, 271, 8, 7595);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      insert_hydration_dev(target, t1, anchor);
      mount_component(chevrondown, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*expandText*/
      1048576) set_data_dev(
        t0,
        /*expandText*/
        ctx2[20]
      );
      const chevrondown_changes = {};
      if (dirty[0] & /*expandText*/
      1048576) chevrondown_changes["aria-label"] = /*expandText*/
      ctx2[20];
      chevrondown.$set(chevrondown_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(chevrondown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevrondown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
        detach_dev(t1);
      }
      destroy_component(chevrondown, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: '(263:6) <Button         kind=\\"ghost\\"         size=\\"small\\"         class=\\"bx--snippet-btn--expand\\"         disabled=\\"{disabled}\\"         on:click=\\"{() => {           expanded = !expanded;         }}\\"       >',
    ctx
  });
  return block;
}
function create_else_block11(ctx) {
  let button;
  let code_1;
  let t0;
  let span;
  let t1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_14(ctx);
  let button_levels = [
    { type: "button" },
    { "aria-live": "polite" },
    { "aria-label": (
      /*copyLabel*/
      ctx[12]
    ) },
    /*$$restProps*/
    ctx[22]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      code_1 = element("code");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      t0 = space();
      span = element("span");
      t1 = text(
        /*feedback*/
        ctx[13]
      );
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-live": true,
        "aria-label": true
      });
      var button_nodes = children(button);
      code_1 = claim_element(button_nodes, "CODE", { id: true });
      var code_1_nodes = children(code_1);
      if (default_slot_or_fallback) default_slot_or_fallback.l(code_1_nodes);
      code_1_nodes.forEach(detach_dev);
      t0 = claim_space(button_nodes);
      span = claim_element(button_nodes, "SPAN", { "aria-hidden": true });
      var span_nodes = children(span);
      t1 = claim_text(
        span_nodes,
        /*feedback*/
        ctx[13]
      );
      span_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        code_1,
        "id",
        /*id*/
        ctx[15]
      );
      add_location(code_1, file44, 207, 6, 5710);
      attr_dev(span, "aria-hidden", "true");
      toggle_class(span, "bx--assistive-text", true);
      toggle_class(span, "bx--copy-btn__feedback", true);
      add_location(span, file44, 210, 6, 5775);
      set_attributes(button, button_data);
      toggle_class(button, "bx--copy", true);
      toggle_class(button, "bx--btn--copy", true);
      toggle_class(
        button,
        "bx--copy-btn--animating",
        /*animation*/
        ctx[16]
      );
      toggle_class(
        button,
        "bx--copy-btn--fade-in",
        /*animation*/
        ctx[16] === "fade-in"
      );
      toggle_class(
        button,
        "bx--copy-btn--fade-out",
        /*animation*/
        ctx[16] === "fade-out"
      );
      toggle_class(button, "bx--snippet", true);
      toggle_class(
        button,
        "bx--snippet--inline",
        /*type*/
        ctx[3] === "inline"
      );
      toggle_class(
        button,
        "bx--snippet--expand",
        /*expanded*/
        ctx[0]
      );
      toggle_class(
        button,
        "bx--snippet--light",
        /*light*/
        ctx[9]
      );
      toggle_class(
        button,
        "bx--snippet--wraptext",
        /*wrapText*/
        ctx[8]
      );
      add_location(button, file44, 173, 4, 4648);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, code_1);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(code_1, null);
      }
      append_hydration_dev(button, t0);
      append_hydration_dev(button, span);
      append_hydration_dev(span, t1);
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler_1*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler_3*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "animationend",
            /*animationend_handler_1*/
            ctx[38],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseover",
            /*mouseover_handler_1*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseleave",
            /*mouseleave_handler_1*/
            ctx[29],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*code*/
        16)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      32768) {
        attr_dev(
          code_1,
          "id",
          /*id*/
          ctx2[15]
        );
      }
      if (!current || dirty[0] & /*feedback*/
      8192) set_data_dev(
        t1,
        /*feedback*/
        ctx2[13]
      );
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        { "aria-live": "polite" },
        (!current || dirty[0] & /*copyLabel*/
        4096) && { "aria-label": (
          /*copyLabel*/
          ctx2[12]
        ) },
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22]
      ]));
      toggle_class(button, "bx--copy", true);
      toggle_class(button, "bx--btn--copy", true);
      toggle_class(
        button,
        "bx--copy-btn--animating",
        /*animation*/
        ctx2[16]
      );
      toggle_class(
        button,
        "bx--copy-btn--fade-in",
        /*animation*/
        ctx2[16] === "fade-in"
      );
      toggle_class(
        button,
        "bx--copy-btn--fade-out",
        /*animation*/
        ctx2[16] === "fade-out"
      );
      toggle_class(button, "bx--snippet", true);
      toggle_class(
        button,
        "bx--snippet--inline",
        /*type*/
        ctx2[3] === "inline"
      );
      toggle_class(
        button,
        "bx--snippet--expand",
        /*expanded*/
        ctx2[0]
      );
      toggle_class(
        button,
        "bx--snippet--light",
        /*light*/
        ctx2[9]
      );
      toggle_class(
        button,
        "bx--snippet--wraptext",
        /*wrapText*/
        ctx2[8]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block11.name,
    type: "else",
    source: "(173:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_26(ctx) {
  let span;
  let code_1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block7(ctx);
  let span_levels = [
    /*$$restProps*/
    ctx[22]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      code_1 = element("code");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      code_1 = claim_element(span_nodes, "CODE", { id: true });
      var code_1_nodes = children(code_1);
      if (default_slot_or_fallback) default_slot_or_fallback.l(code_1_nodes);
      code_1_nodes.forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        code_1,
        "id",
        /*id*/
        ctx[15]
      );
      add_location(code_1, file44, 168, 6, 4563);
      set_attributes(span, span_data);
      toggle_class(span, "bx--snippet", true);
      toggle_class(
        span,
        "bx--snippet--expand",
        /*expanded*/
        ctx[0]
      );
      toggle_class(
        span,
        "bx--snippet--light",
        /*light*/
        ctx[9]
      );
      toggle_class(
        span,
        "bx--snippet--no-copy",
        /*hideCopyButton*/
        ctx[6]
      );
      toggle_class(
        span,
        "bx--snippet--wraptext",
        /*wrapText*/
        ctx[8]
      );
      toggle_class(
        span,
        "bx--snippet--single",
        /*type*/
        ctx[3] === "single"
      );
      toggle_class(
        span,
        "bx--snippet--inline",
        /*type*/
        ctx[3] === "inline"
      );
      toggle_class(
        span,
        "bx--snippet--multi",
        /*type*/
        ctx[3] === "multi"
      );
      add_location(span, file44, 157, 4, 4144);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, code_1);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(code_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*code*/
        16)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      32768) {
        attr_dev(
          code_1,
          "id",
          /*id*/
          ctx2[15]
        );
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [dirty[0] & /*$$restProps*/
      4194304 && /*$$restProps*/
      ctx2[22]]));
      toggle_class(span, "bx--snippet", true);
      toggle_class(
        span,
        "bx--snippet--expand",
        /*expanded*/
        ctx2[0]
      );
      toggle_class(
        span,
        "bx--snippet--light",
        /*light*/
        ctx2[9]
      );
      toggle_class(
        span,
        "bx--snippet--no-copy",
        /*hideCopyButton*/
        ctx2[6]
      );
      toggle_class(
        span,
        "bx--snippet--wraptext",
        /*wrapText*/
        ctx2[8]
      );
      toggle_class(
        span,
        "bx--snippet--single",
        /*type*/
        ctx2[3] === "single"
      );
      toggle_class(
        span,
        "bx--snippet--inline",
        /*type*/
        ctx2[3] === "inline"
      );
      toggle_class(
        span,
        "bx--snippet--multi",
        /*type*/
        ctx2[3] === "multi"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(157:2) {#if hideCopyButton}",
    ctx
  });
  return block;
}
function fallback_block_14(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*code*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*code*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*code*/
      16) set_data_dev(
        t,
        /*code*/
        ctx2[4]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_14.name,
    type: "fallback",
    source: "(209:14) {code}",
    ctx
  });
  return block;
}
function fallback_block7(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*code*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*code*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*code*/
      16) set_data_dev(
        t,
        /*code*/
        ctx2[4]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block7.name,
    type: "fallback",
    source: "(170:14) {code}",
    ctx
  });
  return block;
}
function create_fragment45(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block26, create_if_block_110, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*skeleton*/
      ctx2[10]
    ) return 0;
    if (
      /*type*/
      ctx2[3] === "inline"
    ) return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  let expandText;
  let minHeight;
  let maxHeight;
  const omit_props_names = [
    "type",
    "code",
    "copy",
    "expanded",
    "hideCopyButton",
    "disabled",
    "wrapText",
    "light",
    "skeleton",
    "copyButtonDescription",
    "copyLabel",
    "feedback",
    "feedbackTimeout",
    "showLessText",
    "showMoreText",
    "showMoreLess",
    "id",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodeSnippet", slots, ["default"]);
  let { type = "single" } = $$props;
  let { code = void 0 } = $$props;
  let { copy = async (code2) => {
    try {
      await navigator.clipboard.writeText(code2);
    } catch (e) {
      console.log(e);
    }
  } } = $$props;
  let { expanded = false } = $$props;
  let { hideCopyButton = false } = $$props;
  let { disabled = false } = $$props;
  let { wrapText = false } = $$props;
  let { light = false } = $$props;
  let { skeleton = false } = $$props;
  let { copyButtonDescription = void 0 } = $$props;
  let { copyLabel = void 0 } = $$props;
  let { feedback = "Copied!" } = $$props;
  let { feedbackTimeout = 2e3 } = $$props;
  let { showLessText = "Show less" } = $$props;
  let { showMoreText = "Show more" } = $$props;
  let { showMoreLess = true } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let animation = void 0;
  let timeout = void 0;
  function setShowMoreLess() {
    const { height } = ref.getBoundingClientRect();
    if (height > 0) $$invalidate(1, showMoreLess = ref.getBoundingClientRect().height > 255);
  }
  onMount(() => {
    return () => clearTimeout(timeout);
  });
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_3 = () => {
    copy(code);
    dispatch("copy");
    if (animation === "fade-in") return;
    $$invalidate(16, animation = "fade-in");
    $$invalidate(17, timeout = setTimeout(
      () => {
        $$invalidate(16, animation = "fade-out");
      },
      feedbackTimeout
    ));
  };
  const animationend_handler_1 = ({ animationName }) => {
    if (animationName === "hide-feedback") {
      $$invalidate(16, animation = void 0);
    }
  };
  function pre_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(2, ref);
    });
  }
  function click_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function copy_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function animationend_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_4 = () => {
    $$invalidate(0, expanded = !expanded);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
    if ("code" in $$new_props) $$invalidate(4, code = $$new_props.code);
    if ("copy" in $$new_props) $$invalidate(5, copy = $$new_props.copy);
    if ("expanded" in $$new_props) $$invalidate(0, expanded = $$new_props.expanded);
    if ("hideCopyButton" in $$new_props) $$invalidate(6, hideCopyButton = $$new_props.hideCopyButton);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("wrapText" in $$new_props) $$invalidate(8, wrapText = $$new_props.wrapText);
    if ("light" in $$new_props) $$invalidate(9, light = $$new_props.light);
    if ("skeleton" in $$new_props) $$invalidate(10, skeleton = $$new_props.skeleton);
    if ("copyButtonDescription" in $$new_props) $$invalidate(11, copyButtonDescription = $$new_props.copyButtonDescription);
    if ("copyLabel" in $$new_props) $$invalidate(12, copyLabel = $$new_props.copyLabel);
    if ("feedback" in $$new_props) $$invalidate(13, feedback = $$new_props.feedback);
    if ("feedbackTimeout" in $$new_props) $$invalidate(14, feedbackTimeout = $$new_props.feedbackTimeout);
    if ("showLessText" in $$new_props) $$invalidate(23, showLessText = $$new_props.showLessText);
    if ("showMoreText" in $$new_props) $$invalidate(24, showMoreText = $$new_props.showMoreText);
    if ("showMoreLess" in $$new_props) $$invalidate(1, showMoreLess = $$new_props.showMoreLess);
    if ("id" in $$new_props) $$invalidate(15, id = $$new_props.id);
    if ("ref" in $$new_props) $$invalidate(2, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(44, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    type,
    code,
    copy,
    expanded,
    hideCopyButton,
    disabled,
    wrapText,
    light,
    skeleton,
    copyButtonDescription,
    copyLabel,
    feedback,
    feedbackTimeout,
    showLessText,
    showMoreText,
    showMoreLess,
    id,
    ref,
    createEventDispatcher,
    tick,
    onMount,
    ChevronDown: ChevronDown_default,
    Button: Button_default,
    CopyButton: CopyButton_default,
    CodeSnippetSkeleton: CodeSnippetSkeleton_default,
    dispatch,
    animation,
    timeout,
    setShowMoreLess,
    maxHeight,
    minHeight,
    expandText
  });
  $$self.$inject_state = ($$new_props) => {
    if ("type" in $$props) $$invalidate(3, type = $$new_props.type);
    if ("code" in $$props) $$invalidate(4, code = $$new_props.code);
    if ("copy" in $$props) $$invalidate(5, copy = $$new_props.copy);
    if ("expanded" in $$props) $$invalidate(0, expanded = $$new_props.expanded);
    if ("hideCopyButton" in $$props) $$invalidate(6, hideCopyButton = $$new_props.hideCopyButton);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("wrapText" in $$props) $$invalidate(8, wrapText = $$new_props.wrapText);
    if ("light" in $$props) $$invalidate(9, light = $$new_props.light);
    if ("skeleton" in $$props) $$invalidate(10, skeleton = $$new_props.skeleton);
    if ("copyButtonDescription" in $$props) $$invalidate(11, copyButtonDescription = $$new_props.copyButtonDescription);
    if ("copyLabel" in $$props) $$invalidate(12, copyLabel = $$new_props.copyLabel);
    if ("feedback" in $$props) $$invalidate(13, feedback = $$new_props.feedback);
    if ("feedbackTimeout" in $$props) $$invalidate(14, feedbackTimeout = $$new_props.feedbackTimeout);
    if ("showLessText" in $$props) $$invalidate(23, showLessText = $$new_props.showLessText);
    if ("showMoreText" in $$props) $$invalidate(24, showMoreText = $$new_props.showMoreText);
    if ("showMoreLess" in $$props) $$invalidate(1, showMoreLess = $$new_props.showMoreLess);
    if ("id" in $$props) $$invalidate(15, id = $$new_props.id);
    if ("ref" in $$props) $$invalidate(2, ref = $$new_props.ref);
    if ("animation" in $$props) $$invalidate(16, animation = $$new_props.animation);
    if ("timeout" in $$props) $$invalidate(17, timeout = $$new_props.timeout);
    if ("maxHeight" in $$props) $$invalidate(18, maxHeight = $$new_props.maxHeight);
    if ("minHeight" in $$props) $$invalidate(19, minHeight = $$new_props.minHeight);
    if ("expandText" in $$props) $$invalidate(20, expandText = $$new_props.expandText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*expanded, showLessText, showMoreText*/
    25165825) {
      $: $$invalidate(20, expandText = expanded ? showLessText : showMoreText);
    }
    if ($$self.$$.dirty[0] & /*expanded*/
    1) {
      $: $$invalidate(19, minHeight = expanded ? 16 * 15 : 48);
    }
    if ($$self.$$.dirty[0] & /*expanded*/
    1) {
      $: $$invalidate(18, maxHeight = expanded ? "none" : 16 * 15 + "px");
    }
    if ($$self.$$.dirty[0] & /*type*/
    8) {
      $: if (type !== "multi") $$invalidate(1, showMoreLess = false);
    }
    if ($$self.$$.dirty[0] & /*type, ref, showMoreLess, code*/
    30) {
      $: if (type === "multi" && ref) {
        if (showMoreLess) {
          if (code === void 0) setShowMoreLess();
          if (code) tick().then(setShowMoreLess);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*type, expanded*/
    9) {
      $: if (type === "multi") dispatch(expanded ? "expand" : "collapse");
    }
  };
  return [
    expanded,
    showMoreLess,
    ref,
    type,
    code,
    copy,
    hideCopyButton,
    disabled,
    wrapText,
    light,
    skeleton,
    copyButtonDescription,
    copyLabel,
    feedback,
    feedbackTimeout,
    id,
    animation,
    timeout,
    maxHeight,
    minHeight,
    expandText,
    dispatch,
    $$restProps,
    showLessText,
    showMoreText,
    slots,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    mouseover_handler_2,
    mouseenter_handler_2,
    mouseleave_handler_2,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler_3,
    animationend_handler_1,
    pre_binding,
    click_handler_2,
    copy_handler,
    animationend_handler,
    click_handler_4,
    $$scope
  ];
}
var CodeSnippet = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance45,
      create_fragment45,
      safe_not_equal,
      {
        type: 3,
        code: 4,
        copy: 5,
        expanded: 0,
        hideCopyButton: 6,
        disabled: 7,
        wrapText: 8,
        light: 9,
        skeleton: 10,
        copyButtonDescription: 11,
        copyLabel: 12,
        feedback: 13,
        feedbackTimeout: 14,
        showLessText: 23,
        showMoreText: 24,
        showMoreLess: 1,
        id: 15,
        ref: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeSnippet",
      options,
      id: create_fragment45.name
    });
  }
  get type() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get code() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get copy() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set copy(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expanded() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideCopyButton() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideCopyButton(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapText() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapText(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skeleton() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skeleton(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get copyButtonDescription() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set copyButtonDescription(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get copyLabel() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set copyLabel(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get feedback() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set feedback(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get feedbackTimeout() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set feedbackTimeout(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLessText() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLessText(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showMoreText() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showMoreText(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showMoreLess() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showMoreLess(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeSnippet_default = CodeSnippet;

// node_modules/carbon-components-svelte/src/RadioButton/RadioButton.svelte
var file45 = "node_modules/carbon-components-svelte/src/RadioButton/RadioButton.svelte";
var get_labelText_slot_changes3 = (dirty) => ({});
var get_labelText_slot_context3 = (ctx) => ({});
function create_if_block27(ctx) {
  let span;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[20].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_labelText_slot_context3
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block8(ctx);
  const block = {
    c: function create() {
      span = element("span");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(
        span,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[7]
      );
      add_location(span, file45, 83, 6, 2032);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_labelText_slot_changes3
            ),
            get_labelText_slot_context3
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & /*labelText*/
        64)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*hideLabel*/
      128) {
        toggle_class(
          span,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[7]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block27.name,
    type: "if",
    source: "(83:4) {#if labelText || $$slots.labelText}",
    ctx
  });
  return block;
}
function fallback_block8(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[6]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[6]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelText*/
      64) set_data_dev(
        t,
        /*labelText*/
        ctx2[6]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block8.name,
    type: "fallback",
    source: "(85:31)            ",
    ctx
  });
  return block;
}
function create_fragment46(ctx) {
  let div;
  let input;
  let input_name_value;
  let input_required_value;
  let t0;
  let label;
  let span;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*labelText*/
    (ctx[6] || /*$$slots*/
    ctx[17].labelText) && create_if_block27(ctx)
  );
  let div_levels = [
    /*$$restProps*/
    ctx[16]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t0 = space();
      label = element("label");
      span = element("span");
      t1 = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", { type: true, id: true, name: true });
      t0 = claim_space(div_nodes);
      label = claim_element(div_nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      span = claim_element(label_nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      t1 = claim_space(label_nodes);
      if (if_block) if_block.l(label_nodes);
      label_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "radio");
      attr_dev(
        input,
        "id",
        /*id*/
        ctx[8]
      );
      attr_dev(input, "name", input_name_value = /*$groupName*/
      ctx[10] ?? /*name*/
      ctx[9]);
      input.checked = /*checked*/
      ctx[0];
      input.disabled = /*disabled*/
      ctx[3];
      input.required = input_required_value = /*$groupRequired*/
      ctx[11] ?? /*required*/
      ctx[4];
      input.value = /*value*/
      ctx[2];
      toggle_class(input, "bx--radio-button", true);
      add_location(input, file45, 63, 2, 1519);
      toggle_class(span, "bx--radio-button__appearance", true);
      add_location(span, file45, 81, 4, 1927);
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[8]
      );
      toggle_class(label, "bx--radio-button__label", true);
      add_location(label, file45, 80, 2, 1865);
      set_attributes(div, div_data);
      toggle_class(div, "bx--radio-button-wrapper", true);
      toggle_class(
        div,
        "bx--radio-button-wrapper--label-left",
        /*labelPosition*/
        ctx[5] === "left"
      );
      add_location(div, file45, 58, 0, 1375);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      ctx[22](input);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, label);
      append_hydration_dev(label, span);
      append_hydration_dev(label, t1);
      if (if_block) if_block.m(label, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_1*/
            ctx[23],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*id*/
      256) {
        attr_dev(
          input,
          "id",
          /*id*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*$groupName, name*/
      1536 && input_name_value !== (input_name_value = /*$groupName*/
      ctx2[10] ?? /*name*/
      ctx2[9])) {
        attr_dev(input, "name", input_name_value);
      }
      if (!current || dirty & /*checked*/
      1) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*disabled*/
      8) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*$groupRequired, required*/
      2064 && input_required_value !== (input_required_value = /*$groupRequired*/
      ctx2[11] ?? /*required*/
      ctx2[4])) {
        prop_dev(input, "required", input_required_value);
      }
      if (!current || dirty & /*value*/
      4) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[2]
        );
      }
      if (
        /*labelText*/
        ctx2[6] || /*$$slots*/
        ctx2[17].labelText
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*labelText, $$slots*/
          131136) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block27(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(label, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*id*/
      256) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[8]
        );
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      65536 && /*$$restProps*/
      ctx2[16]]));
      toggle_class(div, "bx--radio-button-wrapper", true);
      toggle_class(
        div,
        "bx--radio-button-wrapper--label-left",
        /*labelPosition*/
        ctx2[5] === "left"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[22](null);
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "value",
    "checked",
    "disabled",
    "required",
    "labelPosition",
    "labelText",
    "hideLabel",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedValue;
  let $groupName;
  let $groupRequired;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioButton", slots, ["labelText"]);
  const $$slots = compute_slots(slots);
  let { value = "" } = $$props;
  let { checked = false } = $$props;
  let { disabled = false } = $$props;
  let { required = false } = $$props;
  let { labelPosition = "right" } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  const { add, update, selectedValue, groupName, groupRequired } = getContext("RadioButtonGroup") ?? {
    groupName: readable(void 0),
    groupRequired: readable(void 0),
    selectedValue: readable(checked ? value : void 0)
  };
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value2) => $$invalidate(18, $selectedValue = value2));
  validate_store(groupName, "groupName");
  component_subscribe($$self, groupName, (value2) => $$invalidate(10, $groupName = value2));
  validate_store(groupRequired, "groupRequired");
  component_subscribe($$self, groupRequired, (value2) => $$invalidate(11, $groupRequired = value2));
  if (add) {
    add({ id, checked, disabled, value });
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const change_handler_1 = () => {
    if (update) {
      update(value);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(2, value = $$new_props.value);
    if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
    if ("required" in $$new_props) $$invalidate(4, required = $$new_props.required);
    if ("labelPosition" in $$new_props) $$invalidate(5, labelPosition = $$new_props.labelPosition);
    if ("labelText" in $$new_props) $$invalidate(6, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props) $$invalidate(7, hideLabel = $$new_props.hideLabel);
    if ("id" in $$new_props) $$invalidate(8, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(9, name = $$new_props.name);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    checked,
    disabled,
    required,
    labelPosition,
    labelText,
    hideLabel,
    id,
    name,
    ref,
    getContext,
    readable,
    add,
    update,
    selectedValue,
    groupName,
    groupRequired,
    $selectedValue,
    $groupName,
    $groupRequired
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(2, value = $$new_props.value);
    if ("checked" in $$props) $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$props) $$invalidate(3, disabled = $$new_props.disabled);
    if ("required" in $$props) $$invalidate(4, required = $$new_props.required);
    if ("labelPosition" in $$props) $$invalidate(5, labelPosition = $$new_props.labelPosition);
    if ("labelText" in $$props) $$invalidate(6, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props) $$invalidate(7, hideLabel = $$new_props.hideLabel);
    if ("id" in $$props) $$invalidate(8, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(9, name = $$new_props.name);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selectedValue, value*/
    262148) {
      $: $$invalidate(0, checked = $selectedValue === value);
    }
  };
  return [
    checked,
    ref,
    value,
    disabled,
    required,
    labelPosition,
    labelText,
    hideLabel,
    id,
    name,
    $groupName,
    $groupRequired,
    update,
    selectedValue,
    groupName,
    groupRequired,
    $$restProps,
    $$slots,
    $selectedValue,
    $$scope,
    slots,
    change_handler,
    input_binding,
    change_handler_1
  ];
}
var RadioButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, {
      value: 2,
      checked: 0,
      disabled: 3,
      required: 4,
      labelPosition: 5,
      labelText: 6,
      hideLabel: 7,
      id: 8,
      name: 9,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioButton",
      options,
      id: create_fragment46.name
    });
  }
  get value() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelPosition() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelPosition(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioButton_default = RadioButton;

// node_modules/carbon-components-svelte/src/DataTable/Table.svelte
var file46 = "node_modules/carbon-components-svelte/src/DataTable/Table.svelte";
function create_else_block12(ctx) {
  let table;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let table_levels = [
    /*$$restProps*/
    ctx[6],
    { style: (
      /*tableStyle*/
      ctx[5]
    ) }
  ];
  let table_data = {};
  for (let i = 0; i < table_levels.length; i += 1) {
    table_data = assign(table_data, table_levels[i]);
  }
  const block = {
    c: function create() {
      table = element("table");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", { style: true });
      var table_nodes = children(table);
      if (default_slot) default_slot.l(table_nodes);
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(table, table_data);
      toggle_class(table, "bx--data-table", true);
      toggle_class(
        table,
        "bx--data-table--compact",
        /*size*/
        ctx[0] === "compact"
      );
      toggle_class(
        table,
        "bx--data-table--short",
        /*size*/
        ctx[0] === "short"
      );
      toggle_class(
        table,
        "bx--data-table--tall",
        /*size*/
        ctx[0] === "tall"
      );
      toggle_class(
        table,
        "bx--data-table--md",
        /*size*/
        ctx[0] === "medium"
      );
      toggle_class(
        table,
        "bx--data-table--sort",
        /*sortable*/
        ctx[3]
      );
      toggle_class(
        table,
        "bx--data-table--zebra",
        /*zebra*/
        ctx[1]
      );
      toggle_class(
        table,
        "bx--data-table--static",
        /*useStaticWidth*/
        ctx[2]
      );
      toggle_class(
        table,
        "bx--data-table--sticky-header",
        /*stickyHeader*/
        ctx[4]
      );
      add_location(table, file46, 44, 2, 1235);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      if (default_slot) {
        default_slot.m(table, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(table, table_data = get_spread_update(table_levels, [
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*tableStyle*/
        32) && { style: (
          /*tableStyle*/
          ctx2[5]
        ) }
      ]));
      toggle_class(table, "bx--data-table", true);
      toggle_class(
        table,
        "bx--data-table--compact",
        /*size*/
        ctx2[0] === "compact"
      );
      toggle_class(
        table,
        "bx--data-table--short",
        /*size*/
        ctx2[0] === "short"
      );
      toggle_class(
        table,
        "bx--data-table--tall",
        /*size*/
        ctx2[0] === "tall"
      );
      toggle_class(
        table,
        "bx--data-table--md",
        /*size*/
        ctx2[0] === "medium"
      );
      toggle_class(
        table,
        "bx--data-table--sort",
        /*sortable*/
        ctx2[3]
      );
      toggle_class(
        table,
        "bx--data-table--zebra",
        /*zebra*/
        ctx2[1]
      );
      toggle_class(
        table,
        "bx--data-table--static",
        /*useStaticWidth*/
        ctx2[2]
      );
      toggle_class(
        table,
        "bx--data-table--sticky-header",
        /*stickyHeader*/
        ctx2[4]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(table);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block12.name,
    type: "else",
    source: "(44:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block28(ctx) {
  let section;
  let table;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let section_levels = [
    /*$$restProps*/
    ctx[6]
  ];
  let section_data = {};
  for (let i = 0; i < section_levels.length; i += 1) {
    section_data = assign(section_data, section_levels[i]);
  }
  const block = {
    c: function create() {
      section = element("section");
      table = element("table");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", {});
      var section_nodes = children(section);
      table = claim_element(section_nodes, "TABLE", { style: true });
      var table_nodes = children(table);
      if (default_slot) default_slot.l(table_nodes);
      table_nodes.forEach(detach_dev);
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        table,
        "style",
        /*tableStyle*/
        ctx[5]
      );
      toggle_class(table, "bx--data-table", true);
      toggle_class(
        table,
        "bx--data-table--compact",
        /*size*/
        ctx[0] === "compact"
      );
      toggle_class(
        table,
        "bx--data-table--short",
        /*size*/
        ctx[0] === "short"
      );
      toggle_class(
        table,
        "bx--data-table--tall",
        /*size*/
        ctx[0] === "tall"
      );
      toggle_class(
        table,
        "bx--data-table--md",
        /*size*/
        ctx[0] === "medium"
      );
      toggle_class(
        table,
        "bx--data-table--sort",
        /*sortable*/
        ctx[3]
      );
      toggle_class(
        table,
        "bx--data-table--zebra",
        /*zebra*/
        ctx[1]
      );
      toggle_class(
        table,
        "bx--data-table--static",
        /*useStaticWidth*/
        ctx[2]
      );
      toggle_class(
        table,
        "bx--data-table--sticky-header",
        /*stickyHeader*/
        ctx[4]
      );
      add_location(table, file46, 28, 4, 685);
      set_attributes(section, section_data);
      toggle_class(section, "bx--data-table_inner-container", true);
      add_location(section, file46, 27, 2, 608);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      append_hydration_dev(section, table);
      if (default_slot) {
        default_slot.m(table, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*tableStyle*/
      32) {
        attr_dev(
          table,
          "style",
          /*tableStyle*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*size*/
      1) {
        toggle_class(
          table,
          "bx--data-table--compact",
          /*size*/
          ctx2[0] === "compact"
        );
      }
      if (!current || dirty & /*size*/
      1) {
        toggle_class(
          table,
          "bx--data-table--short",
          /*size*/
          ctx2[0] === "short"
        );
      }
      if (!current || dirty & /*size*/
      1) {
        toggle_class(
          table,
          "bx--data-table--tall",
          /*size*/
          ctx2[0] === "tall"
        );
      }
      if (!current || dirty & /*size*/
      1) {
        toggle_class(
          table,
          "bx--data-table--md",
          /*size*/
          ctx2[0] === "medium"
        );
      }
      if (!current || dirty & /*sortable*/
      8) {
        toggle_class(
          table,
          "bx--data-table--sort",
          /*sortable*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*zebra*/
      2) {
        toggle_class(
          table,
          "bx--data-table--zebra",
          /*zebra*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*useStaticWidth*/
      4) {
        toggle_class(
          table,
          "bx--data-table--static",
          /*useStaticWidth*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*stickyHeader*/
      16) {
        toggle_class(
          table,
          "bx--data-table--sticky-header",
          /*stickyHeader*/
          ctx2[4]
        );
      }
      set_attributes(section, section_data = get_spread_update(section_levels, [dirty & /*$$restProps*/
      64 && /*$$restProps*/
      ctx2[6]]));
      toggle_class(section, "bx--data-table_inner-container", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(section);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block28.name,
    type: "if",
    source: "(27:0) {#if stickyHeader}",
    ctx
  });
  return block;
}
function create_fragment47(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block28, create_else_block12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*stickyHeader*/
      ctx2[4]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  const omit_props_names = ["size", "zebra", "useStaticWidth", "sortable", "stickyHeader", "tableStyle"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, ["default"]);
  let { size = void 0 } = $$props;
  let { zebra = false } = $$props;
  let { useStaticWidth = false } = $$props;
  let { sortable = false } = $$props;
  let { stickyHeader = false } = $$props;
  let { tableStyle = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("zebra" in $$new_props) $$invalidate(1, zebra = $$new_props.zebra);
    if ("useStaticWidth" in $$new_props) $$invalidate(2, useStaticWidth = $$new_props.useStaticWidth);
    if ("sortable" in $$new_props) $$invalidate(3, sortable = $$new_props.sortable);
    if ("stickyHeader" in $$new_props) $$invalidate(4, stickyHeader = $$new_props.stickyHeader);
    if ("tableStyle" in $$new_props) $$invalidate(5, tableStyle = $$new_props.tableStyle);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    zebra,
    useStaticWidth,
    sortable,
    stickyHeader,
    tableStyle
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("zebra" in $$props) $$invalidate(1, zebra = $$new_props.zebra);
    if ("useStaticWidth" in $$props) $$invalidate(2, useStaticWidth = $$new_props.useStaticWidth);
    if ("sortable" in $$props) $$invalidate(3, sortable = $$new_props.sortable);
    if ("stickyHeader" in $$props) $$invalidate(4, stickyHeader = $$new_props.stickyHeader);
    if ("tableStyle" in $$props) $$invalidate(5, tableStyle = $$new_props.tableStyle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    size,
    zebra,
    useStaticWidth,
    sortable,
    stickyHeader,
    tableStyle,
    $$restProps,
    $$scope,
    slots
  ];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {
      size: 0,
      zebra: 1,
      useStaticWidth: 2,
      sortable: 3,
      stickyHeader: 4,
      tableStyle: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment47.name
    });
  }
  get size() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zebra() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zebra(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useStaticWidth() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useStaticWidth(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortable() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortable(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stickyHeader() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stickyHeader(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tableStyle() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tableStyle(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/carbon-components-svelte/src/DataTable/TableBody.svelte
var file47 = "node_modules/carbon-components-svelte/src/DataTable/TableBody.svelte";
function create_fragment48(ctx) {
  let tbody;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let tbody_levels = [
    { "aria-live": "polite" },
    /*$$restProps*/
    ctx[0]
  ];
  let tbody_data = {};
  for (let i = 0; i < tbody_levels.length; i += 1) {
    tbody_data = assign(tbody_data, tbody_levels[i]);
  }
  const block = {
    c: function create() {
      tbody = element("tbody");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      tbody = claim_element(nodes, "TBODY", { "aria-live": true });
      var tbody_nodes = children(tbody);
      if (default_slot) default_slot.l(tbody_nodes);
      tbody_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(tbody, tbody_data);
      add_location(tbody, file47, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tbody, anchor);
      if (default_slot) {
        default_slot.m(tbody, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(tbody, tbody_data = get_spread_update(tbody_levels, [
        { "aria-live": "polite" },
        dirty & /*$$restProps*/
        1 && /*$$restProps*/
        ctx2[0]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tbody);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableBody", slots, ["default"]);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [$$restProps, $$scope, slots];
}
var TableBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance48, create_fragment48, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableBody",
      options,
      id: create_fragment48.name
    });
  }
};
var TableBody_default = TableBody;

// node_modules/carbon-components-svelte/src/DataTable/TableCell.svelte
var file48 = "node_modules/carbon-components-svelte/src/DataTable/TableCell.svelte";
function create_fragment49(ctx) {
  let td;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let td_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let td_data = {};
  for (let i = 0; i < td_levels.length; i += 1) {
    td_data = assign(td_data, td_levels[i]);
  }
  const block = {
    c: function create() {
      td = element("td");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", {});
      var td_nodes = children(td);
      if (default_slot) default_slot.l(td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(td, td_data);
      add_location(td, file48, 1, 0, 57);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      if (default_slot) {
        default_slot.m(td, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            td,
            "click",
            /*click_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            td,
            "mouseover",
            /*mouseover_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            td,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            td,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(td, td_data = get_spread_update(td_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance49($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableCell", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var TableCell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableCell",
      options,
      id: create_fragment49.name
    });
  }
};
var TableCell_default = TableCell;

// node_modules/carbon-components-svelte/src/DataTable/TableContainer.svelte
var file49 = "node_modules/carbon-components-svelte/src/DataTable/TableContainer.svelte";
function create_if_block29(ctx) {
  let div;
  let h4;
  let t0;
  let t1;
  let p;
  let t2;
  const block = {
    c: function create() {
      div = element("div");
      h4 = element("h4");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      p = element("p");
      t2 = text(
        /*description*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      h4 = claim_element(div_nodes, "H4", {});
      var h4_nodes = children(h4);
      t0 = claim_text(
        h4_nodes,
        /*title*/
        ctx[0]
      );
      h4_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      p = claim_element(div_nodes, "P", {});
      var p_nodes = children(p);
      t2 = claim_text(
        p_nodes,
        /*description*/
        ctx[1]
      );
      p_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(h4, "bx--data-table-header__title", true);
      add_location(h4, file49, 22, 6, 585);
      toggle_class(p, "bx--data-table-header__description", true);
      add_location(p, file49, 23, 6, 652);
      toggle_class(div, "bx--data-table-header", true);
      add_location(div, file49, 21, 4, 536);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, h4);
      append_hydration_dev(h4, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, p);
      append_hydration_dev(p, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      1) set_data_dev(
        t0,
        /*title*/
        ctx2[0]
      );
      if (dirty & /*description*/
      2) set_data_dev(
        t2,
        /*description*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block29.name,
    type: "if",
    source: "(21:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment50(ctx) {
  let div;
  let t;
  let current;
  let if_block = (
    /*title*/
    ctx[0] && create_if_block29(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block) if_block.c();
      t = space();
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block) if_block.l(div_nodes);
      t = claim_space(div_nodes);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--data-table-container", true);
      toggle_class(
        div,
        "bx--data-table-container--static",
        /*useStaticWidth*/
        ctx[3]
      );
      toggle_class(
        div,
        "bx--data-table--max-width",
        /*stickyHeader*/
        ctx[2]
      );
      add_location(div, file49, 14, 0, 339);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append_hydration_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block29(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      16 && /*$$restProps*/
      ctx2[4]]));
      toggle_class(div, "bx--data-table-container", true);
      toggle_class(
        div,
        "bx--data-table-container--static",
        /*useStaticWidth*/
        ctx2[3]
      );
      toggle_class(
        div,
        "bx--data-table--max-width",
        /*stickyHeader*/
        ctx2[2]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  const omit_props_names = ["title", "description", "stickyHeader", "useStaticWidth"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableContainer", slots, ["default"]);
  let { title = "" } = $$props;
  let { description = "" } = $$props;
  let { stickyHeader = false } = $$props;
  let { useStaticWidth = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("title" in $$new_props) $$invalidate(0, title = $$new_props.title);
    if ("description" in $$new_props) $$invalidate(1, description = $$new_props.description);
    if ("stickyHeader" in $$new_props) $$invalidate(2, stickyHeader = $$new_props.stickyHeader);
    if ("useStaticWidth" in $$new_props) $$invalidate(3, useStaticWidth = $$new_props.useStaticWidth);
    if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    title,
    description,
    stickyHeader,
    useStaticWidth
  });
  $$self.$inject_state = ($$new_props) => {
    if ("title" in $$props) $$invalidate(0, title = $$new_props.title);
    if ("description" in $$props) $$invalidate(1, description = $$new_props.description);
    if ("stickyHeader" in $$props) $$invalidate(2, stickyHeader = $$new_props.stickyHeader);
    if ("useStaticWidth" in $$props) $$invalidate(3, useStaticWidth = $$new_props.useStaticWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, description, stickyHeader, useStaticWidth, $$restProps, $$scope, slots];
}
var TableContainer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, {
      title: 0,
      description: 1,
      stickyHeader: 2,
      useStaticWidth: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableContainer",
      options,
      id: create_fragment50.name
    });
  }
  get title() {
    throw new Error("<TableContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<TableContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<TableContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<TableContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stickyHeader() {
    throw new Error("<TableContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stickyHeader(value) {
    throw new Error("<TableContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useStaticWidth() {
    throw new Error("<TableContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useStaticWidth(value) {
    throw new Error("<TableContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableContainer_default = TableContainer;

// node_modules/carbon-components-svelte/src/DataTable/TableHead.svelte
var file50 = "node_modules/carbon-components-svelte/src/DataTable/TableHead.svelte";
function create_fragment51(ctx) {
  let thead;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let thead_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let thead_data = {};
  for (let i = 0; i < thead_levels.length; i += 1) {
    thead_data = assign(thead_data, thead_levels[i]);
  }
  const block = {
    c: function create() {
      thead = element("thead");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      thead = claim_element(nodes, "THEAD", {});
      var thead_nodes = children(thead);
      if (default_slot) default_slot.l(thead_nodes);
      thead_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(thead, thead_data);
      add_location(thead, file50, 2, 0, 124);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, thead, anchor);
      if (default_slot) {
        default_slot.m(thead, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            thead,
            "click",
            /*click_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            thead,
            "mouseover",
            /*mouseover_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            thead,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            thead,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(thead, thead_data = get_spread_update(thead_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(thead);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableHead", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var TableHead = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableHead",
      options,
      id: create_fragment51.name
    });
  }
};
var TableHead_default = TableHead;

// node_modules/carbon-components-svelte/src/icons/ArrowUp.svelte
var file51 = "node_modules/carbon-components-svelte/src/icons/ArrowUp.svelte";
function create_if_block30(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file51, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block30.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment52(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block30(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 4L6 14 7.41 15.41 15 7.83 15 28 17 28 17 7.83 24.59 15.41 26 14 16 4z");
      add_location(path, file51, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file51, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block30(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowUp", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var ArrowUp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment52, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowUp",
      options,
      id: create_fragment52.name
    });
  }
  get size() {
    throw new Error("<ArrowUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ArrowUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ArrowUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowUp_default = ArrowUp;

// node_modules/carbon-components-svelte/src/icons/ArrowsVertical.svelte
var file52 = "node_modules/carbon-components-svelte/src/icons/ArrowsVertical.svelte";
function create_if_block31(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file52, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block31.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment53(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block31(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M27.6 20.6L24 24.2 24 4 22 4 22 24.2 18.4 20.6 17 22 23 28 29 22zM9 4L3 10 4.4 11.4 8 7.8 8 28 10 28 10 7.8 13.6 11.4 15 10z");
      add_location(path, file52, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file52, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block31(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance53($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowsVertical", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var ArrowsVertical = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance53, create_fragment53, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowsVertical",
      options,
      id: create_fragment53.name
    });
  }
  get size() {
    throw new Error("<ArrowsVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowsVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ArrowsVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ArrowsVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowsVertical_default = ArrowsVertical;

// node_modules/carbon-components-svelte/src/DataTable/TableHeader.svelte
var file53 = "node_modules/carbon-components-svelte/src/DataTable/TableHeader.svelte";
function create_else_block13(ctx) {
  let th;
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let th_levels = [
    { scope: (
      /*scope*/
      ctx[3]
    ) },
    { "data-header": (
      /*id*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  let th_data = {};
  for (let i = 0; i < th_levels.length; i += 1) {
    th_data = assign(th_data, th_levels[i]);
  }
  const block = {
    c: function create() {
      th = element("th");
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { scope: true, "data-header": true });
      var th_nodes = children(th);
      div = claim_element(th_nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--table-header-label", true);
      add_location(div, file53, 76, 4, 1748);
      set_attributes(th, th_data);
      add_location(th, file53, 67, 2, 1606);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            th,
            "click",
            /*click_handler_1*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            th,
            "mouseover",
            /*mouseover_handler_1*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            th,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            th,
            "mouseleave",
            /*mouseleave_handler_1*/
            ctx[17],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(th, th_data = get_spread_update(th_levels, [
        (!current || dirty & /*scope*/
        8) && { scope: (
          /*scope*/
          ctx2[3]
        ) },
        (!current || dirty & /*id*/
        16) && { "data-header": (
          /*id*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block13.name,
    type: "else",
    source: "(67:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block32(ctx) {
  let th;
  let button;
  let div;
  let t0;
  let arrowup;
  let t1;
  let arrowsvertical;
  let th_aria_sort_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  arrowup = new ArrowUp_default({
    props: {
      size: 20,
      "aria-label": (
        /*ariaLabel*/
        ctx[5]
      ),
      class: "bx--table-sort__icon"
    },
    $$inline: true
  });
  arrowsvertical = new ArrowsVertical_default({
    props: {
      size: 20,
      "aria-label": (
        /*ariaLabel*/
        ctx[5]
      ),
      class: "bx--table-sort__icon-unsorted"
    },
    $$inline: true
  });
  let th_levels = [
    {
      "aria-sort": th_aria_sort_value = /*active*/
      ctx[2] ? (
        /*sortDirection*/
        ctx[1]
      ) : "none"
    },
    { scope: (
      /*scope*/
      ctx[3]
    ) },
    { "data-header": (
      /*id*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  let th_data = {};
  for (let i = 0; i < th_levels.length; i += 1) {
    th_data = assign(th_data, th_levels[i]);
  }
  const block = {
    c: function create() {
      th = element("th");
      button = element("button");
      div = element("div");
      if (default_slot) default_slot.c();
      t0 = space();
      create_component(arrowup.$$.fragment);
      t1 = space();
      create_component(arrowsvertical.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", {
        "aria-sort": true,
        scope: true,
        "data-header": true
      });
      var th_nodes = children(th);
      button = claim_element(th_nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      div = claim_element(button_nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t0 = claim_space(button_nodes);
      claim_component(arrowup.$$.fragment, button_nodes);
      t1 = claim_space(button_nodes);
      claim_component(arrowsvertical.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--table-header-label", true);
      add_location(div, file53, 51, 6, 1256);
      attr_dev(button, "type", "button");
      toggle_class(button, "bx--table-sort", true);
      toggle_class(
        button,
        "bx--table-sort--active",
        /*active*/
        ctx[2]
      );
      toggle_class(
        button,
        "bx--table-sort--ascending",
        /*active*/
        ctx[2] && /*sortDirection*/
        ctx[1] === "descending"
      );
      add_location(button, file53, 43, 4, 1028);
      set_attributes(th, th_data);
      add_location(th, file53, 34, 2, 849);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, button);
      append_hydration_dev(button, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(button, t0);
      mount_component(arrowup, button, null);
      append_hydration_dev(button, t1);
      mount_component(arrowsvertical, button, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            th,
            "mouseover",
            /*mouseover_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            th,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            th,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      const arrowup_changes = {};
      if (dirty & /*ariaLabel*/
      32) arrowup_changes["aria-label"] = /*ariaLabel*/
      ctx2[5];
      arrowup.$set(arrowup_changes);
      const arrowsvertical_changes = {};
      if (dirty & /*ariaLabel*/
      32) arrowsvertical_changes["aria-label"] = /*ariaLabel*/
      ctx2[5];
      arrowsvertical.$set(arrowsvertical_changes);
      if (!current || dirty & /*active*/
      4) {
        toggle_class(
          button,
          "bx--table-sort--active",
          /*active*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*active, sortDirection*/
      6) {
        toggle_class(
          button,
          "bx--table-sort--ascending",
          /*active*/
          ctx2[2] && /*sortDirection*/
          ctx2[1] === "descending"
        );
      }
      set_attributes(th, th_data = get_spread_update(th_levels, [
        (!current || dirty & /*active, sortDirection*/
        6 && th_aria_sort_value !== (th_aria_sort_value = /*active*/
        ctx2[2] ? (
          /*sortDirection*/
          ctx2[1]
        ) : "none")) && { "aria-sort": th_aria_sort_value },
        (!current || dirty & /*scope*/
        8) && { scope: (
          /*scope*/
          ctx2[3]
        ) },
        (!current || dirty & /*id*/
        16) && { "data-header": (
          /*id*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(arrowup.$$.fragment, local);
      transition_in(arrowsvertical.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(arrowup.$$.fragment, local);
      transition_out(arrowsvertical.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      if (default_slot) default_slot.d(detaching);
      destroy_component(arrowup);
      destroy_component(arrowsvertical);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block32.name,
    type: "if",
    source: "(34:0) {#if sortable}",
    ctx
  });
  return block;
}
function create_fragment54(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block32, create_else_block13];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*sortable*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance54($$self, $$props, $$invalidate) {
  let ariaLabel;
  const omit_props_names = ["sortable", "sortDirection", "active", "scope", "translateWithId", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableHeader", slots, ["default"]);
  let { sortable = false } = $$props;
  let { sortDirection = "none" } = $$props;
  let { active = false } = $$props;
  let { scope = "col" } = $$props;
  let { translateWithId = () => "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("sortable" in $$new_props) $$invalidate(0, sortable = $$new_props.sortable);
    if ("sortDirection" in $$new_props) $$invalidate(1, sortDirection = $$new_props.sortDirection);
    if ("active" in $$new_props) $$invalidate(2, active = $$new_props.active);
    if ("scope" in $$new_props) $$invalidate(3, scope = $$new_props.scope);
    if ("translateWithId" in $$new_props) $$invalidate(7, translateWithId = $$new_props.translateWithId);
    if ("id" in $$new_props) $$invalidate(4, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    sortable,
    sortDirection,
    active,
    scope,
    translateWithId,
    id,
    ArrowUp: ArrowUp_default,
    ArrowsVertical: ArrowsVertical_default,
    ariaLabel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("sortable" in $$props) $$invalidate(0, sortable = $$new_props.sortable);
    if ("sortDirection" in $$props) $$invalidate(1, sortDirection = $$new_props.sortDirection);
    if ("active" in $$props) $$invalidate(2, active = $$new_props.active);
    if ("scope" in $$props) $$invalidate(3, scope = $$new_props.scope);
    if ("translateWithId" in $$props) $$invalidate(7, translateWithId = $$new_props.translateWithId);
    if ("id" in $$props) $$invalidate(4, id = $$new_props.id);
    if ("ariaLabel" in $$props) $$invalidate(5, ariaLabel = $$new_props.ariaLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*translateWithId*/
    128) {
      $: $$invalidate(5, ariaLabel = translateWithId());
    }
  };
  return [
    sortable,
    sortDirection,
    active,
    scope,
    id,
    ariaLabel,
    $$restProps,
    translateWithId,
    $$scope,
    slots,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1
  ];
}
var TableHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment54, safe_not_equal, {
      sortable: 0,
      sortDirection: 1,
      active: 2,
      scope: 3,
      translateWithId: 7,
      id: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableHeader",
      options,
      id: create_fragment54.name
    });
  }
  get sortable() {
    throw new Error("<TableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortable(value) {
    throw new Error("<TableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortDirection() {
    throw new Error("<TableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortDirection(value) {
    throw new Error("<TableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scope() {
    throw new Error("<TableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scope(value) {
    throw new Error("<TableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<TableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<TableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableHeader_default = TableHeader;

// node_modules/carbon-components-svelte/src/DataTable/TableRow.svelte
var file54 = "node_modules/carbon-components-svelte/src/DataTable/TableRow.svelte";
function create_fragment55(ctx) {
  let tr;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let tr_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let tr_data = {};
  for (let i = 0; i < tr_levels.length; i += 1) {
    tr_data = assign(tr_data, tr_levels[i]);
  }
  const block = {
    c: function create() {
      tr = element("tr");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", {});
      var tr_nodes = children(tr);
      if (default_slot) default_slot.l(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(tr, tr_data);
      add_location(tr, file54, 1, 0, 57);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            tr,
            "click",
            /*click_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            tr,
            "mouseover",
            /*mouseover_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            tr,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            tr,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(tr, tr_data = get_spread_update(tr_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance55($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableRow", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var TableRow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance55, create_fragment55, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableRow",
      options,
      id: create_fragment55.name
    });
  }
};
var TableRow_default = TableRow;

// node_modules/carbon-components-svelte/src/DataTable/DataTable.svelte
var file55 = "node_modules/carbon-components-svelte/src/DataTable/DataTable.svelte";
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[66] = list[i];
  child_ctx[68] = i;
  return child_ctx;
}
var get_expanded_row_slot_changes = (dirty) => ({
  row: dirty[0] & /*sorting, displayedSortedRows, displayedRows*/
  201850880
});
var get_expanded_row_slot_context = (ctx) => ({ row: (
  /*row*/
  ctx[66]
) });
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[69] = list[i];
  child_ctx[71] = i;
  return child_ctx;
}
var get_cell_slot_changes_1 = (dirty) => ({
  row: dirty[0] & /*sorting, displayedSortedRows, displayedRows*/
  201850880,
  cell: dirty[0] & /*tableCellsByRowId, sorting, displayedSortedRows, displayedRows*/
  470286336,
  rowIndex: dirty[0] & /*sorting, displayedSortedRows, displayedRows*/
  201850880,
  cellIndex: dirty[0] & /*tableCellsByRowId, sorting, displayedSortedRows, displayedRows*/
  470286336
});
var get_cell_slot_context_1 = (ctx) => ({
  row: (
    /*row*/
    ctx[66]
  ),
  cell: (
    /*cell*/
    ctx[69]
  ),
  rowIndex: (
    /*i*/
    ctx[68]
  ),
  cellIndex: (
    /*j*/
    ctx[71]
  )
});
var get_cell_slot_changes = (dirty) => ({
  row: dirty[0] & /*sorting, displayedSortedRows, displayedRows*/
  201850880,
  cell: dirty[0] & /*tableCellsByRowId, sorting, displayedSortedRows, displayedRows*/
  470286336,
  rowIndex: dirty[0] & /*sorting, displayedSortedRows, displayedRows*/
  201850880,
  cellIndex: dirty[0] & /*tableCellsByRowId, sorting, displayedSortedRows, displayedRows*/
  470286336
});
var get_cell_slot_context = (ctx) => ({
  row: (
    /*row*/
    ctx[66]
  ),
  cell: (
    /*cell*/
    ctx[69]
  ),
  rowIndex: (
    /*i*/
    ctx[68]
  ),
  cellIndex: (
    /*j*/
    ctx[71]
  )
});
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[72] = list[i];
  return child_ctx;
}
var get_cell_header_slot_changes = (dirty) => ({ header: dirty[0] & /*headers*/
64 });
var get_cell_header_slot_context = (ctx) => ({ header: (
  /*header*/
  ctx[72]
) });
var get_description_slot_changes = (dirty) => ({});
var get_description_slot_context = (ctx) => ({});
var get_title_slot_changes2 = (dirty) => ({});
var get_title_slot_context2 = (ctx) => ({});
function create_if_block_132(ctx) {
  let div;
  let t;
  let current;
  let if_block0 = (
    /*title*/
    (ctx[8] || /*$$slots*/
    ctx[38].title) && create_if_block_152(ctx)
  );
  let if_block1 = (
    /*description*/
    (ctx[9] || /*$$slots*/
    ctx[38].description) && create_if_block_142(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0) if_block0.c();
      t = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block0) if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1) if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--data-table-header", true);
      add_location(div, file55, 262, 4, 8748);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append_hydration_dev(div, t);
      if (if_block1) if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*title*/
        ctx2[8] || /*$$slots*/
        ctx2[38].title
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*title*/
          256 | dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_152(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*description*/
        ctx2[9] || /*$$slots*/
        ctx2[38].description
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*description*/
          512 | dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_142(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_132.name,
    type: "if",
    source: "(262:2) {#if title || $$slots.title || description || $$slots.description}",
    ctx
  });
  return block;
}
function create_if_block_152(ctx) {
  let h4;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[48].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[62],
    get_title_slot_context2
  );
  const title_slot_or_fallback = title_slot || fallback_block_42(ctx);
  const block = {
    c: function create() {
      h4 = element("h4");
      if (title_slot_or_fallback) title_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      h4 = claim_element(nodes, "H4", {});
      var h4_nodes = children(h4);
      if (title_slot_or_fallback) title_slot_or_fallback.l(h4_nodes);
      h4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(h4, "bx--data-table-header__title", true);
      add_location(h4, file55, 264, 8, 8834);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h4, anchor);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(h4, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        1)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[62],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[62]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[62],
              dirty,
              get_title_slot_changes2
            ),
            get_title_slot_context2
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty[0] & /*title*/
        256)) {
          title_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(title_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h4);
      }
      if (title_slot_or_fallback) title_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_152.name,
    type: "if",
    source: "(264:6) {#if title || $$slots.title}",
    ctx
  });
  return block;
}
function fallback_block_42(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*title*/
        ctx[8]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*title*/
        ctx[8]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*title*/
      256) set_data_dev(
        t,
        /*title*/
        ctx2[8]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_42.name,
    type: "fallback",
    source: "(266:29) {title}",
    ctx
  });
  return block;
}
function create_if_block_142(ctx) {
  let p;
  let current;
  const description_slot_template = (
    /*#slots*/
    ctx[48].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[62],
    get_description_slot_context
  );
  const description_slot_or_fallback = description_slot || fallback_block_32(ctx);
  const block = {
    c: function create() {
      p = element("p");
      if (description_slot_or_fallback) description_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      if (description_slot_or_fallback) description_slot_or_fallback.l(p_nodes);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(p, "bx--data-table-header__description", true);
      add_location(p, file55, 269, 8, 9008);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      if (description_slot_or_fallback) {
        description_slot_or_fallback.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (description_slot) {
        if (description_slot.p && (!current || dirty[2] & /*$$scope*/
        1)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[62],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[62]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[62],
              dirty,
              get_description_slot_changes
            ),
            get_description_slot_context
          );
        }
      } else {
        if (description_slot_or_fallback && description_slot_or_fallback.p && (!current || dirty[0] & /*description*/
        512)) {
          description_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(description_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(description_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
      if (description_slot_or_fallback) description_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_142.name,
    type: "if",
    source: "(269:6) {#if description || $$slots.description}",
    ctx
  });
  return block;
}
function fallback_block_32(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*description*/
        ctx[9]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*description*/
        ctx[9]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*description*/
      512) set_data_dev(
        t,
        /*description*/
        ctx2[9]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_32.name,
    type: "fallback",
    source: "(271:35) {description}",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let th;
  let th_data_previous_value_value;
  let current;
  let if_block = (
    /*batchExpansion*/
    ctx[12] && create_if_block_122(ctx)
  );
  const block = {
    c: function create() {
      th = element("th");
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { scope: true, "data-previous-value": true });
      var th_nodes = children(th);
      if (if_block) if_block.l(th_nodes);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "scope", "col");
      attr_dev(th, "data-previous-value", th_data_previous_value_value = /*expanded*/
      ctx[22] ? "collapsed" : void 0);
      toggle_class(th, "bx--table-expand", true);
      add_location(th, file55, 287, 10, 9455);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      if (if_block) if_block.m(th, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*batchExpansion*/
        ctx2[12]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*batchExpansion*/
          4096) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_122(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(th, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*expanded*/
      4194304 && th_data_previous_value_value !== (th_data_previous_value_value = /*expanded*/
      ctx2[22] ? "collapsed" : void 0)) {
        attr_dev(th, "data-previous-value", th_data_previous_value_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(287:8) {#if expandable}",
    ctx
  });
  return block;
}
function create_if_block_122(ctx) {
  let button;
  let chevronright;
  let current;
  let mounted;
  let dispose;
  chevronright = new ChevronRight_default({
    props: { class: "bx--table-expand__svg" },
    $$inline: true
  });
  const block = {
    c: function create() {
      button = element("button");
      create_component(chevronright.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      claim_component(chevronright.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      toggle_class(button, "bx--table-expand__button", true);
      add_location(button, file55, 293, 14, 9657);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(chevronright, button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[49],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      transition_in(chevronright.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronright.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      destroy_component(chevronright);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_122.name,
    type: "if",
    source: "(293:12) {#if batchExpansion}",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let th;
  const block = {
    c: function create() {
      th = element("th");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { scope: true });
      children(th).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "scope", "col");
      add_location(th, file55, 309, 10, 10187);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(309:8) {#if selectable && !batchSelection}",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let th;
  let inlinecheckbox;
  let updating_ref;
  let current;
  function inlinecheckbox_ref_binding(value) {
    ctx[50](value);
  }
  let inlinecheckbox_props = {
    "aria-label": "Select all rows",
    checked: (
      /*selectAll*/
      ctx[30]
    ),
    indeterminate: (
      /*indeterminate*/
      ctx[29]
    )
  };
  if (
    /*refSelectAll*/
    ctx[24] !== void 0
  ) {
    inlinecheckbox_props.ref = /*refSelectAll*/
    ctx[24];
  }
  inlinecheckbox = new InlineCheckbox_default({
    props: inlinecheckbox_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(inlinecheckbox, "ref", inlinecheckbox_ref_binding));
  inlinecheckbox.$on(
    "change",
    /*change_handler*/
    ctx[51]
  );
  const block = {
    c: function create() {
      th = element("th");
      create_component(inlinecheckbox.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { scope: true });
      var th_nodes = children(th);
      claim_component(inlinecheckbox.$$.fragment, th_nodes);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "scope", "col");
      toggle_class(th, "bx--table-column-checkbox", true);
      add_location(th, file55, 312, 10, 10272);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      mount_component(inlinecheckbox, th, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const inlinecheckbox_changes = {};
      if (dirty[0] & /*selectAll*/
      1073741824) inlinecheckbox_changes.checked = /*selectAll*/
      ctx2[30];
      if (dirty[0] & /*indeterminate*/
      536870912) inlinecheckbox_changes.indeterminate = /*indeterminate*/
      ctx2[29];
      if (!updating_ref && dirty[0] & /*refSelectAll*/
      16777216) {
        updating_ref = true;
        inlinecheckbox_changes.ref = /*refSelectAll*/
        ctx2[24];
        add_flush_callback(() => updating_ref = false);
      }
      inlinecheckbox.$set(inlinecheckbox_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(inlinecheckbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inlinecheckbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      destroy_component(inlinecheckbox);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(312:8) {#if batchSelection && !radio}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let tableheader;
  let current;
  function click_handler_13() {
    return (
      /*click_handler_1*/
      ctx[52](
        /*header*/
        ctx[72]
      )
    );
  }
  tableheader = new TableHeader_default({
    props: {
      id: (
        /*header*/
        ctx[72].key
      ),
      style: (
        /*formatHeaderWidth*/
        ctx[36](
          /*header*/
          ctx[72]
        )
      ),
      sortable: (
        /*sortable*/
        ctx[11] && /*header*/
        ctx[72].sort !== false
      ),
      sortDirection: (
        /*sortKey*/
        ctx[0] === /*header*/
        ctx[72].key ? (
          /*sortDirection*/
          ctx[1]
        ) : "none"
      ),
      active: (
        /*sortKey*/
        ctx[0] === /*header*/
        ctx[72].key
      ),
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tableheader.$on("click", click_handler_13);
  const block = {
    c: function create() {
      create_component(tableheader.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tableheader.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tableheader, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const tableheader_changes = {};
      if (dirty[0] & /*headers*/
      64) tableheader_changes.id = /*header*/
      ctx[72].key;
      if (dirty[0] & /*headers*/
      64) tableheader_changes.style = /*formatHeaderWidth*/
      ctx[36](
        /*header*/
        ctx[72]
      );
      if (dirty[0] & /*sortable, headers*/
      2112) tableheader_changes.sortable = /*sortable*/
      ctx[11] && /*header*/
      ctx[72].sort !== false;
      if (dirty[0] & /*sortKey, headers, sortDirection*/
      67) tableheader_changes.sortDirection = /*sortKey*/
      ctx[0] === /*header*/
      ctx[72].key ? (
        /*sortDirection*/
        ctx[1]
      ) : "none";
      if (dirty[0] & /*sortKey, headers*/
      65) tableheader_changes.active = /*sortKey*/
      ctx[0] === /*header*/
      ctx[72].key;
      if (dirty[0] & /*headers*/
      64 | dirty[2] & /*$$scope*/
      1) {
        tableheader_changes.$$scope = { dirty, ctx };
      }
      tableheader.$set(tableheader_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(tableheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tableheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tableheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(344:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block_82(ctx) {
  let th;
  let th_style_value;
  const block = {
    c: function create() {
      th = element("th");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { scope: true, style: true });
      children(th).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "scope", "col");
      attr_dev(th, "style", th_style_value = /*formatHeaderWidth*/
      ctx[36](
        /*header*/
        ctx[72]
      ));
      add_location(th, file55, 342, 12, 11255);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*headers*/
      64 && th_style_value !== (th_style_value = /*formatHeaderWidth*/
      ctx2[36](
        /*header*/
        ctx2[72]
      ))) {
        attr_dev(th, "style", th_style_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_82.name,
    type: "if",
    source: "(342:10) {#if header.empty}",
    ctx
  });
  return block;
}
function fallback_block_23(ctx) {
  let t_value = (
    /*header*/
    ctx[72].value + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*headers*/
      64 && t_value !== (t_value = /*header*/
      ctx2[72].value + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_23.name,
    type: "fallback",
    source: "(366:57) {header.value}",
    ctx
  });
  return block;
}
function create_default_slot_9(ctx) {
  let t;
  let current;
  const cell_header_slot_template = (
    /*#slots*/
    ctx[48]["cell-header"]
  );
  const cell_header_slot = create_slot(
    cell_header_slot_template,
    ctx,
    /*$$scope*/
    ctx[62],
    get_cell_header_slot_context
  );
  const cell_header_slot_or_fallback = cell_header_slot || fallback_block_23(ctx);
  const block = {
    c: function create() {
      if (cell_header_slot_or_fallback) cell_header_slot_or_fallback.c();
      t = space();
    },
    l: function claim(nodes) {
      if (cell_header_slot_or_fallback) cell_header_slot_or_fallback.l(nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if (cell_header_slot_or_fallback) {
        cell_header_slot_or_fallback.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (cell_header_slot) {
        if (cell_header_slot.p && (!current || dirty[0] & /*headers*/
        64 | dirty[2] & /*$$scope*/
        1)) {
          update_slot_base(
            cell_header_slot,
            cell_header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[62],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[62]
            ) : get_slot_changes(
              cell_header_slot_template,
              /*$$scope*/
              ctx2[62],
              dirty,
              get_cell_header_slot_changes
            ),
            get_cell_header_slot_context
          );
        }
      } else {
        if (cell_header_slot_or_fallback && cell_header_slot_or_fallback.p && (!current || dirty[0] & /*headers*/
        64)) {
          cell_header_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(cell_header_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cell_header_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (cell_header_slot_or_fallback) cell_header_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9.name,
    type: "slot",
    source: `(345:12) <TableHeader               id=\\"{header.key}\\"               style=\\"{formatHeaderWidth(header)}\\"               sortable=\\"{sortable && header.sort !== false}\\"               sortDirection=\\"{sortKey === header.key ? sortDirection : 'none'}\\"               active=\\"{sortKey === header.key}\\"               on:click=\\"{() => {                 dispatch('click', { header });                  if (header.sort === false) {                   dispatch('click:header', { header });                 } else {                   let currentSortDirection =                     sortKey === header.key ? sortDirection : 'none';                   sortDirection = sortDirectionMap[currentSortDirection];                   sortKey =                     sortDirection === 'none' ? null : thKeys[header.key];                   dispatch('click:header', { header, sortDirection });                 }               }}\\"             >`,
    ctx
  });
  return block;
}
function create_each_block_2(key_1, ctx) {
  let first;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_82, create_else_block_2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*header*/
      ctx2[72].empty
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(341:8) {#each headers as header (header.key)}",
    ctx
  });
  return block;
}
function create_default_slot_8(ctx) {
  let t0;
  let t1;
  let t2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let if_block0 = (
    /*expandable*/
    ctx[4] && create_if_block_11(ctx)
  );
  let if_block1 = (
    /*selectable*/
    ctx[5] && !/*batchSelection*/
    ctx[15] && create_if_block_10(ctx)
  );
  let if_block2 = (
    /*batchSelection*/
    ctx[15] && !/*radio*/
    ctx[14] && create_if_block_9(ctx)
  );
  let each_value_2 = ensure_array_like_dev(
    /*headers*/
    ctx[6]
  );
  const get_key = (ctx2) => (
    /*header*/
    ctx2[72].key
  );
  validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_2(ctx, each_value_2, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
  }
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2) if_block2.l(nodes);
      t2 = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*expandable*/
        ctx2[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*expandable*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_11(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*selectable*/
        ctx2[5] && !/*batchSelection*/
        ctx2[15]
      ) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_10(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*batchSelection*/
        ctx2[15] && !/*radio*/
        ctx2[14]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*batchSelection, radio*/
          49152) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_9(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*headers, sortable, sortKey, sortDirection*/
      2115 | dirty[1] & /*formatHeaderWidth, dispatch, sortDirectionMap, thKeys*/
      46 | dirty[2] & /*$$scope*/
      1) {
        each_value_2 = ensure_array_like_dev(
          /*headers*/
          ctx2[6]
        );
        group_outros();
        validate_each_keys(ctx2, each_value_2, get_each_context_2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_2, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_2, each_1_anchor, get_each_context_2);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block2);
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(each_1_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8.name,
    type: "slot",
    source: "(286:6) <TableRow>",
    ctx
  });
  return block;
}
function create_default_slot_7(ctx) {
  let tablerow;
  let current;
  tablerow = new TableRow_default({
    props: {
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tablerow.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tablerow.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tablerow, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tablerow_changes = {};
      if (dirty[0] & /*headers, sortable, sortKey, sortDirection, selectAll, indeterminate, refSelectAll, selectedRowIds, selectableRowIds, batchSelection, radio, selectable, expanded, expandedRowIds, expandableRowIds, batchExpansion, expandable*/
      1634785407 | dirty[1] & /*thKeys*/
      2 | dirty[2] & /*$$scope*/
      1) {
        tablerow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablerow.$set(tablerow_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(tablerow.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablerow.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tablerow, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7.name,
    type: "slot",
    source: "(285:4) <TableHead>",
    ctx
  });
  return block;
}
function create_if_block_63(ctx) {
  let tablecell;
  let current;
  tablecell = new TableCell_default({
    props: {
      class: "bx--table-expand",
      headers: "expand",
      "data-previous-value": !/*nonExpandableRowIds*/
      ctx[13].includes(
        /*row*/
        ctx[66].id
      ) && /*expandedRows*/
      ctx[31][
        /*row*/
        ctx[66].id
      ] ? "collapsed" : void 0,
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tablecell.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tablecell.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tablecell, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tablecell_changes = {};
      if (dirty[0] & /*nonExpandableRowIds, sorting, displayedSortedRows, displayedRows*/
      201859072 | dirty[1] & /*expandedRows*/
      1) tablecell_changes["data-previous-value"] = !/*nonExpandableRowIds*/
      ctx2[13].includes(
        /*row*/
        ctx2[66].id
      ) && /*expandedRows*/
      ctx2[31][
        /*row*/
        ctx2[66].id
      ] ? "collapsed" : void 0;
      if (dirty[0] & /*sorting, displayedSortedRows, displayedRows, expandedRowIds, nonExpandableRowIds*/
      201859076 | dirty[1] & /*expandedRows*/
      1 | dirty[2] & /*$$scope*/
      1) {
        tablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablecell.$set(tablecell_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(tablecell.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablecell.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tablecell, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_63.name,
    type: "if",
    source: "(404:10) {#if expandable}",
    ctx
  });
  return block;
}
function create_if_block_72(ctx) {
  let button;
  let chevronright;
  let button_aria_label_value;
  let current;
  let mounted;
  let dispose;
  chevronright = new ChevronRight_default({
    props: { class: "bx--table-expand__svg" },
    $$inline: true
  });
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[53](
        /*row*/
        ctx[66]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      create_component(chevronright.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, "aria-label": true });
      var button_nodes = children(button);
      claim_component(chevronright.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "aria-label", button_aria_label_value = /*expandedRows*/
      ctx[31][
        /*row*/
        ctx[66].id
      ] ? "Collapse current row" : "Expand current row");
      toggle_class(button, "bx--table-expand__button", true);
      add_location(button, file55, 413, 16, 13988);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(chevronright, button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", stop_propagation(click_handler_2), false, false, true, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & /*sorting, displayedSortedRows, displayedRows*/
      201850880 | dirty[1] & /*expandedRows*/
      1 && button_aria_label_value !== (button_aria_label_value = /*expandedRows*/
      ctx[31][
        /*row*/
        ctx[66].id
      ] ? "Collapse current row" : "Expand current row")) {
        attr_dev(button, "aria-label", button_aria_label_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(chevronright.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronright.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      destroy_component(chevronright);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_72.name,
    type: "if",
    source: "(413:14) {#if !nonExpandableRowIds.includes(row.id)}",
    ctx
  });
  return block;
}
function create_default_slot_6(ctx) {
  let show_if = !/*nonExpandableRowIds*/
  ctx[13].includes(
    /*row*/
    ctx[66].id
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_72(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*nonExpandableRowIds, sorting, displayedSortedRows, displayedRows*/
      201859072) show_if = !/*nonExpandableRowIds*/
      ctx2[13].includes(
        /*row*/
        ctx2[66].id
      );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*nonExpandableRowIds, sorting, displayedSortedRows, displayedRows*/
          201859072) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_72(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6.name,
    type: "slot",
    source: `(405:12) <TableCell               class=\\"bx--table-expand\\"               headers=\\"expand\\"               data-previous-value=\\"{!nonExpandableRowIds.includes(row.id) &&               expandedRows[row.id]                 ? 'collapsed'                 : undefined}\\"             >`,
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let td;
  let show_if = !/*nonSelectableRowIds*/
  ctx[16].includes(
    /*row*/
    ctx[66].id
  );
  let current;
  let if_block = show_if && create_if_block_44(ctx);
  const block = {
    c: function create() {
      td = element("td");
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", {});
      var td_nodes = children(td);
      if (if_block) if_block.l(td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(td, "bx--table-column-checkbox", true);
      toggle_class(
        td,
        "bx--table-column-radio",
        /*radio*/
        ctx[14]
      );
      add_location(td, file55, 438, 12, 14898);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      if (if_block) if_block.m(td, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*nonSelectableRowIds, sorting, displayedSortedRows, displayedRows*/
      201916416) show_if = !/*nonSelectableRowIds*/
      ctx2[16].includes(
        /*row*/
        ctx2[66].id
      );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*nonSelectableRowIds, sorting, displayedSortedRows, displayedRows*/
          201916416) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_44(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(td, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*radio*/
      16384) {
        toggle_class(
          td,
          "bx--table-column-radio",
          /*radio*/
          ctx2[14]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(438:10) {#if selectable}",
    ctx
  });
  return block;
}
function create_if_block_44(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_53, create_else_block_12];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*radio*/
      ctx2[14]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_44.name,
    type: "if",
    source: "(443:14) {#if !nonSelectableRowIds.includes(row.id)}",
    ctx
  });
  return block;
}
function create_else_block_12(ctx) {
  let inlinecheckbox;
  let current;
  function change_handler_2() {
    return (
      /*change_handler_2*/
      ctx[55](
        /*row*/
        ctx[66]
      )
    );
  }
  inlinecheckbox = new InlineCheckbox_default({
    props: {
      name: "select-row-" + /*row*/
      ctx[66].id,
      checked: (
        /*selectedRowIds*/
        ctx[3].includes(
          /*row*/
          ctx[66].id
        )
      )
    },
    $$inline: true
  });
  inlinecheckbox.$on("change", change_handler_2);
  const block = {
    c: function create() {
      create_component(inlinecheckbox.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(inlinecheckbox.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(inlinecheckbox, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const inlinecheckbox_changes = {};
      if (dirty[0] & /*sorting, displayedSortedRows, displayedRows*/
      201850880) inlinecheckbox_changes.name = "select-row-" + /*row*/
      ctx[66].id;
      if (dirty[0] & /*selectedRowIds, sorting, displayedSortedRows, displayedRows*/
      201850888) inlinecheckbox_changes.checked = /*selectedRowIds*/
      ctx[3].includes(
        /*row*/
        ctx[66].id
      );
      inlinecheckbox.$set(inlinecheckbox_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(inlinecheckbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inlinecheckbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(inlinecheckbox, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_12.name,
    type: "else",
    source: "(453:16) {:else}",
    ctx
  });
  return block;
}
function create_if_block_53(ctx) {
  let radiobutton;
  let current;
  function change_handler_1() {
    return (
      /*change_handler_1*/
      ctx[54](
        /*row*/
        ctx[66]
      )
    );
  }
  radiobutton = new RadioButton_default({
    props: {
      name: "select-row-" + /*row*/
      ctx[66].id,
      checked: (
        /*selectedRowIds*/
        ctx[3].includes(
          /*row*/
          ctx[66].id
        )
      )
    },
    $$inline: true
  });
  radiobutton.$on("change", change_handler_1);
  const block = {
    c: function create() {
      create_component(radiobutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(radiobutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(radiobutton, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const radiobutton_changes = {};
      if (dirty[0] & /*sorting, displayedSortedRows, displayedRows*/
      201850880) radiobutton_changes.name = "select-row-" + /*row*/
      ctx[66].id;
      if (dirty[0] & /*selectedRowIds, sorting, displayedSortedRows, displayedRows*/
      201850888) radiobutton_changes.checked = /*selectedRowIds*/
      ctx[3].includes(
        /*row*/
        ctx[66].id
      );
      radiobutton.$set(radiobutton_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(radiobutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(radiobutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(radiobutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_53.name,
    type: "if",
    source: "(444:16) {#if radio}",
    ctx
  });
  return block;
}
function create_else_block14(ctx) {
  let tablecell;
  let current;
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[56](
        /*row*/
        ctx[66],
        /*cell*/
        ctx[69]
      )
    );
  }
  tablecell = new TableCell_default({
    props: {
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tablecell.$on("click", click_handler_3);
  const block = {
    c: function create() {
      create_component(tablecell.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tablecell.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tablecell, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const tablecell_changes = {};
      if (dirty[0] & /*tableCellsByRowId, sorting, displayedSortedRows, displayedRows*/
      470286336 | dirty[2] & /*$$scope*/
      1) {
        tablecell_changes.$$scope = { dirty, ctx };
      }
      tablecell.$set(tablecell_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(tablecell.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablecell.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tablecell, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block14.name,
    type: "else",
    source: "(486:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_27(ctx) {
  let td;
  let t;
  let current;
  const cell_slot_template = (
    /*#slots*/
    ctx[48].cell
  );
  const cell_slot = create_slot(
    cell_slot_template,
    ctx,
    /*$$scope*/
    ctx[62],
    get_cell_slot_context
  );
  const cell_slot_or_fallback = cell_slot || fallback_block9(ctx);
  const block = {
    c: function create() {
      td = element("td");
      if (cell_slot_or_fallback) cell_slot_or_fallback.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", {});
      var td_nodes = children(td);
      if (cell_slot_or_fallback) cell_slot_or_fallback.l(td_nodes);
      t = claim_space(td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(
        td,
        "bx--table-column-menu",
        /*headers*/
        ctx[6][
          /*j*/
          ctx[71]
        ].columnMenu
      );
      add_location(td, file55, 474, 14, 16395);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      if (cell_slot_or_fallback) {
        cell_slot_or_fallback.m(td, null);
      }
      append_hydration_dev(td, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (cell_slot) {
        if (cell_slot.p && (!current || dirty[0] & /*sorting, displayedSortedRows, displayedRows, tableCellsByRowId*/
        470286336 | dirty[2] & /*$$scope*/
        1)) {
          update_slot_base(
            cell_slot,
            cell_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[62],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[62]
            ) : get_slot_changes(
              cell_slot_template,
              /*$$scope*/
              ctx2[62],
              dirty,
              get_cell_slot_changes
            ),
            get_cell_slot_context
          );
        }
      } else {
        if (cell_slot_or_fallback && cell_slot_or_fallback.p && (!current || dirty[0] & /*tableCellsByRowId, sorting, displayedSortedRows, displayedRows*/
        470286336)) {
          cell_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*headers, tableCellsByRowId, sorting, displayedSortedRows, displayedRows*/
      470286400) {
        toggle_class(
          td,
          "bx--table-column-menu",
          /*headers*/
          ctx2[6][
            /*j*/
            ctx2[71]
          ].columnMenu
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(cell_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cell_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      if (cell_slot_or_fallback) cell_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(474:12) {#if headers[j].empty}",
    ctx
  });
  return block;
}
function fallback_block_15(ctx) {
  let t_value = (
    /*cell*/
    (ctx[69].display ? (
      /*cell*/
      ctx[69].display(
        /*cell*/
        ctx[69].value,
        /*row*/
        ctx[66]
      )
    ) : (
      /*cell*/
      ctx[69].value
    )) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*tableCellsByRowId, sorting, displayedSortedRows, displayedRows*/
      470286336 && t_value !== (t_value = /*cell*/
      (ctx2[69].display ? (
        /*cell*/
        ctx2[69].display(
          /*cell*/
          ctx2[69].value,
          /*row*/
          ctx2[66]
        )
      ) : (
        /*cell*/
        ctx2[69].value
      )) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_15.name,
    type: "fallback",
    source: "(499:17)                    ",
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let t;
  let current;
  const cell_slot_template = (
    /*#slots*/
    ctx[48].cell
  );
  const cell_slot = create_slot(
    cell_slot_template,
    ctx,
    /*$$scope*/
    ctx[62],
    get_cell_slot_context_1
  );
  const cell_slot_or_fallback = cell_slot || fallback_block_15(ctx);
  const block = {
    c: function create() {
      if (cell_slot_or_fallback) cell_slot_or_fallback.c();
      t = space();
    },
    l: function claim(nodes) {
      if (cell_slot_or_fallback) cell_slot_or_fallback.l(nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if (cell_slot_or_fallback) {
        cell_slot_or_fallback.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (cell_slot) {
        if (cell_slot.p && (!current || dirty[0] & /*sorting, displayedSortedRows, displayedRows, tableCellsByRowId*/
        470286336 | dirty[2] & /*$$scope*/
        1)) {
          update_slot_base(
            cell_slot,
            cell_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[62],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[62]
            ) : get_slot_changes(
              cell_slot_template,
              /*$$scope*/
              ctx2[62],
              dirty,
              get_cell_slot_changes_1
            ),
            get_cell_slot_context_1
          );
        }
      } else {
        if (cell_slot_or_fallback && cell_slot_or_fallback.p && (!current || dirty[0] & /*tableCellsByRowId, sorting, displayedSortedRows, displayedRows*/
        470286336)) {
          cell_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(cell_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cell_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (cell_slot_or_fallback) cell_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: `(487:14) <TableCell                 on:click=\\"{() => {                   dispatch('click', { row, cell });                   dispatch('click:cell', cell);                 }}\\"               >`,
    ctx
  });
  return block;
}
function fallback_block9(ctx) {
  let t_value = (
    /*cell*/
    (ctx[69].display ? (
      /*cell*/
      ctx[69].display(
        /*cell*/
        ctx[69].value,
        /*row*/
        ctx[66]
      )
    ) : (
      /*cell*/
      ctx[69].value
    )) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*tableCellsByRowId, sorting, displayedSortedRows, displayedRows*/
      470286336 && t_value !== (t_value = /*cell*/
      (ctx2[69].display ? (
        /*cell*/
        ctx2[69].display(
          /*cell*/
          ctx2[69].value,
          /*row*/
          ctx2[66]
        )
      ) : (
        /*cell*/
        ctx2[69].value
      )) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block9.name,
    type: "fallback",
    source: "(482:17)                    ",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  let first;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_27, create_else_block14];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*headers*/
      ctx2[6][
        /*j*/
        ctx2[71]
      ].empty
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(473:10) {#each tableCellsByRowId[row.id] as cell, j (cell.key)}",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let t0;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let if_block0 = (
    /*expandable*/
    ctx[4] && create_if_block_63(ctx)
  );
  let if_block1 = (
    /*selectable*/
    ctx[5] && create_if_block_34(ctx)
  );
  let each_value_1 = ensure_array_like_dev(
    /*tableCellsByRowId*/
    ctx[28][
      /*row*/
      ctx[66].id
    ]
  );
  const get_key = (ctx2) => (
    /*cell*/
    ctx2[69].key
  );
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      t1 = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*expandable*/
        ctx2[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*expandable*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_63(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*selectable*/
        ctx2[5]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*selectable*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_34(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*headers, tableCellsByRowId, sorting, displayedSortedRows, displayedRows*/
      470286400 | dirty[1] & /*dispatch*/
      8 | dirty[2] & /*$$scope*/
      1) {
        each_value_1 = ensure_array_like_dev(
          /*tableCellsByRowId*/
          ctx2[28][
            /*row*/
            ctx2[66].id
          ]
        );
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1, each_1_anchor, get_each_context_1);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(each_1_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: `(374:8) <TableRow           data-row=\\"{row.id}\\"           data-parent-row=\\"{expandable ? true : undefined}\\"           class=\\"{selectedRowIds.includes(row.id)             ? 'bx--data-table--selected'             : ''} {expandedRows[row.id] ? 'bx--expandable-row' : ''} {expandable             ? 'bx--parent-row'             : ''} {expandable && parentRowId === row.id             ? 'bx--expandable-row--hover'             : ''}\\"           on:click=\\"{({ target }) => {             // forgo \\"click\\", \\"click:row\\" events if target             // resembles an overflow menu, a checkbox, or radio button             if (               [...target.classList].some((name) =>                 /^bx--(overflow-menu|checkbox|radio-button)/.test(name)               )             ) {               return;             }             dispatch('click', { row });             dispatch('click:row', row);           }}\\"           on:mouseenter=\\"{() => {             dispatch('mouseenter:row', row);           }}\\"           on:mouseleave=\\"{() => {             dispatch('mouseleave:row', row);           }}\\"         >`,
    ctx
  });
  return block;
}
function create_if_block33(ctx) {
  let tr;
  let show_if = (
    /*expandedRows*/
    ctx[31][
      /*row*/
      ctx[66].id
    ] && !/*nonExpandableRowIds*/
    ctx[13].includes(
      /*row*/
      ctx[66].id
    )
  );
  let t;
  let current;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block_111(ctx);
  function mouseenter_handler_1() {
    return (
      /*mouseenter_handler_1*/
      ctx[60](
        /*row*/
        ctx[66]
      )
    );
  }
  function mouseleave_handler_1() {
    return (
      /*mouseleave_handler_1*/
      ctx[61](
        /*row*/
        ctx[66]
      )
    );
  }
  const block = {
    c: function create() {
      tr = element("tr");
      if (if_block) if_block.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { "data-child-row": true });
      var tr_nodes = children(tr);
      if (if_block) if_block.l(tr_nodes);
      t = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "data-child-row", "");
      toggle_class(tr, "bx--expandable-row", true);
      add_location(tr, file55, 507, 10, 17411);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      if (if_block) if_block.m(tr, null);
      append_hydration_dev(tr, t);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(tr, "mouseenter", mouseenter_handler_1, false, false, false, false),
          listen_dev(tr, "mouseleave", mouseleave_handler_1, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*sorting, displayedSortedRows, displayedRows, nonExpandableRowIds*/
      201859072 | dirty[1] & /*expandedRows*/
      1) show_if = /*expandedRows*/
      ctx[31][
        /*row*/
        ctx[66].id
      ] && !/*nonExpandableRowIds*/
      ctx[13].includes(
        /*row*/
        ctx[66].id
      );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*sorting, displayedSortedRows, displayedRows, nonExpandableRowIds*/
          201859072 | dirty[1] & /*expandedRows*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_111(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(tr, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block33.name,
    type: "if",
    source: "(507:8) {#if expandable}",
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let tablecell;
  let current;
  tablecell = new TableCell_default({
    props: {
      colspan: (
        /*selectable*/
        ctx[5] ? (
          /*headers*/
          ctx[6].length + 2
        ) : (
          /*headers*/
          ctx[6].length + 1
        )
      ),
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tablecell.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tablecell.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tablecell, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tablecell_changes = {};
      if (dirty[0] & /*selectable, headers*/
      96) tablecell_changes.colspan = /*selectable*/
      ctx2[5] ? (
        /*headers*/
        ctx2[6].length + 2
      ) : (
        /*headers*/
        ctx2[6].length + 1
      );
      if (dirty[0] & /*sorting, displayedSortedRows, displayedRows*/
      201850880 | dirty[2] & /*$$scope*/
      1) {
        tablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablecell.$set(tablecell_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(tablecell.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablecell.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tablecell, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(520:12) {#if expandedRows[row.id] && !nonExpandableRowIds.includes(row.id)}",
    ctx
  });
  return block;
}
function create_default_slot_32(ctx) {
  let div;
  let current;
  const expanded_row_slot_template = (
    /*#slots*/
    ctx[48]["expanded-row"]
  );
  const expanded_row_slot = create_slot(
    expanded_row_slot_template,
    ctx,
    /*$$scope*/
    ctx[62],
    get_expanded_row_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (expanded_row_slot) expanded_row_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (expanded_row_slot) expanded_row_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--child-row-inner-container", true);
      add_location(div, file55, 523, 16, 18020);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (expanded_row_slot) {
        expanded_row_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (expanded_row_slot) {
        if (expanded_row_slot.p && (!current || dirty[0] & /*sorting, displayedSortedRows, displayedRows*/
        201850880 | dirty[2] & /*$$scope*/
        1)) {
          update_slot_base(
            expanded_row_slot,
            expanded_row_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[62],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[62]
            ) : get_slot_changes(
              expanded_row_slot_template,
              /*$$scope*/
              ctx2[62],
              dirty,
              get_expanded_row_slot_changes
            ),
            get_expanded_row_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(expanded_row_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(expanded_row_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (expanded_row_slot) expanded_row_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_32.name,
    type: "slot",
    source: '(521:14) <TableCell                 colspan=\\"{selectable ? headers.length + 2 : headers.length + 1}\\"               >',
    ctx
  });
  return block;
}
function create_each_block6(key_1, ctx) {
  let first;
  let tablerow;
  let t;
  let if_block_anchor;
  let current;
  function click_handler_4(...args) {
    return (
      /*click_handler_4*/
      ctx[57](
        /*row*/
        ctx[66],
        ...args
      )
    );
  }
  function mouseenter_handler() {
    return (
      /*mouseenter_handler*/
      ctx[58](
        /*row*/
        ctx[66]
      )
    );
  }
  function mouseleave_handler() {
    return (
      /*mouseleave_handler*/
      ctx[59](
        /*row*/
        ctx[66]
      )
    );
  }
  tablerow = new TableRow_default({
    props: {
      "data-row": (
        /*row*/
        ctx[66].id
      ),
      "data-parent-row": (
        /*expandable*/
        ctx[4] ? true : void 0
      ),
      class: (
        /*selectedRowIds*/
        (ctx[3].includes(
          /*row*/
          ctx[66].id
        ) ? "bx--data-table--selected" : "") + " " + /*expandedRows*/
        (ctx[31][
          /*row*/
          ctx[66].id
        ] ? "bx--expandable-row" : "") + " " + /*expandable*/
        (ctx[4] ? "bx--parent-row" : "") + " " + /*expandable*/
        (ctx[4] && /*parentRowId*/
        ctx[23] === /*row*/
        ctx[66].id ? "bx--expandable-row--hover" : "")
      ),
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tablerow.$on("click", click_handler_4);
  tablerow.$on("mouseenter", mouseenter_handler);
  tablerow.$on("mouseleave", mouseleave_handler);
  let if_block = (
    /*expandable*/
    ctx[4] && create_if_block33(ctx)
  );
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(tablerow.$$.fragment);
      t = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(tablerow.$$.fragment, nodes);
      t = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(tablerow, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const tablerow_changes = {};
      if (dirty[0] & /*sorting, displayedSortedRows, displayedRows*/
      201850880) tablerow_changes["data-row"] = /*row*/
      ctx[66].id;
      if (dirty[0] & /*expandable*/
      16) tablerow_changes["data-parent-row"] = /*expandable*/
      ctx[4] ? true : void 0;
      if (dirty[0] & /*selectedRowIds, sorting, displayedSortedRows, displayedRows, expandable, parentRowId*/
      210239512 | dirty[1] & /*expandedRows*/
      1) tablerow_changes.class = /*selectedRowIds*/
      (ctx[3].includes(
        /*row*/
        ctx[66].id
      ) ? "bx--data-table--selected" : "") + " " + /*expandedRows*/
      (ctx[31][
        /*row*/
        ctx[66].id
      ] ? "bx--expandable-row" : "") + " " + /*expandable*/
      (ctx[4] ? "bx--parent-row" : "") + " " + /*expandable*/
      (ctx[4] && /*parentRowId*/
      ctx[23] === /*row*/
      ctx[66].id ? "bx--expandable-row--hover" : "");
      if (dirty[0] & /*tableCellsByRowId, sorting, displayedSortedRows, displayedRows, headers, radio, selectedRowIds, nonSelectableRowIds, selectable, nonExpandableRowIds, expandedRowIds, expandable*/
      470376572 | dirty[1] & /*expandedRows*/
      1 | dirty[2] & /*$$scope*/
      1) {
        tablerow_changes.$$scope = { dirty, ctx };
      }
      tablerow.$set(tablerow_changes);
      if (
        /*expandable*/
        ctx[4]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*expandable*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block33(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(tablerow.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablerow.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      destroy_component(tablerow, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(373:6) {#each sorting ? displayedSortedRows : displayedRows as row, i (row.id)}",
    ctx
  });
  return block;
}
function create_default_slot_23(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*sorting*/
    ctx[19] ? (
      /*displayedSortedRows*/
      ctx[26]
    ) : (
      /*displayedRows*/
      ctx[27]
    )
  );
  const get_key = (ctx2) => (
    /*row*/
    ctx2[66].id
  );
  validate_each_keys(ctx, each_value, get_each_context6, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context6(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block6(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*nonExpandableRowIds, sorting, displayedSortedRows, displayedRows, parentRowId, selectable, headers, expandable, selectedRowIds, tableCellsByRowId, radio, nonSelectableRowIds, expandedRowIds*/
      478765180 | dirty[1] & /*expandedRows, dispatch*/
      9 | dirty[2] & /*$$scope*/
      1) {
        each_value = ensure_array_like_dev(
          /*sorting*/
          ctx2[19] ? (
            /*displayedSortedRows*/
            ctx2[26]
          ) : (
            /*displayedRows*/
            ctx2[27]
          )
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context6, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block6, each_1_anchor, get_each_context6);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_23.name,
    type: "slot",
    source: "(372:4) <TableBody>",
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let tablehead;
  let t;
  let tablebody;
  let current;
  tablehead = new TableHead_default({
    props: {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tablebody = new TableBody_default({
    props: {
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tablehead.$$.fragment);
      t = space();
      create_component(tablebody.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tablehead.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tablebody.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tablehead, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tablebody, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tablehead_changes = {};
      if (dirty[0] & /*headers, sortable, sortKey, sortDirection, selectAll, indeterminate, refSelectAll, selectedRowIds, selectableRowIds, batchSelection, radio, selectable, expanded, expandedRowIds, expandableRowIds, batchExpansion, expandable*/
      1634785407 | dirty[1] & /*thKeys*/
      2 | dirty[2] & /*$$scope*/
      1) {
        tablehead_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablehead.$set(tablehead_changes);
      const tablebody_changes = {};
      if (dirty[0] & /*sorting, displayedSortedRows, displayedRows, nonExpandableRowIds, parentRowId, selectable, headers, expandable, selectedRowIds, tableCellsByRowId, radio, nonSelectableRowIds, expandedRowIds*/
      478765180 | dirty[1] & /*expandedRows*/
      1 | dirty[2] & /*$$scope*/
      1) {
        tablebody_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablebody.$set(tablebody_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(tablehead.$$.fragment, local);
      transition_in(tablebody.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablehead.$$.fragment, local);
      transition_out(tablebody.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(tablehead, detaching);
      destroy_component(tablebody, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: `(277:2) <Table     zebra=\\"{zebra}\\"     size=\\"{size}\\"     stickyHeader=\\"{stickyHeader}\\"     sortable=\\"{sortable}\\"     useStaticWidth=\\"{useStaticWidth}\\"     tableStyle=\\"{hasCustomHeaderWidth && 'table-layout: fixed'}\\"   >`,
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let t0;
  let t1;
  let table;
  let current;
  let if_block = (
    /*title*/
    (ctx[8] || /*$$slots*/
    ctx[38].title || /*description*/
    ctx[9] || /*$$slots*/
    ctx[38].description) && create_if_block_132(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[48].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[62],
    null
  );
  table = new Table_default({
    props: {
      zebra: (
        /*zebra*/
        ctx[10]
      ),
      size: (
        /*size*/
        ctx[7]
      ),
      stickyHeader: (
        /*stickyHeader*/
        ctx[17]
      ),
      sortable: (
        /*sortable*/
        ctx[11]
      ),
      useStaticWidth: (
        /*useStaticWidth*/
        ctx[18]
      ),
      tableStyle: (
        /*hasCustomHeaderWidth*/
        ctx[25] && "table-layout: fixed"
      ),
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      t0 = space();
      if (default_slot) default_slot.c();
      t1 = space();
      create_component(table.$$.fragment);
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      t0 = claim_space(nodes);
      if (default_slot) default_slot.l(nodes);
      t1 = claim_space(nodes);
      claim_component(table.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t1, anchor);
      mount_component(table, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*title*/
        ctx2[8] || /*$$slots*/
        ctx2[38].title || /*description*/
        ctx2[9] || /*$$slots*/
        ctx2[38].description
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*title, description*/
          768 | dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_132(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[62],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[62]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[62],
              dirty,
              null
            ),
            null
          );
        }
      }
      const table_changes = {};
      if (dirty[0] & /*zebra*/
      1024) table_changes.zebra = /*zebra*/
      ctx2[10];
      if (dirty[0] & /*size*/
      128) table_changes.size = /*size*/
      ctx2[7];
      if (dirty[0] & /*stickyHeader*/
      131072) table_changes.stickyHeader = /*stickyHeader*/
      ctx2[17];
      if (dirty[0] & /*sortable*/
      2048) table_changes.sortable = /*sortable*/
      ctx2[11];
      if (dirty[0] & /*useStaticWidth*/
      262144) table_changes.useStaticWidth = /*useStaticWidth*/
      ctx2[18];
      if (dirty[0] & /*hasCustomHeaderWidth*/
      33554432) table_changes.tableStyle = /*hasCustomHeaderWidth*/
      ctx2[25] && "table-layout: fixed";
      if (dirty[0] & /*sorting, displayedSortedRows, displayedRows, nonExpandableRowIds, parentRowId, selectable, headers, expandable, selectedRowIds, tableCellsByRowId, radio, nonSelectableRowIds, expandedRowIds, sortable, sortKey, sortDirection, selectAll, indeterminate, refSelectAll, selectableRowIds, batchSelection, expanded, expandableRowIds, batchExpansion*/
      2113534079 | dirty[1] & /*expandedRows, thKeys*/
      3 | dirty[2] & /*$$scope*/
      1) {
        table_changes.$$scope = { dirty, ctx: ctx2 };
      }
      table.$set(table_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(default_slot, local);
      transition_in(table.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      transition_out(table.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      if (if_block) if_block.d(detaching);
      if (default_slot) default_slot.d(detaching);
      destroy_component(table, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: '(261:0) <TableContainer useStaticWidth=\\"{useStaticWidth}\\" {...$$restProps}>',
    ctx
  });
  return block;
}
function create_fragment56(ctx) {
  let tablecontainer;
  let current;
  const tablecontainer_spread_levels = [
    {
      useStaticWidth: (
        /*useStaticWidth*/
        ctx[18]
      )
    },
    /*$$restProps*/
    ctx[37]
  ];
  let tablecontainer_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < tablecontainer_spread_levels.length; i += 1) {
    tablecontainer_props = assign(tablecontainer_props, tablecontainer_spread_levels[i]);
  }
  tablecontainer = new TableContainer_default({
    props: tablecontainer_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tablecontainer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tablecontainer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tablecontainer, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tablecontainer_changes = dirty[0] & /*useStaticWidth*/
      262144 | dirty[1] & /*$$restProps*/
      64 ? get_spread_update(tablecontainer_spread_levels, [
        dirty[0] & /*useStaticWidth*/
        262144 && {
          useStaticWidth: (
            /*useStaticWidth*/
            ctx2[18]
          )
        },
        dirty[1] & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[37]
        )
      ]) : {};
      if (dirty[0] & /*zebra, size, stickyHeader, sortable, useStaticWidth, hasCustomHeaderWidth, sorting, displayedSortedRows, displayedRows, nonExpandableRowIds, parentRowId, selectable, headers, expandable, selectedRowIds, tableCellsByRowId, radio, nonSelectableRowIds, expandedRowIds, sortKey, sortDirection, selectAll, indeterminate, refSelectAll, selectableRowIds, batchSelection, expanded, expandableRowIds, batchExpansion, description, title*/
      2147483647 | dirty[1] & /*expandedRows, thKeys, $$slots*/
      131 | dirty[2] & /*$$scope*/
      1) {
        tablecontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablecontainer.$set(tablecontainer_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(tablecontainer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablecontainer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tablecontainer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance56($$self, $$props, $$invalidate) {
  let thKeys;
  let expandedRows;
  let rowIds;
  let expandableRowIds;
  let selectableRowIds;
  let selectAll;
  let indeterminate;
  let headerKeys;
  let tableCellsByRowId;
  let sortedRows;
  let ascending;
  let sorting;
  let sortingHeader;
  let displayedRows;
  let displayedSortedRows;
  let hasCustomHeaderWidth;
  const omit_props_names = [
    "headers",
    "rows",
    "size",
    "title",
    "description",
    "zebra",
    "sortable",
    "sortKey",
    "sortDirection",
    "expandable",
    "batchExpansion",
    "expandedRowIds",
    "nonExpandableRowIds",
    "radio",
    "selectable",
    "batchSelection",
    "selectedRowIds",
    "nonSelectableRowIds",
    "stickyHeader",
    "useStaticWidth",
    "pageSize",
    "page"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $tableRows;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DataTable", slots, ["title", "description", "default", "cell-header", "cell", "expanded-row"]);
  const $$slots = compute_slots(slots);
  let { headers = [] } = $$props;
  let { rows = [] } = $$props;
  let { size = void 0 } = $$props;
  let { title = "" } = $$props;
  let { description = "" } = $$props;
  let { zebra = false } = $$props;
  let { sortable = false } = $$props;
  let { sortKey = null } = $$props;
  let { sortDirection = "none" } = $$props;
  let { expandable = false } = $$props;
  let { batchExpansion = false } = $$props;
  let { expandedRowIds = [] } = $$props;
  let { nonExpandableRowIds = [] } = $$props;
  let { radio = false } = $$props;
  let { selectable = false } = $$props;
  let { batchSelection = false } = $$props;
  let { selectedRowIds = [] } = $$props;
  let { nonSelectableRowIds = [] } = $$props;
  let { stickyHeader = false } = $$props;
  let { useStaticWidth = false } = $$props;
  let { pageSize = 0 } = $$props;
  let { page = 0 } = $$props;
  const sortDirectionMap = {
    none: "ascending",
    ascending: "descending",
    descending: "none"
  };
  const dispatch = createEventDispatcher();
  const batchSelectedIds = writable(false);
  const tableRows = writable(rows);
  validate_store(tableRows, "tableRows");
  component_subscribe($$self, tableRows, (value) => $$invalidate(47, $tableRows = value));
  const resolvePath = (object, path) => {
    if (path in object) return object[path];
    return path.split(/[\.\[\]\'\"]/).filter((p) => p).reduce((o, p) => o && typeof o === "object" ? o[p] : o, object);
  };
  setContext("DataTable", {
    batchSelectedIds,
    tableRows,
    resetSelectedRowIds: () => {
      $$invalidate(30, selectAll = false);
      $$invalidate(3, selectedRowIds = []);
      if (refSelectAll) $$invalidate(24, refSelectAll.checked = false, refSelectAll);
    }
  });
  let expanded = false;
  let parentRowId = null;
  let refSelectAll = null;
  const getDisplayedRows = (rows2, page2, pageSize2) => page2 && pageSize2 ? rows2.slice((page2 - 1) * pageSize2, page2 * pageSize2) : rows2;
  const formatHeaderWidth = (header) => {
    const styles = [
      header.width && `width: ${header.width}`,
      header.minWidth && `min-width: ${header.minWidth}`
    ].filter(Boolean);
    if (styles.length === 0) return void 0;
    return styles.join(";");
  };
  const click_handler = () => {
    $$invalidate(22, expanded = !expanded);
    $$invalidate(2, expandedRowIds = expanded ? expandableRowIds : []);
    dispatch("click:header--expand", { expanded });
  };
  function inlinecheckbox_ref_binding(value) {
    refSelectAll = value;
    $$invalidate(24, refSelectAll);
  }
  const change_handler = (e) => {
    dispatch("click:header--select", {
      indeterminate,
      selected: !indeterminate && e.target.checked
    });
    if (indeterminate) {
      e.target.checked = false;
      $$invalidate(30, selectAll = false);
      $$invalidate(3, selectedRowIds = []);
      return;
    }
    if (e.target.checked) {
      $$invalidate(3, selectedRowIds = selectableRowIds);
    } else {
      $$invalidate(3, selectedRowIds = []);
    }
  };
  const click_handler_13 = (header) => {
    dispatch("click", { header });
    if (header.sort === false) {
      dispatch("click:header", { header });
    } else {
      let currentSortDirection = sortKey === header.key ? sortDirection : "none";
      $$invalidate(1, sortDirection = sortDirectionMap[currentSortDirection]);
      $$invalidate(0, sortKey = sortDirection === "none" ? null : thKeys[header.key]);
      dispatch("click:header", { header, sortDirection });
    }
  };
  const click_handler_2 = (row) => {
    const rowExpanded = !!expandedRows[row.id];
    $$invalidate(2, expandedRowIds = rowExpanded ? expandedRowIds.filter((id) => id !== row.id) : [...expandedRowIds, row.id]);
    dispatch("click:row--expand", { row, expanded: !rowExpanded });
  };
  const change_handler_1 = (row) => {
    $$invalidate(3, selectedRowIds = [row.id]);
    dispatch("click:row--select", { row, selected: true });
  };
  const change_handler_2 = (row) => {
    if (selectedRowIds.includes(row.id)) {
      $$invalidate(3, selectedRowIds = selectedRowIds.filter((id) => id !== row.id));
      dispatch("click:row--select", { row, selected: false });
    } else {
      $$invalidate(3, selectedRowIds = [...selectedRowIds, row.id]);
      dispatch("click:row--select", { row, selected: true });
    }
  };
  const click_handler_3 = (row, cell) => {
    dispatch("click", { row, cell });
    dispatch("click:cell", cell);
  };
  const click_handler_4 = (row, { target }) => {
    if ([...target.classList].some((name) => /^bx--(overflow-menu|checkbox|radio-button)/.test(name))) {
      return;
    }
    dispatch("click", { row });
    dispatch("click:row", row);
  };
  const mouseenter_handler = (row) => {
    dispatch("mouseenter:row", row);
  };
  const mouseleave_handler = (row) => {
    dispatch("mouseleave:row", row);
  };
  const mouseenter_handler_1 = (row) => {
    if (nonExpandableRowIds.includes(row.id)) return;
    $$invalidate(23, parentRowId = row.id);
  };
  const mouseleave_handler_1 = (row) => {
    if (nonExpandableRowIds.includes(row.id)) return;
    $$invalidate(23, parentRowId = null);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(37, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("headers" in $$new_props) $$invalidate(6, headers = $$new_props.headers);
    if ("rows" in $$new_props) $$invalidate(39, rows = $$new_props.rows);
    if ("size" in $$new_props) $$invalidate(7, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(8, title = $$new_props.title);
    if ("description" in $$new_props) $$invalidate(9, description = $$new_props.description);
    if ("zebra" in $$new_props) $$invalidate(10, zebra = $$new_props.zebra);
    if ("sortable" in $$new_props) $$invalidate(11, sortable = $$new_props.sortable);
    if ("sortKey" in $$new_props) $$invalidate(0, sortKey = $$new_props.sortKey);
    if ("sortDirection" in $$new_props) $$invalidate(1, sortDirection = $$new_props.sortDirection);
    if ("expandable" in $$new_props) $$invalidate(4, expandable = $$new_props.expandable);
    if ("batchExpansion" in $$new_props) $$invalidate(12, batchExpansion = $$new_props.batchExpansion);
    if ("expandedRowIds" in $$new_props) $$invalidate(2, expandedRowIds = $$new_props.expandedRowIds);
    if ("nonExpandableRowIds" in $$new_props) $$invalidate(13, nonExpandableRowIds = $$new_props.nonExpandableRowIds);
    if ("radio" in $$new_props) $$invalidate(14, radio = $$new_props.radio);
    if ("selectable" in $$new_props) $$invalidate(5, selectable = $$new_props.selectable);
    if ("batchSelection" in $$new_props) $$invalidate(15, batchSelection = $$new_props.batchSelection);
    if ("selectedRowIds" in $$new_props) $$invalidate(3, selectedRowIds = $$new_props.selectedRowIds);
    if ("nonSelectableRowIds" in $$new_props) $$invalidate(16, nonSelectableRowIds = $$new_props.nonSelectableRowIds);
    if ("stickyHeader" in $$new_props) $$invalidate(17, stickyHeader = $$new_props.stickyHeader);
    if ("useStaticWidth" in $$new_props) $$invalidate(18, useStaticWidth = $$new_props.useStaticWidth);
    if ("pageSize" in $$new_props) $$invalidate(40, pageSize = $$new_props.pageSize);
    if ("page" in $$new_props) $$invalidate(41, page = $$new_props.page);
    if ("$$scope" in $$new_props) $$invalidate(62, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    headers,
    rows,
    size,
    title,
    description,
    zebra,
    sortable,
    sortKey,
    sortDirection,
    expandable,
    batchExpansion,
    expandedRowIds,
    nonExpandableRowIds,
    radio,
    selectable,
    batchSelection,
    selectedRowIds,
    nonSelectableRowIds,
    stickyHeader,
    useStaticWidth,
    pageSize,
    page,
    createEventDispatcher,
    setContext,
    writable,
    ChevronRight: ChevronRight_default,
    InlineCheckbox: InlineCheckbox_default,
    RadioButton: RadioButton_default,
    Table: Table_default,
    TableBody: TableBody_default,
    TableCell: TableCell_default,
    TableContainer: TableContainer_default,
    TableHead: TableHead_default,
    TableHeader: TableHeader_default,
    TableRow: TableRow_default,
    sortDirectionMap,
    dispatch,
    batchSelectedIds,
    tableRows,
    resolvePath,
    expanded,
    parentRowId,
    refSelectAll,
    getDisplayedRows,
    formatHeaderWidth,
    hasCustomHeaderWidth,
    sortedRows,
    displayedSortedRows,
    displayedRows,
    ascending,
    sortingHeader,
    sorting,
    headerKeys,
    tableCellsByRowId,
    expandableRowIds,
    selectableRowIds,
    indeterminate,
    selectAll,
    rowIds,
    expandedRows,
    thKeys,
    $tableRows
  });
  $$self.$inject_state = ($$new_props) => {
    if ("headers" in $$props) $$invalidate(6, headers = $$new_props.headers);
    if ("rows" in $$props) $$invalidate(39, rows = $$new_props.rows);
    if ("size" in $$props) $$invalidate(7, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(8, title = $$new_props.title);
    if ("description" in $$props) $$invalidate(9, description = $$new_props.description);
    if ("zebra" in $$props) $$invalidate(10, zebra = $$new_props.zebra);
    if ("sortable" in $$props) $$invalidate(11, sortable = $$new_props.sortable);
    if ("sortKey" in $$props) $$invalidate(0, sortKey = $$new_props.sortKey);
    if ("sortDirection" in $$props) $$invalidate(1, sortDirection = $$new_props.sortDirection);
    if ("expandable" in $$props) $$invalidate(4, expandable = $$new_props.expandable);
    if ("batchExpansion" in $$props) $$invalidate(12, batchExpansion = $$new_props.batchExpansion);
    if ("expandedRowIds" in $$props) $$invalidate(2, expandedRowIds = $$new_props.expandedRowIds);
    if ("nonExpandableRowIds" in $$props) $$invalidate(13, nonExpandableRowIds = $$new_props.nonExpandableRowIds);
    if ("radio" in $$props) $$invalidate(14, radio = $$new_props.radio);
    if ("selectable" in $$props) $$invalidate(5, selectable = $$new_props.selectable);
    if ("batchSelection" in $$props) $$invalidate(15, batchSelection = $$new_props.batchSelection);
    if ("selectedRowIds" in $$props) $$invalidate(3, selectedRowIds = $$new_props.selectedRowIds);
    if ("nonSelectableRowIds" in $$props) $$invalidate(16, nonSelectableRowIds = $$new_props.nonSelectableRowIds);
    if ("stickyHeader" in $$props) $$invalidate(17, stickyHeader = $$new_props.stickyHeader);
    if ("useStaticWidth" in $$props) $$invalidate(18, useStaticWidth = $$new_props.useStaticWidth);
    if ("pageSize" in $$props) $$invalidate(40, pageSize = $$new_props.pageSize);
    if ("page" in $$props) $$invalidate(41, page = $$new_props.page);
    if ("expanded" in $$props) $$invalidate(22, expanded = $$new_props.expanded);
    if ("parentRowId" in $$props) $$invalidate(23, parentRowId = $$new_props.parentRowId);
    if ("refSelectAll" in $$props) $$invalidate(24, refSelectAll = $$new_props.refSelectAll);
    if ("hasCustomHeaderWidth" in $$props) $$invalidate(25, hasCustomHeaderWidth = $$new_props.hasCustomHeaderWidth);
    if ("sortedRows" in $$props) $$invalidate(42, sortedRows = $$new_props.sortedRows);
    if ("displayedSortedRows" in $$props) $$invalidate(26, displayedSortedRows = $$new_props.displayedSortedRows);
    if ("displayedRows" in $$props) $$invalidate(27, displayedRows = $$new_props.displayedRows);
    if ("ascending" in $$props) $$invalidate(43, ascending = $$new_props.ascending);
    if ("sortingHeader" in $$props) $$invalidate(44, sortingHeader = $$new_props.sortingHeader);
    if ("sorting" in $$props) $$invalidate(19, sorting = $$new_props.sorting);
    if ("headerKeys" in $$props) $$invalidate(45, headerKeys = $$new_props.headerKeys);
    if ("tableCellsByRowId" in $$props) $$invalidate(28, tableCellsByRowId = $$new_props.tableCellsByRowId);
    if ("expandableRowIds" in $$props) $$invalidate(20, expandableRowIds = $$new_props.expandableRowIds);
    if ("selectableRowIds" in $$props) $$invalidate(21, selectableRowIds = $$new_props.selectableRowIds);
    if ("indeterminate" in $$props) $$invalidate(29, indeterminate = $$new_props.indeterminate);
    if ("selectAll" in $$props) $$invalidate(30, selectAll = $$new_props.selectAll);
    if ("rowIds" in $$props) $$invalidate(46, rowIds = $$new_props.rowIds);
    if ("expandedRows" in $$props) $$invalidate(31, expandedRows = $$new_props.expandedRows);
    if ("thKeys" in $$props) $$invalidate(32, thKeys = $$new_props.thKeys);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*headers*/
    64) {
      $: $$invalidate(32, thKeys = headers.reduce((a, c) => ({ ...a, [c.key]: c.key }), {}));
    }
    if ($$self.$$.dirty[0] & /*expandedRowIds*/
    4) {
      $: $$invalidate(31, expandedRows = expandedRowIds.reduce((a, id) => ({ ...a, [id]: true }), {}));
    }
    if ($$self.$$.dirty[0] & /*selectedRowIds*/
    8) {
      $: batchSelectedIds.set(selectedRowIds);
    }
    if ($$self.$$.dirty[0] & /*headers*/
    64) {
      $: $$invalidate(45, headerKeys = headers.map(({ key }) => key));
    }
    if ($$self.$$.dirty[0] & /*headers*/
    64 | $$self.$$.dirty[1] & /*rows, headerKeys*/
    16640) {
      $: $$invalidate(28, tableCellsByRowId = rows.reduce(
        (rows2, row) => {
          rows2[row.id] = headerKeys.map((key, index) => ({
            key,
            value: resolvePath(row, key),
            display: headers[index].display
          }));
          return rows2;
        },
        {}
      ));
    }
    if ($$self.$$.dirty[1] & /*rows*/
    256) {
      $: set_store_value(tableRows, $tableRows = rows, $tableRows);
    }
    if ($$self.$$.dirty[1] & /*$tableRows*/
    65536) {
      $: $$invalidate(46, rowIds = $tableRows.map((row) => row.id));
    }
    if ($$self.$$.dirty[0] & /*nonExpandableRowIds*/
    8192 | $$self.$$.dirty[1] & /*rowIds*/
    32768) {
      $: $$invalidate(20, expandableRowIds = rowIds.filter((id) => !nonExpandableRowIds.includes(id)));
    }
    if ($$self.$$.dirty[0] & /*nonSelectableRowIds*/
    65536 | $$self.$$.dirty[1] & /*rowIds*/
    32768) {
      $: $$invalidate(21, selectableRowIds = rowIds.filter((id) => !nonSelectableRowIds.includes(id)));
    }
    if ($$self.$$.dirty[0] & /*selectableRowIds, selectedRowIds*/
    2097160) {
      $: $$invalidate(30, selectAll = selectableRowIds.length > 0 && selectedRowIds.length === selectableRowIds.length);
    }
    if ($$self.$$.dirty[0] & /*selectedRowIds, selectableRowIds*/
    2097160) {
      $: $$invalidate(29, indeterminate = selectedRowIds.length > 0 && selectedRowIds.length < selectableRowIds.length);
    }
    if ($$self.$$.dirty[0] & /*batchExpansion, expandedRowIds, expandableRowIds*/
    1052676) {
      $: if (batchExpansion) {
        $$invalidate(4, expandable = true);
        $$invalidate(22, expanded = expandedRowIds.length === expandableRowIds.length);
      }
    }
    if ($$self.$$.dirty[0] & /*radio, batchSelection*/
    49152) {
      $: if (radio || batchSelection) $$invalidate(5, selectable = true);
    }
    if ($$self.$$.dirty[1] & /*$tableRows*/
    65536) {
      $: $$invalidate(42, sortedRows = [...$tableRows]);
    }
    if ($$self.$$.dirty[0] & /*sortDirection*/
    2) {
      $: $$invalidate(43, ascending = sortDirection === "ascending");
    }
    if ($$self.$$.dirty[0] & /*sortable, sortKey*/
    2049) {
      $: $$invalidate(19, sorting = sortable && sortKey != null);
    }
    if ($$self.$$.dirty[0] & /*headers, sortKey*/
    65) {
      $: $$invalidate(44, sortingHeader = headers.find((header) => header.key === sortKey));
    }
    if ($$self.$$.dirty[0] & /*sorting, sortDirection, sortKey*/
    524291 | $$self.$$.dirty[1] & /*$tableRows, ascending, sortingHeader*/
    77824) {
      $: if (sorting) {
        if (sortDirection === "none") {
          $$invalidate(42, sortedRows = $tableRows);
        } else {
          $$invalidate(42, sortedRows = [...$tableRows].sort((a, b) => {
            const itemA = ascending ? resolvePath(a, sortKey) : resolvePath(b, sortKey);
            const itemB = ascending ? resolvePath(b, sortKey) : resolvePath(a, sortKey);
            if (sortingHeader == null ? void 0 : sortingHeader.sort) return sortingHeader.sort(itemA, itemB);
            if (typeof itemA === "number" && typeof itemB === "number") return itemA - itemB;
            if ([itemA, itemB].every((item) => !item && item !== 0)) return 0;
            if (!itemA && itemA !== 0) return ascending ? 1 : -1;
            if (!itemB && itemB !== 0) return ascending ? -1 : 1;
            return itemA.toString().localeCompare(itemB.toString(), "en", { numeric: true });
          }));
        }
      }
    }
    if ($$self.$$.dirty[1] & /*$tableRows, page, pageSize*/
    67072) {
      $: $$invalidate(27, displayedRows = getDisplayedRows($tableRows, page, pageSize));
    }
    if ($$self.$$.dirty[1] & /*sortedRows, page, pageSize*/
    3584) {
      $: $$invalidate(26, displayedSortedRows = getDisplayedRows(sortedRows, page, pageSize));
    }
    if ($$self.$$.dirty[0] & /*headers*/
    64) {
      $: $$invalidate(25, hasCustomHeaderWidth = headers.some((header) => header.width || header.minWidth));
    }
  };
  return [
    sortKey,
    sortDirection,
    expandedRowIds,
    selectedRowIds,
    expandable,
    selectable,
    headers,
    size,
    title,
    description,
    zebra,
    sortable,
    batchExpansion,
    nonExpandableRowIds,
    radio,
    batchSelection,
    nonSelectableRowIds,
    stickyHeader,
    useStaticWidth,
    sorting,
    expandableRowIds,
    selectableRowIds,
    expanded,
    parentRowId,
    refSelectAll,
    hasCustomHeaderWidth,
    displayedSortedRows,
    displayedRows,
    tableCellsByRowId,
    indeterminate,
    selectAll,
    expandedRows,
    thKeys,
    sortDirectionMap,
    dispatch,
    tableRows,
    formatHeaderWidth,
    $$restProps,
    $$slots,
    rows,
    pageSize,
    page,
    sortedRows,
    ascending,
    sortingHeader,
    headerKeys,
    rowIds,
    $tableRows,
    slots,
    click_handler,
    inlinecheckbox_ref_binding,
    change_handler,
    click_handler_13,
    click_handler_2,
    change_handler_1,
    change_handler_2,
    click_handler_3,
    click_handler_4,
    mouseenter_handler,
    mouseleave_handler,
    mouseenter_handler_1,
    mouseleave_handler_1,
    $$scope
  ];
}
var DataTable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance56,
      create_fragment56,
      safe_not_equal,
      {
        headers: 6,
        rows: 39,
        size: 7,
        title: 8,
        description: 9,
        zebra: 10,
        sortable: 11,
        sortKey: 0,
        sortDirection: 1,
        expandable: 4,
        batchExpansion: 12,
        expandedRowIds: 2,
        nonExpandableRowIds: 13,
        radio: 14,
        selectable: 5,
        batchSelection: 15,
        selectedRowIds: 3,
        nonSelectableRowIds: 16,
        stickyHeader: 17,
        useStaticWidth: 18,
        pageSize: 40,
        page: 41
      },
      null,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DataTable",
      options,
      id: create_fragment56.name
    });
  }
  get headers() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headers(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zebra() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zebra(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortable() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortable(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortKey() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortKey(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortDirection() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortDirection(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandable() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandable(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get batchExpansion() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set batchExpansion(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandedRowIds() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandedRowIds(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonExpandableRowIds() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonExpandableRowIds(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radio() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radio(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectable() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectable(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get batchSelection() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set batchSelection(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedRowIds() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedRowIds(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonSelectableRowIds() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonSelectableRowIds(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stickyHeader() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stickyHeader(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useStaticWidth() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useStaticWidth(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageSize() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageSize(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get page() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set page(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DataTable_default = DataTable;

// node_modules/carbon-components-svelte/src/DataTable/DataTableSkeleton.svelte
var file56 = "node_modules/carbon-components-svelte/src/DataTable/DataTableSkeleton.svelte";
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function get_each_context_22(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function create_if_block_28(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", {});
      children(div0).forEach(detach_dev);
      t = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", {});
      children(div1).forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--data-table-header__title", true);
      add_location(div0, file56, 51, 6, 1266);
      toggle_class(div1, "bx--data-table-header__description", true);
      add_location(div1, file56, 52, 6, 1328);
      toggle_class(div2, "bx--data-table-header", true);
      add_location(div2, file56, 50, 4, 1217);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div2, t);
      append_hydration_dev(div2, div1);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(50:2) {#if showHeader}",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let section;
  let div;
  let span;
  const block = {
    c: function create() {
      section = element("section");
      div = element("div");
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", { "aria-label": true });
      var section_nodes = children(section);
      div = claim_element(section_nodes, "DIV", {});
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--skeleton", true);
      toggle_class(span, "bx--btn", true);
      toggle_class(span, "bx--btn--sm", true);
      add_location(span, file56, 58, 8, 1563);
      toggle_class(div, "bx--toolbar-content", true);
      add_location(div, file56, 57, 6, 1514);
      attr_dev(section, "aria-label", "data table toolbar");
      toggle_class(section, "bx--table-toolbar", true);
      add_location(section, file56, 56, 4, 1433);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      append_hydration_dev(section, div);
      append_hydration_dev(div, span);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(section);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(56:2) {#if showToolbar}",
    ctx
  });
  return block;
}
function create_else_block15(ctx) {
  let th;
  let t_value = (
    /*values*/
    (ctx[6][
      /*col*/
      ctx[17]
    ] || "") + ""
  );
  let t;
  const block = {
    c: function create() {
      th = element("th");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", {});
      var th_nodes = children(th);
      t = claim_text(th_nodes, t_value);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(th, file56, 85, 12, 2384);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*values, cols*/
      96 && t_value !== (t_value = /*values*/
      (ctx2[6][
        /*col*/
        ctx2[17]
      ] || "") + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block15.name,
    type: "else",
    source: "(85:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block34(ctx) {
  let th;
  const block = {
    c: function create() {
      th = element("th");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", {});
      children(th).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(th, file56, 83, 12, 2344);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block34.name,
    type: "if",
    source: '(83:10) {#if typeof values[col] === \\"object\\" && values[col].empty === true}',
    ctx
  });
  return block;
}
function create_each_block_22(key_1, ctx) {
  let first;
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (typeof /*values*/
    ctx2[6][
      /*col*/
      ctx2[17]
    ] === "object" && /*values*/
    ctx2[6][
      /*col*/
      ctx2[17]
    ].empty === true) return create_if_block34;
    return create_else_block15;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_22.name,
    type: "each",
    source: "(82:8) {#each cols as col (col)}",
    ctx
  });
  return block;
}
function create_each_block_12(key_1, ctx) {
  let td;
  let span;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      td = element("td");
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", {});
      var td_nodes = children(td);
      span = claim_element(td_nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file56, 94, 16, 2616);
      add_location(td, file56, 94, 12, 2612);
      this.first = td;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, span);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_12.name,
    type: "each",
    source: "(94:10) {#each cols as col (col)}",
    ctx
  });
  return block;
}
function create_each_block7(key_1, ctx) {
  let tr;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let each_value_1 = ensure_array_like_dev(
    /*cols*/
    ctx[5]
  );
  const get_key = (ctx2) => (
    /*col*/
    ctx2[17]
  );
  validate_each_keys(ctx, each_value_1, get_each_context_12, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_12(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_12(key, child_ctx));
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", {});
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file56, 92, 8, 2559);
      this.first = tr;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append_hydration_dev(tr, t);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*cols*/
      32) {
        each_value_1 = ensure_array_like_dev(
          /*cols*/
          ctx[5]
        );
        validate_each_keys(ctx, each_value_1, get_each_context_12, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, tr, destroy_block, create_each_block_12, t, get_each_context_12);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(92:6) {#each Array.from({ length: rows }, (_, i) => i) as row (row)}",
    ctx
  });
  return block;
}
function create_fragment57(ctx) {
  let div;
  let t0;
  let t1;
  let table;
  let thead;
  let tr;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t2;
  let tbody;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let if_block0 = (
    /*showHeader*/
    ctx[3] && create_if_block_28(ctx)
  );
  let if_block1 = (
    /*showToolbar*/
    ctx[4] && create_if_block_112(ctx)
  );
  let each_value_2 = ensure_array_like_dev(
    /*cols*/
    ctx[5]
  );
  const get_key = (ctx2) => (
    /*col*/
    ctx2[17]
  );
  validate_each_keys(ctx, each_value_2, get_each_context_22, get_key);
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_22(ctx, each_value_2, i);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_1[i] = create_each_block_22(key, child_ctx));
  }
  let each_value = ensure_array_like_dev(Array.from({ length: (
    /*rows*/
    ctx[0]
  ) }, func3));
  const get_key_1 = (ctx2) => (
    /*row*/
    ctx2[14]
  );
  validate_each_keys(ctx, each_value, get_each_context7, get_key_1);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context7(ctx, each_value, i);
    let key = get_key_1(child_ctx);
    each1_lookup.set(key, each_blocks[i] = create_each_block7(key, child_ctx));
  }
  let div_levels = [
    /*$$restProps*/
    ctx[7]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block0) if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1) if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      table = claim_element(div_nodes, "TABLE", {});
      var table_nodes = children(table);
      thead = claim_element(table_nodes, "THEAD", {});
      var thead_nodes = children(thead);
      tr = claim_element(thead_nodes, "TR", {});
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(tr_nodes);
      }
      tr_nodes.forEach(detach_dev);
      thead_nodes.forEach(detach_dev);
      t2 = claim_space(table_nodes);
      tbody = claim_element(table_nodes, "TBODY", {});
      var tbody_nodes = children(tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tbody_nodes);
      }
      tbody_nodes.forEach(detach_dev);
      table_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file56, 80, 6, 2215);
      add_location(thead, file56, 79, 4, 2201);
      add_location(tbody, file56, 90, 4, 2474);
      toggle_class(table, "bx--skeleton", true);
      toggle_class(table, "bx--data-table", true);
      toggle_class(
        table,
        "bx--data-table--compact",
        /*size*/
        ctx[1] === "compact"
      );
      toggle_class(
        table,
        "bx--data-table--short",
        /*size*/
        ctx[1] === "short"
      );
      toggle_class(
        table,
        "bx--data-table--tall",
        /*size*/
        ctx[1] === "tall"
      );
      toggle_class(
        table,
        "bx--data-table--zebra",
        /*zebra*/
        ctx[2]
      );
      add_location(table, file56, 67, 2, 1851);
      set_attributes(div, div_data);
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--data-table-container", true);
      add_location(div, file56, 44, 0, 1096);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if (if_block1) if_block1.m(div, null);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, table);
      append_hydration_dev(table, thead);
      append_hydration_dev(thead, tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(tr, null);
        }
      }
      append_hydration_dev(table, t2);
      append_hydration_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
      if (!mounted) {
        dispose = [
          listen_dev(
            table,
            "click",
            /*click_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            table,
            "mouseover",
            /*mouseover_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            table,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            table,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*showHeader*/
        ctx2[3]
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_28(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*showToolbar*/
        ctx2[4]
      ) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_112(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*values, cols*/
      96) {
        each_value_2 = ensure_array_like_dev(
          /*cols*/
          ctx2[5]
        );
        validate_each_keys(ctx2, each_value_2, get_each_context_22, get_key);
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_2, each0_lookup, tr, destroy_block, create_each_block_22, null, get_each_context_22);
      }
      if (dirty & /*cols, rows*/
      33) {
        each_value = ensure_array_like_dev(Array.from({ length: (
          /*rows*/
          ctx2[0]
        ) }, func3));
        validate_each_keys(ctx2, each_value, get_each_context7, get_key_1);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value, each1_lookup, tbody, destroy_block, create_each_block7, null, get_each_context7);
      }
      if (dirty & /*size*/
      2) {
        toggle_class(
          table,
          "bx--data-table--compact",
          /*size*/
          ctx2[1] === "compact"
        );
      }
      if (dirty & /*size*/
      2) {
        toggle_class(
          table,
          "bx--data-table--short",
          /*size*/
          ctx2[1] === "short"
        );
      }
      if (dirty & /*size*/
      2) {
        toggle_class(
          table,
          "bx--data-table--tall",
          /*size*/
          ctx2[1] === "tall"
        );
      }
      if (dirty & /*zebra*/
      4) {
        toggle_class(
          table,
          "bx--data-table--zebra",
          /*zebra*/
          ctx2[2]
        );
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      128 && /*$$restProps*/
      ctx2[7]]));
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--data-table-container", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func3 = (_, i) => i;
function instance57($$self, $$props, $$invalidate) {
  let values;
  let cols;
  const omit_props_names = ["columns", "rows", "size", "zebra", "showHeader", "headers", "showToolbar"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DataTableSkeleton", slots, []);
  let { columns = 5 } = $$props;
  let { rows = 5 } = $$props;
  let { size = void 0 } = $$props;
  let { zebra = false } = $$props;
  let { showHeader = true } = $$props;
  let { headers = [] } = $$props;
  let { showToolbar = true } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("columns" in $$new_props) $$invalidate(8, columns = $$new_props.columns);
    if ("rows" in $$new_props) $$invalidate(0, rows = $$new_props.rows);
    if ("size" in $$new_props) $$invalidate(1, size = $$new_props.size);
    if ("zebra" in $$new_props) $$invalidate(2, zebra = $$new_props.zebra);
    if ("showHeader" in $$new_props) $$invalidate(3, showHeader = $$new_props.showHeader);
    if ("headers" in $$new_props) $$invalidate(9, headers = $$new_props.headers);
    if ("showToolbar" in $$new_props) $$invalidate(4, showToolbar = $$new_props.showToolbar);
  };
  $$self.$capture_state = () => ({
    columns,
    rows,
    size,
    zebra,
    showHeader,
    headers,
    showToolbar,
    cols,
    values
  });
  $$self.$inject_state = ($$new_props) => {
    if ("columns" in $$props) $$invalidate(8, columns = $$new_props.columns);
    if ("rows" in $$props) $$invalidate(0, rows = $$new_props.rows);
    if ("size" in $$props) $$invalidate(1, size = $$new_props.size);
    if ("zebra" in $$props) $$invalidate(2, zebra = $$new_props.zebra);
    if ("showHeader" in $$props) $$invalidate(3, showHeader = $$new_props.showHeader);
    if ("headers" in $$props) $$invalidate(9, headers = $$new_props.headers);
    if ("showToolbar" in $$props) $$invalidate(4, showToolbar = $$new_props.showToolbar);
    if ("cols" in $$props) $$invalidate(5, cols = $$new_props.cols);
    if ("values" in $$props) $$invalidate(6, values = $$new_props.values);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*headers*/
    512) {
      $: $$invalidate(6, values = headers.map((header) => header.value !== void 0 ? header.value : header));
    }
    if ($$self.$$.dirty & /*headers, columns*/
    768) {
      $: $$invalidate(5, cols = Array.from(
        {
          length: headers.length > 0 ? headers.length : columns
        },
        (_, i) => i
      ));
    }
  };
  return [
    rows,
    size,
    zebra,
    showHeader,
    showToolbar,
    cols,
    values,
    $$restProps,
    columns,
    headers,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var DataTableSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment57, safe_not_equal, {
      columns: 8,
      rows: 0,
      size: 1,
      zebra: 2,
      showHeader: 3,
      headers: 9,
      showToolbar: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DataTableSkeleton",
      options,
      id: create_fragment57.name
    });
  }
  get columns() {
    throw new Error("<DataTableSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columns(value) {
    throw new Error("<DataTableSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error("<DataTableSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<DataTableSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<DataTableSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DataTableSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zebra() {
    throw new Error("<DataTableSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zebra(value) {
    throw new Error("<DataTableSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showHeader() {
    throw new Error("<DataTableSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showHeader(value) {
    throw new Error("<DataTableSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headers() {
    throw new Error("<DataTableSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headers(value) {
    throw new Error("<DataTableSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showToolbar() {
    throw new Error("<DataTableSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showToolbar(value) {
    throw new Error("<DataTableSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DataTableSkeleton_default = DataTableSkeleton;

// node_modules/carbon-components-svelte/src/DataTable/Toolbar.svelte
var file57 = "node_modules/carbon-components-svelte/src/DataTable/Toolbar.svelte";
function create_fragment58(ctx) {
  let section;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let section_levels = [
    { "aria-label": "data table toolbar" },
    /*$$restProps*/
    ctx[2]
  ];
  let section_data = {};
  for (let i = 0; i < section_levels.length; i += 1) {
    section_data = assign(section_data, section_levels[i]);
  }
  const block = {
    c: function create() {
      section = element("section");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", { "aria-label": true });
      var section_nodes = children(section);
      if (default_slot) default_slot.l(section_nodes);
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(section, section_data);
      toggle_class(section, "bx--table-toolbar", true);
      toggle_class(
        section,
        "bx--table-toolbar--small",
        /*size*/
        ctx[0] === "sm"
      );
      toggle_class(
        section,
        "bx--table-toolbar--normal",
        /*size*/
        ctx[0] === "default"
      );
      set_style(section, "z-index", 1);
      add_location(section, file57, 23, 0, 474);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      if (default_slot) {
        default_slot.m(section, null);
      }
      ctx[5](section);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(section, section_data = get_spread_update(section_levels, [
        { "aria-label": "data table toolbar" },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      toggle_class(section, "bx--table-toolbar", true);
      toggle_class(
        section,
        "bx--table-toolbar--small",
        /*size*/
        ctx2[0] === "sm"
      );
      toggle_class(
        section,
        "bx--table-toolbar--normal",
        /*size*/
        ctx2[0] === "default"
      );
      set_style(section, "z-index", 1);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(section);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[5](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance58($$self, $$props, $$invalidate) {
  const omit_props_names = ["size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toolbar", slots, ["default"]);
  let { size = "default" } = $$props;
  let ref = null;
  const overflowVisible = writable(false);
  setContext("Toolbar", {
    overflowVisible,
    setOverflowVisible: (visible) => {
      overflowVisible.set(visible);
      if (ref) $$invalidate(1, ref.style.overflow = visible ? "visible" : "inherit", ref);
    }
  });
  function section_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    setContext,
    writable,
    ref,
    overflowVisible
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, ref, $$restProps, $$scope, slots, section_binding];
}
var Toolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance58, create_fragment58, safe_not_equal, { size: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toolbar",
      options,
      id: create_fragment58.name
    });
  }
  get size() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toolbar_default = Toolbar;

// node_modules/carbon-components-svelte/src/DataTable/ToolbarContent.svelte
var file58 = "node_modules/carbon-components-svelte/src/DataTable/ToolbarContent.svelte";
function create_fragment59(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--toolbar-content", true);
      add_location(div, file58, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment59.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance59($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToolbarContent", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ToolbarContent> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ToolbarContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance59, create_fragment59, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToolbarContent",
      options,
      id: create_fragment59.name
    });
  }
};
var ToolbarContent_default = ToolbarContent;

// node_modules/carbon-components-svelte/src/icons/IconSearch.svelte
var file59 = "node_modules/carbon-components-svelte/src/icons/IconSearch.svelte";
function create_if_block35(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file59, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block35.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment60(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block35(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M29,27.5859l-7.5521-7.5521a11.0177,11.0177,0,1,0-1.4141,1.4141L27.5859,29ZM4,13a9,9,0,1,1,9,9A9.01,9.01,0,0,1,4,13Z");
      add_location(path, file59, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file59, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block35(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment60.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance60($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("IconSearch", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var IconSearch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance60, create_fragment60, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "IconSearch",
      options,
      id: create_fragment60.name
    });
  }
  get size() {
    throw new Error("<IconSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<IconSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<IconSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<IconSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var IconSearch_default = IconSearch;

// node_modules/carbon-components-svelte/src/Search/SearchSkeleton.svelte
var file60 = "node_modules/carbon-components-svelte/src/Search/SearchSkeleton.svelte";
function create_fragment61(ctx) {
  let div1;
  let span;
  let t;
  let div0;
  let mounted;
  let dispose;
  let div1_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      span = element("span");
      t = space();
      div0 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      span = claim_element(div1_nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--label", true);
      add_location(span, file60, 21, 2, 487);
      toggle_class(div0, "bx--search-input", true);
      add_location(div0, file60, 22, 2, 528);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--skeleton", true);
      toggle_class(
        div1,
        "bx--search--sm",
        /*size*/
        ctx[0] === "sm"
      );
      toggle_class(
        div1,
        "bx--search--lg",
        /*size*/
        ctx[0] === "lg"
      );
      toggle_class(
        div1,
        "bx--search--xl",
        /*size*/
        ctx[0] === "xl"
      );
      add_location(div1, file60, 10, 0, 248);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, span);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseover",
            /*mouseover_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(div1, "bx--skeleton", true);
      toggle_class(
        div1,
        "bx--search--sm",
        /*size*/
        ctx2[0] === "sm"
      );
      toggle_class(
        div1,
        "bx--search--lg",
        /*size*/
        ctx2[0] === "lg"
      );
      toggle_class(
        div1,
        "bx--search--xl",
        /*size*/
        ctx2[0] === "xl"
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment61.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance61($$self, $$props, $$invalidate) {
  const omit_props_names = ["size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SearchSkeleton", slots, []);
  let { size = "xl" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
  };
  $$self.$capture_state = () => ({ size });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    size,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var SearchSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance61, create_fragment61, safe_not_equal, { size: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SearchSkeleton",
      options,
      id: create_fragment61.name
    });
  }
  get size() {
    throw new Error("<SearchSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SearchSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SearchSkeleton_default = SearchSkeleton;

// node_modules/carbon-components-svelte/src/Search/Search.svelte
var file61 = "node_modules/carbon-components-svelte/src/Search/Search.svelte";
var get_labelText_slot_changes4 = (dirty) => ({});
var get_labelText_slot_context4 = (ctx) => ({});
function create_else_block16(ctx) {
  let div1;
  let div0;
  let switch_instance0;
  let t0;
  let label;
  let label_id_value;
  let t1;
  let input;
  let input_autofocus_value;
  let t2;
  let button;
  let switch_instance1;
  let div1_aria_labelledby_value;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*icon*/
    ctx[14]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: { class: "bx--search-magnifier-icon" },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const labelText_slot_template = (
    /*#slots*/
    ctx[20].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_labelText_slot_context4
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block10(ctx);
  let input_levels = [
    { type: "text" },
    { role: "searchbox" },
    {
      autofocus: input_autofocus_value = /*autofocus*/
      ctx[11] === true ? true : void 0
    },
    { autocomplete: (
      /*autocomplete*/
      ctx[10]
    ) },
    { disabled: (
      /*disabled*/
      ctx[7]
    ) },
    { id: (
      /*id*/
      ctx[15]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[9]
    ) },
    /*$$restProps*/
    ctx[18]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  var switch_value_1 = Close_default;
  function switch_props_1(ctx2, dirty) {
    return {
      props: { size: (
        /*size*/
        ctx2[3] === "xl" ? 20 : 16
      ) },
      $$inline: true
    };
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (switch_instance0) create_component(switch_instance0.$$.fragment);
      t0 = space();
      label = element("label");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      t1 = space();
      input = element("input");
      t2 = space();
      button = element("button");
      if (switch_instance1) create_component(switch_instance1.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        role: true,
        "aria-labelledby": true,
        class: true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (switch_instance0) claim_component(switch_instance0.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      label = claim_element(div1_nodes, "LABEL", { id: true, for: true });
      var label_nodes = children(label);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(label_nodes);
      label_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      input = claim_element(div1_nodes, "INPUT", {
        type: true,
        role: true,
        autocomplete: true,
        id: true,
        placeholder: true
      });
      t2 = claim_space(div1_nodes);
      button = claim_element(div1_nodes, "BUTTON", { type: true, "aria-label": true });
      var button_nodes = children(button);
      if (switch_instance1) claim_component(switch_instance1.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--search-magnifier", true);
      add_location(div0, file61, 107, 4, 2762);
      attr_dev(label, "id", label_id_value = /*id*/
      ctx[15] + "-search");
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[15]
      );
      toggle_class(label, "bx--label", true);
      add_location(label, file61, 116, 4, 3011);
      set_attributes(input, input_data);
      toggle_class(input, "bx--search-input", true);
      add_location(input, file61, 122, 4, 3195);
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "aria-label",
        /*closeButtonLabelText*/
        ctx[12]
      );
      button.disabled = /*disabled*/
      ctx[7];
      toggle_class(button, "bx--search-close", true);
      toggle_class(
        button,
        "bx--search-close--hidden",
        /*value*/
        ctx[2] === "" || /*value*/
        ctx[2] == null
      );
      add_location(button, file61, 156, 4, 3979);
      attr_dev(div1, "role", "search");
      attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value = /*id*/
      ctx[15] + "-search");
      attr_dev(
        div1,
        "class",
        /*searchClass*/
        ctx[4]
      );
      toggle_class(div1, "bx--search", true);
      toggle_class(
        div1,
        "bx--search--light",
        /*light*/
        ctx[6]
      );
      toggle_class(
        div1,
        "bx--search--disabled",
        /*disabled*/
        ctx[7]
      );
      toggle_class(
        div1,
        "bx--search--sm",
        /*size*/
        ctx[3] === "sm"
      );
      toggle_class(
        div1,
        "bx--search--lg",
        /*size*/
        ctx[3] === "lg"
      );
      toggle_class(
        div1,
        "bx--search--xl",
        /*size*/
        ctx[3] === "xl"
      );
      toggle_class(
        div1,
        "bx--search--expandable",
        /*expandable*/
        ctx[8]
      );
      toggle_class(
        div1,
        "bx--search--expanded",
        /*expanded*/
        ctx[0]
      );
      add_location(div1, file61, 92, 2, 2214);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (switch_instance0) mount_component(switch_instance0, div0, null);
      ctx[33](div0);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, label);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, input);
      if (input.autofocus) input.focus();
      ctx[35](input);
      set_input_value(
        input,
        /*value*/
        ctx[2]
      );
      append_hydration_dev(div1, t2);
      append_hydration_dev(div1, button);
      if (switch_instance1) mount_component(switch_instance1, button, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div0,
            "click",
            /*click_handler_2*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[36]
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_1*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler_1*/
            ctx[38],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_1*/
            ctx[39],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "paste",
            /*paste_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler_1*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler_3*/
            ctx[40],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*icon*/
      16384 && switch_value !== (switch_value = /*icon*/
      ctx2[14])) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, div0, null);
        } else {
          switch_instance0 = null;
        }
      } else if (switch_value) {
      }
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & /*$$scope*/
        524288)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_labelText_slot_changes4
            ),
            get_labelText_slot_context4
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & /*labelText*/
        8192)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      32768 && label_id_value !== (label_id_value = /*id*/
      ctx2[15] + "-search")) {
        attr_dev(label, "id", label_id_value);
      }
      if (!current || dirty[0] & /*id*/
      32768) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[15]
        );
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        { role: "searchbox" },
        (!current || dirty[0] & /*autofocus*/
        2048 && input_autofocus_value !== (input_autofocus_value = /*autofocus*/
        ctx2[11] === true ? true : void 0)) && { autofocus: input_autofocus_value },
        (!current || dirty[0] & /*autocomplete*/
        1024) && { autocomplete: (
          /*autocomplete*/
          ctx2[10]
        ) },
        (!current || dirty[0] & /*disabled*/
        128) && { disabled: (
          /*disabled*/
          ctx2[7]
        ) },
        (!current || dirty[0] & /*id*/
        32768) && { id: (
          /*id*/
          ctx2[15]
        ) },
        (!current || dirty[0] & /*placeholder*/
        512) && { placeholder: (
          /*placeholder*/
          ctx2[9]
        ) },
        dirty[0] & /*$$restProps*/
        262144 && /*$$restProps*/
        ctx2[18]
      ]));
      if (dirty[0] & /*value*/
      4 && input.value !== /*value*/
      ctx2[2]) {
        set_input_value(
          input,
          /*value*/
          ctx2[2]
        );
      }
      toggle_class(input, "bx--search-input", true);
      if (switch_value_1 !== (switch_value_1 = Close_default)) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx2, dirty));
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, button, null);
        } else {
          switch_instance1 = null;
        }
      } else if (switch_value_1) {
        const switch_instance1_changes = {};
        if (dirty[0] & /*size*/
        8) switch_instance1_changes.size = /*size*/
        ctx2[3] === "xl" ? 20 : 16;
        switch_instance1.$set(switch_instance1_changes);
      }
      if (!current || dirty[0] & /*closeButtonLabelText*/
      4096) {
        attr_dev(
          button,
          "aria-label",
          /*closeButtonLabelText*/
          ctx2[12]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      128) {
        prop_dev(
          button,
          "disabled",
          /*disabled*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*value*/
      4) {
        toggle_class(
          button,
          "bx--search-close--hidden",
          /*value*/
          ctx2[2] === "" || /*value*/
          ctx2[2] == null
        );
      }
      if (!current || dirty[0] & /*id*/
      32768 && div1_aria_labelledby_value !== (div1_aria_labelledby_value = /*id*/
      ctx2[15] + "-search")) {
        attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value);
      }
      if (!current || dirty[0] & /*searchClass*/
      16) {
        attr_dev(
          div1,
          "class",
          /*searchClass*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*searchClass*/
      16) {
        toggle_class(div1, "bx--search", true);
      }
      if (!current || dirty[0] & /*searchClass, light*/
      80) {
        toggle_class(
          div1,
          "bx--search--light",
          /*light*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*searchClass, disabled*/
      144) {
        toggle_class(
          div1,
          "bx--search--disabled",
          /*disabled*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*searchClass, size*/
      24) {
        toggle_class(
          div1,
          "bx--search--sm",
          /*size*/
          ctx2[3] === "sm"
        );
      }
      if (!current || dirty[0] & /*searchClass, size*/
      24) {
        toggle_class(
          div1,
          "bx--search--lg",
          /*size*/
          ctx2[3] === "lg"
        );
      }
      if (!current || dirty[0] & /*searchClass, size*/
      24) {
        toggle_class(
          div1,
          "bx--search--xl",
          /*size*/
          ctx2[3] === "xl"
        );
      }
      if (!current || dirty[0] & /*searchClass, expandable*/
      272) {
        toggle_class(
          div1,
          "bx--search--expandable",
          /*expandable*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*searchClass, expanded*/
      17) {
        toggle_class(
          div1,
          "bx--search--expanded",
          /*expanded*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance0) transition_in(switch_instance0.$$.fragment, local);
      transition_in(labelText_slot_or_fallback, local);
      if (switch_instance1) transition_in(switch_instance1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance0) transition_out(switch_instance0.$$.fragment, local);
      transition_out(labelText_slot_or_fallback, local);
      if (switch_instance1) transition_out(switch_instance1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (switch_instance0) destroy_component(switch_instance0);
      ctx[33](null);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
      ctx[35](null);
      if (switch_instance1) destroy_component(switch_instance1);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block16.name,
    type: "else",
    source: "(92:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block36(ctx) {
  let searchskeleton;
  let current;
  const searchskeleton_spread_levels = [
    { size: (
      /*size*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[18]
  ];
  let searchskeleton_props = {};
  for (let i = 0; i < searchskeleton_spread_levels.length; i += 1) {
    searchskeleton_props = assign(searchskeleton_props, searchskeleton_spread_levels[i]);
  }
  searchskeleton = new SearchSkeleton_default({
    props: searchskeleton_props,
    $$inline: true
  });
  searchskeleton.$on(
    "click",
    /*click_handler*/
    ctx[29]
  );
  searchskeleton.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[30]
  );
  searchskeleton.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx[31]
  );
  searchskeleton.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx[32]
  );
  const block = {
    c: function create() {
      create_component(searchskeleton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(searchskeleton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(searchskeleton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const searchskeleton_changes = dirty[0] & /*size, $$restProps*/
      262152 ? get_spread_update(searchskeleton_spread_levels, [
        dirty[0] & /*size*/
        8 && { size: (
          /*size*/
          ctx2[3]
        ) },
        dirty[0] & /*$$restProps*/
        262144 && get_spread_object(
          /*$$restProps*/
          ctx2[18]
        )
      ]) : {};
      searchskeleton.$set(searchskeleton_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(searchskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(searchskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(searchskeleton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block36.name,
    type: "if",
    source: "(83:0) {#if skeleton}",
    ctx
  });
  return block;
}
function fallback_block10(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[13]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[13]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelText*/
      8192) set_data_dev(
        t,
        /*labelText*/
        ctx2[13]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block10.name,
    type: "fallback",
    source: "(118:29)          ",
    ctx
  });
  return block;
}
function create_fragment62(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block36, create_else_block16];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*skeleton*/
      ctx2[5]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment62.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance62($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "value",
    "size",
    "searchClass",
    "skeleton",
    "light",
    "disabled",
    "expandable",
    "expanded",
    "placeholder",
    "autocomplete",
    "autofocus",
    "closeButtonLabelText",
    "labelText",
    "icon",
    "id",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Search", slots, ["labelText"]);
  let { value = "" } = $$props;
  let { size = "xl" } = $$props;
  let { searchClass = "" } = $$props;
  let { skeleton = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { expandable = false } = $$props;
  let { expanded = false } = $$props;
  let { placeholder = "Search..." } = $$props;
  let { autocomplete = "off" } = $$props;
  let { autofocus = false } = $$props;
  let { closeButtonLabelText = "Clear search input" } = $$props;
  let { labelText = "" } = $$props;
  let { icon = IconSearch_default } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let searchRef = null;
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      searchRef = $$value;
      $$invalidate(16, searchRef);
    });
  }
  const click_handler_2 = () => {
    if (expandable) $$invalidate(0, expanded = true);
  };
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(2, value);
  }
  const focus_handler_1 = () => {
    if (expandable) $$invalidate(0, expanded = true);
  };
  const blur_handler_1 = () => {
    if (expanded && (value === "" || value == null)) {
      $$invalidate(0, expanded = false);
    }
  };
  const keydown_handler_12 = ({ key }) => {
    if (key === "Escape") {
      $$invalidate(2, value = "");
      dispatch("clear");
    }
  };
  const click_handler_3 = () => {
    $$invalidate(2, value = "");
    ref.focus();
    dispatch("clear");
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(2, value = $$new_props.value);
    if ("size" in $$new_props) $$invalidate(3, size = $$new_props.size);
    if ("searchClass" in $$new_props) $$invalidate(4, searchClass = $$new_props.searchClass);
    if ("skeleton" in $$new_props) $$invalidate(5, skeleton = $$new_props.skeleton);
    if ("light" in $$new_props) $$invalidate(6, light = $$new_props.light);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("expandable" in $$new_props) $$invalidate(8, expandable = $$new_props.expandable);
    if ("expanded" in $$new_props) $$invalidate(0, expanded = $$new_props.expanded);
    if ("placeholder" in $$new_props) $$invalidate(9, placeholder = $$new_props.placeholder);
    if ("autocomplete" in $$new_props) $$invalidate(10, autocomplete = $$new_props.autocomplete);
    if ("autofocus" in $$new_props) $$invalidate(11, autofocus = $$new_props.autofocus);
    if ("closeButtonLabelText" in $$new_props) $$invalidate(12, closeButtonLabelText = $$new_props.closeButtonLabelText);
    if ("labelText" in $$new_props) $$invalidate(13, labelText = $$new_props.labelText);
    if ("icon" in $$new_props) $$invalidate(14, icon = $$new_props.icon);
    if ("id" in $$new_props) $$invalidate(15, id = $$new_props.id);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    size,
    searchClass,
    skeleton,
    light,
    disabled,
    expandable,
    expanded,
    placeholder,
    autocomplete,
    autofocus,
    closeButtonLabelText,
    labelText,
    icon,
    id,
    ref,
    createEventDispatcher,
    Close: Close_default,
    IconSearch: IconSearch_default,
    SearchSkeleton: SearchSkeleton_default,
    dispatch,
    searchRef
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(2, value = $$new_props.value);
    if ("size" in $$props) $$invalidate(3, size = $$new_props.size);
    if ("searchClass" in $$props) $$invalidate(4, searchClass = $$new_props.searchClass);
    if ("skeleton" in $$props) $$invalidate(5, skeleton = $$new_props.skeleton);
    if ("light" in $$props) $$invalidate(6, light = $$new_props.light);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("expandable" in $$props) $$invalidate(8, expandable = $$new_props.expandable);
    if ("expanded" in $$props) $$invalidate(0, expanded = $$new_props.expanded);
    if ("placeholder" in $$props) $$invalidate(9, placeholder = $$new_props.placeholder);
    if ("autocomplete" in $$props) $$invalidate(10, autocomplete = $$new_props.autocomplete);
    if ("autofocus" in $$props) $$invalidate(11, autofocus = $$new_props.autofocus);
    if ("closeButtonLabelText" in $$props) $$invalidate(12, closeButtonLabelText = $$new_props.closeButtonLabelText);
    if ("labelText" in $$props) $$invalidate(13, labelText = $$new_props.labelText);
    if ("icon" in $$props) $$invalidate(14, icon = $$new_props.icon);
    if ("id" in $$props) $$invalidate(15, id = $$new_props.id);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("searchRef" in $$props) $$invalidate(16, searchRef = $$new_props.searchRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*expanded, ref*/
    3) {
      $: if (expanded && ref) ref.focus();
    }
    if ($$self.$$.dirty[0] & /*expanded*/
    1) {
      $: dispatch(expanded ? "expand" : "collapse");
    }
  };
  return [
    expanded,
    ref,
    value,
    size,
    searchClass,
    skeleton,
    light,
    disabled,
    expandable,
    placeholder,
    autocomplete,
    autofocus,
    closeButtonLabelText,
    labelText,
    icon,
    id,
    searchRef,
    dispatch,
    $$restProps,
    $$scope,
    slots,
    click_handler_13,
    change_handler,
    input_handler,
    focus_handler,
    blur_handler,
    keydown_handler,
    keyup_handler,
    paste_handler,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    div0_binding,
    click_handler_2,
    input_binding,
    input_input_handler,
    focus_handler_1,
    blur_handler_1,
    keydown_handler_12,
    click_handler_3
  ];
}
var Search = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance62,
      create_fragment62,
      safe_not_equal,
      {
        value: 2,
        size: 3,
        searchClass: 4,
        skeleton: 5,
        light: 6,
        disabled: 7,
        expandable: 8,
        expanded: 0,
        placeholder: 9,
        autocomplete: 10,
        autofocus: 11,
        closeButtonLabelText: 12,
        labelText: 13,
        icon: 14,
        id: 15,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Search",
      options,
      id: create_fragment62.name
    });
  }
  get value() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchClass() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchClass(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skeleton() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skeleton(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandable() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandable(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expanded() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocomplete() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocomplete(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autofocus() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autofocus(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeButtonLabelText() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeButtonLabelText(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Search_default = Search;

// node_modules/carbon-components-svelte/src/DataTable/ToolbarSearch.svelte
function create_fragment63(ctx) {
  let search;
  let updating_ref;
  let updating_value;
  let current;
  const search_spread_levels = [
    { tabindex: (
      /*tabindex*/
      ctx[5]
    ) },
    { disabled: (
      /*disabled*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[9],
    {
      searchClass: (
        /*classes*/
        ctx[6] + " " + /*$$restProps*/
        ctx[9].class
      )
    }
  ];
  function search_ref_binding(value) {
    ctx[14](value);
  }
  function search_value_binding(value) {
    ctx[15](value);
  }
  let search_props = {};
  for (let i = 0; i < search_spread_levels.length; i += 1) {
    search_props = assign(search_props, search_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[2] !== void 0
  ) {
    search_props.ref = /*ref*/
    ctx[2];
  }
  if (
    /*value*/
    ctx[0] !== void 0
  ) {
    search_props.value = /*value*/
    ctx[0];
  }
  search = new Search_default({ props: search_props, $$inline: true });
  binding_callbacks.push(() => bind(search, "ref", search_ref_binding));
  binding_callbacks.push(() => bind(search, "value", search_value_binding));
  search.$on(
    "clear",
    /*clear_handler*/
    ctx[16]
  );
  search.$on(
    "clear",
    /*expandSearch*/
    ctx[8]
  );
  search.$on(
    "change",
    /*change_handler*/
    ctx[17]
  );
  search.$on(
    "input",
    /*input_handler*/
    ctx[18]
  );
  search.$on(
    "focus",
    /*focus_handler*/
    ctx[19]
  );
  search.$on(
    "focus",
    /*expandSearch*/
    ctx[8]
  );
  search.$on(
    "blur",
    /*blur_handler*/
    ctx[20]
  );
  search.$on(
    "blur",
    /*blur_handler_1*/
    ctx[21]
  );
  search.$on(
    "keyup",
    /*keyup_handler*/
    ctx[22]
  );
  search.$on(
    "keydown",
    /*keydown_handler*/
    ctx[23]
  );
  search.$on(
    "paste",
    /*paste_handler*/
    ctx[24]
  );
  const block = {
    c: function create() {
      create_component(search.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(search.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(search, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const search_changes = dirty & /*tabindex, disabled, $$restProps, classes*/
      624 ? get_spread_update(search_spread_levels, [
        dirty & /*tabindex*/
        32 && { tabindex: (
          /*tabindex*/
          ctx2[5]
        ) },
        dirty & /*disabled*/
        16 && { disabled: (
          /*disabled*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        512 && get_spread_object(
          /*$$restProps*/
          ctx2[9]
        ),
        dirty & /*classes, $$restProps*/
        576 && {
          searchClass: (
            /*classes*/
            ctx2[6] + " " + /*$$restProps*/
            ctx2[9].class
          )
        }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      4) {
        updating_ref = true;
        search_changes.ref = /*ref*/
        ctx2[2];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_value && dirty & /*value*/
      1) {
        updating_value = true;
        search_changes.value = /*value*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      search.$set(search_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(search.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(search.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(search, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment63.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance63($$self, $$props, $$invalidate) {
  let originalRows;
  let classes;
  const omit_props_names = [
    "value",
    "expanded",
    "persistent",
    "disabled",
    "shouldFilterRows",
    "filteredRowIds",
    "tabindex",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $tableRows;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToolbarSearch", slots, []);
  let { value = "" } = $$props;
  let { expanded = false } = $$props;
  let { persistent = false } = $$props;
  let { disabled = false } = $$props;
  let { shouldFilterRows = false } = $$props;
  let { filteredRowIds = [] } = $$props;
  let { tabindex = "0" } = $$props;
  let { ref = null } = $$props;
  const { tableRows } = getContext("DataTable") ?? {};
  validate_store(tableRows, "tableRows");
  component_subscribe($$self, tableRows, (value2) => $$invalidate(13, $tableRows = value2));
  async function expandSearch() {
    await tick();
    if (disabled || persistent || expanded) return;
    $$invalidate(1, expanded = true);
    await tick();
    ref.focus();
  }
  function search_ref_binding(value2) {
    ref = value2;
    $$invalidate(2, ref);
  }
  function search_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function clear_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const blur_handler_1 = () => {
    $$invalidate(1, expanded = !persistent && !!value.length);
  };
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    if ("expanded" in $$new_props) $$invalidate(1, expanded = $$new_props.expanded);
    if ("persistent" in $$new_props) $$invalidate(3, persistent = $$new_props.persistent);
    if ("disabled" in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
    if ("shouldFilterRows" in $$new_props) $$invalidate(11, shouldFilterRows = $$new_props.shouldFilterRows);
    if ("filteredRowIds" in $$new_props) $$invalidate(10, filteredRowIds = $$new_props.filteredRowIds);
    if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    if ("ref" in $$new_props) $$invalidate(2, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    value,
    expanded,
    persistent,
    disabled,
    shouldFilterRows,
    filteredRowIds,
    tabindex,
    ref,
    tick,
    getContext,
    Search: Search_default,
    tableRows,
    expandSearch,
    classes,
    originalRows,
    $tableRows
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    if ("expanded" in $$props) $$invalidate(1, expanded = $$new_props.expanded);
    if ("persistent" in $$props) $$invalidate(3, persistent = $$new_props.persistent);
    if ("disabled" in $$props) $$invalidate(4, disabled = $$new_props.disabled);
    if ("shouldFilterRows" in $$props) $$invalidate(11, shouldFilterRows = $$new_props.shouldFilterRows);
    if ("filteredRowIds" in $$props) $$invalidate(10, filteredRowIds = $$new_props.filteredRowIds);
    if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    if ("ref" in $$props) $$invalidate(2, ref = $$new_props.ref);
    if ("classes" in $$props) $$invalidate(6, classes = $$new_props.classes);
    if ("originalRows" in $$props) $$invalidate(12, originalRows = $$new_props.originalRows);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$tableRows*/
    8192) {
      $: $$invalidate(12, originalRows = tableRows ? [...$tableRows] : []);
    }
    if ($$self.$$.dirty & /*shouldFilterRows, originalRows, value*/
    6145) {
      $: if (shouldFilterRows) {
        let rows = originalRows;
        if (value.trim().length > 0) {
          if (shouldFilterRows === true) {
            rows = rows.filter((row) => {
              return Object.entries(row).filter(([key]) => key !== "id").some(([key, _value]) => {
                var _a;
                if (typeof _value === "string" || typeof _value === "number") {
                  return (_a = _value + "") == null ? void 0 : _a.toLowerCase().includes(value.trim().toLowerCase());
                }
              });
            });
          } else if (typeof shouldFilterRows === "function") {
            rows = rows.filter((row) => shouldFilterRows(row, value) ?? false);
          }
        }
        tableRows.set(rows);
        $$invalidate(10, filteredRowIds = rows.map((row) => row.id));
      }
    }
    if ($$self.$$.dirty & /*value*/
    1) {
      $: $$invalidate(1, expanded = !!value.length);
    }
    if ($$self.$$.dirty & /*expanded, persistent, disabled*/
    26) {
      $: $$invalidate(6, classes = [
        expanded && "bx--toolbar-search-container-active",
        persistent ? "bx--toolbar-search-container-persistent" : "bx--toolbar-search-container-expandable",
        disabled && "bx--toolbar-search-container-disabled"
      ].filter(Boolean).join(" "));
    }
  };
  return [
    value,
    expanded,
    ref,
    persistent,
    disabled,
    tabindex,
    classes,
    tableRows,
    expandSearch,
    $$restProps,
    filteredRowIds,
    shouldFilterRows,
    originalRows,
    $tableRows,
    search_ref_binding,
    search_value_binding,
    clear_handler,
    change_handler,
    input_handler,
    focus_handler,
    blur_handler,
    blur_handler_1,
    keyup_handler,
    keydown_handler,
    paste_handler
  ];
}
var ToolbarSearch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance63, create_fragment63, safe_not_equal, {
      value: 0,
      expanded: 1,
      persistent: 3,
      disabled: 4,
      shouldFilterRows: 11,
      filteredRowIds: 10,
      tabindex: 5,
      ref: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToolbarSearch",
      options,
      id: create_fragment63.name
    });
  }
  get value() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expanded() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persistent() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persistent(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldFilterRows() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldFilterRows(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filteredRowIds() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filteredRowIds(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToolbarSearch_default = ToolbarSearch;

// node_modules/carbon-components-svelte/src/DataTable/ToolbarBatchActions.svelte
var file62 = "node_modules/carbon-components-svelte/src/DataTable/ToolbarBatchActions.svelte";
var get_cancel_slot_changes = (dirty) => ({});
var get_cancel_slot_context = (ctx) => ({});
function create_if_block37(ctx) {
  let div2;
  let div0;
  let p;
  let span;
  let t0_value = (
    /*formatTotalSelected*/
    ctx[0](
      /*batchSelectedIds*/
      ctx[1].length
    ) + ""
  );
  let t0;
  let t1;
  let div1;
  let t2;
  let button;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  button = new Button_default({
    props: {
      class: "bx--batch-summary__cancel",
      tabindex: (
        /*showActions*/
        ctx[3] ? "0" : "-1"
      ),
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on(
    "click",
    /*cancel*/
    ctx[4]
  );
  let div2_levels = [
    /*$$restProps*/
    ctx[5]
  ];
  let div_data_2 = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      p = element("p");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      if (default_slot) default_slot.c();
      t2 = space();
      create_component(button.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", {});
      var div0_nodes = children(div0);
      p = claim_element(div0_nodes, "P", {});
      var p_nodes = children(p);
      span = claim_element(p_nodes, "SPAN", {});
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      span_nodes.forEach(detach_dev);
      p_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", {});
      var div1_nodes = children(div1);
      if (default_slot) default_slot.l(div1_nodes);
      t2 = claim_space(div1_nodes);
      claim_component(button.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file62, 84, 8, 1788);
      toggle_class(p, "bx--batch-summary__para", true);
      add_location(p, file62, 83, 6, 1737);
      toggle_class(div0, "bx--batch-summary", true);
      add_location(div0, file62, 82, 4, 1692);
      toggle_class(div1, "bx--action-list", true);
      add_location(div1, file62, 87, 4, 1876);
      set_attributes(div2, div_data_2);
      toggle_class(div2, "bx--batch-actions", true);
      toggle_class(
        div2,
        "bx--batch-actions--active",
        /*showActions*/
        ctx[3]
      );
      add_location(div2, file62, 77, 2, 1569);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, p);
      append_hydration_dev(p, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_hydration_dev(div1, t2);
      mount_component(button, div1, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*formatTotalSelected, batchSelectedIds*/
      3) && t0_value !== (t0_value = /*formatTotalSelected*/
      ctx2[0](
        /*batchSelectedIds*/
        ctx2[1].length
      ) + "")) set_data_dev(t0, t0_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      const button_changes = {};
      if (dirty & /*showActions*/
      8) button_changes.tabindex = /*showActions*/
      ctx2[3] ? "0" : "-1";
      if (dirty & /*$$scope*/
      512) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [dirty & /*$$restProps*/
      32 && /*$$restProps*/
      ctx2[5]]));
      toggle_class(div2, "bx--batch-actions", true);
      toggle_class(
        div2,
        "bx--batch-actions--active",
        /*showActions*/
        ctx2[3]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (default_slot) default_slot.d(detaching);
      destroy_component(button);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block37.name,
    type: "if",
    source: "(77:0) {#if !overflowVisible}",
    ctx
  });
  return block;
}
function fallback_block11(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Cancel");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Cancel");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block11.name,
    type: "fallback",
    source: "(95:28) Cancel",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let current;
  const cancel_slot_template = (
    /*#slots*/
    ctx[8].cancel
  );
  const cancel_slot = create_slot(
    cancel_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_cancel_slot_context
  );
  const cancel_slot_or_fallback = cancel_slot || fallback_block11(ctx);
  const block = {
    c: function create() {
      if (cancel_slot_or_fallback) cancel_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (cancel_slot_or_fallback) cancel_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (cancel_slot_or_fallback) {
        cancel_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (cancel_slot) {
        if (cancel_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            cancel_slot,
            cancel_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              cancel_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_cancel_slot_changes
            ),
            get_cancel_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(cancel_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cancel_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (cancel_slot_or_fallback) cancel_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: `(90:6) <Button         class=\\"bx--batch-summary__cancel\\"         tabindex=\\"{showActions ? '0' : '-1'}\\"         on:click=\\"{cancel}\\"       >`,
    ctx
  });
  return block;
}
function create_fragment64(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*overflowVisible*/
  ctx[2] && create_if_block37(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!/*overflowVisible*/
      ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*overflowVisible*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block37(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment64.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance64($$self, $$props, $$invalidate) {
  let showActions;
  const omit_props_names = ["formatTotalSelected", "active"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToolbarBatchActions", slots, ["default", "cancel"]);
  let { formatTotalSelected = (totalSelected) => `${totalSelected} item${totalSelected === 1 ? "" : "s"} selected` } = $$props;
  let { active = void 0 } = $$props;
  let batchSelectedIds = [];
  let prevActive;
  const dispatch = createEventDispatcher();
  const ctx = getContext("DataTable");
  function cancel() {
    const shouldContinue = dispatch("cancel", null, { cancelable: true });
    if (shouldContinue) {
      ctx.resetSelectedRowIds();
    }
  }
  const unsubscribe = ctx.batchSelectedIds.subscribe((value) => {
    $$invalidate(1, batchSelectedIds = value);
  });
  let overflowVisible = false;
  const ctxToolbar = getContext("Toolbar");
  const unsubscribeOverflow = ctxToolbar.overflowVisible.subscribe((value) => {
    $$invalidate(2, overflowVisible = value);
  });
  onMount(() => {
    return () => {
      unsubscribe();
      unsubscribeOverflow();
    };
  });
  afterUpdate(() => {
    if (active === false && showActions) {
      $$invalidate(6, active = true);
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("formatTotalSelected" in $$new_props) $$invalidate(0, formatTotalSelected = $$new_props.formatTotalSelected);
    if ("active" in $$new_props) $$invalidate(6, active = $$new_props.active);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    formatTotalSelected,
    active,
    onMount,
    getContext,
    createEventDispatcher,
    afterUpdate,
    Button: Button_default,
    batchSelectedIds,
    prevActive,
    dispatch,
    ctx,
    cancel,
    unsubscribe,
    overflowVisible,
    ctxToolbar,
    unsubscribeOverflow,
    showActions
  });
  $$self.$inject_state = ($$new_props) => {
    if ("formatTotalSelected" in $$props) $$invalidate(0, formatTotalSelected = $$new_props.formatTotalSelected);
    if ("active" in $$props) $$invalidate(6, active = $$new_props.active);
    if ("batchSelectedIds" in $$props) $$invalidate(1, batchSelectedIds = $$new_props.batchSelectedIds);
    if ("prevActive" in $$props) $$invalidate(7, prevActive = $$new_props.prevActive);
    if ("overflowVisible" in $$props) $$invalidate(2, overflowVisible = $$new_props.overflowVisible);
    if ("showActions" in $$props) $$invalidate(3, showActions = $$new_props.showActions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*batchSelectedIds, active*/
    66) {
      $: $$invalidate(3, showActions = batchSelectedIds.length > 0 || active);
    }
    if ($$self.$$.dirty & /*prevActive, active*/
    192) {
      $: {
        if (prevActive !== active && active === false) {
          $$invalidate(3, showActions = false);
        }
        $$invalidate(7, prevActive = active);
      }
    }
  };
  return [
    formatTotalSelected,
    batchSelectedIds,
    overflowVisible,
    showActions,
    cancel,
    $$restProps,
    active,
    prevActive,
    slots,
    $$scope
  ];
}
var ToolbarBatchActions = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance64, create_fragment64, safe_not_equal, { formatTotalSelected: 0, active: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToolbarBatchActions",
      options,
      id: create_fragment64.name
    });
  }
  get formatTotalSelected() {
    throw new Error("<ToolbarBatchActions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatTotalSelected(value) {
    throw new Error("<ToolbarBatchActions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<ToolbarBatchActions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<ToolbarBatchActions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToolbarBatchActions_default = ToolbarBatchActions;

// node_modules/carbon-components-svelte/src/icons/Settings.svelte
var file63 = "node_modules/carbon-components-svelte/src/icons/Settings.svelte";
function create_if_block38(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file63, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block38.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment65(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block38(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M27,16.76c0-.25,0-.5,0-.76s0-.51,0-.77l1.92-1.68A2,2,0,0,0,29.3,11L26.94,7a2,2,0,0,0-1.73-1,2,2,0,0,0-.64.1l-2.43.82a11.35,11.35,0,0,0-1.31-.75l-.51-2.52a2,2,0,0,0-2-1.61H13.64a2,2,0,0,0-2,1.61l-.51,2.52a11.48,11.48,0,0,0-1.32.75L7.43,6.06A2,2,0,0,0,6.79,6,2,2,0,0,0,5.06,7L2.7,11a2,2,0,0,0,.41,2.51L5,15.24c0,.25,0,.5,0,.76s0,.51,0,.77L3.11,18.45A2,2,0,0,0,2.7,21L5.06,25a2,2,0,0,0,1.73,1,2,2,0,0,0,.64-.1l2.43-.82a11.35,11.35,0,0,0,1.31.75l.51,2.52a2,2,0,0,0,2,1.61h4.72a2,2,0,0,0,2-1.61l.51-2.52a11.48,11.48,0,0,0,1.32-.75l2.42.82a2,2,0,0,0,.64.1,2,2,0,0,0,1.73-1L29.3,21a2,2,0,0,0-.41-2.51ZM25.21,24l-3.43-1.16a8.86,8.86,0,0,1-2.71,1.57L18.36,28H13.64l-.71-3.55a9.36,9.36,0,0,1-2.7-1.57L6.79,24,4.43,20l2.72-2.4a8.9,8.9,0,0,1,0-3.13L4.43,12,6.79,8l3.43,1.16a8.86,8.86,0,0,1,2.71-1.57L13.64,4h4.72l.71,3.55a9.36,9.36,0,0,1,2.7,1.57L25.21,8,27.57,12l-2.72,2.4a8.9,8.9,0,0,1,0,3.13L27.57,20Z");
      add_location(path0, file63, 24, 2, 579);
      attr_dev(path1, "d", "M16,22a6,6,0,1,1,6-6A5.94,5.94,0,0,1,16,22Zm0-10a3.91,3.91,0,0,0-4,4,3.91,3.91,0,0,0,4,4,3.91,3.91,0,0,0,4-4A3.91,3.91,0,0,0,16,12Z");
      add_location(path1, file63, 26, 10, 1496);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file63, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block38(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment65.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance65($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Settings", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Settings = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance65, create_fragment65, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Settings",
      options,
      id: create_fragment65.name
    });
  }
  get size() {
    throw new Error("<Settings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Settings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Settings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Settings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Settings_default = Settings;

// node_modules/carbon-components-svelte/src/icons/OverflowMenuVertical.svelte
var file64 = "node_modules/carbon-components-svelte/src/icons/OverflowMenuVertical.svelte";
function create_if_block39(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file64, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block39.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment66(ctx) {
  let svg;
  let circle0;
  let circle1;
  let circle2;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block39(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      circle2 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "16");
      attr_dev(circle0, "cy", "8");
      attr_dev(circle0, "r", "2");
      add_location(circle0, file64, 24, 2, 579);
      attr_dev(circle1, "cx", "16");
      attr_dev(circle1, "cy", "16");
      attr_dev(circle1, "r", "2");
      add_location(circle1, file64, 24, 40, 617);
      attr_dev(circle2, "cx", "16");
      attr_dev(circle2, "cy", "24");
      attr_dev(circle2, "r", "2");
      add_location(circle2, file64, 25, 12, 659);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file64, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, circle2);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block39(ctx2);
          if_block.c();
          if_block.m(svg, circle0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment66.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance66($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OverflowMenuVertical", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var OverflowMenuVertical = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance66, create_fragment66, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OverflowMenuVertical",
      options,
      id: create_fragment66.name
    });
  }
  get size() {
    throw new Error("<OverflowMenuVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<OverflowMenuVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<OverflowMenuVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<OverflowMenuVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OverflowMenuVertical_default = OverflowMenuVertical;

// node_modules/carbon-components-svelte/src/icons/OverflowMenuHorizontal.svelte
var file65 = "node_modules/carbon-components-svelte/src/icons/OverflowMenuHorizontal.svelte";
function create_if_block40(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file65, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block40.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment67(ctx) {
  let svg;
  let circle0;
  let circle1;
  let circle2;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block40(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      circle2 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "8");
      attr_dev(circle0, "cy", "16");
      attr_dev(circle0, "r", "2");
      add_location(circle0, file65, 24, 2, 579);
      attr_dev(circle1, "cx", "16");
      attr_dev(circle1, "cy", "16");
      attr_dev(circle1, "r", "2");
      add_location(circle1, file65, 24, 40, 617);
      attr_dev(circle2, "cx", "24");
      attr_dev(circle2, "cy", "16");
      attr_dev(circle2, "r", "2");
      add_location(circle2, file65, 25, 12, 659);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file65, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, circle2);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block40(ctx2);
          if_block.c();
          if_block.m(svg, circle0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment67.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance67($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OverflowMenuHorizontal", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var OverflowMenuHorizontal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance67, create_fragment67, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OverflowMenuHorizontal",
      options,
      id: create_fragment67.name
    });
  }
  get size() {
    throw new Error("<OverflowMenuHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<OverflowMenuHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<OverflowMenuHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<OverflowMenuHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OverflowMenuHorizontal_default = OverflowMenuHorizontal;

// node_modules/carbon-components-svelte/src/OverflowMenu/OverflowMenu.svelte
var file66 = "node_modules/carbon-components-svelte/src/OverflowMenu/OverflowMenu.svelte";
var get_menu_slot_changes = (dirty) => ({});
var get_menu_slot_context = (ctx) => ({});
function fallback_block12(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[1]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        "aria-label": (
          /*iconDescription*/
          ctx2[10]
        ),
        title: (
          /*iconDescription*/
          ctx2[10]
        ),
        class: "bx--overflow-menu__icon " + /*iconClass*/
        ctx2[9]
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*icon*/
      2 && switch_value !== (switch_value = /*icon*/
      ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*iconDescription*/
        1024) switch_instance_changes["aria-label"] = /*iconDescription*/
        ctx2[10];
        if (dirty[0] & /*iconDescription*/
        1024) switch_instance_changes.title = /*iconDescription*/
        ctx2[10];
        if (dirty[0] & /*iconClass*/
        512) switch_instance_changes.class = "bx--overflow-menu__icon " + /*iconClass*/
        ctx2[9];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block12.name,
    type: "fallback",
    source: "(237:20)      ",
    ctx
  });
  return block;
}
function create_if_block41(ctx) {
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[24].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    null
  );
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {
        role: true,
        tabindex: true,
        "aria-label": true,
        "data-floating-menu-direction": true,
        class: true
      });
      var ul_nodes = children(ul);
      if (default_slot) default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "role", "menu");
      attr_dev(ul, "tabindex", "-1");
      attr_dev(
        ul,
        "aria-label",
        /*ariaLabel*/
        ctx[13]
      );
      attr_dev(
        ul,
        "data-floating-menu-direction",
        /*direction*/
        ctx[5]
      );
      attr_dev(
        ul,
        "class",
        /*menuOptionsClass*/
        ctx[8]
      );
      toggle_class(ul, "bx--overflow-menu-options", true);
      toggle_class(
        ul,
        "bx--overflow-menu--flip",
        /*flipped*/
        ctx[7]
      );
      toggle_class(
        ul,
        "bx--overflow-menu-options--open",
        /*open*/
        ctx[0]
      );
      toggle_class(
        ul,
        "bx--overflow-menu-options--light",
        /*light*/
        ctx[6]
      );
      toggle_class(
        ul,
        "bx--overflow-menu-options--sm",
        /*size*/
        ctx[4] === "sm"
      );
      toggle_class(
        ul,
        "bx--overflow-menu-options--xl",
        /*size*/
        ctx[4] === "xl"
      );
      toggle_class(ul, "bx--breadcrumb-menu-options", !!/*ctxBreadcrumbItem*/
      ctx[14]);
      add_location(ul, file66, 246, 4, 5921);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[31](ul);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*ariaLabel*/
      8192) {
        attr_dev(
          ul,
          "aria-label",
          /*ariaLabel*/
          ctx2[13]
        );
      }
      if (!current || dirty[0] & /*direction*/
      32) {
        attr_dev(
          ul,
          "data-floating-menu-direction",
          /*direction*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*menuOptionsClass*/
      256) {
        attr_dev(
          ul,
          "class",
          /*menuOptionsClass*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*menuOptionsClass*/
      256) {
        toggle_class(ul, "bx--overflow-menu-options", true);
      }
      if (!current || dirty[0] & /*menuOptionsClass, flipped*/
      384) {
        toggle_class(
          ul,
          "bx--overflow-menu--flip",
          /*flipped*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*menuOptionsClass, open*/
      257) {
        toggle_class(
          ul,
          "bx--overflow-menu-options--open",
          /*open*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*menuOptionsClass, light*/
      320) {
        toggle_class(
          ul,
          "bx--overflow-menu-options--light",
          /*light*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*menuOptionsClass, size*/
      272) {
        toggle_class(
          ul,
          "bx--overflow-menu-options--sm",
          /*size*/
          ctx2[4] === "sm"
        );
      }
      if (!current || dirty[0] & /*menuOptionsClass, size*/
      272) {
        toggle_class(
          ul,
          "bx--overflow-menu-options--xl",
          /*size*/
          ctx2[4] === "xl"
        );
      }
      if (!current || dirty[0] & /*menuOptionsClass, ctxBreadcrumbItem*/
      16640) {
        toggle_class(ul, "bx--breadcrumb-menu-options", !!/*ctxBreadcrumbItem*/
        ctx2[14]);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[31](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block41.name,
    type: "if",
    source: "(245:2) {#if open}",
    ctx
  });
  return block;
}
function create_fragment68(ctx) {
  let html_tag;
  let html_anchor;
  let t0;
  let button;
  let t1;
  let current;
  let mounted;
  let dispose;
  const menu_slot_template = (
    /*#slots*/
    ctx[24].menu
  );
  const menu_slot = create_slot(
    menu_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_menu_slot_context
  );
  const menu_slot_or_fallback = menu_slot || fallback_block12(ctx);
  let if_block = (
    /*open*/
    ctx[0] && create_if_block41(ctx)
  );
  let button_levels = [
    { type: "button" },
    { "aria-haspopup": "" },
    { "aria-expanded": (
      /*open*/
      ctx[0]
    ) },
    { "aria-label": (
      /*ariaLabel*/
      ctx[13]
    ) },
    { id: (
      /*id*/
      ctx[11]
    ) },
    /*$$restProps*/
    ctx[19]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      t0 = space();
      button = element("button");
      if (menu_slot_or_fallback) menu_slot_or_fallback.c();
      t1 = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      const head_nodes = head_selector("svelte-7ztmff", document.head);
      html_tag = claim_html_tag(head_nodes, false);
      html_anchor = empty();
      head_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-haspopup": true,
        "aria-expanded": true,
        "aria-label": true,
        id: true
      });
      var button_nodes = children(button);
      if (menu_slot_or_fallback) menu_slot_or_fallback.l(button_nodes);
      t1 = claim_space(button_nodes);
      if (if_block) if_block.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
      set_attributes(button, button_data);
      toggle_class(button, "bx--overflow-menu", true);
      toggle_class(
        button,
        "bx--overflow-menu--open",
        /*open*/
        ctx[0]
      );
      toggle_class(
        button,
        "bx--overflow-menu--light",
        /*light*/
        ctx[6]
      );
      toggle_class(
        button,
        "bx--overflow-menu--sm",
        /*size*/
        ctx[4] === "sm"
      );
      toggle_class(
        button,
        "bx--overflow-menu--xl",
        /*size*/
        ctx[4] === "xl"
      );
      add_location(button, file66, 191, 0, 4568);
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*styles*/
        ctx[12],
        document.head
      );
      append_hydration_dev(document.head, html_anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, button, anchor);
      if (menu_slot_or_fallback) {
        menu_slot_or_fallback.m(button, null);
      }
      append_hydration_dev(button, t1);
      if (if_block) if_block.m(button, null);
      if (button.autofocus) button.focus();
      ctx[32](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "click",
            /*click_handler_1*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler_2*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseover",
            /*mouseover_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler_1*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "focusout",
            /*focusout_handler*/
            ctx[35],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*styles*/
      4096) html_tag.p(
        /*styles*/
        ctx2[12]
      );
      if (menu_slot) {
        if (menu_slot.p && (!current || dirty[0] & /*$$scope*/
        8388608)) {
          update_slot_base(
            menu_slot,
            menu_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              menu_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_menu_slot_changes
            ),
            get_menu_slot_context
          );
        }
      } else {
        if (menu_slot_or_fallback && menu_slot_or_fallback.p && (!current || dirty[0] & /*icon, iconDescription, iconClass*/
        1538)) {
          menu_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*open*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block41(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(button, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        { "aria-haspopup": "" },
        (!current || dirty[0] & /*open*/
        1) && { "aria-expanded": (
          /*open*/
          ctx2[0]
        ) },
        (!current || dirty[0] & /*ariaLabel*/
        8192) && { "aria-label": (
          /*ariaLabel*/
          ctx2[13]
        ) },
        (!current || dirty[0] & /*id*/
        2048) && { id: (
          /*id*/
          ctx2[11]
        ) },
        dirty[0] & /*$$restProps*/
        524288 && /*$$restProps*/
        ctx2[19]
      ]));
      toggle_class(button, "bx--overflow-menu", true);
      toggle_class(
        button,
        "bx--overflow-menu--open",
        /*open*/
        ctx2[0]
      );
      toggle_class(
        button,
        "bx--overflow-menu--light",
        /*light*/
        ctx2[6]
      );
      toggle_class(
        button,
        "bx--overflow-menu--sm",
        /*size*/
        ctx2[4] === "sm"
      );
      toggle_class(
        button,
        "bx--overflow-menu--xl",
        /*size*/
        ctx2[4] === "xl"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(menu_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(menu_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        html_tag.d();
        detach_dev(t0);
        detach_dev(button);
      }
      detach_dev(html_anchor);
      if (menu_slot_or_fallback) menu_slot_or_fallback.d(detaching);
      if (if_block) if_block.d();
      ctx[32](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment68.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance68($$self, $$props, $$invalidate) {
  let ariaLabel;
  let styles;
  const omit_props_names = [
    "size",
    "direction",
    "open",
    "light",
    "flipped",
    "menuOptionsClass",
    "icon",
    "iconClass",
    "iconDescription",
    "id",
    "buttonRef",
    "menuRef"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $currentIndex;
  let $items;
  let $currentId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OverflowMenu", slots, ["menu", "default"]);
  let { size = void 0 } = $$props;
  let { direction = "bottom" } = $$props;
  let { open = false } = $$props;
  let { light = false } = $$props;
  let { flipped = false } = $$props;
  let { menuOptionsClass = void 0 } = $$props;
  let { icon = OverflowMenuVertical_default } = $$props;
  let { iconClass = void 0 } = $$props;
  let { iconDescription = "Open and close list of options" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { buttonRef = null } = $$props;
  let { menuRef = null } = $$props;
  const ctxBreadcrumbItem = getContext("BreadcrumbItem");
  const dispatch = createEventDispatcher();
  const items = writable([]);
  validate_store(items, "items");
  component_subscribe($$self, items, (value) => $$invalidate(22, $items = value));
  const currentId = writable(void 0);
  validate_store(currentId, "currentId");
  component_subscribe($$self, currentId, (value) => $$invalidate(37, $currentId = value));
  const focusedId = writable(void 0);
  const currentIndex = writable(-1);
  validate_store(currentIndex, "currentIndex");
  component_subscribe($$self, currentIndex, (value) => $$invalidate(21, $currentIndex = value));
  let buttonWidth = void 0;
  let onMountAfterUpdate = true;
  setContext("OverflowMenu", {
    focusedId,
    add: ({ id: id2, text: text2, primaryFocus, disabled }) => {
      items.update((_) => {
        if (primaryFocus) {
          currentIndex.set(_.length);
        }
        return [
          ..._,
          {
            id: id2,
            text: text2,
            primaryFocus,
            disabled,
            index: _.length
          }
        ];
      });
    },
    update: (id2) => {
      currentId.set(id2);
    },
    change: (direction2) => {
      let index = $currentIndex + direction2;
      if (index < 0) {
        index = $items.length - 1;
      } else if (index >= $items.length) {
        index = 0;
      }
      let disabled = $items[index].disabled;
      while (disabled) {
        index = index + direction2;
        if (index < 0) {
          index = $items.length - 1;
        } else if (index >= $items.length) {
          index = 0;
        }
        disabled = $items[index].disabled;
      }
      currentIndex.set(index);
    }
  });
  afterUpdate(() => {
    if ($currentId) {
      const { index, text: text2 } = $items.filter((_) => _.id === $currentId)[0];
      dispatch("close", { index, text: text2 });
      $$invalidate(0, open = false);
    }
    if (open) {
      const width = buttonRef.offsetWidth;
      const height = buttonRef.offsetHeight;
      $$invalidate(20, buttonWidth = width);
      if (!onMountAfterUpdate && $currentIndex < 0) {
        menuRef.focus();
      }
      if (flipped) {
        $$invalidate(3, menuRef.style.left = "auto", menuRef);
        $$invalidate(3, menuRef.style.right = 0, menuRef);
      }
      if (direction === "top") {
        $$invalidate(3, menuRef.style.top = "auto", menuRef);
        $$invalidate(3, menuRef.style.bottom = height + "px", menuRef);
      } else if (direction === "bottom") {
        $$invalidate(3, menuRef.style.top = height + "px", menuRef);
      }
      if (ctxBreadcrumbItem) {
        $$invalidate(3, menuRef.style.top = height + 10 + "px", menuRef);
        $$invalidate(3, menuRef.style.left = "-11px", menuRef);
      }
    }
    if (!open) {
      items.set([]);
      currentId.set(void 0);
      currentIndex.set(0);
    }
    onMountAfterUpdate = false;
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = ({ target }) => {
    if (buttonRef && buttonRef.contains(target)) return;
    if (menuRef && !menuRef.contains(target)) {
      $$invalidate(0, open = false);
    }
  };
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menuRef = $$value;
      $$invalidate(3, menuRef);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonRef = $$value;
      $$invalidate(2, buttonRef);
    });
  }
  const click_handler_2 = ({ target }) => {
    if (!(menuRef && menuRef.contains(target))) {
      $$invalidate(0, open = !open);
      if (!open) dispatch("close");
    }
  };
  const keydown_handler_12 = (e) => {
    if (open) {
      if (["ArrowDown", "ArrowLeft", "ArrowRight", "ArrowUp"].includes(e.key)) {
        e.preventDefault();
      } else if (e.key === "Escape") {
        e.stopPropagation();
        dispatch("close");
        $$invalidate(0, open = false);
        buttonRef.focus();
      }
    }
  };
  const focusout_handler = (e) => {
    if (open) {
      if (!buttonRef.contains(e.relatedTarget)) {
        dispatch("close");
        $$invalidate(0, open = false);
      }
    }
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(39, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(4, size = $$new_props.size);
    if ("direction" in $$new_props) $$invalidate(5, direction = $$new_props.direction);
    if ("open" in $$new_props) $$invalidate(0, open = $$new_props.open);
    if ("light" in $$new_props) $$invalidate(6, light = $$new_props.light);
    if ("flipped" in $$new_props) $$invalidate(7, flipped = $$new_props.flipped);
    if ("menuOptionsClass" in $$new_props) $$invalidate(8, menuOptionsClass = $$new_props.menuOptionsClass);
    if ("icon" in $$new_props) $$invalidate(1, icon = $$new_props.icon);
    if ("iconClass" in $$new_props) $$invalidate(9, iconClass = $$new_props.iconClass);
    if ("iconDescription" in $$new_props) $$invalidate(10, iconDescription = $$new_props.iconDescription);
    if ("id" in $$new_props) $$invalidate(11, id = $$new_props.id);
    if ("buttonRef" in $$new_props) $$invalidate(2, buttonRef = $$new_props.buttonRef);
    if ("menuRef" in $$new_props) $$invalidate(3, menuRef = $$new_props.menuRef);
    if ("$$scope" in $$new_props) $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    direction,
    open,
    light,
    flipped,
    menuOptionsClass,
    icon,
    iconClass,
    iconDescription,
    id,
    buttonRef,
    menuRef,
    createEventDispatcher,
    getContext,
    setContext,
    afterUpdate,
    writable,
    OverflowMenuVertical: OverflowMenuVertical_default,
    OverflowMenuHorizontal: OverflowMenuHorizontal_default,
    ctxBreadcrumbItem,
    dispatch,
    items,
    currentId,
    focusedId,
    currentIndex,
    buttonWidth,
    onMountAfterUpdate,
    styles,
    ariaLabel,
    $currentIndex,
    $items,
    $currentId
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(39, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(4, size = $$new_props.size);
    if ("direction" in $$props) $$invalidate(5, direction = $$new_props.direction);
    if ("open" in $$props) $$invalidate(0, open = $$new_props.open);
    if ("light" in $$props) $$invalidate(6, light = $$new_props.light);
    if ("flipped" in $$props) $$invalidate(7, flipped = $$new_props.flipped);
    if ("menuOptionsClass" in $$props) $$invalidate(8, menuOptionsClass = $$new_props.menuOptionsClass);
    if ("icon" in $$props) $$invalidate(1, icon = $$new_props.icon);
    if ("iconClass" in $$props) $$invalidate(9, iconClass = $$new_props.iconClass);
    if ("iconDescription" in $$props) $$invalidate(10, iconDescription = $$new_props.iconDescription);
    if ("id" in $$props) $$invalidate(11, id = $$new_props.id);
    if ("buttonRef" in $$props) $$invalidate(2, buttonRef = $$new_props.buttonRef);
    if ("menuRef" in $$props) $$invalidate(3, menuRef = $$new_props.menuRef);
    if ("buttonWidth" in $$props) $$invalidate(20, buttonWidth = $$new_props.buttonWidth);
    if ("onMountAfterUpdate" in $$props) onMountAfterUpdate = $$new_props.onMountAfterUpdate;
    if ("styles" in $$props) $$invalidate(12, styles = $$new_props.styles);
    if ("ariaLabel" in $$props) $$invalidate(13, ariaLabel = $$new_props.ariaLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(13, ariaLabel = $$props["aria-label"] || "menu");
    if ($$self.$$.dirty[0] & /*$items, $currentIndex*/
    6291456) {
      $: if ($items[$currentIndex]) {
        focusedId.set($items[$currentIndex].id);
      }
    }
    if ($$self.$$.dirty[0] & /*id, buttonWidth*/
    1050624) {
      $: $$invalidate(12, styles = `<style>
    #${id} .bx--overflow-menu-options.bx--overflow-menu-options:after {
      width: ${buttonWidth ? buttonWidth + "px" : "2rem"};
    }
  </style>`);
    }
  };
  $: if (ctxBreadcrumbItem) {
    $$invalidate(1, icon = OverflowMenuHorizontal_default);
  }
  $$props = exclude_internal_props($$props);
  return [
    open,
    icon,
    buttonRef,
    menuRef,
    size,
    direction,
    light,
    flipped,
    menuOptionsClass,
    iconClass,
    iconDescription,
    id,
    styles,
    ariaLabel,
    ctxBreadcrumbItem,
    dispatch,
    items,
    currentId,
    currentIndex,
    $$restProps,
    buttonWidth,
    $currentIndex,
    $items,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    click_handler_13,
    ul_binding,
    button_binding,
    click_handler_2,
    keydown_handler_12,
    focusout_handler
  ];
}
var OverflowMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance68,
      create_fragment68,
      safe_not_equal,
      {
        size: 4,
        direction: 5,
        open: 0,
        light: 6,
        flipped: 7,
        menuOptionsClass: 8,
        icon: 1,
        iconClass: 9,
        iconDescription: 10,
        id: 11,
        buttonRef: 2,
        menuRef: 3
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OverflowMenu",
      options,
      id: create_fragment68.name
    });
  }
  get size() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flipped() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flipped(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuOptionsClass() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuOptionsClass(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconClass() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconClass(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonRef() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonRef(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuRef() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuRef(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OverflowMenu_default = OverflowMenu;

// node_modules/carbon-components-svelte/src/DataTable/ToolbarMenu.svelte
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: '(16:0) <OverflowMenu   bind:menuRef   icon=\\"{Settings}\\"   {...$$restProps}   class=\\"bx--toolbar-action bx--overflow-menu {$$restProps.class}\\"   flipped >',
    ctx
  });
  return block;
}
function create_fragment69(ctx) {
  let overflowmenu;
  let updating_menuRef;
  let current;
  const overflowmenu_spread_levels = [
    { icon: Settings_default },
    /*$$restProps*/
    ctx[1],
    {
      class: "bx--toolbar-action bx--overflow-menu " + /*$$restProps*/
      ctx[1].class
    },
    { flipped: true }
  ];
  function overflowmenu_menuRef_binding(value) {
    ctx[3](value);
  }
  let overflowmenu_props = {
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  for (let i = 0; i < overflowmenu_spread_levels.length; i += 1) {
    overflowmenu_props = assign(overflowmenu_props, overflowmenu_spread_levels[i]);
  }
  if (
    /*menuRef*/
    ctx[0] !== void 0
  ) {
    overflowmenu_props.menuRef = /*menuRef*/
    ctx[0];
  }
  overflowmenu = new OverflowMenu_default({
    props: overflowmenu_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(overflowmenu, "menuRef", overflowmenu_menuRef_binding));
  const block = {
    c: function create() {
      create_component(overflowmenu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(overflowmenu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(overflowmenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const overflowmenu_changes = dirty & /*$$restProps*/
      2 ? get_spread_update(overflowmenu_spread_levels, [
        overflowmenu_spread_levels[0],
        get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        {
          class: "bx--toolbar-action bx--overflow-menu " + /*$$restProps*/
          ctx2[1].class
        },
        overflowmenu_spread_levels[3]
      ]) : {};
      if (dirty & /*$$scope*/
      16) {
        overflowmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_menuRef && dirty & /*menuRef*/
      1) {
        updating_menuRef = true;
        overflowmenu_changes.menuRef = /*menuRef*/
        ctx2[0];
        add_flush_callback(() => updating_menuRef = false);
      }
      overflowmenu.$set(overflowmenu_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(overflowmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(overflowmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(overflowmenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment69.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance69($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToolbarMenu", slots, ["default"]);
  const ctx = getContext("Toolbar");
  let menuRef = null;
  function overflowmenu_menuRef_binding(value) {
    menuRef = value;
    $$invalidate(0, menuRef);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    Settings: Settings_default,
    OverflowMenu: OverflowMenu_default,
    ctx,
    menuRef
  });
  $$self.$inject_state = ($$new_props) => {
    if ("menuRef" in $$props) $$invalidate(0, menuRef = $$new_props.menuRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*menuRef*/
    1) {
      $: if (menuRef) $$invalidate(0, menuRef.style.top = "100%", menuRef);
    }
    if ($$self.$$.dirty & /*menuRef*/
    1) {
      $: ctx.setOverflowVisible(menuRef != null);
    }
  };
  return [menuRef, $$restProps, slots, overflowmenu_menuRef_binding, $$scope];
}
var ToolbarMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance69, create_fragment69, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToolbarMenu",
      options,
      id: create_fragment69.name
    });
  }
};
var ToolbarMenu_default = ToolbarMenu;

// node_modules/carbon-components-svelte/src/OverflowMenu/OverflowMenuItem.svelte
var file67 = "node_modules/carbon-components-svelte/src/OverflowMenu/OverflowMenuItem.svelte";
function create_else_block17(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_16(ctx);
  let button_levels = [
    /*buttonProps*/
    ctx[7]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {});
      var button_nodes = children(button);
      if (default_slot_or_fallback) default_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file67, 89, 4, 2277);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      if (button.autofocus) button.focus();
      ctx[24](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler_1*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler_3*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler_1*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler_3*/
            ctx[26],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*text*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [dirty & /*buttonProps*/
      128 && /*buttonProps*/
      ctx2[7]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block17.name,
    type: "else",
    source: "(89:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block42(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block13(ctx);
  let a_levels = [
    /*buttonProps*/
    ctx[7]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {});
      var a_nodes = children(a);
      if (default_slot_or_fallback) default_slot_or_fallback.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file67, 66, 4, 1809);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(a, null);
      }
      ctx[21](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "click",
            /*click_handler_2*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keydown",
            /*keydown_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keydown",
            /*keydown_handler_2*/
            ctx[23],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*text*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [dirty & /*buttonProps*/
      128 && /*buttonProps*/
      ctx2[7]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block42.name,
    type: "if",
    source: "(64:2) {#if href}",
    ctx
  });
  return block;
}
function fallback_block_16(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*text*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*text*/
        ctx[1]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--overflow-menu-options__option-content", true);
      add_location(div, file67, 106, 8, 2618);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text*/
      2) set_data_dev(
        t,
        /*text*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_16.name,
    type: "fallback",
    source: "(106:12)          ",
    ctx
  });
  return block;
}
function fallback_block13(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*text*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*text*/
        ctx[1]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--overflow-menu-options__option-content", true);
      add_location(div, file67, 83, 8, 2145);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text*/
      2) set_data_dev(
        t,
        /*text*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block13.name,
    type: "fallback",
    source: "(83:12)          ",
    ctx
  });
  return block;
}
function create_fragment70(ctx) {
  let li;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block42, create_else_block17];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*href*/
      ctx2[2]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let li_levels = [
    { role: "none" },
    { id: (
      /*id*/
      ctx[6]
    ) },
    /*$$restProps*/
    ctx[11]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { role: true, id: true });
      var li_nodes = children(li);
      if_block.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(li, li_data);
      toggle_class(li, "bx--overflow-menu-options__option", true);
      toggle_class(
        li,
        "bx--overflow-menu--divider",
        /*hasDivider*/
        ctx[4]
      );
      toggle_class(
        li,
        "bx--overflow-menu-options__option--danger",
        /*danger*/
        ctx[5]
      );
      toggle_class(
        li,
        "bx--overflow-menu-options__option--disabled",
        /*disabled*/
        ctx[3]
      );
      add_location(li, file67, 54, 0, 1401);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li, null);
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        { role: "none" },
        (!current || dirty & /*id*/
        64) && { id: (
          /*id*/
          ctx2[6]
        ) },
        dirty & /*$$restProps*/
        2048 && /*$$restProps*/
        ctx2[11]
      ]));
      toggle_class(li, "bx--overflow-menu-options__option", true);
      toggle_class(
        li,
        "bx--overflow-menu--divider",
        /*hasDivider*/
        ctx2[4]
      );
      toggle_class(
        li,
        "bx--overflow-menu-options__option--danger",
        /*danger*/
        ctx2[5]
      );
      toggle_class(
        li,
        "bx--overflow-menu-options__option--disabled",
        /*disabled*/
        ctx2[3]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment70.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance70($$self, $$props, $$invalidate) {
  let buttonProps;
  const omit_props_names = [
    "text",
    "href",
    "primaryFocus",
    "disabled",
    "hasDivider",
    "danger",
    "requireTitle",
    "id",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $focusedId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OverflowMenuItem", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { text: text2 = "Provide text" } = $$props;
  let { href = "" } = $$props;
  let { primaryFocus = false } = $$props;
  let { disabled = false } = $$props;
  let { hasDivider = false } = $$props;
  let { danger = false } = $$props;
  let { requireTitle = true } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const { focusedId, add, update, change } = getContext("OverflowMenu");
  validate_store(focusedId, "focusedId");
  component_subscribe($$self, focusedId, (value) => $$invalidate(14, $focusedId = value));
  add({ id, text: text2, primaryFocus, disabled });
  afterUpdate(() => {
    if (ref && primaryFocus) {
      ref.focus();
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler_12(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const click_handler_2 = () => {
    update(id);
  };
  const keydown_handler_2 = ({ key }) => {
    if (key === "ArrowDown") {
      change(1);
    } else if (key === "ArrowUp") {
      change(-1);
    }
  };
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const click_handler_3 = () => {
    update(id);
  };
  const keydown_handler_3 = ({ key }) => {
    if (key === "ArrowDown") {
      change(1);
    } else if (key === "ArrowUp") {
      change(-1);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("text" in $$new_props) $$invalidate(1, text2 = $$new_props.text);
    if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
    if ("primaryFocus" in $$new_props) $$invalidate(12, primaryFocus = $$new_props.primaryFocus);
    if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
    if ("hasDivider" in $$new_props) $$invalidate(4, hasDivider = $$new_props.hasDivider);
    if ("danger" in $$new_props) $$invalidate(5, danger = $$new_props.danger);
    if ("requireTitle" in $$new_props) $$invalidate(13, requireTitle = $$new_props.requireTitle);
    if ("id" in $$new_props) $$invalidate(6, id = $$new_props.id);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    text: text2,
    href,
    primaryFocus,
    disabled,
    hasDivider,
    danger,
    requireTitle,
    id,
    ref,
    getContext,
    afterUpdate,
    focusedId,
    add,
    update,
    change,
    buttonProps,
    $focusedId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("text" in $$props) $$invalidate(1, text2 = $$new_props.text);
    if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
    if ("primaryFocus" in $$props) $$invalidate(12, primaryFocus = $$new_props.primaryFocus);
    if ("disabled" in $$props) $$invalidate(3, disabled = $$new_props.disabled);
    if ("hasDivider" in $$props) $$invalidate(4, hasDivider = $$new_props.hasDivider);
    if ("danger" in $$props) $$invalidate(5, danger = $$new_props.danger);
    if ("requireTitle" in $$props) $$invalidate(13, requireTitle = $$new_props.requireTitle);
    if ("id" in $$props) $$invalidate(6, id = $$new_props.id);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    if ("buttonProps" in $$props) $$invalidate(7, buttonProps = $$new_props.buttonProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$focusedId, id*/
    16448) {
      $: $$invalidate(12, primaryFocus = $focusedId === id);
    }
    if ($$self.$$.dirty & /*href, disabled, requireTitle, text*/
    8206) {
      $: $$invalidate(7, buttonProps = {
        role: "menuitem",
        tabindex: "-1",
        class: "bx--overflow-menu-options__btn",
        disabled: href ? void 0 : disabled,
        href: href ? href : void 0,
        title: requireTitle ? $$slots.default ? void 0 : text2 : void 0
      });
    }
  };
  return [
    ref,
    text2,
    href,
    disabled,
    hasDivider,
    danger,
    id,
    buttonProps,
    focusedId,
    update,
    change,
    $$restProps,
    primaryFocus,
    requireTitle,
    $focusedId,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    click_handler_13,
    keydown_handler_12,
    a_binding,
    click_handler_2,
    keydown_handler_2,
    button_binding,
    click_handler_3,
    keydown_handler_3
  ];
}
var OverflowMenuItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance70, create_fragment70, safe_not_equal, {
      text: 1,
      href: 2,
      primaryFocus: 12,
      disabled: 3,
      hasDivider: 4,
      danger: 5,
      requireTitle: 13,
      id: 6,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OverflowMenuItem",
      options,
      id: create_fragment70.name
    });
  }
  get text() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryFocus() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryFocus(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasDivider() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasDivider(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get danger() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set danger(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get requireTitle() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set requireTitle(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OverflowMenuItem_default = OverflowMenuItem;

// node_modules/carbon-components-svelte/src/DataTable/ToolbarMenuItem.svelte
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(7:0) <OverflowMenuItem {...$$restProps} on:click on:keydown>",
    ctx
  });
  return block;
}
function create_fragment71(ctx) {
  let overflowmenuitem;
  let current;
  const overflowmenuitem_spread_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let overflowmenuitem_props = {
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  for (let i = 0; i < overflowmenuitem_spread_levels.length; i += 1) {
    overflowmenuitem_props = assign(overflowmenuitem_props, overflowmenuitem_spread_levels[i]);
  }
  overflowmenuitem = new OverflowMenuItem_default({
    props: overflowmenuitem_props,
    $$inline: true
  });
  overflowmenuitem.$on(
    "click",
    /*click_handler*/
    ctx[2]
  );
  overflowmenuitem.$on(
    "keydown",
    /*keydown_handler*/
    ctx[3]
  );
  const block = {
    c: function create() {
      create_component(overflowmenuitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(overflowmenuitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(overflowmenuitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const overflowmenuitem_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(overflowmenuitem_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      16) {
        overflowmenuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      overflowmenuitem.$set(overflowmenuitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(overflowmenuitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(overflowmenuitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(overflowmenuitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment71.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance71($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToolbarMenuItem", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ OverflowMenuItem: OverflowMenuItem_default });
  return [$$restProps, slots, click_handler, keydown_handler, $$scope];
}
var ToolbarMenuItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance71, create_fragment71, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToolbarMenuItem",
      options,
      id: create_fragment71.name
    });
  }
};
var ToolbarMenuItem_default = ToolbarMenuItem;

// node_modules/carbon-components-svelte/src/DatePicker/createCalendar.js
var l10n;
function updateClasses(instance207) {
  const {
    calendarContainer,
    days,
    daysContainer,
    weekdayContainer,
    selectedDates
  } = instance207;
  calendarContainer.classList.add("bx--date-picker__calendar");
  calendarContainer.querySelector(".flatpickr-month").classList.add("bx--date-picker__month");
  weekdayContainer.classList.add("bx--date-picker__weekdays");
  weekdayContainer.querySelectorAll(".flatpickr-weekday").forEach((node) => {
    node.classList.add("bx--date-picker__weekday");
  });
  daysContainer.classList.add("bx--date-picker__days");
  days.querySelectorAll(".flatpickr-day").forEach((node) => {
    node.classList.add("bx--date-picker__day");
    if (node.classList.contains("today") && selectedDates.length > 0) {
      node.classList.add("no-border");
    } else if (node.classList.contains("today") && selectedDates.length === 0) {
      node.classList.remove("no-border");
    }
  });
}
function updateMonthNode(instance207) {
  const monthText = instance207.l10n.months.longhand[instance207.currentMonth];
  const staticMonthNode = instance207.monthNav.querySelector(".cur-month");
  if (staticMonthNode) {
    staticMonthNode.textContent = monthText;
  } else {
    const monthSelectNode = instance207.monthsDropdownContainer;
    const span = document.createElement("span");
    span.setAttribute("class", "cur-month");
    span.textContent = monthText;
    monthSelectNode.parentNode.replaceChild(span, monthSelectNode);
  }
}
async function createCalendar({ options, base, input, dispatch }) {
  let locale = options.locale;
  if (options.locale === "en" && l10n && l10n.en) {
    l10n.en.weekdays.shorthand.forEach((_, index) => {
      const shorthand = _.slice(0, 2);
      l10n.en.weekdays.shorthand[index] = shorthand === "Th" ? "Th" : shorthand.charAt(0);
    });
    locale = l10n.en;
  }
  let rangePlugin;
  if (options.mode === "range") {
    const importee = await import("./flatpickr_dist_esm_plugins_rangePlugin.js");
    rangePlugin = importee.default;
  }
  return new esm_default(base, {
    allowInput: true,
    disableMobile: true,
    clickOpens: true,
    locale,
    plugins: [
      options.mode === "range" && new rangePlugin({ position: "left", input })
    ].filter(Boolean),
    nextArrow: '<svg width="16px" height="16px" viewBox="0 0 16 16"><polygon points="11,8 6,13 5.3,12.3 9.6,8 5.3,3.7 6,3 "/><rect width="16" height="16" style="fill: none" /></svg>',
    prevArrow: '<svg width="16px" height="16px" viewBox="0 0 16 16"><polygon points="5,8 10,3 10.7,3.7 6.4,8 10.7,12.3 10,13 "/><rect width="16" height="16" style="fill: none" /></svg>',
    onChange: () => {
      dispatch("change");
    },
    onClose: () => {
      dispatch("close");
    },
    onMonthChange: (s, d, instance207) => {
      updateMonthNode(instance207);
    },
    onOpen: (s, d, instance207) => {
      dispatch("open");
      updateClasses(instance207);
      updateMonthNode(instance207);
    },
    ...options
  });
}

// node_modules/carbon-components-svelte/src/DatePicker/DatePicker.svelte
var file68 = "node_modules/carbon-components-svelte/src/DatePicker/DatePicker.svelte";
function create_fragment72(ctx) {
  let div1;
  let div0;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[30].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    null
  );
  let div1_levels = [
    /*$$restProps*/
    ctx[15]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { id: true });
      var div0_nodes = children(div0);
      if (default_slot) default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div0,
        "id",
        /*id*/
        ctx[3]
      );
      toggle_class(div0, "bx--date-picker", true);
      toggle_class(
        div0,
        "bx--date-picker--short",
        /*short*/
        ctx[1]
      );
      toggle_class(
        div0,
        "bx--date-picker--light",
        /*light*/
        ctx[2]
      );
      toggle_class(
        div0,
        "bx--date-picker--simple",
        /*datePickerType*/
        ctx[0] === "simple"
      );
      toggle_class(
        div0,
        "bx--date-picker--single",
        /*datePickerType*/
        ctx[0] === "single"
      );
      toggle_class(
        div0,
        "bx--date-picker--range",
        /*datePickerType*/
        ctx[0] === "range"
      );
      toggle_class(
        div0,
        "bx--date-picker--nolabel",
        /*datePickerType*/
        ctx[0] === "range" && /*$labelTextEmpty*/
        ctx[6]
      );
      add_location(div0, file68, 250, 2, 6248);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file68, 241, 0, 6070);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[36](div0);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "click",
            /*click_handler_1*/
            ctx[35],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "keydown",
            /*keydown_handler*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseover",
            /*mouseover_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[34],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*id*/
      8) {
        attr_dev(
          div0,
          "id",
          /*id*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*short*/
      2) {
        toggle_class(
          div0,
          "bx--date-picker--short",
          /*short*/
          ctx2[1]
        );
      }
      if (!current || dirty[0] & /*light*/
      4) {
        toggle_class(
          div0,
          "bx--date-picker--light",
          /*light*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*datePickerType*/
      1) {
        toggle_class(
          div0,
          "bx--date-picker--simple",
          /*datePickerType*/
          ctx2[0] === "simple"
        );
      }
      if (!current || dirty[0] & /*datePickerType*/
      1) {
        toggle_class(
          div0,
          "bx--date-picker--single",
          /*datePickerType*/
          ctx2[0] === "single"
        );
      }
      if (!current || dirty[0] & /*datePickerType*/
      1) {
        toggle_class(
          div0,
          "bx--date-picker--range",
          /*datePickerType*/
          ctx2[0] === "range"
        );
      }
      if (!current || dirty[0] & /*datePickerType, $labelTextEmpty*/
      65) {
        toggle_class(
          div0,
          "bx--date-picker--nolabel",
          /*datePickerType*/
          ctx2[0] === "range" && /*$labelTextEmpty*/
          ctx2[6]
        );
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty[0] & /*$$restProps*/
      32768 && /*$$restProps*/
      ctx2[15]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[36](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment72.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance72($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "datePickerType",
    "value",
    "valueFrom",
    "valueTo",
    "dateFormat",
    "maxDate",
    "minDate",
    "locale",
    "short",
    "light",
    "id",
    "flatpickrProps"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $hasCalendar;
  let $inputValueTo;
  let $inputValueFrom;
  let $inputValue;
  let $range;
  let $mode;
  let $inputIds;
  let $labelTextEmpty;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DatePicker", slots, ["default"]);
  let { datePickerType = "simple" } = $$props;
  let { value = "" } = $$props;
  let { valueFrom = "" } = $$props;
  let { valueTo = "" } = $$props;
  let { dateFormat = "m/d/Y" } = $$props;
  let { maxDate = null } = $$props;
  let { minDate = null } = $$props;
  let { locale = "en" } = $$props;
  let { short = false } = $$props;
  let { light = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { flatpickrProps = { static: true } } = $$props;
  const dispatch = createEventDispatcher();
  const inputs = writable([]);
  const inputIds = derived(inputs, (_) => _.map(({ id: id2 }) => id2));
  validate_store(inputIds, "inputIds");
  component_subscribe($$self, inputIds, (value2) => $$invalidate(41, $inputIds = value2));
  const labelTextEmpty = derived(inputs, (_) => _.filter(({ labelText }) => !!labelText).length === 0);
  validate_store(labelTextEmpty, "labelTextEmpty");
  component_subscribe($$self, labelTextEmpty, (value2) => $$invalidate(6, $labelTextEmpty = value2));
  const inputValue = writable(value);
  validate_store(inputValue, "inputValue");
  component_subscribe($$self, inputValue, (value2) => $$invalidate(28, $inputValue = value2));
  const inputValueFrom = writable(valueFrom);
  validate_store(inputValueFrom, "inputValueFrom");
  component_subscribe($$self, inputValueFrom, (value2) => $$invalidate(27, $inputValueFrom = value2));
  const inputValueTo = writable(valueTo);
  validate_store(inputValueTo, "inputValueTo");
  component_subscribe($$self, inputValueTo, (value2) => $$invalidate(26, $inputValueTo = value2));
  const mode = writable(datePickerType);
  validate_store(mode, "mode");
  component_subscribe($$self, mode, (value2) => $$invalidate(40, $mode = value2));
  const range = derived(mode, (_) => _ === "range");
  validate_store(range, "range");
  component_subscribe($$self, range, (value2) => $$invalidate(39, $range = value2));
  const hasCalendar = derived(mode, (_) => _ === "single" || _ === "range");
  validate_store(hasCalendar, "hasCalendar");
  component_subscribe($$self, hasCalendar, (value2) => $$invalidate(25, $hasCalendar = value2));
  let calendar = null;
  let datePickerRef = null;
  let inputRef = null;
  let inputRefTo = null;
  setContext("DatePicker", {
    range,
    inputValue,
    inputValueFrom,
    inputValueTo,
    inputIds,
    hasCalendar,
    add: (data) => {
      inputs.update((_) => [..._, data]);
    },
    declareRef: ({ id: id2, ref }) => {
      if ($inputIds.indexOf(id2) === 0) {
        $$invalidate(24, inputRef = ref);
      } else {
        inputRefTo = ref;
      }
    },
    updateValue: ({ type, value: value2 }) => {
      if (!calendar && type === "input" || type === "change") {
        inputValue.set(value2);
      }
      if (!calendar && type === "change") {
        dispatch("change", value2);
      }
    },
    blurInput: (relatedTarget) => {
      if (calendar && !calendar.calendarContainer.contains(relatedTarget)) {
        calendar.close();
      }
    },
    openCalendar: () => {
      calendar.open();
    },
    focusCalendar: () => {
      (calendar.selectedDateElem || calendar.todayDateElem || calendar.calendarContainer.querySelector(".flatpickr-day[tabindex]") || calendar.calendarContainer).focus();
    }
  });
  async function initCalendar(options) {
    var _a, _b;
    if (calendar) {
      calendar.set("minDate", minDate);
      calendar.set("maxDate", maxDate);
      calendar.set("locale", locale);
      calendar.set("dateFormat", dateFormat);
      Object.entries(flatpickrProps).forEach(([option, value2]) => {
        calendar.set(options, value2);
      });
      return;
    }
    $$invalidate(4, calendar = await createCalendar({
      options: {
        ...options,
        appendTo: datePickerRef,
        defaultDate: $inputValue,
        mode: $mode
      },
      base: inputRef,
      input: inputRefTo,
      dispatch: (event2) => {
        const detail = { selectedDates: calendar.selectedDates };
        if ($range) {
          const from = inputRef.value;
          const to = inputRefTo.value;
          detail.dateStr = {
            from: inputRef.value,
            to: inputRefTo.value
          };
          $$invalidate(17, valueFrom = from);
          $$invalidate(18, valueTo = to);
        } else {
          detail.dateStr = inputRef.value;
        }
        return dispatch(event2, detail);
      }
    }));
    (_a = calendar == null ? void 0 : calendar.calendarContainer) == null ? void 0 : _a.setAttribute("role", "application");
    (_b = calendar == null ? void 0 : calendar.calendarContainer) == null ? void 0 : _b.setAttribute("aria-label", "calendar-container");
  }
  onMount(() => {
    return () => {
      if (calendar) {
        calendar.destroy();
        $$invalidate(4, calendar = null);
      }
    };
  });
  afterUpdate(() => {
    if (calendar) {
      if ($range) {
        calendar.setDate([$inputValueFrom, $inputValueTo]);
        $$invalidate(24, inputRef.value = $inputValueFrom, inputRef);
      } else {
        calendar.setDate($inputValue);
      }
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = ({ target }) => {
    if (!calendar || !calendar.isOpen) return;
    if (datePickerRef && datePickerRef.contains(target)) return;
    if (!calendar.calendarContainer.contains(target)) calendar.close();
  };
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      datePickerRef = $$value;
      $$invalidate(5, datePickerRef);
    });
  }
  const keydown_handler = (e) => {
    if ((calendar == null ? void 0 : calendar.isOpen) && e.key === "Escape") {
      e.stopPropagation();
      calendar.close();
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("datePickerType" in $$new_props) $$invalidate(0, datePickerType = $$new_props.datePickerType);
    if ("value" in $$new_props) $$invalidate(16, value = $$new_props.value);
    if ("valueFrom" in $$new_props) $$invalidate(17, valueFrom = $$new_props.valueFrom);
    if ("valueTo" in $$new_props) $$invalidate(18, valueTo = $$new_props.valueTo);
    if ("dateFormat" in $$new_props) $$invalidate(19, dateFormat = $$new_props.dateFormat);
    if ("maxDate" in $$new_props) $$invalidate(20, maxDate = $$new_props.maxDate);
    if ("minDate" in $$new_props) $$invalidate(21, minDate = $$new_props.minDate);
    if ("locale" in $$new_props) $$invalidate(22, locale = $$new_props.locale);
    if ("short" in $$new_props) $$invalidate(1, short = $$new_props.short);
    if ("light" in $$new_props) $$invalidate(2, light = $$new_props.light);
    if ("id" in $$new_props) $$invalidate(3, id = $$new_props.id);
    if ("flatpickrProps" in $$new_props) $$invalidate(23, flatpickrProps = $$new_props.flatpickrProps);
    if ("$$scope" in $$new_props) $$invalidate(29, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    datePickerType,
    value,
    valueFrom,
    valueTo,
    dateFormat,
    maxDate,
    minDate,
    locale,
    short,
    light,
    id,
    flatpickrProps,
    createEventDispatcher,
    setContext,
    afterUpdate,
    onMount,
    writable,
    derived,
    createCalendar,
    dispatch,
    inputs,
    inputIds,
    labelTextEmpty,
    inputValue,
    inputValueFrom,
    inputValueTo,
    mode,
    range,
    hasCalendar,
    calendar,
    datePickerRef,
    inputRef,
    inputRefTo,
    initCalendar,
    $hasCalendar,
    $inputValueTo,
    $inputValueFrom,
    $inputValue,
    $range,
    $mode,
    $inputIds,
    $labelTextEmpty
  });
  $$self.$inject_state = ($$new_props) => {
    if ("datePickerType" in $$props) $$invalidate(0, datePickerType = $$new_props.datePickerType);
    if ("value" in $$props) $$invalidate(16, value = $$new_props.value);
    if ("valueFrom" in $$props) $$invalidate(17, valueFrom = $$new_props.valueFrom);
    if ("valueTo" in $$props) $$invalidate(18, valueTo = $$new_props.valueTo);
    if ("dateFormat" in $$props) $$invalidate(19, dateFormat = $$new_props.dateFormat);
    if ("maxDate" in $$props) $$invalidate(20, maxDate = $$new_props.maxDate);
    if ("minDate" in $$props) $$invalidate(21, minDate = $$new_props.minDate);
    if ("locale" in $$props) $$invalidate(22, locale = $$new_props.locale);
    if ("short" in $$props) $$invalidate(1, short = $$new_props.short);
    if ("light" in $$props) $$invalidate(2, light = $$new_props.light);
    if ("id" in $$props) $$invalidate(3, id = $$new_props.id);
    if ("flatpickrProps" in $$props) $$invalidate(23, flatpickrProps = $$new_props.flatpickrProps);
    if ("calendar" in $$props) $$invalidate(4, calendar = $$new_props.calendar);
    if ("datePickerRef" in $$props) $$invalidate(5, datePickerRef = $$new_props.datePickerRef);
    if ("inputRef" in $$props) $$invalidate(24, inputRef = $$new_props.inputRef);
    if ("inputRefTo" in $$props) inputRefTo = $$new_props.inputRefTo;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$inputValue*/
    268435456) {
      $: $$invalidate(16, value = $inputValue);
    }
    if ($$self.$$.dirty[0] & /*value*/
    65536) {
      $: inputValue.set(value);
    }
    if ($$self.$$.dirty[0] & /*$inputValueFrom*/
    134217728) {
      $: $$invalidate(17, valueFrom = $inputValueFrom);
    }
    if ($$self.$$.dirty[0] & /*valueFrom*/
    131072) {
      $: inputValueFrom.set(valueFrom);
    }
    if ($$self.$$.dirty[0] & /*$inputValueTo*/
    67108864) {
      $: $$invalidate(18, valueTo = $inputValueTo);
    }
    if ($$self.$$.dirty[0] & /*valueTo*/
    262144) {
      $: inputValueTo.set(valueTo);
    }
    if ($$self.$$.dirty[0] & /*$hasCalendar, inputRef, dateFormat, locale, maxDate, minDate, flatpickrProps*/
    66584576) {
      $: if ($hasCalendar && inputRef) {
        initCalendar({
          dateFormat,
          locale,
          maxDate,
          minDate,
          // default to static: true so the
          // date picker works inside a modal
          static: true,
          ...flatpickrProps
        });
      }
    }
  };
  return [
    datePickerType,
    short,
    light,
    id,
    calendar,
    datePickerRef,
    $labelTextEmpty,
    inputIds,
    labelTextEmpty,
    inputValue,
    inputValueFrom,
    inputValueTo,
    mode,
    range,
    hasCalendar,
    $$restProps,
    value,
    valueFrom,
    valueTo,
    dateFormat,
    maxDate,
    minDate,
    locale,
    flatpickrProps,
    inputRef,
    $hasCalendar,
    $inputValueTo,
    $inputValueFrom,
    $inputValue,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler_13,
    div0_binding,
    keydown_handler
  ];
}
var DatePicker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance72,
      create_fragment72,
      safe_not_equal,
      {
        datePickerType: 0,
        value: 16,
        valueFrom: 17,
        valueTo: 18,
        dateFormat: 19,
        maxDate: 20,
        minDate: 21,
        locale: 22,
        short: 1,
        light: 2,
        id: 3,
        flatpickrProps: 23
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DatePicker",
      options,
      id: create_fragment72.name
    });
  }
  get datePickerType() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set datePickerType(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueFrom() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueFrom(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueTo() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueTo(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dateFormat() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dateFormat(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxDate() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxDate(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minDate() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minDate(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get locale() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set locale(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get short() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set short(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flatpickrProps() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flatpickrProps(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DatePicker_default = DatePicker;

// node_modules/carbon-components-svelte/src/icons/Calendar.svelte
var file69 = "node_modules/carbon-components-svelte/src/icons/Calendar.svelte";
function create_if_block43(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file69, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block43.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment73(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block43(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M26,4h-4V2h-2v2h-8V2h-2v2H6C4.9,4,4,4.9,4,6v20c0,1.1,0.9,2,2,2h20c1.1,0,2-0.9,2-2V6C28,4.9,27.1,4,26,4z M26,26H6V12h20	V26z M26,10H6V6h4v2h2V6h8v2h2V6h4V10z");
      add_location(path, file69, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file69, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block43(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment73.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance73($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Calendar", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Calendar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance73, create_fragment73, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Calendar",
      options,
      id: create_fragment73.name
    });
  }
  get size() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Calendar_default = Calendar;

// node_modules/carbon-components-svelte/src/DatePicker/DatePickerInput.svelte
var file70 = "node_modules/carbon-components-svelte/src/DatePicker/DatePickerInput.svelte";
var get_labelText_slot_changes5 = (dirty) => ({});
var get_labelText_slot_context5 = (ctx) => ({});
function create_if_block_64(ctx) {
  let label;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[35].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[34],
    get_labelText_slot_context5
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block14(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[8]
      );
      toggle_class(label, "bx--label", true);
      toggle_class(
        label,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[10]
      );
      toggle_class(
        label,
        "bx--label--disabled",
        /*disabled*/
        ctx[5]
      );
      add_location(label, file70, 85, 4, 1995);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[1] & /*$$scope*/
        8)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[34],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[34]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[34],
              dirty,
              get_labelText_slot_changes5
            ),
            get_labelText_slot_context5
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & /*labelText*/
        512)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      256) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*hideLabel*/
      1024) {
        toggle_class(
          label,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      32) {
        toggle_class(
          label,
          "bx--label--disabled",
          /*disabled*/
          ctx2[5]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_64.name,
    type: "if",
    source: "(85:2) {#if labelText || $$slots.labelText}",
    ctx
  });
  return block;
}
function fallback_block14(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[9]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[9]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelText*/
      512) set_data_dev(
        t,
        /*labelText*/
        ctx2[9]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block14.name,
    type: "fallback",
    source: "(92:29)          ",
    ctx
  });
  return block;
}
function create_if_block_54(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: {
      class: "bx--date-picker__icon bx--date-picker__icon--invalid"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_54.name,
    type: "if",
    source: "(141:4) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_45(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--date-picker__icon bx--date-picker__icon--warn"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningaltfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_45.name,
    type: "if",
    source: "(146:4) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_35(ctx) {
  let calendar;
  let current;
  calendar = new Calendar_default({
    props: {
      class: "bx--date-picker__icon",
      "aria-label": (
        /*iconDescription*/
        ctx[7]
      )
    },
    $$inline: true
  });
  calendar.$on(
    "click",
    /*openCalendar*/
    ctx[27]
  );
  const block = {
    c: function create() {
      create_component(calendar.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(calendar.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(calendar, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const calendar_changes = {};
      if (dirty[0] & /*iconDescription*/
      128) calendar_changes["aria-label"] = /*iconDescription*/
      ctx2[7];
      calendar.$set(calendar_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(calendar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(calendar.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(calendar, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: "(151:4) {#if $hasCalendar && !invalid && !warn}",
    ctx
  });
  return block;
}
function create_if_block_29(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*invalidText*/
        ctx[12]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*invalidText*/
        ctx[12]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file70, 159, 4, 3988);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*invalidText*/
      4096) set_data_dev(
        t,
        /*invalidText*/
        ctx2[12]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_29.name,
    type: "if",
    source: "(159:2) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_113(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*warnText*/
        ctx[14]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*warnText*/
        ctx[14]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file70, 162, 4, 4086);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*warnText*/
      16384) set_data_dev(
        t,
        /*warnText*/
        ctx2[14]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(162:2) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block44(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[6]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[6]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(
        div,
        "bx--form__helper-text--disabled",
        /*disabled*/
        ctx[5]
      );
      add_location(div, file70, 165, 4, 4196);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*helperText*/
      64) set_data_dev(
        t,
        /*helperText*/
        ctx2[6]
      );
      if (dirty[0] & /*disabled*/
      32) {
        toggle_class(
          div,
          "bx--form__helper-text--disabled",
          /*disabled*/
          ctx2[5]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block44.name,
    type: "if",
    source: "(165:2) {#if !invalid && !warn && helperText}",
    ctx
  });
  return block;
}
function create_fragment74(ctx) {
  let div1;
  let t0;
  let div0;
  let input;
  let input_data_invalid_value;
  let input_value_value;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*labelText*/
    (ctx[9] || /*$$slots*/
    ctx[32].labelText) && create_if_block_64(ctx)
  );
  let input_levels = [
    {
      "data-invalid": input_data_invalid_value = /*invalid*/
      ctx[11] || void 0
    },
    { id: (
      /*id*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[15]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[3]
    ) },
    { type: (
      /*type*/
      ctx[2]
    ) },
    { pattern: (
      /*pattern*/
      ctx[4]
    ) },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    /*$$restProps*/
    ctx[33],
    {
      value: input_value_value = /*$range*/
      ctx[16] ? (
        /*$inputIds*/
        ctx[17].indexOf(
          /*id*/
          ctx[8]
        ) === 0 ? (
          /*$inputValueFrom*/
          ctx[18]
        ) : (
          /*$inputValueTo*/
          ctx[19]
        )
      ) : (
        /*$inputValue*/
        ctx[20]
      )
    }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block1 = (
    /*invalid*/
    ctx[11] && create_if_block_54(ctx)
  );
  let if_block2 = !/*invalid*/
  ctx[11] && /*warn*/
  ctx[13] && create_if_block_45(ctx);
  let if_block3 = (
    /*$hasCalendar*/
    ctx[21] && !/*invalid*/
    ctx[11] && !/*warn*/
    ctx[13] && create_if_block_35(ctx)
  );
  let if_block4 = (
    /*invalid*/
    ctx[11] && create_if_block_29(ctx)
  );
  let if_block5 = !/*invalid*/
  ctx[11] && /*warn*/
  ctx[13] && create_if_block_113(ctx);
  let if_block6 = !/*invalid*/
  ctx[11] && !/*warn*/
  ctx[13] && /*helperText*/
  ctx[6] && create_if_block44(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      div0 = element("div");
      input = element("input");
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      t3 = space();
      if (if_block3) if_block3.c();
      t4 = space();
      if (if_block4) if_block4.c();
      t5 = space();
      if (if_block5) if_block5.c();
      t6 = space();
      if (if_block6) if_block6.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      if (if_block0) if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", {
        "data-invalid": true,
        id: true,
        name: true,
        placeholder: true,
        type: true,
        pattern: true
      });
      t1 = claim_space(div0_nodes);
      if (if_block1) if_block1.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      if (if_block2) if_block2.l(div0_nodes);
      t3 = claim_space(div0_nodes);
      if (if_block3) if_block3.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t4 = claim_space(div1_nodes);
      if (if_block4) if_block4.l(div1_nodes);
      t5 = claim_space(div1_nodes);
      if (if_block5) if_block5.l(div1_nodes);
      t6 = claim_space(div1_nodes);
      if (if_block6) if_block6.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "bx--date-picker__input", true);
      toggle_class(
        input,
        "bx--date-picker__input--invalid",
        /*invalid*/
        ctx[11]
      );
      toggle_class(
        input,
        "bx--date-picker__input--sm",
        /*size*/
        ctx[1] === "sm"
      );
      toggle_class(
        input,
        "bx--date-picker__input--xl",
        /*size*/
        ctx[1] === "xl"
      );
      add_location(input, file70, 101, 4, 2415);
      toggle_class(div0, "bx--date-picker-input__wrapper", true);
      toggle_class(
        div0,
        "bx--date-picker-input__wrapper--invalid",
        /*invalid*/
        ctx[11]
      );
      toggle_class(
        div0,
        "bx--date-picker-input__wrapper--warn",
        /*warn*/
        ctx[13]
      );
      add_location(div0, file70, 96, 2, 2234);
      toggle_class(div1, "bx--date-picker-container", true);
      toggle_class(div1, "bx--date-picker--nolabel", !/*labelText*/
      ctx[9]);
      add_location(div1, file70, 80, 0, 1854);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0) if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, input);
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      if (input.autofocus) input.focus();
      ctx[41](input);
      append_hydration_dev(div0, t1);
      if (if_block1) if_block1.m(div0, null);
      append_hydration_dev(div0, t2);
      if (if_block2) if_block2.m(div0, null);
      append_hydration_dev(div0, t3);
      if (if_block3) if_block3.m(div0, null);
      append_hydration_dev(div1, t4);
      if (if_block4) if_block4.m(div1, null);
      append_hydration_dev(div1, t5);
      if (if_block5) if_block5.m(div1, null);
      append_hydration_dev(div1, t6);
      if (if_block6) if_block6.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[36],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_1*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[43],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_1*/
            ctx[44],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[38],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[39],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler_1*/
            ctx[45],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "paste",
            /*paste_handler*/
            ctx[40],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*labelText*/
        ctx2[9] || /*$$slots*/
        ctx2[32].labelText
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*labelText*/
          512 | dirty[1] & /*$$slots*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_64(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        (!current || dirty[0] & /*invalid*/
        2048 && input_data_invalid_value !== (input_data_invalid_value = /*invalid*/
        ctx2[11] || void 0)) && { "data-invalid": input_data_invalid_value },
        (!current || dirty[0] & /*id*/
        256) && { id: (
          /*id*/
          ctx2[8]
        ) },
        (!current || dirty[0] & /*name*/
        32768) && { name: (
          /*name*/
          ctx2[15]
        ) },
        (!current || dirty[0] & /*placeholder*/
        8) && { placeholder: (
          /*placeholder*/
          ctx2[3]
        ) },
        (!current || dirty[0] & /*type*/
        4) && { type: (
          /*type*/
          ctx2[2]
        ) },
        (!current || dirty[0] & /*pattern*/
        16) && { pattern: (
          /*pattern*/
          ctx2[4]
        ) },
        (!current || dirty[0] & /*disabled*/
        32) && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        dirty[1] & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[33],
        (!current || dirty[0] & /*$range, $inputIds, id, $inputValueFrom, $inputValueTo, $inputValue*/
        2031872 && input_value_value !== (input_value_value = /*$range*/
        ctx2[16] ? (
          /*$inputIds*/
          ctx2[17].indexOf(
            /*id*/
            ctx2[8]
          ) === 0 ? (
            /*$inputValueFrom*/
            ctx2[18]
          ) : (
            /*$inputValueTo*/
            ctx2[19]
          )
        ) : (
          /*$inputValue*/
          ctx2[20]
        )) && input.value !== input_value_value) && { value: input_value_value }
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      toggle_class(input, "bx--date-picker__input", true);
      toggle_class(
        input,
        "bx--date-picker__input--invalid",
        /*invalid*/
        ctx2[11]
      );
      toggle_class(
        input,
        "bx--date-picker__input--sm",
        /*size*/
        ctx2[1] === "sm"
      );
      toggle_class(
        input,
        "bx--date-picker__input--xl",
        /*size*/
        ctx2[1] === "xl"
      );
      if (
        /*invalid*/
        ctx2[11]
      ) {
        if (if_block1) {
          if (dirty[0] & /*invalid*/
          2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_54(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!/*invalid*/
      ctx2[11] && /*warn*/
      ctx2[13]) {
        if (if_block2) {
          if (dirty[0] & /*invalid, warn*/
          10240) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_45(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*$hasCalendar*/
        ctx2[21] && !/*invalid*/
        ctx2[11] && !/*warn*/
        ctx2[13]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*$hasCalendar, invalid, warn*/
          2107392) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_35(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*invalid*/
      2048) {
        toggle_class(
          div0,
          "bx--date-picker-input__wrapper--invalid",
          /*invalid*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*warn*/
      8192) {
        toggle_class(
          div0,
          "bx--date-picker-input__wrapper--warn",
          /*warn*/
          ctx2[13]
        );
      }
      if (
        /*invalid*/
        ctx2[11]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_29(ctx2);
          if_block4.c();
          if_block4.m(div1, t5);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (!/*invalid*/
      ctx2[11] && /*warn*/
      ctx2[13]) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block_113(ctx2);
          if_block5.c();
          if_block5.m(div1, t6);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (!/*invalid*/
      ctx2[11] && !/*warn*/
      ctx2[13] && /*helperText*/
      ctx2[6]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
        } else {
          if_block6 = create_if_block44(ctx2);
          if_block6.c();
          if_block6.m(div1, null);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
      if (!current || dirty[0] & /*labelText*/
      512) {
        toggle_class(div1, "bx--date-picker--nolabel", !/*labelText*/
        ctx2[9]);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block0) if_block0.d();
      ctx[41](null);
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      if (if_block4) if_block4.d();
      if (if_block5) if_block5.d();
      if (if_block6) if_block6.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment74.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance74($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "size",
    "type",
    "placeholder",
    "pattern",
    "disabled",
    "helperText",
    "iconDescription",
    "id",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $range;
  let $inputIds;
  let $inputValueFrom;
  let $inputValueTo;
  let $inputValue;
  let $hasCalendar;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DatePickerInput", slots, ["labelText"]);
  const $$slots = compute_slots(slots);
  let { size = void 0 } = $$props;
  let { type = "text" } = $$props;
  let { placeholder = "" } = $$props;
  let { pattern = "\\d{1,2}\\/\\d{1,2}\\/\\d{4}" } = $$props;
  let { disabled = false } = $$props;
  let { helperText = "" } = $$props;
  let { iconDescription = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  const { range, add, hasCalendar, declareRef, inputIds, updateValue, blurInput, openCalendar, focusCalendar, inputValue, inputValueFrom, inputValueTo } = getContext("DatePicker");
  validate_store(range, "range");
  component_subscribe($$self, range, (value) => $$invalidate(16, $range = value));
  validate_store(hasCalendar, "hasCalendar");
  component_subscribe($$self, hasCalendar, (value) => $$invalidate(21, $hasCalendar = value));
  validate_store(inputIds, "inputIds");
  component_subscribe($$self, inputIds, (value) => $$invalidate(17, $inputIds = value));
  validate_store(inputValue, "inputValue");
  component_subscribe($$self, inputValue, (value) => $$invalidate(20, $inputValue = value));
  validate_store(inputValueFrom, "inputValueFrom");
  component_subscribe($$self, inputValueFrom, (value) => $$invalidate(18, $inputValueFrom = value));
  validate_store(inputValueTo, "inputValueTo");
  component_subscribe($$self, inputValueTo, (value) => $$invalidate(19, $inputValueTo = value));
  add({ id, labelText });
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const input_handler_1 = ({ target }) => {
    updateValue({ type: "input", value: target.value });
  };
  const change_handler = ({ target }) => {
    updateValue({ type: "change", value: target.value });
  };
  const keydown_handler_12 = ({ key }) => {
    if (key === "ArrowDown") {
      focusCalendar();
    }
  };
  const blur_handler_1 = ({ relatedTarget }) => {
    blurInput(relatedTarget);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(33, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(1, size = $$new_props.size);
    if ("type" in $$new_props) $$invalidate(2, type = $$new_props.type);
    if ("placeholder" in $$new_props) $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("pattern" in $$new_props) $$invalidate(4, pattern = $$new_props.pattern);
    if ("disabled" in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
    if ("helperText" in $$new_props) $$invalidate(6, helperText = $$new_props.helperText);
    if ("iconDescription" in $$new_props) $$invalidate(7, iconDescription = $$new_props.iconDescription);
    if ("id" in $$new_props) $$invalidate(8, id = $$new_props.id);
    if ("labelText" in $$new_props) $$invalidate(9, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props) $$invalidate(10, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$new_props) $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props) $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props) $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$new_props) $$invalidate(14, warnText = $$new_props.warnText);
    if ("name" in $$new_props) $$invalidate(15, name = $$new_props.name);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(34, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    type,
    placeholder,
    pattern,
    disabled,
    helperText,
    iconDescription,
    id,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    warn,
    warnText,
    name,
    ref,
    getContext,
    Calendar: Calendar_default,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    range,
    add,
    hasCalendar,
    declareRef,
    inputIds,
    updateValue,
    blurInput,
    openCalendar,
    focusCalendar,
    inputValue,
    inputValueFrom,
    inputValueTo,
    $range,
    $inputIds,
    $inputValueFrom,
    $inputValueTo,
    $inputValue,
    $hasCalendar
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props) $$invalidate(1, size = $$new_props.size);
    if ("type" in $$props) $$invalidate(2, type = $$new_props.type);
    if ("placeholder" in $$props) $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("pattern" in $$props) $$invalidate(4, pattern = $$new_props.pattern);
    if ("disabled" in $$props) $$invalidate(5, disabled = $$new_props.disabled);
    if ("helperText" in $$props) $$invalidate(6, helperText = $$new_props.helperText);
    if ("iconDescription" in $$props) $$invalidate(7, iconDescription = $$new_props.iconDescription);
    if ("id" in $$props) $$invalidate(8, id = $$new_props.id);
    if ("labelText" in $$props) $$invalidate(9, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props) $$invalidate(10, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$props) $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$props) $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$props) $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$props) $$invalidate(14, warnText = $$new_props.warnText);
    if ("name" in $$props) $$invalidate(15, name = $$new_props.name);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*ref, id*/
    257) {
      $: if (ref) declareRef({ id, ref });
    }
  };
  return [
    ref,
    size,
    type,
    placeholder,
    pattern,
    disabled,
    helperText,
    iconDescription,
    id,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    warn,
    warnText,
    name,
    $range,
    $inputIds,
    $inputValueFrom,
    $inputValueTo,
    $inputValue,
    $hasCalendar,
    range,
    hasCalendar,
    inputIds,
    updateValue,
    blurInput,
    openCalendar,
    focusCalendar,
    inputValue,
    inputValueFrom,
    inputValueTo,
    $$slots,
    $$restProps,
    $$scope,
    slots,
    input_handler,
    keydown_handler,
    keyup_handler,
    blur_handler,
    paste_handler,
    input_binding,
    input_handler_1,
    change_handler,
    keydown_handler_12,
    blur_handler_1
  ];
}
var DatePickerInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance74,
      create_fragment74,
      safe_not_equal,
      {
        size: 1,
        type: 2,
        placeholder: 3,
        pattern: 4,
        disabled: 5,
        helperText: 6,
        iconDescription: 7,
        id: 8,
        labelText: 9,
        hideLabel: 10,
        invalid: 11,
        invalidText: 12,
        warn: 13,
        warnText: 14,
        name: 15,
        ref: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DatePickerInput",
      options,
      id: create_fragment74.name
    });
  }
  get size() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pattern() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pattern(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DatePickerInput_default = DatePickerInput;

// node_modules/carbon-components-svelte/src/DatePicker/DatePickerSkeleton.svelte
var file71 = "node_modules/carbon-components-svelte/src/DatePicker/DatePickerSkeleton.svelte";
function get_each_context8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  child_ctx[9] = i;
  return child_ctx;
}
function create_each_block8(key_1, ctx) {
  let div1;
  let label;
  let t0;
  let div0;
  let t1;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div1 = element("div");
      label = element("label");
      t0 = space();
      div0 = element("div");
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      label = claim_element(div1_nodes, "LABEL", { for: true });
      children(label).forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      children(div0).forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[1]
      );
      toggle_class(label, "bx--label", true);
      add_location(label, file71, 27, 8, 787);
      toggle_class(div0, "bx--date-picker__input", true);
      toggle_class(div0, "bx--skeleton", true);
      add_location(div0, file71, 28, 8, 847);
      toggle_class(div1, "bx--date-picker-container", true);
      add_location(div1, file71, 26, 6, 732);
      this.first = div1;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, label);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div1, t1);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*id*/
      2) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block8.name,
    type: "each",
    source: "(26:4) {#each Array.from({ length: range ? 2 : 1 }, (_, i) => i) as input, i (input)}",
    ctx
  });
  return block;
}
function create_fragment75(ctx) {
  let div1;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(Array.from({ length: (
    /*range*/
    ctx[0] ? 2 : 1
  ) }, func4));
  const get_key = (ctx2) => (
    /*input*/
    ctx2[7]
  );
  validate_each_keys(ctx, each_value, get_each_context8, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context8(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block8(key, child_ctx));
  }
  let div1_levels = [
    /*$$restProps*/
    ctx[2]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--date-picker", true);
      toggle_class(div0, "bx--skeleton", true);
      toggle_class(div0, "bx--date-picker--range", true);
      toggle_class(div0, "bx--date-picker--short", !/*range*/
      ctx[0]);
      toggle_class(div0, "bx--date-picker--simple", !/*range*/
      ctx[0]);
      add_location(div0, file71, 18, 2, 436);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file71, 10, 0, 319);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseover",
            /*mouseover_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*id, range*/
      3) {
        each_value = ensure_array_like_dev(Array.from({ length: (
          /*range*/
          ctx2[0] ? 2 : 1
        ) }, func4));
        validate_each_keys(ctx2, each_value, get_each_context8, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, destroy_block, create_each_block8, null, get_each_context8);
      }
      if (dirty & /*range*/
      1) {
        toggle_class(div0, "bx--date-picker--short", !/*range*/
        ctx2[0]);
      }
      if (dirty & /*range*/
      1) {
        toggle_class(div0, "bx--date-picker--simple", !/*range*/
        ctx2[0]);
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty & /*$$restProps*/
      4 && /*$$restProps*/
      ctx2[2]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment75.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func4 = (_, i) => i;
function instance75($$self, $$props, $$invalidate) {
  const omit_props_names = ["range", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DatePickerSkeleton", slots, []);
  let { range = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("range" in $$new_props) $$invalidate(0, range = $$new_props.range);
    if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
  };
  $$self.$capture_state = () => ({ range, id });
  $$self.$inject_state = ($$new_props) => {
    if ("range" in $$props) $$invalidate(0, range = $$new_props.range);
    if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    range,
    id,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var DatePickerSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance75, create_fragment75, safe_not_equal, { range: 0, id: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DatePickerSkeleton",
      options,
      id: create_fragment75.name
    });
  }
  get range() {
    throw new Error("<DatePickerSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set range(value) {
    throw new Error("<DatePickerSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DatePickerSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DatePickerSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DatePickerSkeleton_default = DatePickerSkeleton;

// node_modules/carbon-components-svelte/src/Dropdown/Dropdown.svelte
var file72 = "node_modules/carbon-components-svelte/src/Dropdown/Dropdown.svelte";
function get_each_context9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[39] = list[i];
  child_ctx[41] = i;
  return child_ctx;
}
var get_default_slot_changes5 = (dirty) => ({
  item: dirty[0] & /*items*/
  8,
  index: dirty[0] & /*items*/
  8
});
var get_default_slot_context5 = (ctx) => ({
  item: (
    /*item*/
    ctx[39]
  ),
  index: (
    /*i*/
    ctx[41]
  )
});
function create_if_block_55(ctx) {
  let label_1;
  let t;
  const block = {
    c: function create() {
      label_1 = element("label");
      t = text(
        /*titleText*/
        ctx[10]
      );
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { for: true });
      var label_1_nodes = children(label_1);
      t = claim_text(
        label_1_nodes,
        /*titleText*/
        ctx[10]
      );
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label_1,
        "for",
        /*id*/
        ctx[19]
      );
      toggle_class(label_1, "bx--label", true);
      toggle_class(
        label_1,
        "bx--label--disabled",
        /*disabled*/
        ctx[9]
      );
      toggle_class(
        label_1,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[17]
      );
      add_location(label_1, file72, 184, 4, 4378);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      append_hydration_dev(label_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*titleText*/
      1024) set_data_dev(
        t,
        /*titleText*/
        ctx2[10]
      );
      if (dirty[0] & /*id*/
      524288) {
        attr_dev(
          label_1,
          "for",
          /*id*/
          ctx2[19]
        );
      }
      if (dirty[0] & /*disabled*/
      512) {
        toggle_class(
          label_1,
          "bx--label--disabled",
          /*disabled*/
          ctx2[9]
        );
      }
      if (dirty[0] & /*hideLabel*/
      131072) {
        toggle_class(
          label_1,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[17]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_55.name,
    type: "if",
    source: "(184:2) {#if titleText}",
    ctx
  });
  return block;
}
function create_if_block_46(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--list-box__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_46.name,
    type: "if",
    source: "(222:4) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_36(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--list-box__invalid-icon bx--list-box__invalid-icon--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningaltfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_36.name,
    type: "if",
    source: "(225:4) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_else_block18(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*label*/
        ctx[16]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*label*/
        ctx[16]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*label*/
      65536) set_data_dev(
        t,
        /*label*/
        ctx2[16]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block18.name,
    type: "else",
    source: "(287:54) {:else}",
    ctx
  });
  return block;
}
function create_if_block_210(ctx) {
  let t_value = (
    /*itemToString*/
    ctx[4](
      /*selectedItem*/
      ctx[22]
    ) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*itemToString, selectedItem*/
      4194320 && t_value !== (t_value = /*itemToString*/
      ctx2[4](
        /*selectedItem*/
        ctx2[22]
      ) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_210.name,
    type: "if",
    source: "(287:8) {#if selectedItem}",
    ctx
  });
  return block;
}
function create_if_block_114(ctx) {
  let listboxmenu;
  let current;
  listboxmenu = new ListBoxMenu_default({
    props: {
      "aria-labelledby": (
        /*id*/
        ctx[19]
      ),
      id: (
        /*id*/
        ctx[19]
      ),
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(listboxmenu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(listboxmenu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(listboxmenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const listboxmenu_changes = {};
      if (dirty[0] & /*id*/
      524288) listboxmenu_changes["aria-labelledby"] = /*id*/
      ctx2[19];
      if (dirty[0] & /*id*/
      524288) listboxmenu_changes.id = /*id*/
      ctx2[19];
      if (dirty[0] & /*items, selectedId, highlightedIndex, ref, itemToString*/
      2097181 | dirty[1] & /*$$scope*/
      64) {
        listboxmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listboxmenu.$set(listboxmenu_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(listboxmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listboxmenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(299:4) {#if open}",
    ctx
  });
  return block;
}
function fallback_block15(ctx) {
  let t_value = (
    /*itemToString*/
    ctx[4](
      /*item*/
      ctx[39]
    ) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*itemToString, items*/
      24 && t_value !== (t_value = /*itemToString*/
      ctx2[4](
        /*item*/
        ctx2[39]
      ) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block15.name,
    type: "fallback",
    source: "(321:44)                ",
    ctx
  });
  return block;
}
function create_default_slot_24(ctx) {
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[29].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[37],
    get_default_slot_context5
  );
  const default_slot_or_fallback = default_slot || fallback_block15(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      t = space();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback) default_slot_or_fallback.l(nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*items*/
        8 | dirty[1] & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[37],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[37]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[37],
              dirty,
              get_default_slot_changes5
            ),
            get_default_slot_context5
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*itemToString, items*/
        24)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_24.name,
    type: "slot",
    source: '(302:10) <ListBoxMenuItem             id=\\"{item.id}\\"             active=\\"{selectedId === item.id}\\"             highlighted=\\"{highlightedIndex === i}\\"             disabled=\\"{item.disabled}\\"             on:click=\\"{(e) => {               if (item.disabled) {                 e.stopPropagation();                 return;               }               selectedId = item.id;               dispatchSelect();               ref.focus();             }}\\"             on:mouseenter=\\"{() => {               if (item.disabled) return;               highlightedIndex = i;             }}\\"           >',
    ctx
  });
  return block;
}
function create_each_block9(key_1, ctx) {
  let first;
  let listboxmenuitem;
  let current;
  function click_handler_13(...args) {
    return (
      /*click_handler_1*/
      ctx[34](
        /*item*/
        ctx[39],
        ...args
      )
    );
  }
  function mouseenter_handler() {
    return (
      /*mouseenter_handler*/
      ctx[35](
        /*item*/
        ctx[39],
        /*i*/
        ctx[41]
      )
    );
  }
  listboxmenuitem = new ListBoxMenuItem_default({
    props: {
      id: (
        /*item*/
        ctx[39].id
      ),
      active: (
        /*selectedId*/
        ctx[0] === /*item*/
        ctx[39].id
      ),
      highlighted: (
        /*highlightedIndex*/
        ctx[21] === /*i*/
        ctx[41]
      ),
      disabled: (
        /*item*/
        ctx[39].disabled
      ),
      $$slots: { default: [create_default_slot_24] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  listboxmenuitem.$on("click", click_handler_13);
  listboxmenuitem.$on("mouseenter", mouseenter_handler);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(listboxmenuitem.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(listboxmenuitem.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(listboxmenuitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const listboxmenuitem_changes = {};
      if (dirty[0] & /*items*/
      8) listboxmenuitem_changes.id = /*item*/
      ctx[39].id;
      if (dirty[0] & /*selectedId, items*/
      9) listboxmenuitem_changes.active = /*selectedId*/
      ctx[0] === /*item*/
      ctx[39].id;
      if (dirty[0] & /*highlightedIndex, items*/
      2097160) listboxmenuitem_changes.highlighted = /*highlightedIndex*/
      ctx[21] === /*i*/
      ctx[41];
      if (dirty[0] & /*items*/
      8) listboxmenuitem_changes.disabled = /*item*/
      ctx[39].disabled;
      if (dirty[0] & /*itemToString, items*/
      24 | dirty[1] & /*$$scope*/
      64) {
        listboxmenuitem_changes.$$scope = { dirty, ctx };
      }
      listboxmenuitem.$set(listboxmenuitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(listboxmenuitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxmenuitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(listboxmenuitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block9.name,
    type: "each",
    source: "(301:8) {#each items as item, i (item.id)}",
    ctx
  });
  return block;
}
function create_default_slot_14(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*items*/
    ctx[3]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[39].id
  );
  validate_each_keys(ctx, each_value, get_each_context9, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context9(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block9(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*items, selectedId, highlightedIndex, dispatchSelect, ref, itemToString*/
      35651613 | dirty[1] & /*$$scope*/
      64) {
        each_value = ensure_array_like_dev(
          /*items*/
          ctx2[3]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context9, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block9, each_1_anchor, get_each_context9);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: '(300:6) <ListBoxMenu aria-labelledby=\\"{id}\\" id=\\"{id}\\">',
    ctx
  });
  return block;
}
function create_default_slot10(ctx) {
  let t0;
  let t1;
  let button;
  let span;
  let t2;
  let listboxmenuicon;
  let t3;
  let if_block3_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*invalid*/
    ctx[11] && create_if_block_46(ctx)
  );
  let if_block1 = !/*invalid*/
  ctx[11] && /*warn*/
  ctx[13] && create_if_block_36(ctx);
  function select_block_type(ctx2, dirty) {
    if (
      /*selectedItem*/
      ctx2[22]
    ) return create_if_block_210;
    return create_else_block18;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block2 = current_block_type(ctx);
  listboxmenuicon = new ListBoxMenuIcon_default({
    props: {
      translateWithId: (
        /*translateWithId*/
        ctx[18]
      ),
      open: (
        /*open*/
        ctx[1]
      )
    },
    $$inline: true
  });
  listboxmenuicon.$on(
    "click",
    /*click_handler*/
    ctx[30]
  );
  let if_block3 = (
    /*open*/
    ctx[1] && create_if_block_114(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      button = element("button");
      span = element("span");
      if_block2.c();
      t2 = space();
      create_component(listboxmenuicon.$$.fragment);
      t3 = space();
      if (if_block3) if_block3.c();
      if_block3_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      t1 = claim_space(nodes);
      button = claim_element(nodes, "BUTTON", {
        type: true,
        tabindex: true,
        "aria-expanded": true,
        translatewithid: true,
        id: true
      });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", {});
      var span_nodes = children(span);
      if_block2.l(span_nodes);
      span_nodes.forEach(detach_dev);
      t2 = claim_space(button_nodes);
      claim_component(listboxmenuicon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (if_block3) if_block3.l(nodes);
      if_block3_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--list-box__label", true);
      add_location(span, file72, 285, 6, 7122);
      attr_dev(button, "type", "button");
      attr_dev(button, "tabindex", "0");
      attr_dev(
        button,
        "aria-expanded",
        /*open*/
        ctx[1]
      );
      button.disabled = /*disabled*/
      ctx[9];
      attr_dev(
        button,
        "translatewithid",
        /*translateWithId*/
        ctx[18]
      );
      attr_dev(
        button,
        "id",
        /*id*/
        ctx[19]
      );
      toggle_class(button, "bx--list-box__field", true);
      add_location(button, file72, 229, 4, 5650);
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, span);
      if_block2.m(span, null);
      append_hydration_dev(button, t2);
      mount_component(listboxmenuicon, button, null);
      ctx[31](button);
      insert_hydration_dev(target, t3, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert_hydration_dev(target, if_block3_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "keydown",
            /*keydown_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keyup",
            /*keyup_handler*/
            ctx[33],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*invalid*/
        ctx2[11]
      ) {
        if (if_block0) {
          if (dirty[0] & /*invalid*/
          2048) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_46(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*invalid*/
      ctx2[11] && /*warn*/
      ctx2[13]) {
        if (if_block1) {
          if (dirty[0] & /*invalid, warn*/
          10240) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_36(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(span, null);
        }
      }
      const listboxmenuicon_changes = {};
      if (dirty[0] & /*translateWithId*/
      262144) listboxmenuicon_changes.translateWithId = /*translateWithId*/
      ctx2[18];
      if (dirty[0] & /*open*/
      2) listboxmenuicon_changes.open = /*open*/
      ctx2[1];
      listboxmenuicon.$set(listboxmenuicon_changes);
      if (!current || dirty[0] & /*open*/
      2) {
        attr_dev(
          button,
          "aria-expanded",
          /*open*/
          ctx2[1]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      512) {
        prop_dev(
          button,
          "disabled",
          /*disabled*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*translateWithId*/
      262144) {
        attr_dev(
          button,
          "translatewithid",
          /*translateWithId*/
          ctx2[18]
        );
      }
      if (!current || dirty[0] & /*id*/
      524288) {
        attr_dev(
          button,
          "id",
          /*id*/
          ctx2[19]
        );
      }
      if (
        /*open*/
        ctx2[1]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*open*/
          2) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_114(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(listboxmenuicon.$$.fragment, local);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(listboxmenuicon.$$.fragment, local);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(button);
        detach_dev(t3);
        detach_dev(if_block3_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if_block2.d();
      destroy_component(listboxmenuicon);
      ctx[31](null);
      if (if_block3) if_block3.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: `(194:2) <ListBox     role=\\"{undefined}\\"     type=\\"{type}\\"     size=\\"{size}\\"     name=\\"{name}\\"     aria-label=\\"{$$props['aria-label']}\\"     class=\\"bx--dropdown        {direction === 'top' && 'bx--list-box--up'}        {invalid && 'bx--dropdown--invalid'}        {!invalid && warn && 'bx--dropdown--warning'}        {open && 'bx--dropdown--open'}       {size === 'sm' && 'bx--dropdown--sm'}       {size === 'xl' && 'bx--dropdown--xl'}       {inline && 'bx--dropdown--inline'}       {disabled && 'bx--dropdown--disabled'}       {light && 'bx--dropdown--light'}\\"     on:click=\\"{({ target }) => {       if (disabled) return;       open = ref.contains(target) ? !open : false;     }}\\"     disabled=\\"{disabled}\\"     open=\\"{open}\\"     invalid=\\"{invalid}\\"     invalidText=\\"{invalidText}\\"     light=\\"{light}\\"     warn=\\"{warn}\\"     warnText=\\"{warnText}\\"   >`,
    ctx
  });
  return block;
}
function create_if_block45(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[15]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[15]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(
        div,
        "bx--form__helper-text--disabled",
        /*disabled*/
        ctx[9]
      );
      add_location(div, file72, 329, 4, 8432);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*helperText*/
      32768) set_data_dev(
        t,
        /*helperText*/
        ctx2[15]
      );
      if (dirty[0] & /*disabled*/
      512) {
        toggle_class(
          div,
          "bx--form__helper-text--disabled",
          /*disabled*/
          ctx2[9]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block45.name,
    type: "if",
    source: "(329:2) {#if !inline && !invalid && !warn && helperText}",
    ctx
  });
  return block;
}
function create_fragment76(ctx) {
  let div;
  let t0;
  let listbox;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*titleText*/
    ctx[10] && create_if_block_55(ctx)
  );
  listbox = new ListBox_default({
    props: {
      role: void 0,
      type: (
        /*type*/
        ctx[5]
      ),
      size: (
        /*size*/
        ctx[7]
      ),
      name: (
        /*name*/
        ctx[20]
      ),
      "aria-label": (
        /*$$props*/
        ctx[28]["aria-label"]
      ),
      class: "bx--dropdown \n      " + /*direction*/
      (ctx[6] === "top" && "bx--list-box--up") + " \n      " + /*invalid*/
      (ctx[11] && "bx--dropdown--invalid") + " \n      " + (!/*invalid*/
      ctx[11] && /*warn*/
      ctx[13] && "bx--dropdown--warning") + " \n      " + /*open*/
      (ctx[1] && "bx--dropdown--open") + "\n      " + /*size*/
      (ctx[7] === "sm" && "bx--dropdown--sm") + "\n      " + /*size*/
      (ctx[7] === "xl" && "bx--dropdown--xl") + "\n      " + /*inline*/
      (ctx[23] && "bx--dropdown--inline") + "\n      " + /*disabled*/
      (ctx[9] && "bx--dropdown--disabled") + "\n      " + /*light*/
      (ctx[8] && "bx--dropdown--light"),
      disabled: (
        /*disabled*/
        ctx[9]
      ),
      open: (
        /*open*/
        ctx[1]
      ),
      invalid: (
        /*invalid*/
        ctx[11]
      ),
      invalidText: (
        /*invalidText*/
        ctx[12]
      ),
      light: (
        /*light*/
        ctx[8]
      ),
      warn: (
        /*warn*/
        ctx[13]
      ),
      warnText: (
        /*warnText*/
        ctx[14]
      ),
      $$slots: { default: [create_default_slot10] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  listbox.$on(
    "click",
    /*click_handler_2*/
    ctx[36]
  );
  let if_block1 = !/*inline*/
  ctx[23] && !/*invalid*/
  ctx[11] && !/*warn*/
  ctx[13] && /*helperText*/
  ctx[15] && create_if_block45(ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[27]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      create_component(listbox.$$.fragment);
      t1 = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block0) if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      claim_component(listbox.$$.fragment, div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block1) if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--dropdown__wrapper", true);
      toggle_class(div, "bx--list-box__wrapper", true);
      toggle_class(
        div,
        "bx--dropdown__wrapper--inline",
        /*inline*/
        ctx[23]
      );
      toggle_class(
        div,
        "bx--list-box__wrapper--inline",
        /*inline*/
        ctx[23]
      );
      toggle_class(
        div,
        "bx--dropdown__wrapper--inline--invalid",
        /*inline*/
        ctx[23] && /*invalid*/
        ctx[11]
      );
      add_location(div, file72, 175, 0, 4085);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append_hydration_dev(div, t0);
      mount_component(listbox, div, null);
      append_hydration_dev(div, t1);
      if (if_block1) if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "click",
          /*pageClickHandler*/
          ctx[26],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*titleText*/
        ctx2[10]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_55(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      const listbox_changes = {};
      if (dirty[0] & /*type*/
      32) listbox_changes.type = /*type*/
      ctx2[5];
      if (dirty[0] & /*size*/
      128) listbox_changes.size = /*size*/
      ctx2[7];
      if (dirty[0] & /*name*/
      1048576) listbox_changes.name = /*name*/
      ctx2[20];
      if (dirty[0] & /*$$props*/
      268435456) listbox_changes["aria-label"] = /*$$props*/
      ctx2[28]["aria-label"];
      if (dirty[0] & /*direction, invalid, warn, open, size, inline, disabled, light*/
      8399810) listbox_changes.class = "bx--dropdown \n      " + /*direction*/
      (ctx2[6] === "top" && "bx--list-box--up") + " \n      " + /*invalid*/
      (ctx2[11] && "bx--dropdown--invalid") + " \n      " + (!/*invalid*/
      ctx2[11] && /*warn*/
      ctx2[13] && "bx--dropdown--warning") + " \n      " + /*open*/
      (ctx2[1] && "bx--dropdown--open") + "\n      " + /*size*/
      (ctx2[7] === "sm" && "bx--dropdown--sm") + "\n      " + /*size*/
      (ctx2[7] === "xl" && "bx--dropdown--xl") + "\n      " + /*inline*/
      (ctx2[23] && "bx--dropdown--inline") + "\n      " + /*disabled*/
      (ctx2[9] && "bx--dropdown--disabled") + "\n      " + /*light*/
      (ctx2[8] && "bx--dropdown--light");
      if (dirty[0] & /*disabled*/
      512) listbox_changes.disabled = /*disabled*/
      ctx2[9];
      if (dirty[0] & /*open*/
      2) listbox_changes.open = /*open*/
      ctx2[1];
      if (dirty[0] & /*invalid*/
      2048) listbox_changes.invalid = /*invalid*/
      ctx2[11];
      if (dirty[0] & /*invalidText*/
      4096) listbox_changes.invalidText = /*invalidText*/
      ctx2[12];
      if (dirty[0] & /*light*/
      256) listbox_changes.light = /*light*/
      ctx2[8];
      if (dirty[0] & /*warn*/
      8192) listbox_changes.warn = /*warn*/
      ctx2[13];
      if (dirty[0] & /*warnText*/
      16384) listbox_changes.warnText = /*warnText*/
      ctx2[14];
      if (dirty[0] & /*id, items, selectedId, highlightedIndex, ref, itemToString, open, disabled, translateWithId, selectedItem, label, invalid, warn*/
      7154207 | dirty[1] & /*$$scope*/
      64) {
        listbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listbox.$set(listbox_changes);
      if (!/*inline*/
      ctx2[23] && !/*invalid*/
      ctx2[11] && !/*warn*/
      ctx2[13] && /*helperText*/
      ctx2[15]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block45(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty[0] & /*$$restProps*/
      134217728 && /*$$restProps*/
      ctx2[27]]));
      toggle_class(div, "bx--dropdown__wrapper", true);
      toggle_class(div, "bx--list-box__wrapper", true);
      toggle_class(
        div,
        "bx--dropdown__wrapper--inline",
        /*inline*/
        ctx2[23]
      );
      toggle_class(
        div,
        "bx--list-box__wrapper--inline",
        /*inline*/
        ctx2[23]
      );
      toggle_class(
        div,
        "bx--dropdown__wrapper--inline--invalid",
        /*inline*/
        ctx2[23] && /*invalid*/
        ctx2[11]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(listbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0) if_block0.d();
      destroy_component(listbox);
      if (if_block1) if_block1.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment76.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance76($$self, $$props, $$invalidate) {
  let inline;
  let selectedItem;
  const omit_props_names = [
    "items",
    "itemToString",
    "selectedId",
    "type",
    "direction",
    "size",
    "open",
    "light",
    "disabled",
    "titleText",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "helperText",
    "label",
    "hideLabel",
    "translateWithId",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dropdown", slots, ["default"]);
  let { items = [] } = $$props;
  let { itemToString = (item) => item.text || item.id } = $$props;
  let { selectedId } = $$props;
  let { type = "default" } = $$props;
  let { direction = "bottom" } = $$props;
  let { size = void 0 } = $$props;
  let { open = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { titleText = "" } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { helperText = "" } = $$props;
  let { label = void 0 } = $$props;
  let { hideLabel = false } = $$props;
  let { translateWithId = void 0 } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let highlightedIndex = -1;
  function change(dir) {
    let index = highlightedIndex + dir;
    if (items.length === 0) return;
    if (index < 0) {
      index = items.length - 1;
    } else if (index >= items.length) {
      index = 0;
    }
    let disabled2 = items[index].disabled;
    while (disabled2) {
      index = index + dir;
      if (index < 0) {
        index = items.length - 1;
      } else if (index >= items.length) {
        index = 0;
      }
      disabled2 = items[index].disabled;
    }
    $$invalidate(21, highlightedIndex = index);
  }
  const dispatchSelect = () => {
    dispatch("select", {
      selectedId,
      selectedItem: items.find((item) => item.id === selectedId)
    });
  };
  const pageClickHandler = ({ target }) => {
    if (open && ref && !ref.contains(target)) {
      $$invalidate(1, open = false);
    }
  };
  onMount(() => {
    if (parent) {
      parent.addEventListener("click", pageClickHandler);
    }
    return () => {
      if (parent) {
        parent.removeEventListener("click", pageClickHandler);
      }
    };
  });
  $$self.$$.on_mount.push(function() {
    if (selectedId === void 0 && !("selectedId" in $$props || $$self.$$.bound[$$self.$$.props["selectedId"]])) {
      console.warn("<Dropdown> was created without expected prop 'selectedId'");
    }
  });
  const click_handler = (e) => {
    e.stopPropagation();
    if (disabled) return;
    $$invalidate(1, open = !open);
  };
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(2, ref);
    });
  }
  const keydown_handler = (e) => {
    const { key } = e;
    if (["Enter", "ArrowDown", "ArrowUp"].includes(key)) {
      e.preventDefault();
    }
    if (key === "Enter") {
      $$invalidate(1, open = !open);
      if (highlightedIndex > -1 && items[highlightedIndex].id !== selectedId) {
        $$invalidate(0, selectedId = items[highlightedIndex].id);
        dispatchSelect();
        $$invalidate(1, open = false);
      }
    } else if (key === "Tab") {
      $$invalidate(1, open = false);
      ref.blur();
    } else if (key === "ArrowDown") {
      if (!open) $$invalidate(1, open = true);
      change(1);
    } else if (key === "ArrowUp") {
      if (!open) $$invalidate(1, open = true);
      change(-1);
    } else if (key === "Escape") {
      $$invalidate(1, open = false);
    }
  };
  const keyup_handler = (e) => {
    const { key } = e;
    if ([" "].includes(key)) {
      e.preventDefault();
    } else {
      return;
    }
    $$invalidate(1, open = !open);
    if (highlightedIndex > -1 && items[highlightedIndex].id !== selectedId) {
      $$invalidate(0, selectedId = items[highlightedIndex].id);
      dispatchSelect();
      $$invalidate(1, open = false);
    }
  };
  const click_handler_13 = (item, e) => {
    if (item.disabled) {
      e.stopPropagation();
      return;
    }
    $$invalidate(0, selectedId = item.id);
    dispatchSelect();
    ref.focus();
  };
  const mouseenter_handler = (item, i) => {
    if (item.disabled) return;
    $$invalidate(21, highlightedIndex = i);
  };
  const click_handler_2 = ({ target }) => {
    if (disabled) return;
    $$invalidate(1, open = ref.contains(target) ? !open : false);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(28, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(27, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("items" in $$new_props) $$invalidate(3, items = $$new_props.items);
    if ("itemToString" in $$new_props) $$invalidate(4, itemToString = $$new_props.itemToString);
    if ("selectedId" in $$new_props) $$invalidate(0, selectedId = $$new_props.selectedId);
    if ("type" in $$new_props) $$invalidate(5, type = $$new_props.type);
    if ("direction" in $$new_props) $$invalidate(6, direction = $$new_props.direction);
    if ("size" in $$new_props) $$invalidate(7, size = $$new_props.size);
    if ("open" in $$new_props) $$invalidate(1, open = $$new_props.open);
    if ("light" in $$new_props) $$invalidate(8, light = $$new_props.light);
    if ("disabled" in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
    if ("titleText" in $$new_props) $$invalidate(10, titleText = $$new_props.titleText);
    if ("invalid" in $$new_props) $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props) $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props) $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$new_props) $$invalidate(14, warnText = $$new_props.warnText);
    if ("helperText" in $$new_props) $$invalidate(15, helperText = $$new_props.helperText);
    if ("label" in $$new_props) $$invalidate(16, label = $$new_props.label);
    if ("hideLabel" in $$new_props) $$invalidate(17, hideLabel = $$new_props.hideLabel);
    if ("translateWithId" in $$new_props) $$invalidate(18, translateWithId = $$new_props.translateWithId);
    if ("id" in $$new_props) $$invalidate(19, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(20, name = $$new_props.name);
    if ("ref" in $$new_props) $$invalidate(2, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(37, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    items,
    itemToString,
    selectedId,
    type,
    direction,
    size,
    open,
    light,
    disabled,
    titleText,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    label,
    hideLabel,
    translateWithId,
    id,
    name,
    ref,
    createEventDispatcher,
    onMount,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    ListBox: ListBox_default,
    ListBoxMenu: ListBoxMenu_default,
    ListBoxMenuIcon: ListBoxMenuIcon_default,
    ListBoxMenuItem: ListBoxMenuItem_default,
    dispatch,
    highlightedIndex,
    change,
    dispatchSelect,
    pageClickHandler,
    selectedItem,
    inline
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(28, $$props = assign(assign({}, $$props), $$new_props));
    if ("items" in $$props) $$invalidate(3, items = $$new_props.items);
    if ("itemToString" in $$props) $$invalidate(4, itemToString = $$new_props.itemToString);
    if ("selectedId" in $$props) $$invalidate(0, selectedId = $$new_props.selectedId);
    if ("type" in $$props) $$invalidate(5, type = $$new_props.type);
    if ("direction" in $$props) $$invalidate(6, direction = $$new_props.direction);
    if ("size" in $$props) $$invalidate(7, size = $$new_props.size);
    if ("open" in $$props) $$invalidate(1, open = $$new_props.open);
    if ("light" in $$props) $$invalidate(8, light = $$new_props.light);
    if ("disabled" in $$props) $$invalidate(9, disabled = $$new_props.disabled);
    if ("titleText" in $$props) $$invalidate(10, titleText = $$new_props.titleText);
    if ("invalid" in $$props) $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$props) $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$props) $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$props) $$invalidate(14, warnText = $$new_props.warnText);
    if ("helperText" in $$props) $$invalidate(15, helperText = $$new_props.helperText);
    if ("label" in $$props) $$invalidate(16, label = $$new_props.label);
    if ("hideLabel" in $$props) $$invalidate(17, hideLabel = $$new_props.hideLabel);
    if ("translateWithId" in $$props) $$invalidate(18, translateWithId = $$new_props.translateWithId);
    if ("id" in $$props) $$invalidate(19, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(20, name = $$new_props.name);
    if ("ref" in $$props) $$invalidate(2, ref = $$new_props.ref);
    if ("highlightedIndex" in $$props) $$invalidate(21, highlightedIndex = $$new_props.highlightedIndex);
    if ("selectedItem" in $$props) $$invalidate(22, selectedItem = $$new_props.selectedItem);
    if ("inline" in $$props) $$invalidate(23, inline = $$new_props.inline);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*type*/
    32) {
      $: $$invalidate(23, inline = type === "inline");
    }
    if ($$self.$$.dirty[0] & /*items, selectedId*/
    9) {
      $: $$invalidate(22, selectedItem = items.find((item) => item.id === selectedId));
    }
    if ($$self.$$.dirty[0] & /*open*/
    2) {
      $: if (!open) {
        $$invalidate(21, highlightedIndex = -1);
      }
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    selectedId,
    open,
    ref,
    items,
    itemToString,
    type,
    direction,
    size,
    light,
    disabled,
    titleText,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    label,
    hideLabel,
    translateWithId,
    id,
    name,
    highlightedIndex,
    selectedItem,
    inline,
    change,
    dispatchSelect,
    pageClickHandler,
    $$restProps,
    $$props,
    slots,
    click_handler,
    button_binding,
    keydown_handler,
    keyup_handler,
    click_handler_13,
    mouseenter_handler,
    click_handler_2,
    $$scope
  ];
}
var Dropdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance76,
      create_fragment76,
      safe_not_equal,
      {
        items: 3,
        itemToString: 4,
        selectedId: 0,
        type: 5,
        direction: 6,
        size: 7,
        open: 1,
        light: 8,
        disabled: 9,
        titleText: 10,
        invalid: 11,
        invalidText: 12,
        warn: 13,
        warnText: 14,
        helperText: 15,
        label: 16,
        hideLabel: 17,
        translateWithId: 18,
        id: 19,
        name: 20,
        ref: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dropdown",
      options,
      id: create_fragment76.name
    });
  }
  get items() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemToString() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemToString(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedId() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedId(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleText() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleText(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dropdown_default = Dropdown;

// node_modules/carbon-components-svelte/src/Dropdown/DropdownSkeleton.svelte
var file73 = "node_modules/carbon-components-svelte/src/Dropdown/DropdownSkeleton.svelte";
function create_fragment77(ctx) {
  let div1;
  let div0;
  let span;
  let mounted;
  let dispose;
  let div1_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { role: true });
      var div0_nodes = children(div0);
      span = claim_element(div0_nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--list-box__label", true);
      add_location(span, file73, 20, 4, 523);
      attr_dev(div0, "role", "button");
      toggle_class(div0, "bx--list-box__field", true);
      add_location(div0, file73, 19, 2, 464);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--skeleton", true);
      toggle_class(div1, "bx--dropdown-v2", true);
      toggle_class(div1, "bx--list-box", true);
      toggle_class(div1, "bx--form-item", true);
      toggle_class(
        div1,
        "bx--list-box--inline",
        /*inline*/
        ctx[0]
      );
      add_location(div1, file73, 7, 0, 214);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, span);
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseover",
            /*mouseover_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(div1, "bx--skeleton", true);
      toggle_class(div1, "bx--dropdown-v2", true);
      toggle_class(div1, "bx--list-box", true);
      toggle_class(div1, "bx--form-item", true);
      toggle_class(
        div1,
        "bx--list-box--inline",
        /*inline*/
        ctx2[0]
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment77.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance77($$self, $$props, $$invalidate) {
  const omit_props_names = ["inline"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownSkeleton", slots, []);
  let { inline = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("inline" in $$new_props) $$invalidate(0, inline = $$new_props.inline);
  };
  $$self.$capture_state = () => ({ inline });
  $$self.$inject_state = ($$new_props) => {
    if ("inline" in $$props) $$invalidate(0, inline = $$new_props.inline);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    inline,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var DropdownSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance77, create_fragment77, safe_not_equal, { inline: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownSkeleton",
      options,
      id: create_fragment77.name
    });
  }
  get inline() {
    throw new Error("<DropdownSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<DropdownSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownSkeleton_default = DropdownSkeleton;

// node_modules/carbon-components-svelte/src/icons/CheckmarkFilled.svelte
var file74 = "node_modules/carbon-components-svelte/src/icons/CheckmarkFilled.svelte";
function create_if_block46(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file74, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block46.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment78(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block46(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", {
        fill: true,
        d: true,
        "data-icon-path": true
      });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2ZM14,21.5908l-5-5L10.5906,15,14,18.4092,21.41,11l1.5957,1.5859Z");
      add_location(path0, file74, 24, 2, 579);
      attr_dev(path1, "fill", "none");
      attr_dev(path1, "d", "M14 21.591L9 16.591 10.591 15 14 18.409 21.41 11 23.005 12.585 14 21.591z");
      attr_dev(path1, "data-icon-path", "inner-path");
      add_location(path1, file74, 26, 10, 707);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file74, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block46(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment78.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance78($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckmarkFilled", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var CheckmarkFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance78, create_fragment78, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckmarkFilled",
      options,
      id: create_fragment78.name
    });
  }
  get size() {
    throw new Error("<CheckmarkFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CheckmarkFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CheckmarkFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CheckmarkFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CheckmarkFilled_default = CheckmarkFilled;

// node_modules/carbon-components-svelte/src/Loading/Loading.svelte
var file75 = "node_modules/carbon-components-svelte/src/Loading/Loading.svelte";
function create_else_block19(ctx) {
  let div;
  let svg;
  let title;
  let t;
  let circle;
  let div_aria_live_value;
  let if_block = (
    /*small*/
    ctx[0] && create_if_block_211(ctx)
  );
  let div_levels = [
    { "aria-atomic": "true" },
    {
      "aria-live": div_aria_live_value = /*active*/
      ctx[1] ? "assertive" : "off"
    },
    /*$$restProps*/
    ctx[5]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      svg = svg_element("svg");
      title = svg_element("title");
      t = text(
        /*description*/
        ctx[3]
      );
      if (if_block) if_block.c();
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "aria-atomic": true, "aria-live": true });
      var div_nodes = children(div);
      svg = claim_svg_element(div_nodes, "svg", { viewBox: true });
      var svg_nodes = children(svg);
      title = claim_svg_element(svg_nodes, "title", {});
      var title_nodes = children(title);
      t = claim_text(
        title_nodes,
        /*description*/
        ctx[3]
      );
      title_nodes.forEach(detach_dev);
      if (if_block) if_block.l(svg_nodes);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title, file75, 56, 6, 1497);
      attr_dev(circle, "cx", "50%");
      attr_dev(circle, "cy", "50%");
      attr_dev(
        circle,
        "r",
        /*spinnerRadius*/
        ctx[4]
      );
      toggle_class(circle, "bx--loading__stroke", true);
      add_location(circle, file75, 64, 6, 1705);
      attr_dev(svg, "viewBox", "0 0 100 100");
      toggle_class(svg, "bx--loading__svg", true);
      add_location(svg, file75, 55, 4, 1431);
      set_attributes(div, div_data);
      toggle_class(div, "bx--loading", true);
      toggle_class(
        div,
        "bx--loading--small",
        /*small*/
        ctx[0]
      );
      toggle_class(div, "bx--loading--stop", !/*active*/
      ctx[1]);
      add_location(div, file75, 47, 2, 1217);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, svg);
      append_hydration_dev(svg, title);
      append_hydration_dev(title, t);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, circle);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*description*/
      8) set_data_dev(
        t,
        /*description*/
        ctx2[3]
      );
      if (
        /*small*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_211(ctx2);
          if_block.c();
          if_block.m(svg, circle);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*spinnerRadius*/
      16) {
        attr_dev(
          circle,
          "r",
          /*spinnerRadius*/
          ctx2[4]
        );
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { "aria-atomic": "true" },
        dirty & /*active*/
        2 && div_aria_live_value !== (div_aria_live_value = /*active*/
        ctx2[1] ? "assertive" : "off") && { "aria-live": div_aria_live_value },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      toggle_class(div, "bx--loading", true);
      toggle_class(
        div,
        "bx--loading--small",
        /*small*/
        ctx2[0]
      );
      toggle_class(div, "bx--loading--stop", !/*active*/
      ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block19.name,
    type: "else",
    source: "(47:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block47(ctx) {
  let div1;
  let div0;
  let svg;
  let title;
  let t;
  let circle;
  let div0_aria_live_value;
  let if_block = (
    /*small*/
    ctx[0] && create_if_block_115(ctx)
  );
  let div1_levels = [
    /*$$restProps*/
    ctx[5]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      svg = svg_element("svg");
      title = svg_element("title");
      t = text(
        /*description*/
        ctx[3]
      );
      if (if_block) if_block.c();
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { "aria-atomic": true, "aria-live": true });
      var div0_nodes = children(div0);
      svg = claim_svg_element(div0_nodes, "svg", { viewBox: true });
      var svg_nodes = children(svg);
      title = claim_svg_element(svg_nodes, "title", {});
      var title_nodes = children(title);
      t = claim_text(
        title_nodes,
        /*description*/
        ctx[3]
      );
      title_nodes.forEach(detach_dev);
      if (if_block) if_block.l(svg_nodes);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title, file75, 30, 8, 819);
      attr_dev(circle, "cx", "50%");
      attr_dev(circle, "cy", "50%");
      attr_dev(
        circle,
        "r",
        /*spinnerRadius*/
        ctx[4]
      );
      toggle_class(circle, "bx--loading__stroke", true);
      add_location(circle, file75, 38, 8, 1043);
      attr_dev(svg, "viewBox", "0 0 100 100");
      toggle_class(svg, "bx--loading__svg", true);
      add_location(svg, file75, 29, 6, 751);
      attr_dev(div0, "aria-atomic", "true");
      attr_dev(div0, "aria-live", div0_aria_live_value = /*active*/
      ctx[1] ? "assertive" : "off");
      toggle_class(div0, "bx--loading", true);
      toggle_class(
        div0,
        "bx--loading--small",
        /*small*/
        ctx[0]
      );
      toggle_class(div0, "bx--loading--stop", !/*active*/
      ctx[1]);
      add_location(div0, file75, 22, 4, 544);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--loading-overlay", true);
      toggle_class(div1, "bx--loading-overlay--stop", !/*active*/
      ctx[1]);
      add_location(div1, file75, 17, 2, 423);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, svg);
      append_hydration_dev(svg, title);
      append_hydration_dev(title, t);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, circle);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*description*/
      8) set_data_dev(
        t,
        /*description*/
        ctx2[3]
      );
      if (
        /*small*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_115(ctx2);
          if_block.c();
          if_block.m(svg, circle);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*spinnerRadius*/
      16) {
        attr_dev(
          circle,
          "r",
          /*spinnerRadius*/
          ctx2[4]
        );
      }
      if (dirty & /*active*/
      2 && div0_aria_live_value !== (div0_aria_live_value = /*active*/
      ctx2[1] ? "assertive" : "off")) {
        attr_dev(div0, "aria-live", div0_aria_live_value);
      }
      if (dirty & /*small*/
      1) {
        toggle_class(
          div0,
          "bx--loading--small",
          /*small*/
          ctx2[0]
        );
      }
      if (dirty & /*active*/
      2) {
        toggle_class(div0, "bx--loading--stop", !/*active*/
        ctx2[1]);
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty & /*$$restProps*/
      32 && /*$$restProps*/
      ctx2[5]]));
      toggle_class(div1, "bx--loading-overlay", true);
      toggle_class(div1, "bx--loading-overlay--stop", !/*active*/
      ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block47.name,
    type: "if",
    source: "(17:0) {#if withOverlay}",
    ctx
  });
  return block;
}
function create_if_block_211(ctx) {
  let circle;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "50%");
      attr_dev(circle, "cy", "50%");
      attr_dev(
        circle,
        "r",
        /*spinnerRadius*/
        ctx[4]
      );
      toggle_class(circle, "bx--loading__background", true);
      add_location(circle, file75, 58, 8, 1552);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*spinnerRadius*/
      16) {
        attr_dev(
          circle,
          "r",
          /*spinnerRadius*/
          ctx2[4]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(circle);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_211.name,
    type: "if",
    source: "(58:6) {#if small}",
    ctx
  });
  return block;
}
function create_if_block_115(ctx) {
  let circle;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "50%");
      attr_dev(circle, "cy", "50%");
      attr_dev(
        circle,
        "r",
        /*spinnerRadius*/
        ctx[4]
      );
      toggle_class(circle, "bx--loading__background", true);
      add_location(circle, file75, 32, 10, 878);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*spinnerRadius*/
      16) {
        attr_dev(
          circle,
          "r",
          /*spinnerRadius*/
          ctx2[4]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(circle);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_115.name,
    type: "if",
    source: "(32:8) {#if small}",
    ctx
  });
  return block;
}
function create_fragment79(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*withOverlay*/
      ctx2[2]
    ) return create_if_block47;
    return create_else_block19;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment79.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance79($$self, $$props, $$invalidate) {
  let spinnerRadius;
  const omit_props_names = ["small", "active", "withOverlay", "description"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Loading", slots, []);
  let { small = false } = $$props;
  let { active = true } = $$props;
  let { withOverlay = true } = $$props;
  let { description = "loading" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("small" in $$new_props) $$invalidate(0, small = $$new_props.small);
    if ("active" in $$new_props) $$invalidate(1, active = $$new_props.active);
    if ("withOverlay" in $$new_props) $$invalidate(2, withOverlay = $$new_props.withOverlay);
    if ("description" in $$new_props) $$invalidate(3, description = $$new_props.description);
  };
  $$self.$capture_state = () => ({
    small,
    active,
    withOverlay,
    description,
    spinnerRadius
  });
  $$self.$inject_state = ($$new_props) => {
    if ("small" in $$props) $$invalidate(0, small = $$new_props.small);
    if ("active" in $$props) $$invalidate(1, active = $$new_props.active);
    if ("withOverlay" in $$props) $$invalidate(2, withOverlay = $$new_props.withOverlay);
    if ("description" in $$props) $$invalidate(3, description = $$new_props.description);
    if ("spinnerRadius" in $$props) $$invalidate(4, spinnerRadius = $$new_props.spinnerRadius);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*small*/
    1) {
      $: $$invalidate(4, spinnerRadius = small ? "42" : "44");
    }
  };
  return [small, active, withOverlay, description, spinnerRadius, $$restProps];
}
var Loading = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance79, create_fragment79, safe_not_equal, {
      small: 0,
      active: 1,
      withOverlay: 2,
      description: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Loading",
      options,
      id: create_fragment79.name
    });
  }
  get small() {
    throw new Error("<Loading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<Loading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Loading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Loading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withOverlay() {
    throw new Error("<Loading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withOverlay(value) {
    throw new Error("<Loading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<Loading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<Loading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Loading_default = Loading;

// node_modules/carbon-components-svelte/src/FileUploader/Filename.svelte
var file76 = "node_modules/carbon-components-svelte/src/FileUploader/Filename.svelte";
function create_if_block_37(ctx) {
  let loading;
  let current;
  const loading_spread_levels = [
    { description: (
      /*iconDescription*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[3],
    { small: true },
    { withOverlay: false }
  ];
  let loading_props = {};
  for (let i = 0; i < loading_spread_levels.length; i += 1) {
    loading_props = assign(loading_props, loading_spread_levels[i]);
  }
  loading = new Loading_default({ props: loading_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(loading.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(loading.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const loading_changes = dirty & /*iconDescription, $$restProps*/
      10 ? get_spread_update(loading_spread_levels, [
        dirty & /*iconDescription*/
        2 && { description: (
          /*iconDescription*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        ),
        loading_spread_levels[2],
        loading_spread_levels[3]
      ]) : {};
      loading.$set(loading_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(loading, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_37.name,
    type: "if",
    source: '(24:0) {#if status === \\"uploading\\"}',
    ctx
  });
  return block;
}
function create_if_block_116(ctx) {
  let t;
  let button;
  let close;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*invalid*/
    ctx[2] && create_if_block_212(ctx)
  );
  close = new Close_default({ $$inline: true });
  let button_levels = [
    { "aria-label": (
      /*iconDescription*/
      ctx[1]
    ) },
    { type: "button" },
    { tabindex: "0" },
    /*$$restProps*/
    ctx[3]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      t = space();
      button = element("button");
      create_component(close.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      t = claim_space(nodes);
      button = claim_element(nodes, "BUTTON", {
        "aria-label": true,
        type: true,
        tabindex: true
      });
      var button_nodes = children(button);
      claim_component(close.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      toggle_class(button, "bx--file-close", true);
      add_location(button, file76, 36, 2, 840);
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, button, anchor);
      mount_component(close, button, null);
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*invalid*/
        ctx2[2]
      ) {
        if (if_block) {
          if (dirty & /*invalid*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_212(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        (!current || dirty & /*iconDescription*/
        2) && { "aria-label": (
          /*iconDescription*/
          ctx2[1]
        ) },
        { type: "button" },
        { tabindex: "0" },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
      toggle_class(button, "bx--file-close", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(button);
      }
      if (if_block) if_block.d(detaching);
      destroy_component(close);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_116.name,
    type: "if",
    source: '(33:0) {#if status === \\"edit\\"}',
    ctx
  });
  return block;
}
function create_if_block_212(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--file-invalid" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_212.name,
    type: "if",
    source: "(34:2) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block48(ctx) {
  let checkmarkfilled;
  let current;
  const checkmarkfilled_spread_levels = [
    { "aria-label": (
      /*iconDescription*/
      ctx[1]
    ) },
    { title: (
      /*iconDescription*/
      ctx[1]
    ) },
    { class: "bx--file-complete" },
    /*$$restProps*/
    ctx[3]
  ];
  let checkmarkfilled_props = {};
  for (let i = 0; i < checkmarkfilled_spread_levels.length; i += 1) {
    checkmarkfilled_props = assign(checkmarkfilled_props, checkmarkfilled_spread_levels[i]);
  }
  checkmarkfilled = new CheckmarkFilled_default({
    props: checkmarkfilled_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(checkmarkfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(checkmarkfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(checkmarkfilled, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkmarkfilled_changes = dirty & /*iconDescription, $$restProps*/
      10 ? get_spread_update(checkmarkfilled_spread_levels, [
        dirty & /*iconDescription*/
        2 && { "aria-label": (
          /*iconDescription*/
          ctx2[1]
        ) },
        dirty & /*iconDescription*/
        2 && { title: (
          /*iconDescription*/
          ctx2[1]
        ) },
        checkmarkfilled_spread_levels[2],
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      checkmarkfilled.$set(checkmarkfilled_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(checkmarkfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmarkfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkmarkfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block48.name,
    type: "if",
    source: '(50:0) {#if status === \\"complete\\"}',
    ctx
  });
  return block;
}
function create_fragment80(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*status*/
    ctx[0] === "uploading" && create_if_block_37(ctx)
  );
  let if_block1 = (
    /*status*/
    ctx[0] === "edit" && create_if_block_116(ctx)
  );
  let if_block2 = (
    /*status*/
    ctx[0] === "complete" && create_if_block48(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2) if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*status*/
        ctx2[0] === "uploading"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*status*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_37(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*status*/
        ctx2[0] === "edit"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*status*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_116(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*status*/
        ctx2[0] === "complete"
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*status*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block48(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(if_block2_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment80.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance80($$self, $$props, $$invalidate) {
  const omit_props_names = ["status", "iconDescription", "invalid"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Filename", slots, []);
  let { status = "uploading" } = $$props;
  let { iconDescription = "" } = $$props;
  let { invalid = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("status" in $$new_props) $$invalidate(0, status = $$new_props.status);
    if ("iconDescription" in $$new_props) $$invalidate(1, iconDescription = $$new_props.iconDescription);
    if ("invalid" in $$new_props) $$invalidate(2, invalid = $$new_props.invalid);
  };
  $$self.$capture_state = () => ({
    status,
    iconDescription,
    invalid,
    Close: Close_default,
    CheckmarkFilled: CheckmarkFilled_default,
    WarningFilled: WarningFilled_default,
    Loading: Loading_default
  });
  $$self.$inject_state = ($$new_props) => {
    if ("status" in $$props) $$invalidate(0, status = $$new_props.status);
    if ("iconDescription" in $$props) $$invalidate(1, iconDescription = $$new_props.iconDescription);
    if ("invalid" in $$props) $$invalidate(2, invalid = $$new_props.invalid);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [status, iconDescription, invalid, $$restProps, click_handler, keydown_handler];
}
var Filename = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance80, create_fragment80, safe_not_equal, {
      status: 0,
      iconDescription: 1,
      invalid: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Filename",
      options,
      id: create_fragment80.name
    });
  }
  get status() {
    throw new Error("<Filename>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set status(value) {
    throw new Error("<Filename>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<Filename>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<Filename>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Filename>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Filename>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Filename_default = Filename;

// node_modules/carbon-components-svelte/src/FileUploader/FileUploaderButton.svelte
var file77 = "node_modules/carbon-components-svelte/src/FileUploader/FileUploaderButton.svelte";
var get_labelText_slot_changes6 = (dirty) => ({});
var get_labelText_slot_context6 = (ctx) => ({});
function fallback_block16(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[2]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelText*/
      4) set_data_dev(
        t,
        /*labelText*/
        ctx2[2]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block16.name,
    type: "fallback",
    source: "(96:27)        ",
    ctx
  });
  return block;
}
function create_fragment81(ctx) {
  let label;
  let span;
  let label_tabindex_value;
  let t;
  let input;
  let current;
  let mounted;
  let dispose;
  const labelText_slot_template = (
    /*#slots*/
    ctx[16].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_labelText_slot_context6
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block16(ctx);
  let input_levels = [
    { type: "file" },
    { tabindex: "-1" },
    { accept: (
      /*accept*/
      ctx[3]
    ) },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    { id: (
      /*id*/
      ctx[11]
    ) },
    { multiple: (
      /*multiple*/
      ctx[4]
    ) },
    { name: (
      /*name*/
      ctx[12]
    ) },
    /*$$restProps*/
    ctx[14]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      span = element("span");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      t = space();
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", {
        "aria-disabled": true,
        for: true,
        tabindex: true
      });
      var label_nodes = children(label);
      span = claim_element(label_nodes, "SPAN", { role: true });
      var span_nodes = children(span);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      input = claim_element(nodes, "INPUT", {
        type: true,
        tabindex: true,
        accept: true,
        id: true,
        name: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        span,
        "role",
        /*role*/
        ctx[9]
      );
      add_location(span, file77, 94, 2, 2464);
      attr_dev(
        label,
        "aria-disabled",
        /*disabled*/
        ctx[5]
      );
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[11]
      );
      attr_dev(label, "tabindex", label_tabindex_value = /*disabled*/
      ctx[5] ? "-1" : (
        /*tabindex*/
        ctx[10]
      ));
      toggle_class(label, "bx--btn", true);
      toggle_class(
        label,
        "bx--btn--disabled",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        label,
        "bx--btn--primary",
        /*kind*/
        ctx[7] === "primary"
      );
      toggle_class(
        label,
        "bx--btn--secondary",
        /*kind*/
        ctx[7] === "secondary"
      );
      toggle_class(
        label,
        "bx--btn--tertiary",
        /*kind*/
        ctx[7] === "tertiary"
      );
      toggle_class(
        label,
        "bx--btn--ghost",
        /*kind*/
        ctx[7] === "ghost"
      );
      toggle_class(
        label,
        "bx--btn--danger",
        /*kind*/
        ctx[7] === "danger"
      );
      toggle_class(
        label,
        "bx--btn--danger-tertiary",
        /*kind*/
        ctx[7] === "danger-tertiary"
      );
      toggle_class(
        label,
        "bx--btn--danger-ghost",
        /*kind*/
        ctx[7] === "danger-ghost"
      );
      toggle_class(
        label,
        "bx--btn--sm",
        /*size*/
        ctx[8] === "small"
      );
      toggle_class(
        label,
        "bx--btn--field",
        /*size*/
        ctx[8] === "field"
      );
      toggle_class(
        label,
        "bx--btn--lg",
        /*size*/
        ctx[8] === "lg"
      );
      toggle_class(
        label,
        "bx--btn--xl",
        /*size*/
        ctx[8] === "xl"
      );
      add_location(label, file77, 70, 0, 1666);
      set_attributes(input, input_data);
      toggle_class(input, "bx--visually-hidden", true);
      add_location(input, file77, 100, 0, 2562);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, span);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span, null);
      }
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus) input.focus();
      ctx[20](input);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            label,
            "keydown",
            /*keydown_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "keydown",
            /*keydown_handler_1*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(input, "change", stop_propagation(
            /*change_handler*/
            ctx[21]
          ), false, false, true, false),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(input, "click", click_handler_1, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_labelText_slot_changes6
            ),
            get_labelText_slot_context6
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & /*labelText*/
        4)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*role*/
      512) {
        attr_dev(
          span,
          "role",
          /*role*/
          ctx2[9]
        );
      }
      if (!current || dirty & /*disabled*/
      32) {
        attr_dev(
          label,
          "aria-disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*id*/
      2048) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[11]
        );
      }
      if (!current || dirty & /*disabled, tabindex*/
      1056 && label_tabindex_value !== (label_tabindex_value = /*disabled*/
      ctx2[5] ? "-1" : (
        /*tabindex*/
        ctx2[10]
      ))) {
        attr_dev(label, "tabindex", label_tabindex_value);
      }
      if (!current || dirty & /*disabled*/
      32) {
        toggle_class(
          label,
          "bx--btn--disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*kind*/
      128) {
        toggle_class(
          label,
          "bx--btn--primary",
          /*kind*/
          ctx2[7] === "primary"
        );
      }
      if (!current || dirty & /*kind*/
      128) {
        toggle_class(
          label,
          "bx--btn--secondary",
          /*kind*/
          ctx2[7] === "secondary"
        );
      }
      if (!current || dirty & /*kind*/
      128) {
        toggle_class(
          label,
          "bx--btn--tertiary",
          /*kind*/
          ctx2[7] === "tertiary"
        );
      }
      if (!current || dirty & /*kind*/
      128) {
        toggle_class(
          label,
          "bx--btn--ghost",
          /*kind*/
          ctx2[7] === "ghost"
        );
      }
      if (!current || dirty & /*kind*/
      128) {
        toggle_class(
          label,
          "bx--btn--danger",
          /*kind*/
          ctx2[7] === "danger"
        );
      }
      if (!current || dirty & /*kind*/
      128) {
        toggle_class(
          label,
          "bx--btn--danger-tertiary",
          /*kind*/
          ctx2[7] === "danger-tertiary"
        );
      }
      if (!current || dirty & /*kind*/
      128) {
        toggle_class(
          label,
          "bx--btn--danger-ghost",
          /*kind*/
          ctx2[7] === "danger-ghost"
        );
      }
      if (!current || dirty & /*size*/
      256) {
        toggle_class(
          label,
          "bx--btn--sm",
          /*size*/
          ctx2[8] === "small"
        );
      }
      if (!current || dirty & /*size*/
      256) {
        toggle_class(
          label,
          "bx--btn--field",
          /*size*/
          ctx2[8] === "field"
        );
      }
      if (!current || dirty & /*size*/
      256) {
        toggle_class(
          label,
          "bx--btn--lg",
          /*size*/
          ctx2[8] === "lg"
        );
      }
      if (!current || dirty & /*size*/
      256) {
        toggle_class(
          label,
          "bx--btn--xl",
          /*size*/
          ctx2[8] === "xl"
        );
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "file" },
        { tabindex: "-1" },
        (!current || dirty & /*accept*/
        8) && { accept: (
          /*accept*/
          ctx2[3]
        ) },
        (!current || dirty & /*disabled*/
        32) && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        (!current || dirty & /*id*/
        2048) && { id: (
          /*id*/
          ctx2[11]
        ) },
        (!current || dirty & /*multiple*/
        16) && { multiple: (
          /*multiple*/
          ctx2[4]
        ) },
        (!current || dirty & /*name*/
        4096) && { name: (
          /*name*/
          ctx2[12]
        ) },
        dirty & /*$$restProps*/
        16384 && /*$$restProps*/
        ctx2[14]
      ]));
      toggle_class(input, "bx--visually-hidden", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
        detach_dev(t);
        detach_dev(input);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
      ctx[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment81.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var click_handler_1 = ({ target }) => {
  target.value = null;
};
function instance81($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "accept",
    "files",
    "multiple",
    "disabled",
    "disableLabelChanges",
    "kind",
    "size",
    "labelText",
    "role",
    "tabindex",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileUploaderButton", slots, ["labelText"]);
  let { accept = [] } = $$props;
  let { files = [] } = $$props;
  let { multiple = false } = $$props;
  let { disabled = false } = $$props;
  let { disableLabelChanges = false } = $$props;
  let { kind = "primary" } = $$props;
  let { size = "small" } = $$props;
  let { labelText = "Add file" } = $$props;
  let { role = "button" } = $$props;
  let { tabindex = "0" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = "" } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let initialLabelText = labelText;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const keydown_handler_12 = ({ key }) => {
    if (key === " " || key === "Enter") {
      ref.click();
    }
  };
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref), $$invalidate(0, files), $$invalidate(22, initialLabelText);
    });
  }
  const change_handler = ({ target }) => {
    $$invalidate(0, files = [...target.files]);
    if (files && !disableLabelChanges) {
      $$invalidate(2, labelText = files.length > 1 ? `${files.length} files` : files[0].name);
    }
    dispatch("change", files);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("accept" in $$new_props) $$invalidate(3, accept = $$new_props.accept);
    if ("files" in $$new_props) $$invalidate(0, files = $$new_props.files);
    if ("multiple" in $$new_props) $$invalidate(4, multiple = $$new_props.multiple);
    if ("disabled" in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
    if ("disableLabelChanges" in $$new_props) $$invalidate(6, disableLabelChanges = $$new_props.disableLabelChanges);
    if ("kind" in $$new_props) $$invalidate(7, kind = $$new_props.kind);
    if ("size" in $$new_props) $$invalidate(8, size = $$new_props.size);
    if ("labelText" in $$new_props) $$invalidate(2, labelText = $$new_props.labelText);
    if ("role" in $$new_props) $$invalidate(9, role = $$new_props.role);
    if ("tabindex" in $$new_props) $$invalidate(10, tabindex = $$new_props.tabindex);
    if ("id" in $$new_props) $$invalidate(11, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(12, name = $$new_props.name);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    accept,
    files,
    multiple,
    disabled,
    disableLabelChanges,
    kind,
    size,
    labelText,
    role,
    tabindex,
    id,
    name,
    ref,
    createEventDispatcher,
    dispatch,
    initialLabelText
  });
  $$self.$inject_state = ($$new_props) => {
    if ("accept" in $$props) $$invalidate(3, accept = $$new_props.accept);
    if ("files" in $$props) $$invalidate(0, files = $$new_props.files);
    if ("multiple" in $$props) $$invalidate(4, multiple = $$new_props.multiple);
    if ("disabled" in $$props) $$invalidate(5, disabled = $$new_props.disabled);
    if ("disableLabelChanges" in $$props) $$invalidate(6, disableLabelChanges = $$new_props.disableLabelChanges);
    if ("kind" in $$props) $$invalidate(7, kind = $$new_props.kind);
    if ("size" in $$props) $$invalidate(8, size = $$new_props.size);
    if ("labelText" in $$props) $$invalidate(2, labelText = $$new_props.labelText);
    if ("role" in $$props) $$invalidate(9, role = $$new_props.role);
    if ("tabindex" in $$props) $$invalidate(10, tabindex = $$new_props.tabindex);
    if ("id" in $$props) $$invalidate(11, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(12, name = $$new_props.name);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("initialLabelText" in $$props) $$invalidate(22, initialLabelText = $$new_props.initialLabelText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*ref, files*/
    3) {
      $: if (ref && files.length === 0) {
        $$invalidate(2, labelText = initialLabelText);
        $$invalidate(1, ref.value = "", ref);
      }
    }
  };
  return [
    files,
    ref,
    labelText,
    accept,
    multiple,
    disabled,
    disableLabelChanges,
    kind,
    size,
    role,
    tabindex,
    id,
    name,
    dispatch,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keydown_handler_12,
    input_binding,
    change_handler
  ];
}
var FileUploaderButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance81, create_fragment81, safe_not_equal, {
      accept: 3,
      files: 0,
      multiple: 4,
      disabled: 5,
      disableLabelChanges: 6,
      kind: 7,
      size: 8,
      labelText: 2,
      role: 9,
      tabindex: 10,
      id: 11,
      name: 12,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileUploaderButton",
      options,
      id: create_fragment81.name
    });
  }
  get accept() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accept(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableLabelChanges() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableLabelChanges(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get kind() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileUploaderButton_default = FileUploaderButton;

// node_modules/carbon-components-svelte/src/FileUploader/FileUploader.svelte
var file78 = "node_modules/carbon-components-svelte/src/FileUploader/FileUploader.svelte";
function get_each_context10(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i].name;
  child_ctx[31] = i;
  return child_ctx;
}
var get_labelDescription_slot_changes = (dirty) => ({});
var get_labelDescription_slot_context = (ctx) => ({});
var get_labelTitle_slot_changes = (dirty) => ({});
var get_labelTitle_slot_context = (ctx) => ({});
function create_if_block_117(ctx) {
  let p;
  let current;
  const labelTitle_slot_template = (
    /*#slots*/
    ctx[16].labelTitle
  );
  const labelTitle_slot = create_slot(
    labelTitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_labelTitle_slot_context
  );
  const labelTitle_slot_or_fallback = labelTitle_slot || fallback_block_17(ctx);
  const block = {
    c: function create() {
      p = element("p");
      if (labelTitle_slot_or_fallback) labelTitle_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      if (labelTitle_slot_or_fallback) labelTitle_slot_or_fallback.l(p_nodes);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(p, "bx--file--label", true);
      toggle_class(
        p,
        "bx--label-description--disabled",
        /*disabled*/
        ctx[2]
      );
      add_location(p, file78, 118, 4, 3002);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      if (labelTitle_slot_or_fallback) {
        labelTitle_slot_or_fallback.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelTitle_slot) {
        if (labelTitle_slot.p && (!current || dirty[0] & /*$$scope*/
        32768)) {
          update_slot_base(
            labelTitle_slot,
            labelTitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              labelTitle_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_labelTitle_slot_changes
            ),
            get_labelTitle_slot_context
          );
        }
      } else {
        if (labelTitle_slot_or_fallback && labelTitle_slot_or_fallback.p && (!current || dirty[0] & /*labelTitle*/
        32)) {
          labelTitle_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*disabled*/
      4) {
        toggle_class(
          p,
          "bx--label-description--disabled",
          /*disabled*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelTitle_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelTitle_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
      if (labelTitle_slot_or_fallback) labelTitle_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_117.name,
    type: "if",
    source: "(118:2) {#if labelTitle || $$slots.labelTitle}",
    ctx
  });
  return block;
}
function fallback_block_17(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelTitle*/
        ctx[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelTitle*/
        ctx[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelTitle*/
      32) set_data_dev(
        t,
        /*labelTitle*/
        ctx2[5]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_17.name,
    type: "fallback",
    source: "(123:30)          ",
    ctx
  });
  return block;
}
function create_if_block49(ctx) {
  let p;
  let current;
  const labelDescription_slot_template = (
    /*#slots*/
    ctx[16].labelDescription
  );
  const labelDescription_slot = create_slot(
    labelDescription_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_labelDescription_slot_context
  );
  const labelDescription_slot_or_fallback = labelDescription_slot || fallback_block17(ctx);
  const block = {
    c: function create() {
      p = element("p");
      if (labelDescription_slot_or_fallback) labelDescription_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      if (labelDescription_slot_or_fallback) labelDescription_slot_or_fallback.l(p_nodes);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(p, "bx--label-description", true);
      toggle_class(
        p,
        "bx--label-description--disabled",
        /*disabled*/
        ctx[2]
      );
      add_location(p, file78, 128, 4, 3245);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      if (labelDescription_slot_or_fallback) {
        labelDescription_slot_or_fallback.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelDescription_slot) {
        if (labelDescription_slot.p && (!current || dirty[0] & /*$$scope*/
        32768)) {
          update_slot_base(
            labelDescription_slot,
            labelDescription_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              labelDescription_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_labelDescription_slot_changes
            ),
            get_labelDescription_slot_context
          );
        }
      } else {
        if (labelDescription_slot_or_fallback && labelDescription_slot_or_fallback.p && (!current || dirty[0] & /*labelDescription*/
        64)) {
          labelDescription_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*disabled*/
      4) {
        toggle_class(
          p,
          "bx--label-description--disabled",
          /*disabled*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelDescription_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelDescription_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
      if (labelDescription_slot_or_fallback) labelDescription_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block49.name,
    type: "if",
    source: "(128:2) {#if labelDescription || $$slots.labelDescription}",
    ctx
  });
  return block;
}
function fallback_block17(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelDescription*/
        ctx[6]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelDescription*/
        ctx[6]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelDescription*/
      64) set_data_dev(
        t,
        /*labelDescription*/
        ctx2[6]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block17.name,
    type: "fallback",
    source: "(133:36)          ",
    ctx
  });
  return block;
}
function create_each_block10(ctx) {
  let span1;
  let p;
  let t0_value = (
    /*name*/
    ctx[11] + ""
  );
  let t0;
  let t1;
  let span0;
  let filename;
  let t2;
  let current;
  function keydown_handler_12(...args) {
    return (
      /*keydown_handler_1*/
      ctx[24](
        /*i*/
        ctx[31],
        ...args
      )
    );
  }
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[26](
        /*i*/
        ctx[31]
      )
    );
  }
  filename = new Filename_default({
    props: {
      iconDescription: (
        /*iconDescription*/
        ctx[10]
      ),
      status: (
        /*status*/
        ctx[1]
      )
    },
    $$inline: true
  });
  filename.$on(
    "keydown",
    /*keydown_handler*/
    ctx[23]
  );
  filename.$on("keydown", keydown_handler_12);
  filename.$on(
    "click",
    /*click_handler_1*/
    ctx[25]
  );
  filename.$on("click", click_handler_2);
  const block = {
    c: function create() {
      span1 = element("span");
      p = element("p");
      t0 = text(t0_value);
      t1 = space();
      span0 = element("span");
      create_component(filename.$$.fragment);
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", {});
      var span1_nodes = children(span1);
      p = claim_element(span1_nodes, "P", {});
      var p_nodes = children(p);
      t0 = claim_text(p_nodes, t0_value);
      p_nodes.forEach(detach_dev);
      t1 = claim_space(span1_nodes);
      span0 = claim_element(span1_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      claim_component(filename.$$.fragment, span0_nodes);
      span0_nodes.forEach(detach_dev);
      t2 = claim_space(span1_nodes);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(p, "bx--file-filename", true);
      add_location(p, file78, 154, 8, 3864);
      toggle_class(span0, "bx--file__state-container", true);
      add_location(span0, file78, 155, 8, 3919);
      toggle_class(span1, "bx--file__selected-file", true);
      add_location(span1, file78, 153, 6, 3810);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, p);
      append_hydration_dev(p, t0);
      append_hydration_dev(span1, t1);
      append_hydration_dev(span1, span0);
      mount_component(filename, span0, null);
      append_hydration_dev(span1, t2);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & /*files*/
      1) && t0_value !== (t0_value = /*name*/
      ctx[11] + "")) set_data_dev(t0, t0_value);
      const filename_changes = {};
      if (dirty[0] & /*iconDescription*/
      1024) filename_changes.iconDescription = /*iconDescription*/
      ctx[10];
      if (dirty[0] & /*status*/
      2) filename_changes.status = /*status*/
      ctx[1];
      filename.$set(filename_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(filename.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(filename.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span1);
      }
      destroy_component(filename);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block10.name,
    type: "each",
    source: "(153:4) {#each files as { name }",
    ctx
  });
  return block;
}
function create_fragment82(ctx) {
  let div1;
  let t0;
  let t1;
  let fileuploaderbutton;
  let t2;
  let div0;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*labelTitle*/
    (ctx[5] || /*$$slots*/
    ctx[13].labelTitle) && create_if_block_117(ctx)
  );
  let if_block1 = (
    /*labelDescription*/
    (ctx[6] || /*$$slots*/
    ctx[13].labelDescription) && create_if_block49(ctx)
  );
  fileuploaderbutton = new FileUploaderButton_default({
    props: {
      disabled: (
        /*disabled*/
        ctx[2]
      ),
      disableLabelChanges: true,
      labelText: (
        /*buttonLabel*/
        ctx[9]
      ),
      accept: (
        /*accept*/
        ctx[3]
      ),
      name: (
        /*name*/
        ctx[11]
      ),
      multiple: (
        /*multiple*/
        ctx[4]
      ),
      kind: (
        /*kind*/
        ctx[7]
      ),
      size: (
        /*size*/
        ctx[8]
      )
    },
    $$inline: true
  });
  fileuploaderbutton.$on(
    "change",
    /*change_handler*/
    ctx[21]
  );
  fileuploaderbutton.$on(
    "change",
    /*change_handler_1*/
    ctx[22]
  );
  let each_value = ensure_array_like_dev(
    /*files*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block10(get_each_context10(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let div1_levels = [
    /*$$restProps*/
    ctx[12]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      create_component(fileuploaderbutton.$$.fragment);
      t2 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      if (if_block0) if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      if (if_block1) if_block1.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      claim_component(fileuploaderbutton.$$.fragment, div1_nodes);
      t2 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--file-container", true);
      add_location(div0, file78, 151, 2, 3731);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file78, 109, 0, 2842);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0) if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      if (if_block1) if_block1.m(div1, null);
      append_hydration_dev(div1, t1);
      mount_component(fileuploaderbutton, div1, null);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseover",
            /*mouseover_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*labelTitle*/
        ctx2[5] || /*$$slots*/
        ctx2[13].labelTitle
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*labelTitle, $$slots*/
          8224) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_117(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*labelDescription*/
        ctx2[6] || /*$$slots*/
        ctx2[13].labelDescription
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*labelDescription, $$slots*/
          8256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block49(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const fileuploaderbutton_changes = {};
      if (dirty[0] & /*disabled*/
      4) fileuploaderbutton_changes.disabled = /*disabled*/
      ctx2[2];
      if (dirty[0] & /*buttonLabel*/
      512) fileuploaderbutton_changes.labelText = /*buttonLabel*/
      ctx2[9];
      if (dirty[0] & /*accept*/
      8) fileuploaderbutton_changes.accept = /*accept*/
      ctx2[3];
      if (dirty[0] & /*name*/
      2048) fileuploaderbutton_changes.name = /*name*/
      ctx2[11];
      if (dirty[0] & /*multiple*/
      16) fileuploaderbutton_changes.multiple = /*multiple*/
      ctx2[4];
      if (dirty[0] & /*kind*/
      128) fileuploaderbutton_changes.kind = /*kind*/
      ctx2[7];
      if (dirty[0] & /*size*/
      256) fileuploaderbutton_changes.size = /*size*/
      ctx2[8];
      fileuploaderbutton.$set(fileuploaderbutton_changes);
      if (dirty[0] & /*iconDescription, status, files*/
      1027) {
        each_value = ensure_array_like_dev(
          /*files*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context10(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block10(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty[0] & /*$$restProps*/
      4096 && /*$$restProps*/
      ctx2[12]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(fileuploaderbutton.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(fileuploaderbutton.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      destroy_component(fileuploaderbutton);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment82.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance82($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "status",
    "disabled",
    "accept",
    "files",
    "multiple",
    "clearFiles",
    "labelTitle",
    "labelDescription",
    "kind",
    "size",
    "buttonLabel",
    "iconDescription",
    "name"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileUploader", slots, ["labelTitle", "labelDescription"]);
  const $$slots = compute_slots(slots);
  let { status = "uploading" } = $$props;
  let { disabled = false } = $$props;
  let { accept = [] } = $$props;
  let { files = [] } = $$props;
  let { multiple = false } = $$props;
  const clearFiles = () => {
    $$invalidate(0, files = []);
  };
  let { labelTitle = "" } = $$props;
  let { labelDescription = "" } = $$props;
  let { kind = "primary" } = $$props;
  let { size = "small" } = $$props;
  let { buttonLabel = "" } = $$props;
  let { iconDescription = "Provide icon description" } = $$props;
  let { name = "" } = $$props;
  const dispatch = createEventDispatcher();
  let prevFiles = [];
  const getFileId = (file194) => file194.lastModified + file194.name;
  afterUpdate(() => {
    const fileIds = files.map(getFileId);
    const prevFileIds = prevFiles.map(getFileId);
    const addedIds = fileIds.filter((_) => !prevFileIds.includes(_));
    const removedIds = prevFileIds.filter((_) => !fileIds.includes(_));
    if (addedIds.length > 0) {
      dispatch("add", addedIds.map((id) => files.find((file194) => id === getFileId(file194))));
    }
    if (removedIds.length > 0) {
      dispatch("remove", removedIds.map((id) => prevFiles.find((file194) => id === getFileId(file194))));
    }
    prevFiles = [...files];
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const change_handler_1 = (e) => {
    $$invalidate(0, files = e.detail);
  };
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const keydown_handler_12 = (i, { key }) => {
    if (key === " " || key === "Enter") {
      $$invalidate(0, files = files.filter((_, index) => index !== i));
    }
  };
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_2 = (i) => {
    $$invalidate(0, files = files.filter((_, index) => index !== i));
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("status" in $$new_props) $$invalidate(1, status = $$new_props.status);
    if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("accept" in $$new_props) $$invalidate(3, accept = $$new_props.accept);
    if ("files" in $$new_props) $$invalidate(0, files = $$new_props.files);
    if ("multiple" in $$new_props) $$invalidate(4, multiple = $$new_props.multiple);
    if ("labelTitle" in $$new_props) $$invalidate(5, labelTitle = $$new_props.labelTitle);
    if ("labelDescription" in $$new_props) $$invalidate(6, labelDescription = $$new_props.labelDescription);
    if ("kind" in $$new_props) $$invalidate(7, kind = $$new_props.kind);
    if ("size" in $$new_props) $$invalidate(8, size = $$new_props.size);
    if ("buttonLabel" in $$new_props) $$invalidate(9, buttonLabel = $$new_props.buttonLabel);
    if ("iconDescription" in $$new_props) $$invalidate(10, iconDescription = $$new_props.iconDescription);
    if ("name" in $$new_props) $$invalidate(11, name = $$new_props.name);
    if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    status,
    disabled,
    accept,
    files,
    multiple,
    clearFiles,
    labelTitle,
    labelDescription,
    kind,
    size,
    buttonLabel,
    iconDescription,
    name,
    createEventDispatcher,
    afterUpdate,
    Filename: Filename_default,
    FileUploaderButton: FileUploaderButton_default,
    dispatch,
    prevFiles,
    getFileId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("status" in $$props) $$invalidate(1, status = $$new_props.status);
    if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("accept" in $$props) $$invalidate(3, accept = $$new_props.accept);
    if ("files" in $$props) $$invalidate(0, files = $$new_props.files);
    if ("multiple" in $$props) $$invalidate(4, multiple = $$new_props.multiple);
    if ("labelTitle" in $$props) $$invalidate(5, labelTitle = $$new_props.labelTitle);
    if ("labelDescription" in $$props) $$invalidate(6, labelDescription = $$new_props.labelDescription);
    if ("kind" in $$props) $$invalidate(7, kind = $$new_props.kind);
    if ("size" in $$props) $$invalidate(8, size = $$new_props.size);
    if ("buttonLabel" in $$props) $$invalidate(9, buttonLabel = $$new_props.buttonLabel);
    if ("iconDescription" in $$props) $$invalidate(10, iconDescription = $$new_props.iconDescription);
    if ("name" in $$props) $$invalidate(11, name = $$new_props.name);
    if ("prevFiles" in $$props) prevFiles = $$new_props.prevFiles;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    files,
    status,
    disabled,
    accept,
    multiple,
    labelTitle,
    labelDescription,
    kind,
    size,
    buttonLabel,
    iconDescription,
    name,
    $$restProps,
    $$slots,
    clearFiles,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    change_handler,
    change_handler_1,
    keydown_handler,
    keydown_handler_12,
    click_handler_13,
    click_handler_2
  ];
}
var FileUploader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance82,
      create_fragment82,
      safe_not_equal,
      {
        status: 1,
        disabled: 2,
        accept: 3,
        files: 0,
        multiple: 4,
        clearFiles: 14,
        labelTitle: 5,
        labelDescription: 6,
        kind: 7,
        size: 8,
        buttonLabel: 9,
        iconDescription: 10,
        name: 11
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileUploader",
      options,
      id: create_fragment82.name
    });
  }
  get status() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set status(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accept() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accept(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearFiles() {
    return this.$$.ctx[14];
  }
  set clearFiles(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelTitle() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelTitle(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelDescription() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelDescription(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get kind() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonLabel() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonLabel(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileUploader_default = FileUploader;

// node_modules/carbon-components-svelte/src/FileUploader/FileUploaderItem.svelte
var file79 = "node_modules/carbon-components-svelte/src/FileUploader/FileUploaderItem.svelte";
function create_if_block50(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let if_block = (
    /*errorBody*/
    ctx[5] && create_if_block_118(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(
        /*errorSubject*/
        ctx[4]
      );
      t1 = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*errorSubject*/
        ctx[4]
      );
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (if_block) if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--form-requirement__title", true);
      add_location(div0, file79, 72, 6, 1861);
      toggle_class(div1, "bx--form-requirement", true);
      add_location(div1, file79, 71, 4, 1813);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div1, t1);
      if (if_block) if_block.m(div1, null);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*errorSubject*/
      16) set_data_dev(
        t0,
        /*errorSubject*/
        ctx2[4]
      );
      if (
        /*errorBody*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_118(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block50.name,
    type: "if",
    source: "(71:2) {#if invalid && errorSubject}",
    ctx
  });
  return block;
}
function create_if_block_118(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text(
        /*errorBody*/
        ctx[5]
      );
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(
        p_nodes,
        /*errorBody*/
        ctx[5]
      );
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(p, "bx--form-requirement__supplement", true);
      add_location(p, file79, 74, 8, 1960);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*errorBody*/
      32) set_data_dev(
        t,
        /*errorBody*/
        ctx2[5]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_118.name,
    type: "if",
    source: "(74:6) {#if errorBody}",
    ctx
  });
  return block;
}
function create_fragment83(ctx) {
  let span1;
  let p;
  let t0;
  let t1;
  let span0;
  let filename;
  let t2;
  let current;
  let mounted;
  let dispose;
  filename = new Filename_default({
    props: {
      iconDescription: (
        /*iconDescription*/
        ctx[2]
      ),
      status: (
        /*status*/
        ctx[0]
      ),
      invalid: (
        /*invalid*/
        ctx[3]
      )
    },
    $$inline: true
  });
  filename.$on(
    "keydown",
    /*keydown_handler*/
    ctx[13]
  );
  filename.$on(
    "click",
    /*click_handler*/
    ctx[14]
  );
  let if_block = (
    /*invalid*/
    ctx[3] && /*errorSubject*/
    ctx[4] && create_if_block50(ctx)
  );
  let span1_levels = [
    { id: (
      /*id*/
      ctx[6]
    ) },
    /*$$restProps*/
    ctx[9]
  ];
  let span_data_1 = {};
  for (let i = 0; i < span1_levels.length; i += 1) {
    span_data_1 = assign(span_data_1, span1_levels[i]);
  }
  const block = {
    c: function create() {
      span1 = element("span");
      p = element("p");
      t0 = text(
        /*name*/
        ctx[7]
      );
      t1 = space();
      span0 = element("span");
      create_component(filename.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { id: true });
      var span1_nodes = children(span1);
      p = claim_element(span1_nodes, "P", {});
      var p_nodes = children(p);
      t0 = claim_text(
        p_nodes,
        /*name*/
        ctx[7]
      );
      p_nodes.forEach(detach_dev);
      t1 = claim_space(span1_nodes);
      span0 = claim_element(span1_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      claim_component(filename.$$.fragment, span0_nodes);
      span0_nodes.forEach(detach_dev);
      t2 = claim_space(span1_nodes);
      if (if_block) if_block.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(p, "bx--file-filename", true);
      add_location(p, file79, 54, 2, 1356);
      toggle_class(span0, "bx--file__state-container", true);
      add_location(span0, file79, 55, 2, 1405);
      set_attributes(span1, span_data_1);
      toggle_class(span1, "bx--file__selected-file", true);
      toggle_class(
        span1,
        "bx--file__selected-file--invalid",
        /*invalid*/
        ctx[3]
      );
      toggle_class(
        span1,
        "bx--file__selected-file--md",
        /*size*/
        ctx[1] === "field"
      );
      toggle_class(
        span1,
        "bx--file__selected-file--sm",
        /*size*/
        ctx[1] === "small"
      );
      add_location(span1, file79, 43, 0, 1060);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, p);
      append_hydration_dev(p, t0);
      append_hydration_dev(span1, t1);
      append_hydration_dev(span1, span0);
      mount_component(filename, span0, null);
      append_hydration_dev(span1, t2);
      if (if_block) if_block.m(span1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            span1,
            "mouseover",
            /*mouseover_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*name*/
      128) set_data_dev(
        t0,
        /*name*/
        ctx2[7]
      );
      const filename_changes = {};
      if (dirty & /*iconDescription*/
      4) filename_changes.iconDescription = /*iconDescription*/
      ctx2[2];
      if (dirty & /*status*/
      1) filename_changes.status = /*status*/
      ctx2[0];
      if (dirty & /*invalid*/
      8) filename_changes.invalid = /*invalid*/
      ctx2[3];
      filename.$set(filename_changes);
      if (
        /*invalid*/
        ctx2[3] && /*errorSubject*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block50(ctx2);
          if_block.c();
          if_block.m(span1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(span1, span_data_1 = get_spread_update(span1_levels, [
        (!current || dirty & /*id*/
        64) && { id: (
          /*id*/
          ctx2[6]
        ) },
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9]
      ]));
      toggle_class(span1, "bx--file__selected-file", true);
      toggle_class(
        span1,
        "bx--file__selected-file--invalid",
        /*invalid*/
        ctx2[3]
      );
      toggle_class(
        span1,
        "bx--file__selected-file--md",
        /*size*/
        ctx2[1] === "field"
      );
      toggle_class(
        span1,
        "bx--file__selected-file--sm",
        /*size*/
        ctx2[1] === "small"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(filename.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(filename.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span1);
      }
      destroy_component(filename);
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment83.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance83($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "status",
    "size",
    "iconDescription",
    "invalid",
    "errorSubject",
    "errorBody",
    "id",
    "name"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileUploaderItem", slots, []);
  let { status = "uploading" } = $$props;
  let { size = "default" } = $$props;
  let { iconDescription = "" } = $$props;
  let { invalid = false } = $$props;
  let { errorSubject = "" } = $$props;
  let { errorBody = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = "" } = $$props;
  const dispatch = createEventDispatcher();
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const keydown_handler = ({ key }) => {
    if (key === " " || key === "Enter") {
      dispatch("delete", id);
    }
  };
  const click_handler = () => {
    dispatch("delete", id);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("status" in $$new_props) $$invalidate(0, status = $$new_props.status);
    if ("size" in $$new_props) $$invalidate(1, size = $$new_props.size);
    if ("iconDescription" in $$new_props) $$invalidate(2, iconDescription = $$new_props.iconDescription);
    if ("invalid" in $$new_props) $$invalidate(3, invalid = $$new_props.invalid);
    if ("errorSubject" in $$new_props) $$invalidate(4, errorSubject = $$new_props.errorSubject);
    if ("errorBody" in $$new_props) $$invalidate(5, errorBody = $$new_props.errorBody);
    if ("id" in $$new_props) $$invalidate(6, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(7, name = $$new_props.name);
  };
  $$self.$capture_state = () => ({
    status,
    size,
    iconDescription,
    invalid,
    errorSubject,
    errorBody,
    id,
    name,
    createEventDispatcher,
    Filename: Filename_default,
    dispatch
  });
  $$self.$inject_state = ($$new_props) => {
    if ("status" in $$props) $$invalidate(0, status = $$new_props.status);
    if ("size" in $$props) $$invalidate(1, size = $$new_props.size);
    if ("iconDescription" in $$props) $$invalidate(2, iconDescription = $$new_props.iconDescription);
    if ("invalid" in $$props) $$invalidate(3, invalid = $$new_props.invalid);
    if ("errorSubject" in $$props) $$invalidate(4, errorSubject = $$new_props.errorSubject);
    if ("errorBody" in $$props) $$invalidate(5, errorBody = $$new_props.errorBody);
    if ("id" in $$props) $$invalidate(6, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(7, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    status,
    size,
    iconDescription,
    invalid,
    errorSubject,
    errorBody,
    id,
    name,
    dispatch,
    $$restProps,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    click_handler
  ];
}
var FileUploaderItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance83, create_fragment83, safe_not_equal, {
      status: 0,
      size: 1,
      iconDescription: 2,
      invalid: 3,
      errorSubject: 4,
      errorBody: 5,
      id: 6,
      name: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileUploaderItem",
      options,
      id: create_fragment83.name
    });
  }
  get status() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set status(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get errorSubject() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set errorSubject(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get errorBody() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set errorBody(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileUploaderItem_default = FileUploaderItem;

// node_modules/carbon-components-svelte/src/FileUploader/FileUploaderDropContainer.svelte
var file80 = "node_modules/carbon-components-svelte/src/FileUploader/FileUploaderDropContainer.svelte";
var get_labelText_slot_changes7 = (dirty) => ({});
var get_labelText_slot_context7 = (ctx) => ({});
function fallback_block18(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelText*/
      32) set_data_dev(
        t,
        /*labelText*/
        ctx2[5]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block18.name,
    type: "fallback",
    source: "(104:29)          ",
    ctx
  });
  return block;
}
function create_fragment84(ctx) {
  let div1;
  let label;
  let div0;
  let t;
  let input;
  let current;
  let mounted;
  let dispose;
  const labelText_slot_template = (
    /*#slots*/
    ctx[15].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_labelText_slot_context7
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block18(ctx);
  let div1_levels = [
    /*$$restProps*/
    ctx[13]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      label = element("label");
      div0 = element("div");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      t = space();
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      label = claim_element(div1_nodes, "LABEL", { for: true, tabindex: true });
      var label_nodes = children(label);
      div0 = claim_element(label_nodes, "DIV", { role: true });
      var div0_nodes = children(div0);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      t = claim_space(div1_nodes);
      input = claim_element(div1_nodes, "INPUT", {
        type: true,
        tabindex: true,
        id: true,
        accept: true,
        name: true
      });
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div0,
        "role",
        /*role*/
        ctx[6]
      );
      toggle_class(div0, "bx--file__drop-container", true);
      toggle_class(
        div0,
        "bx--file__drop-container--drag-over",
        /*over*/
        ctx[11]
      );
      add_location(div0, file80, 98, 4, 2440);
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[9]
      );
      attr_dev(
        label,
        "tabindex",
        /*tabindex*/
        ctx[8]
      );
      toggle_class(label, "bx--file-browse-btn", true);
      toggle_class(
        label,
        "bx--file-browse-btn--disabled",
        /*disabled*/
        ctx[7]
      );
      add_location(label, file80, 86, 2, 2164);
      attr_dev(input, "type", "file");
      attr_dev(input, "tabindex", "-1");
      attr_dev(
        input,
        "id",
        /*id*/
        ctx[9]
      );
      input.disabled = /*disabled*/
      ctx[7];
      attr_dev(
        input,
        "accept",
        /*accept*/
        ctx[2]
      );
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[10]
      );
      input.multiple = /*multiple*/
      ctx[3];
      toggle_class(input, "bx--file-input", true);
      add_location(input, file80, 108, 2, 2662);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--file", true);
      add_location(div1, file80, 57, 0, 1380);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, label);
      append_hydration_dev(label, div0);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, input);
      ctx[22](input);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            label,
            "keydown",
            /*keydown_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "keydown",
            /*keydown_handler_1*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(input, "click", click_handler_12, false, false, false, false),
          listen_dev(
            div1,
            "dragover",
            /*dragover_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(div1, "dragover", stop_propagation(prevent_default(
            /*dragover_handler_1*/
            ctx[24]
          )), false, true, true, false),
          listen_dev(
            div1,
            "dragleave",
            /*dragleave_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(div1, "dragleave", stop_propagation(prevent_default(
            /*dragleave_handler_1*/
            ctx[25]
          )), false, true, true, false),
          listen_dev(
            div1,
            "drop",
            /*drop_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(div1, "drop", stop_propagation(prevent_default(
            /*drop_handler_1*/
            ctx[26]
          )), false, true, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_labelText_slot_changes7
            ),
            get_labelText_slot_context7
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & /*labelText*/
        32)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*role*/
      64) {
        attr_dev(
          div0,
          "role",
          /*role*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*over*/
      2048) {
        toggle_class(
          div0,
          "bx--file__drop-container--drag-over",
          /*over*/
          ctx2[11]
        );
      }
      if (!current || dirty & /*id*/
      512) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[9]
        );
      }
      if (!current || dirty & /*tabindex*/
      256) {
        attr_dev(
          label,
          "tabindex",
          /*tabindex*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*disabled*/
      128) {
        toggle_class(
          label,
          "bx--file-browse-btn--disabled",
          /*disabled*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*id*/
      512) {
        attr_dev(
          input,
          "id",
          /*id*/
          ctx2[9]
        );
      }
      if (!current || dirty & /*disabled*/
      128) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*accept*/
      4) {
        attr_dev(
          input,
          "accept",
          /*accept*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*name*/
      1024) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[10]
        );
      }
      if (!current || dirty & /*multiple*/
      8) {
        prop_dev(
          input,
          "multiple",
          /*multiple*/
          ctx2[3]
        );
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty & /*$$restProps*/
      8192 && /*$$restProps*/
      ctx2[13]]));
      toggle_class(div1, "bx--file", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
      ctx[22](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment84.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var click_handler_12 = ({ target }) => {
  target.value = null;
};
function instance84($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "accept",
    "files",
    "multiple",
    "validateFiles",
    "labelText",
    "role",
    "disabled",
    "tabindex",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileUploaderDropContainer", slots, ["labelText"]);
  let { accept = [] } = $$props;
  let { files = [] } = $$props;
  let { multiple = false } = $$props;
  let { validateFiles = (files2) => files2 } = $$props;
  let { labelText = "Add file" } = $$props;
  let { role = "button" } = $$props;
  let { disabled = false } = $$props;
  let { tabindex = "0" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = "" } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let over = false;
  function dragover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function dragleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function drop_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const keydown_handler_12 = ({ key }) => {
    if (key === " " || key === "Enter") {
      ref.click();
    }
  };
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const change_handler = ({ target }) => {
    $$invalidate(0, files = validateFiles([...target.files]));
    dispatch("add", files);
    dispatch("change", files);
  };
  const dragover_handler_1 = ({ dataTransfer }) => {
    if (!disabled) {
      $$invalidate(11, over = true);
      dataTransfer.dropEffect = "copy";
    }
  };
  const dragleave_handler_1 = ({ dataTransfer }) => {
    if (!disabled) {
      $$invalidate(11, over = false);
      dataTransfer.dropEffect = "move";
    }
  };
  const drop_handler_1 = ({ dataTransfer }) => {
    if (!disabled) {
      $$invalidate(11, over = false);
      $$invalidate(0, files = validateFiles([...dataTransfer.files]));
      dispatch("add", files);
      dispatch("change", files);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("accept" in $$new_props) $$invalidate(2, accept = $$new_props.accept);
    if ("files" in $$new_props) $$invalidate(0, files = $$new_props.files);
    if ("multiple" in $$new_props) $$invalidate(3, multiple = $$new_props.multiple);
    if ("validateFiles" in $$new_props) $$invalidate(4, validateFiles = $$new_props.validateFiles);
    if ("labelText" in $$new_props) $$invalidate(5, labelText = $$new_props.labelText);
    if ("role" in $$new_props) $$invalidate(6, role = $$new_props.role);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("tabindex" in $$new_props) $$invalidate(8, tabindex = $$new_props.tabindex);
    if ("id" in $$new_props) $$invalidate(9, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(10, name = $$new_props.name);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    accept,
    files,
    multiple,
    validateFiles,
    labelText,
    role,
    disabled,
    tabindex,
    id,
    name,
    ref,
    createEventDispatcher,
    dispatch,
    over
  });
  $$self.$inject_state = ($$new_props) => {
    if ("accept" in $$props) $$invalidate(2, accept = $$new_props.accept);
    if ("files" in $$props) $$invalidate(0, files = $$new_props.files);
    if ("multiple" in $$props) $$invalidate(3, multiple = $$new_props.multiple);
    if ("validateFiles" in $$props) $$invalidate(4, validateFiles = $$new_props.validateFiles);
    if ("labelText" in $$props) $$invalidate(5, labelText = $$new_props.labelText);
    if ("role" in $$props) $$invalidate(6, role = $$new_props.role);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("tabindex" in $$props) $$invalidate(8, tabindex = $$new_props.tabindex);
    if ("id" in $$props) $$invalidate(9, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(10, name = $$new_props.name);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("over" in $$props) $$invalidate(11, over = $$new_props.over);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    files,
    ref,
    accept,
    multiple,
    validateFiles,
    labelText,
    role,
    disabled,
    tabindex,
    id,
    name,
    over,
    dispatch,
    $$restProps,
    $$scope,
    slots,
    dragover_handler,
    dragleave_handler,
    drop_handler,
    click_handler,
    keydown_handler,
    keydown_handler_12,
    input_binding,
    change_handler,
    dragover_handler_1,
    dragleave_handler_1,
    drop_handler_1
  ];
}
var FileUploaderDropContainer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance84, create_fragment84, safe_not_equal, {
      accept: 2,
      files: 0,
      multiple: 3,
      validateFiles: 4,
      labelText: 5,
      role: 6,
      disabled: 7,
      tabindex: 8,
      id: 9,
      name: 10,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileUploaderDropContainer",
      options,
      id: create_fragment84.name
    });
  }
  get accept() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accept(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validateFiles() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validateFiles(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileUploaderDropContainer_default = FileUploaderDropContainer;

// node_modules/carbon-components-svelte/src/FileUploader/FileUploaderSkeleton.svelte
var file81 = "node_modules/carbon-components-svelte/src/FileUploader/FileUploaderSkeleton.svelte";
function create_fragment85(ctx) {
  let div;
  let skeletontext0;
  let t0;
  let skeletontext1;
  let t1;
  let buttonskeleton;
  let current;
  let mounted;
  let dispose;
  skeletontext0 = new SkeletonText_default({
    props: { heading: true, width: "100px" },
    $$inline: true
  });
  skeletontext1 = new SkeletonText_default({
    props: {
      width: "225px",
      class: "bx--label-description"
    },
    $$inline: true
  });
  buttonskeleton = new ButtonSkeleton_default({ $$inline: true });
  let div_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      create_component(skeletontext0.$$.fragment);
      t0 = space();
      create_component(skeletontext1.$$.fragment);
      t1 = space();
      create_component(buttonskeleton.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(skeletontext0.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      claim_component(skeletontext1.$$.fragment, div_nodes);
      t1 = claim_space(div_nodes);
      claim_component(buttonskeleton.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      add_location(div, file81, 7, 0, 266);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(skeletontext0, div, null);
      append_hydration_dev(div, t0);
      mount_component(skeletontext1, div, null);
      append_hydration_dev(div, t1);
      mount_component(buttonskeleton, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[1],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
      toggle_class(div, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(skeletontext0.$$.fragment, local);
      transition_in(skeletontext1.$$.fragment, local);
      transition_in(buttonskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(skeletontext0.$$.fragment, local);
      transition_out(skeletontext1.$$.fragment, local);
      transition_out(buttonskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(skeletontext0);
      destroy_component(skeletontext1);
      destroy_component(buttonskeleton);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment85.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance85($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileUploaderSkeleton", slots, []);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  $$self.$capture_state = () => ({ ButtonSkeleton: ButtonSkeleton_default, SkeletonText: SkeletonText_default });
  return [
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var FileUploaderSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance85, create_fragment85, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileUploaderSkeleton",
      options,
      id: create_fragment85.name
    });
  }
};
var FileUploaderSkeleton_default = FileUploaderSkeleton;

// node_modules/carbon-components-svelte/src/Form/Form.svelte
var file82 = "node_modules/carbon-components-svelte/src/Form/Form.svelte";
function create_fragment86(ctx) {
  let form;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let form_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let form_data = {};
  for (let i = 0; i < form_levels.length; i += 1) {
    form_data = assign(form_data, form_levels[i]);
  }
  const block = {
    c: function create() {
      form = element("form");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", {});
      var form_nodes = children(form);
      if (default_slot) default_slot.l(form_nodes);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(form, form_data);
      toggle_class(form, "bx--form", true);
      add_location(form, file82, 7, 0, 217);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      if (default_slot) {
        default_slot.m(form, null);
      }
      ctx[10](form);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            form,
            "click",
            /*click_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            form,
            "keydown",
            /*keydown_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            form,
            "mouseover",
            /*mouseover_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            form,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            form,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            form,
            "submit",
            /*submit_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(form, form_data = get_spread_update(form_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(form, "bx--form", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(form);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[10](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment86.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance86($$self, $$props, $$invalidate) {
  const omit_props_names = ["ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Form", slots, ["default"]);
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function submit_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function form_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ ref });
  $$self.$inject_state = ($$new_props) => {
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    submit_handler,
    form_binding
  ];
}
var Form = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance86, create_fragment86, safe_not_equal, { ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Form",
      options,
      id: create_fragment86.name
    });
  }
  get ref() {
    throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Form_default = Form;

// node_modules/carbon-components-svelte/src/FluidForm/FluidForm.svelte
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: '(12:0) <Form   {...$$restProps}   class=\\"bx--form--fluid {$$restProps.class}\\"   on:click   on:keydown   on:mouseover   on:mouseenter   on:mouseleave   on:submit >',
    ctx
  });
  return block;
}
function create_fragment87(ctx) {
  let form;
  let current;
  const form_spread_levels = [
    /*$$restProps*/
    ctx[0],
    {
      class: "bx--form--fluid " + /*$$restProps*/
      ctx[0].class
    }
  ];
  let form_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  for (let i = 0; i < form_spread_levels.length; i += 1) {
    form_props = assign(form_props, form_spread_levels[i]);
  }
  form = new Form_default({ props: form_props, $$inline: true });
  form.$on(
    "click",
    /*click_handler*/
    ctx[2]
  );
  form.$on(
    "keydown",
    /*keydown_handler*/
    ctx[3]
  );
  form.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[4]
  );
  form.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx[5]
  );
  form.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx[6]
  );
  form.$on(
    "submit",
    /*submit_handler*/
    ctx[7]
  );
  const block = {
    c: function create() {
      create_component(form.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(form.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(form, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const form_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(form_spread_levels, [
        get_spread_object(
          /*$$restProps*/
          ctx2[0]
        ),
        {
          class: "bx--form--fluid " + /*$$restProps*/
          ctx2[0].class
        }
      ]) : {};
      if (dirty & /*$$scope*/
      256) {
        form_changes.$$scope = { dirty, ctx: ctx2 };
      }
      form.$set(form_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(form.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(form.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(form, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment87.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance87($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FluidForm", slots, ["default"]);
  setContext("Form", { isFluid: true });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function submit_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ setContext, Form: Form_default });
  return [
    $$restProps,
    slots,
    click_handler,
    keydown_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    submit_handler,
    $$scope
  ];
}
var FluidForm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance87, create_fragment87, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FluidForm",
      options,
      id: create_fragment87.name
    });
  }
};
var FluidForm_default = FluidForm;

// node_modules/carbon-components-svelte/src/FormGroup/FormGroup.svelte
var file83 = "node_modules/carbon-components-svelte/src/FormGroup/FormGroup.svelte";
function create_if_block_119(ctx) {
  let legend;
  let t;
  let legend_id_value;
  const block = {
    c: function create() {
      legend = element("legend");
      t = text(
        /*legendText*/
        ctx[4]
      );
      this.h();
    },
    l: function claim(nodes) {
      legend = claim_element(nodes, "LEGEND", { id: true });
      var legend_nodes = children(legend);
      t = claim_text(
        legend_nodes,
        /*legendText*/
        ctx[4]
      );
      legend_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(legend, "id", legend_id_value = /*legendId*/
      ctx[5] || /*$$restProps*/
      ctx[6]["aria-labelledby"]);
      toggle_class(legend, "bx--label", true);
      add_location(legend, file83, 34, 4, 893);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, legend, anchor);
      append_hydration_dev(legend, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*legendText*/
      16) set_data_dev(
        t,
        /*legendText*/
        ctx2[4]
      );
      if (dirty & /*legendId, $$restProps*/
      96 && legend_id_value !== (legend_id_value = /*legendId*/
      ctx2[5] || /*$$restProps*/
      ctx2[6]["aria-labelledby"])) {
        attr_dev(legend, "id", legend_id_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(legend);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_119.name,
    type: "if",
    source: "(34:2) {#if legendText}",
    ctx
  });
  return block;
}
function create_if_block51(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*messageText*/
        ctx[3]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*messageText*/
        ctx[3]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form__requirement", true);
      add_location(div, file83, 41, 4, 1054);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*messageText*/
      8) set_data_dev(
        t,
        /*messageText*/
        ctx2[3]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block51.name,
    type: "if",
    source: "(41:2) {#if message}",
    ctx
  });
  return block;
}
function create_fragment88(ctx) {
  let fieldset;
  let t0;
  let t1;
  let fieldset_data_invalid_value;
  let fieldset_aria_labelledby_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*legendText*/
    ctx[4] && create_if_block_119(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let if_block1 = (
    /*message*/
    ctx[2] && create_if_block51(ctx)
  );
  let fieldset_levels = [
    {
      "data-invalid": fieldset_data_invalid_value = /*invalid*/
      ctx[1] || void 0
    },
    {
      "aria-labelledby": fieldset_aria_labelledby_value = /*$$restProps*/
      ctx[6]["aria-labelledby"] || /*legendId*/
      ctx[5]
    },
    /*$$restProps*/
    ctx[6]
  ];
  let fieldset_data = {};
  for (let i = 0; i < fieldset_levels.length; i += 1) {
    fieldset_data = assign(fieldset_data, fieldset_levels[i]);
  }
  const block = {
    c: function create() {
      fieldset = element("fieldset");
      if (if_block0) if_block0.c();
      t0 = space();
      if (default_slot) default_slot.c();
      t1 = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      fieldset = claim_element(nodes, "FIELDSET", {
        "data-invalid": true,
        "aria-labelledby": true
      });
      var fieldset_nodes = children(fieldset);
      if (if_block0) if_block0.l(fieldset_nodes);
      t0 = claim_space(fieldset_nodes);
      if (default_slot) default_slot.l(fieldset_nodes);
      t1 = claim_space(fieldset_nodes);
      if (if_block1) if_block1.l(fieldset_nodes);
      fieldset_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(fieldset, fieldset_data);
      toggle_class(fieldset, "bx--fieldset", true);
      toggle_class(
        fieldset,
        "bx--fieldset--no-margin",
        /*noMargin*/
        ctx[0]
      );
      add_location(fieldset, file83, 22, 0, 601);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, fieldset, anchor);
      if (if_block0) if_block0.m(fieldset, null);
      append_hydration_dev(fieldset, t0);
      if (default_slot) {
        default_slot.m(fieldset, null);
      }
      append_hydration_dev(fieldset, t1);
      if (if_block1) if_block1.m(fieldset, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            fieldset,
            "click",
            /*click_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            fieldset,
            "mouseover",
            /*mouseover_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            fieldset,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            fieldset,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*legendText*/
        ctx2[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_119(ctx2);
          if_block0.c();
          if_block0.m(fieldset, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*message*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block51(ctx2);
          if_block1.c();
          if_block1.m(fieldset, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      set_attributes(fieldset, fieldset_data = get_spread_update(fieldset_levels, [
        (!current || dirty & /*invalid*/
        2 && fieldset_data_invalid_value !== (fieldset_data_invalid_value = /*invalid*/
        ctx2[1] || void 0)) && {
          "data-invalid": fieldset_data_invalid_value
        },
        (!current || dirty & /*$$restProps, legendId*/
        96 && fieldset_aria_labelledby_value !== (fieldset_aria_labelledby_value = /*$$restProps*/
        ctx2[6]["aria-labelledby"] || /*legendId*/
        ctx2[5])) && {
          "aria-labelledby": fieldset_aria_labelledby_value
        },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
      toggle_class(fieldset, "bx--fieldset", true);
      toggle_class(
        fieldset,
        "bx--fieldset--no-margin",
        /*noMargin*/
        ctx2[0]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(fieldset);
      }
      if (if_block0) if_block0.d();
      if (default_slot) default_slot.d(detaching);
      if (if_block1) if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment88.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance88($$self, $$props, $$invalidate) {
  const omit_props_names = ["noMargin", "invalid", "message", "messageText", "legendText", "legendId"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormGroup", slots, ["default"]);
  let { noMargin = false } = $$props;
  let { invalid = false } = $$props;
  let { message = false } = $$props;
  let { messageText = "" } = $$props;
  let { legendText = "" } = $$props;
  let { legendId = "" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("noMargin" in $$new_props) $$invalidate(0, noMargin = $$new_props.noMargin);
    if ("invalid" in $$new_props) $$invalidate(1, invalid = $$new_props.invalid);
    if ("message" in $$new_props) $$invalidate(2, message = $$new_props.message);
    if ("messageText" in $$new_props) $$invalidate(3, messageText = $$new_props.messageText);
    if ("legendText" in $$new_props) $$invalidate(4, legendText = $$new_props.legendText);
    if ("legendId" in $$new_props) $$invalidate(5, legendId = $$new_props.legendId);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    noMargin,
    invalid,
    message,
    messageText,
    legendText,
    legendId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("noMargin" in $$props) $$invalidate(0, noMargin = $$new_props.noMargin);
    if ("invalid" in $$props) $$invalidate(1, invalid = $$new_props.invalid);
    if ("message" in $$props) $$invalidate(2, message = $$new_props.message);
    if ("messageText" in $$props) $$invalidate(3, messageText = $$new_props.messageText);
    if ("legendText" in $$props) $$invalidate(4, legendText = $$new_props.legendText);
    if ("legendId" in $$props) $$invalidate(5, legendId = $$new_props.legendId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    noMargin,
    invalid,
    message,
    messageText,
    legendText,
    legendId,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var FormGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance88, create_fragment88, safe_not_equal, {
      noMargin: 0,
      invalid: 1,
      message: 2,
      messageText: 3,
      legendText: 4,
      legendId: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormGroup",
      options,
      id: create_fragment88.name
    });
  }
  get noMargin() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noMargin(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get message() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set message(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get messageText() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set messageText(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legendText() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legendText(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legendId() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legendId(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormGroup_default = FormGroup;

// node_modules/carbon-components-svelte/src/FormItem/FormItem.svelte
var file84 = "node_modules/carbon-components-svelte/src/FormItem/FormItem.svelte";
function create_fragment89(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      add_location(div, file84, 2, 0, 116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
      toggle_class(div, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment89.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance89($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormItem", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var FormItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance89, create_fragment89, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormItem",
      options,
      id: create_fragment89.name
    });
  }
};
var FormItem_default = FormItem;

// node_modules/carbon-components-svelte/src/FormLabel/FormLabel.svelte
var file85 = "node_modules/carbon-components-svelte/src/FormLabel/FormLabel.svelte";
function create_fragment90(ctx) {
  let label;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let label_levels = [
    { for: (
      /*id*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[1]
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      if (default_slot) default_slot.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(label, label_data);
      toggle_class(label, "bx--label", true);
      add_location(label, file85, 7, 0, 250);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            label,
            "click",
            /*click_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "mouseover",
            /*mouseover_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & /*id*/
        1) && { for: (
          /*id*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
      toggle_class(label, "bx--label", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment90.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance90($$self, $$props, $$invalidate) {
  const omit_props_names = ["id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormLabel", slots, ["default"]);
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ id });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    id,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var FormLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance90, create_fragment90, safe_not_equal, { id: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormLabel",
      options,
      id: create_fragment90.name
    });
  }
  get id() {
    throw new Error("<FormLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<FormLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormLabel_default = FormLabel;

// node_modules/carbon-components-svelte/src/Grid/Grid.svelte
var file86 = "node_modules/carbon-components-svelte/src/Grid/Grid.svelte";
var get_default_slot_changes6 = (dirty) => ({ props: dirty & /*props*/
2 });
var get_default_slot_context6 = (ctx) => ({ props: (
  /*props*/
  ctx[1]
) });
function create_else_block20(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let div_levels = [
    /*props*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file86, 54, 2, 1398);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*props*/
      2 && /*props*/
      ctx2[1]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block20.name,
    type: "else",
    source: "(54:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block52(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context6
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, props*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes6
            ),
            get_default_slot_context6
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block52.name,
    type: "if",
    source: "(52:0) {#if as}",
    ctx
  });
  return block;
}
function create_fragment91(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block52, create_else_block20];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*as*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment91.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance91($$self, $$props, $$invalidate) {
  let props;
  const omit_props_names = [
    "as",
    "condensed",
    "narrow",
    "fullWidth",
    "noGutter",
    "noGutterLeft",
    "noGutterRight",
    "padding"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Grid", slots, ["default"]);
  let { as = false } = $$props;
  let { condensed = false } = $$props;
  let { narrow = false } = $$props;
  let { fullWidth = false } = $$props;
  let { noGutter = false } = $$props;
  let { noGutterLeft = false } = $$props;
  let { noGutterRight = false } = $$props;
  let { padding = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props) $$invalidate(0, as = $$new_props.as);
    if ("condensed" in $$new_props) $$invalidate(2, condensed = $$new_props.condensed);
    if ("narrow" in $$new_props) $$invalidate(3, narrow = $$new_props.narrow);
    if ("fullWidth" in $$new_props) $$invalidate(4, fullWidth = $$new_props.fullWidth);
    if ("noGutter" in $$new_props) $$invalidate(5, noGutter = $$new_props.noGutter);
    if ("noGutterLeft" in $$new_props) $$invalidate(6, noGutterLeft = $$new_props.noGutterLeft);
    if ("noGutterRight" in $$new_props) $$invalidate(7, noGutterRight = $$new_props.noGutterRight);
    if ("padding" in $$new_props) $$invalidate(8, padding = $$new_props.padding);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    as,
    condensed,
    narrow,
    fullWidth,
    noGutter,
    noGutterLeft,
    noGutterRight,
    padding,
    props
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props) $$invalidate(0, as = $$new_props.as);
    if ("condensed" in $$props) $$invalidate(2, condensed = $$new_props.condensed);
    if ("narrow" in $$props) $$invalidate(3, narrow = $$new_props.narrow);
    if ("fullWidth" in $$props) $$invalidate(4, fullWidth = $$new_props.fullWidth);
    if ("noGutter" in $$props) $$invalidate(5, noGutter = $$new_props.noGutter);
    if ("noGutterLeft" in $$props) $$invalidate(6, noGutterLeft = $$new_props.noGutterLeft);
    if ("noGutterRight" in $$props) $$invalidate(7, noGutterRight = $$new_props.noGutterRight);
    if ("padding" in $$props) $$invalidate(8, padding = $$new_props.padding);
    if ("props" in $$props) $$invalidate(1, props = $$new_props.props);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(1, props = {
      ...$$restProps,
      class: [
        $$restProps.class,
        "bx--grid",
        condensed && "bx--grid--condensed",
        narrow && "bx--grid--narrow",
        fullWidth && "bx--grid--full-width",
        noGutter && "bx--no-gutter",
        noGutterLeft && "bx--no-gutter--left",
        noGutterRight && "bx--no-gutter--right",
        padding && "bx--row-padding"
      ].filter(Boolean).join(" ")
    });
  };
  return [
    as,
    props,
    condensed,
    narrow,
    fullWidth,
    noGutter,
    noGutterLeft,
    noGutterRight,
    padding,
    $$scope,
    slots
  ];
}
var Grid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance91, create_fragment91, safe_not_equal, {
      as: 0,
      condensed: 2,
      narrow: 3,
      fullWidth: 4,
      noGutter: 5,
      noGutterLeft: 6,
      noGutterRight: 7,
      padding: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Grid",
      options,
      id: create_fragment91.name
    });
  }
  get as() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get condensed() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set condensed(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get narrow() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set narrow(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullWidth() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullWidth(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutter() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutter(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutterLeft() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutterLeft(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutterRight() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutterRight(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Grid_default = Grid;

// node_modules/carbon-components-svelte/src/Grid/Row.svelte
var file87 = "node_modules/carbon-components-svelte/src/Grid/Row.svelte";
var get_default_slot_changes7 = (dirty) => ({ props: dirty & /*props*/
2 });
var get_default_slot_context7 = (ctx) => ({ props: (
  /*props*/
  ctx[1]
) });
function create_else_block21(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let div_levels = [
    /*props*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file87, 50, 2, 1267);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*props*/
      2 && /*props*/
      ctx2[1]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block21.name,
    type: "else",
    source: "(50:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block53(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context7
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, props*/
        258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes7
            ),
            get_default_slot_context7
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block53.name,
    type: "if",
    source: "(48:0) {#if as}",
    ctx
  });
  return block;
}
function create_fragment92(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block53, create_else_block21];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*as*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment92.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance92($$self, $$props, $$invalidate) {
  let props;
  const omit_props_names = ["as", "condensed", "narrow", "noGutter", "noGutterLeft", "noGutterRight", "padding"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Row", slots, ["default"]);
  let { as = false } = $$props;
  let { condensed = false } = $$props;
  let { narrow = false } = $$props;
  let { noGutter = false } = $$props;
  let { noGutterLeft = false } = $$props;
  let { noGutterRight = false } = $$props;
  let { padding = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props) $$invalidate(0, as = $$new_props.as);
    if ("condensed" in $$new_props) $$invalidate(2, condensed = $$new_props.condensed);
    if ("narrow" in $$new_props) $$invalidate(3, narrow = $$new_props.narrow);
    if ("noGutter" in $$new_props) $$invalidate(4, noGutter = $$new_props.noGutter);
    if ("noGutterLeft" in $$new_props) $$invalidate(5, noGutterLeft = $$new_props.noGutterLeft);
    if ("noGutterRight" in $$new_props) $$invalidate(6, noGutterRight = $$new_props.noGutterRight);
    if ("padding" in $$new_props) $$invalidate(7, padding = $$new_props.padding);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    as,
    condensed,
    narrow,
    noGutter,
    noGutterLeft,
    noGutterRight,
    padding,
    props
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props) $$invalidate(0, as = $$new_props.as);
    if ("condensed" in $$props) $$invalidate(2, condensed = $$new_props.condensed);
    if ("narrow" in $$props) $$invalidate(3, narrow = $$new_props.narrow);
    if ("noGutter" in $$props) $$invalidate(4, noGutter = $$new_props.noGutter);
    if ("noGutterLeft" in $$props) $$invalidate(5, noGutterLeft = $$new_props.noGutterLeft);
    if ("noGutterRight" in $$props) $$invalidate(6, noGutterRight = $$new_props.noGutterRight);
    if ("padding" in $$props) $$invalidate(7, padding = $$new_props.padding);
    if ("props" in $$props) $$invalidate(1, props = $$new_props.props);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(1, props = {
      ...$$restProps,
      class: [
        $$restProps.class,
        "bx--row",
        condensed && "bx--row--condensed",
        narrow && "bx--row--narrow",
        noGutter && "bx--no-gutter",
        noGutterLeft && "bx--no-gutter--left",
        noGutterRight && "bx--no-gutter--right",
        padding && "bx--row-padding"
      ].filter(Boolean).join(" ")
    });
  };
  return [
    as,
    props,
    condensed,
    narrow,
    noGutter,
    noGutterLeft,
    noGutterRight,
    padding,
    $$scope,
    slots
  ];
}
var Row = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance92, create_fragment92, safe_not_equal, {
      as: 0,
      condensed: 2,
      narrow: 3,
      noGutter: 4,
      noGutterLeft: 5,
      noGutterRight: 6,
      padding: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Row",
      options,
      id: create_fragment92.name
    });
  }
  get as() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get condensed() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set condensed(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get narrow() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set narrow(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutter() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutter(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutterLeft() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutterLeft(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutterRight() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutterRight(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Row_default = Row;

// node_modules/carbon-components-svelte/src/Grid/Column.svelte
var file88 = "node_modules/carbon-components-svelte/src/Grid/Column.svelte";
var get_default_slot_changes8 = (dirty) => ({ props: dirty & /*props*/
2 });
var get_default_slot_context8 = (ctx) => ({ props: (
  /*props*/
  ctx[1]
) });
function create_else_block22(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  let div_levels = [
    /*props*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file88, 115, 2, 2896);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*props*/
      2 && /*props*/
      ctx2[1]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block22.name,
    type: "else",
    source: "(115:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block54(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context8
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, props*/
        8194)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes8
            ),
            get_default_slot_context8
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block54.name,
    type: "if",
    source: "(113:0) {#if as}",
    ctx
  });
  return block;
}
function create_fragment93(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block54, create_else_block22];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*as*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment93.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance93($$self, $$props, $$invalidate) {
  let columnClass;
  let props;
  const omit_props_names = [
    "as",
    "noGutter",
    "noGutterLeft",
    "noGutterRight",
    "padding",
    "aspectRatio",
    "sm",
    "md",
    "lg",
    "xlg",
    "max"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Column", slots, ["default"]);
  let { as = false } = $$props;
  let { noGutter = false } = $$props;
  let { noGutterLeft = false } = $$props;
  let { noGutterRight = false } = $$props;
  let { padding = false } = $$props;
  let { aspectRatio = void 0 } = $$props;
  let { sm = void 0 } = $$props;
  let { md = void 0 } = $$props;
  let { lg = void 0 } = $$props;
  let { xlg = void 0 } = $$props;
  let { max = void 0 } = $$props;
  const breakpoints2 = ["sm", "md", "lg", "xlg", "max"];
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props) $$invalidate(0, as = $$new_props.as);
    if ("noGutter" in $$new_props) $$invalidate(2, noGutter = $$new_props.noGutter);
    if ("noGutterLeft" in $$new_props) $$invalidate(3, noGutterLeft = $$new_props.noGutterLeft);
    if ("noGutterRight" in $$new_props) $$invalidate(4, noGutterRight = $$new_props.noGutterRight);
    if ("padding" in $$new_props) $$invalidate(5, padding = $$new_props.padding);
    if ("aspectRatio" in $$new_props) $$invalidate(6, aspectRatio = $$new_props.aspectRatio);
    if ("sm" in $$new_props) $$invalidate(7, sm = $$new_props.sm);
    if ("md" in $$new_props) $$invalidate(8, md = $$new_props.md);
    if ("lg" in $$new_props) $$invalidate(9, lg = $$new_props.lg);
    if ("xlg" in $$new_props) $$invalidate(10, xlg = $$new_props.xlg);
    if ("max" in $$new_props) $$invalidate(11, max = $$new_props.max);
    if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    as,
    noGutter,
    noGutterLeft,
    noGutterRight,
    padding,
    aspectRatio,
    sm,
    md,
    lg,
    xlg,
    max,
    breakpoints: breakpoints2,
    columnClass,
    props
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props) $$invalidate(0, as = $$new_props.as);
    if ("noGutter" in $$props) $$invalidate(2, noGutter = $$new_props.noGutter);
    if ("noGutterLeft" in $$props) $$invalidate(3, noGutterLeft = $$new_props.noGutterLeft);
    if ("noGutterRight" in $$props) $$invalidate(4, noGutterRight = $$new_props.noGutterRight);
    if ("padding" in $$props) $$invalidate(5, padding = $$new_props.padding);
    if ("aspectRatio" in $$props) $$invalidate(6, aspectRatio = $$new_props.aspectRatio);
    if ("sm" in $$props) $$invalidate(7, sm = $$new_props.sm);
    if ("md" in $$props) $$invalidate(8, md = $$new_props.md);
    if ("lg" in $$props) $$invalidate(9, lg = $$new_props.lg);
    if ("xlg" in $$props) $$invalidate(10, xlg = $$new_props.xlg);
    if ("max" in $$props) $$invalidate(11, max = $$new_props.max);
    if ("columnClass" in $$props) $$invalidate(12, columnClass = $$new_props.columnClass);
    if ("props" in $$props) $$invalidate(1, props = $$new_props.props);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sm, md, lg, xlg, max*/
    3968) {
      $: $$invalidate(12, columnClass = [sm, md, lg, xlg, max].map((breakpoint, i) => {
        const name = breakpoints2[i];
        if (breakpoint === true) {
          return `bx--col-${name}`;
        } else if (typeof breakpoint === "number") {
          return `bx--col-${name}-${breakpoint}`;
        } else if (typeof breakpoint === "object") {
          let bp = [];
          if (typeof breakpoint.span === "number") {
            bp = [...bp, `bx--col-${name}-${breakpoint.span}`];
          } else if (breakpoint.span === true) {
            bp = [...bp, `bx--col-${name}`];
          }
          if (typeof breakpoint.offset === "number") {
            bp = [...bp, `bx--offset-${name}-${breakpoint.offset}`];
          }
          return bp.join(" ");
        }
      }).filter(Boolean).join(" "));
    }
    $: $$invalidate(1, props = {
      ...$$restProps,
      class: [
        $$restProps.class,
        columnClass,
        !columnClass && "bx--col",
        noGutter && "bx--no-gutter",
        noGutterLeft && "bx--no-gutter--left",
        noGutterRight && "bx--no-gutter--right",
        aspectRatio && `bx--aspect-ratio bx--aspect-ratio--${aspectRatio}`,
        padding && "bx--col-padding"
      ].filter(Boolean).join(" ")
    });
  };
  return [
    as,
    props,
    noGutter,
    noGutterLeft,
    noGutterRight,
    padding,
    aspectRatio,
    sm,
    md,
    lg,
    xlg,
    max,
    columnClass,
    $$scope,
    slots
  ];
}
var Column = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance93, create_fragment93, safe_not_equal, {
      as: 0,
      noGutter: 2,
      noGutterLeft: 3,
      noGutterRight: 4,
      padding: 5,
      aspectRatio: 6,
      sm: 7,
      md: 8,
      lg: 9,
      xlg: 10,
      max: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Column",
      options,
      id: create_fragment93.name
    });
  }
  get as() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutter() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutter(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutterLeft() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutterLeft(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutterRight() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutterRight(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aspectRatio() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aspectRatio(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xlg() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xlg(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Column_default = Column;

// node_modules/carbon-components-svelte/src/ImageLoader/ImageLoader.svelte
var file89 = "node_modules/carbon-components-svelte/src/ImageLoader/ImageLoader.svelte";
var get_error_slot_changes_1 = (dirty) => ({});
var get_error_slot_context_1 = (ctx) => ({});
var get_loading_slot_changes_1 = (dirty) => ({});
var get_loading_slot_context_1 = (ctx) => ({});
var get_error_slot_changes = (dirty) => ({});
var get_error_slot_context = (ctx) => ({});
var get_loading_slot_changes = (dirty) => ({});
var get_loading_slot_context = (ctx) => ({});
function create_else_block23(ctx) {
  let aspectratio;
  let current;
  aspectratio = new AspectRatio_default({
    props: {
      ratio: (
        /*ratio*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(aspectratio.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(aspectratio.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(aspectratio, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const aspectratio_changes = {};
      if (dirty & /*ratio*/
      32) aspectratio_changes.ratio = /*ratio*/
      ctx2[5];
      if (dirty & /*$$scope, error, src, $$restProps, alt, fadeIn, loaded, loading*/
      1247) {
        aspectratio_changes.$$scope = { dirty, ctx: ctx2 };
      }
      aspectratio.$set(aspectratio_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(aspectratio.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(aspectratio.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(aspectratio, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block23.name,
    type: "else",
    source: "(97:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block55(ctx) {
  let t0;
  let previous_key = (
    /*src*/
    ctx[3]
  );
  let t1;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*loading*/
    ctx[2] && create_if_block_38(ctx)
  );
  let key_block = create_key_block(ctx);
  let if_block1 = (
    /*error*/
    ctx[1] && create_if_block_120(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t0 = space();
      key_block.c();
      t1 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t0 = claim_space(nodes);
      key_block.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      key_block.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*loading*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*loading*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_38(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty & /*src*/
      8 && safe_not_equal(previous_key, previous_key = /*src*/
      ctx2[3])) {
        key_block.d(1);
        key_block = create_key_block(ctx2);
        key_block.c();
        key_block.m(t1.parentNode, t1);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (
        /*error*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*error*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_120(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(if_block1_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      key_block.d(detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block55.name,
    type: "if",
    source: "(79:0) {#if ratio === undefined}",
    ctx
  });
  return block;
}
function create_if_block_65(ctx) {
  let current;
  const loading_slot_template = (
    /*#slots*/
    ctx[9].loading
  );
  const loading_slot = create_slot(
    loading_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_loading_slot_context_1
  );
  const block = {
    c: function create() {
      if (loading_slot) loading_slot.c();
    },
    l: function claim(nodes) {
      if (loading_slot) loading_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (loading_slot) {
        loading_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (loading_slot) {
        if (loading_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            loading_slot,
            loading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              loading_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_loading_slot_changes_1
            ),
            get_loading_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(loading_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loading_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (loading_slot) loading_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_65.name,
    type: "if",
    source: "(99:4) {#if loading}",
    ctx
  });
  return block;
}
function create_if_block_56(ctx) {
  let img;
  let img_src_value;
  let img_transition;
  let current;
  let img_levels = [
    /*$$restProps*/
    ctx[7],
    { src: img_src_value = /*src*/
    ctx[3] },
    { alt: (
      /*alt*/
      ctx[4]
    ) }
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { src: true, alt: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      set_style(img, "width", `100%`);
      add_location(img, file89, 103, 8, 2285);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx[7],
        (!current || dirty & /*src*/
        8 && !src_url_equal(img.src, img_src_value = /*src*/
        ctx[3])) && { src: img_src_value },
        (!current || dirty & /*alt*/
        16) && { alt: (
          /*alt*/
          ctx[4]
        ) }
      ]));
      set_style(img, "width", `100%`);
    },
    i: function intro(local) {
      if (current) return;
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!img_transition) img_transition = create_bidirectional_transition(img, fade, { duration: (
            /*fadeIn*/
            ctx[6] ? fast02 : 0
          ) }, true);
          img_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (local) {
        if (!img_transition) img_transition = create_bidirectional_transition(img, fade, { duration: (
          /*fadeIn*/
          ctx[6] ? fast02 : 0
        ) }, false);
        img_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
      if (detaching && img_transition) img_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_56.name,
    type: "if",
    source: "(103:6) {#if loaded}",
    ctx
  });
  return block;
}
function create_key_block_1(ctx) {
  let if_block_anchor;
  let if_block = (
    /*loaded*/
    ctx[0] && create_if_block_56(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*loaded*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*loaded*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_56(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block_1.name,
    type: "key",
    source: "(102:4) {#key src}",
    ctx
  });
  return block;
}
function create_if_block_47(ctx) {
  let current;
  const error_slot_template = (
    /*#slots*/
    ctx[9].error
  );
  const error_slot = create_slot(
    error_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_error_slot_context_1
  );
  const block = {
    c: function create() {
      if (error_slot) error_slot.c();
    },
    l: function claim(nodes) {
      if (error_slot) error_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (error_slot) {
        error_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (error_slot) {
        if (error_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            error_slot,
            error_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              error_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_error_slot_changes_1
            ),
            get_error_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(error_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (error_slot) error_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_47.name,
    type: "if",
    source: "(113:4) {#if error}",
    ctx
  });
  return block;
}
function create_default_slot12(ctx) {
  let t0;
  let previous_key = (
    /*src*/
    ctx[3]
  );
  let t1;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*loading*/
    ctx[2] && create_if_block_65(ctx)
  );
  let key_block = create_key_block_1(ctx);
  let if_block1 = (
    /*error*/
    ctx[1] && create_if_block_47(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t0 = space();
      key_block.c();
      t1 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t0 = claim_space(nodes);
      key_block.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      key_block.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*loading*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*loading*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_65(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty & /*src*/
      8 && safe_not_equal(previous_key, previous_key = /*src*/
      ctx2[3])) {
        key_block.d(1);
        key_block = create_key_block_1(ctx2);
        key_block.c();
        key_block.m(t1.parentNode, t1);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (
        /*error*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*error*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_47(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(if_block1_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      key_block.d(detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: '(98:2) <AspectRatio ratio=\\"{ratio}\\">',
    ctx
  });
  return block;
}
function create_if_block_38(ctx) {
  let current;
  const loading_slot_template = (
    /*#slots*/
    ctx[9].loading
  );
  const loading_slot = create_slot(
    loading_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_loading_slot_context
  );
  const block = {
    c: function create() {
      if (loading_slot) loading_slot.c();
    },
    l: function claim(nodes) {
      if (loading_slot) loading_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (loading_slot) {
        loading_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (loading_slot) {
        if (loading_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            loading_slot,
            loading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              loading_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_loading_slot_changes
            ),
            get_loading_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(loading_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loading_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (loading_slot) loading_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_38.name,
    type: "if",
    source: "(80:2) {#if loading}",
    ctx
  });
  return block;
}
function create_if_block_213(ctx) {
  let img;
  let img_src_value;
  let img_transition;
  let current;
  let img_levels = [
    /*$$restProps*/
    ctx[7],
    { src: img_src_value = /*src*/
    ctx[3] },
    { alt: (
      /*alt*/
      ctx[4]
    ) }
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { src: true, alt: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      set_style(img, "width", `100%`);
      add_location(img, file89, 84, 6, 1904);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx[7],
        (!current || dirty & /*src*/
        8 && !src_url_equal(img.src, img_src_value = /*src*/
        ctx[3])) && { src: img_src_value },
        (!current || dirty & /*alt*/
        16) && { alt: (
          /*alt*/
          ctx[4]
        ) }
      ]));
      set_style(img, "width", `100%`);
    },
    i: function intro(local) {
      if (current) return;
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!img_transition) img_transition = create_bidirectional_transition(img, fade, { duration: (
            /*fadeIn*/
            ctx[6] ? fast02 : 0
          ) }, true);
          img_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (local) {
        if (!img_transition) img_transition = create_bidirectional_transition(img, fade, { duration: (
          /*fadeIn*/
          ctx[6] ? fast02 : 0
        ) }, false);
        img_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
      if (detaching && img_transition) img_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_213.name,
    type: "if",
    source: "(84:4) {#if loaded}",
    ctx
  });
  return block;
}
function create_key_block(ctx) {
  let if_block_anchor;
  let if_block = (
    /*loaded*/
    ctx[0] && create_if_block_213(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*loaded*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*loaded*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_213(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block.name,
    type: "key",
    source: "(83:2) {#key src}",
    ctx
  });
  return block;
}
function create_if_block_120(ctx) {
  let current;
  const error_slot_template = (
    /*#slots*/
    ctx[9].error
  );
  const error_slot = create_slot(
    error_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_error_slot_context
  );
  const block = {
    c: function create() {
      if (error_slot) error_slot.c();
    },
    l: function claim(nodes) {
      if (error_slot) error_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (error_slot) {
        error_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (error_slot) {
        if (error_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            error_slot,
            error_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              error_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_error_slot_changes
            ),
            get_error_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(error_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (error_slot) error_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_120.name,
    type: "if",
    source: "(94:2) {#if error}",
    ctx
  });
  return block;
}
function create_fragment94(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block55, create_else_block23];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*ratio*/
      ctx2[5] === void 0
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment94.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var fast02 = 110;
function instance94($$self, $$props, $$invalidate) {
  const omit_props_names = ["src", "alt", "ratio", "loading", "loaded", "error", "fadeIn", "loadImage"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImageLoader", slots, ["loading", "error"]);
  let { src = "" } = $$props;
  let { alt = "" } = $$props;
  let { ratio = void 0 } = $$props;
  let { loading = false } = $$props;
  let { loaded = false } = $$props;
  let { error = false } = $$props;
  let { fadeIn = false } = $$props;
  const loadImage = (url) => {
    if (image != null) image = null;
    $$invalidate(0, loaded = false);
    $$invalidate(1, error = false);
    image = new Image();
    image.src = url || src;
    image.onload = () => $$invalidate(0, loaded = true);
    image.onerror = () => $$invalidate(1, error = true);
  };
  const dispatch = createEventDispatcher();
  let image = null;
  onMount(() => {
    return () => image = null;
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("src" in $$new_props) $$invalidate(3, src = $$new_props.src);
    if ("alt" in $$new_props) $$invalidate(4, alt = $$new_props.alt);
    if ("ratio" in $$new_props) $$invalidate(5, ratio = $$new_props.ratio);
    if ("loading" in $$new_props) $$invalidate(2, loading = $$new_props.loading);
    if ("loaded" in $$new_props) $$invalidate(0, loaded = $$new_props.loaded);
    if ("error" in $$new_props) $$invalidate(1, error = $$new_props.error);
    if ("fadeIn" in $$new_props) $$invalidate(6, fadeIn = $$new_props.fadeIn);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    src,
    alt,
    ratio,
    loading,
    loaded,
    error,
    fadeIn,
    loadImage,
    onMount,
    createEventDispatcher,
    fade,
    AspectRatio: AspectRatio_default,
    dispatch,
    fast02,
    image
  });
  $$self.$inject_state = ($$new_props) => {
    if ("src" in $$props) $$invalidate(3, src = $$new_props.src);
    if ("alt" in $$props) $$invalidate(4, alt = $$new_props.alt);
    if ("ratio" in $$props) $$invalidate(5, ratio = $$new_props.ratio);
    if ("loading" in $$props) $$invalidate(2, loading = $$new_props.loading);
    if ("loaded" in $$props) $$invalidate(0, loaded = $$new_props.loaded);
    if ("error" in $$props) $$invalidate(1, error = $$new_props.error);
    if ("fadeIn" in $$props) $$invalidate(6, fadeIn = $$new_props.fadeIn);
    if ("image" in $$props) image = $$new_props.image;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*loaded, error*/
    3) {
      $: $$invalidate(2, loading = !loaded && !error);
    }
    if ($$self.$$.dirty & /*src*/
    8) {
      $: if (src && typeof window !== "undefined") loadImage();
    }
    if ($$self.$$.dirty & /*loaded*/
    1) {
      $: if (loaded) dispatch("load");
    }
    if ($$self.$$.dirty & /*error*/
    2) {
      $: if (error) dispatch("error");
    }
  };
  return [
    loaded,
    error,
    loading,
    src,
    alt,
    ratio,
    fadeIn,
    $$restProps,
    loadImage,
    slots,
    $$scope
  ];
}
var ImageLoader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance94, create_fragment94, safe_not_equal, {
      src: 3,
      alt: 4,
      ratio: 5,
      loading: 2,
      loaded: 0,
      error: 1,
      fadeIn: 6,
      loadImage: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImageLoader",
      options,
      id: create_fragment94.name
    });
  }
  get src() {
    throw new Error("<ImageLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<ImageLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ratio() {
    throw new Error("<ImageLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ratio(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error("<ImageLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loaded() {
    throw new Error("<ImageLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loaded(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<ImageLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fadeIn() {
    throw new Error("<ImageLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fadeIn(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loadImage() {
    return this.$$.ctx[8];
  }
  set loadImage(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImageLoader_default = ImageLoader;

// node_modules/carbon-components-svelte/src/icons/ErrorFilled.svelte
var file90 = "node_modules/carbon-components-svelte/src/icons/ErrorFilled.svelte";
function create_if_block56(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file90, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block56.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment95(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block56(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", {
        fill: true,
        d: true,
        "data-icon-path": true,
        transform: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "fill", "none");
      attr_dev(path0, "d", "M14.9 7.2H17.1V24.799H14.9z");
      attr_dev(path0, "data-icon-path", "inner-path");
      attr_dev(path0, "transform", "rotate(-45 16 16)");
      add_location(path0, file90, 24, 2, 579);
      attr_dev(path1, "d", "M16,2A13.914,13.914,0,0,0,2,16,13.914,13.914,0,0,0,16,30,13.914,13.914,0,0,0,30,16,13.914,13.914,0,0,0,16,2Zm5.4449,21L9,10.5557,10.5557,9,23,21.4448Z");
      add_location(path1, file90, 28, 41, 710);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file90, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block56(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment95.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance95($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ErrorFilled", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var ErrorFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance95, create_fragment95, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ErrorFilled",
      options,
      id: create_fragment95.name
    });
  }
  get size() {
    throw new Error("<ErrorFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ErrorFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ErrorFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ErrorFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ErrorFilled_default = ErrorFilled;

// node_modules/carbon-components-svelte/src/InlineLoading/InlineLoading.svelte
var file91 = "node_modules/carbon-components-svelte/src/InlineLoading/InlineLoading.svelte";
function create_if_block_39(ctx) {
  let loading;
  let current;
  loading = new Loading_default({
    props: {
      small: true,
      description: (
        /*iconDescription*/
        ctx[2]
      ),
      withOverlay: false,
      active: (
        /*status*/
        ctx[0] === "active"
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(loading.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(loading.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const loading_changes = {};
      if (dirty & /*iconDescription*/
      4) loading_changes.description = /*iconDescription*/
      ctx2[2];
      if (dirty & /*status*/
      1) loading_changes.active = /*status*/
      ctx2[0] === "active";
      loading.$set(loading_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(loading, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_39.name,
    type: "if",
    source: "(70:59) ",
    ctx
  });
  return block;
}
function create_if_block_214(ctx) {
  let checkmarkfilled;
  let current;
  checkmarkfilled = new CheckmarkFilled_default({
    props: {
      class: "bx--inline-loading__checkmark-container",
      title: (
        /*iconDescription*/
        ctx[2] || /*status*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(checkmarkfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(checkmarkfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(checkmarkfilled, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkmarkfilled_changes = {};
      if (dirty & /*iconDescription, status*/
      5) checkmarkfilled_changes.title = /*iconDescription*/
      ctx2[2] || /*status*/
      ctx2[0];
      checkmarkfilled.$set(checkmarkfilled_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(checkmarkfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmarkfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkmarkfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_214.name,
    type: "if",
    source: "(65:36) ",
    ctx
  });
  return block;
}
function create_if_block_121(ctx) {
  let errorfilled;
  let current;
  errorfilled = new ErrorFilled_default({
    props: {
      class: "bx--inline-loading--error",
      title: (
        /*iconDescription*/
        ctx[2] || /*status*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(errorfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(errorfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(errorfilled, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const errorfilled_changes = {};
      if (dirty & /*iconDescription, status*/
      5) errorfilled_changes.title = /*iconDescription*/
      ctx2[2] || /*status*/
      ctx2[0];
      errorfilled.$set(errorfilled_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(errorfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(errorfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(errorfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_121.name,
    type: "if",
    source: '(60:4) {#if status === \\"error\\"}',
    ctx
  });
  return block;
}
function create_if_block57(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*description*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*description*/
        ctx[1]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--inline-loading__text", true);
      add_location(div, file91, 79, 4, 1991);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*description*/
      2) set_data_dev(
        t,
        /*description*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block57.name,
    type: "if",
    source: "(79:2) {#if description}",
    ctx
  });
  return block;
}
function create_fragment96(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block0;
  let t;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_121, create_if_block_214, create_if_block_39];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*status*/
      ctx2[0] === "error"
    ) return 0;
    if (
      /*status*/
      ctx2[0] === "finished"
    ) return 1;
    if (
      /*status*/
      ctx2[0] === "inactive" || /*status*/
      ctx2[0] === "active"
    ) return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = (
    /*description*/
    ctx[1] && create_if_block57(ctx)
  );
  let div1_levels = [
    { "aria-live": "assertive" },
    /*$$restProps*/
    ctx[3]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0) if_block0.c();
      t = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { "aria-live": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (if_block0) if_block0.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t = claim_space(div1_nodes);
      if (if_block1) if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--inline-loading__animation", true);
      add_location(div0, file91, 58, 2, 1378);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--inline-loading", true);
      add_location(div1, file91, 49, 0, 1232);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div0, null);
      }
      append_hydration_dev(div1, t);
      if (if_block1) if_block1.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseover",
            /*mouseover_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        } else {
          if_block0 = null;
        }
      }
      if (
        /*description*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block57(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        { "aria-live": "assertive" },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
      toggle_class(div1, "bx--inline-loading", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block1) if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment96.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance96($$self, $$props, $$invalidate) {
  const omit_props_names = ["status", "description", "iconDescription", "successDelay"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InlineLoading", slots, []);
  let { status = "active" } = $$props;
  let { description = void 0 } = $$props;
  let { iconDescription = void 0 } = $$props;
  let { successDelay = 1500 } = $$props;
  const dispatch = createEventDispatcher();
  let timeout = void 0;
  onMount(() => {
    return () => {
      clearTimeout(timeout);
    };
  });
  afterUpdate(() => {
    if (status === "finished") {
      timeout = setTimeout(
        () => {
          dispatch("success");
        },
        successDelay
      );
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("status" in $$new_props) $$invalidate(0, status = $$new_props.status);
    if ("description" in $$new_props) $$invalidate(1, description = $$new_props.description);
    if ("iconDescription" in $$new_props) $$invalidate(2, iconDescription = $$new_props.iconDescription);
    if ("successDelay" in $$new_props) $$invalidate(4, successDelay = $$new_props.successDelay);
  };
  $$self.$capture_state = () => ({
    status,
    description,
    iconDescription,
    successDelay,
    createEventDispatcher,
    afterUpdate,
    onMount,
    CheckmarkFilled: CheckmarkFilled_default,
    ErrorFilled: ErrorFilled_default,
    Loading: Loading_default,
    dispatch,
    timeout
  });
  $$self.$inject_state = ($$new_props) => {
    if ("status" in $$props) $$invalidate(0, status = $$new_props.status);
    if ("description" in $$props) $$invalidate(1, description = $$new_props.description);
    if ("iconDescription" in $$props) $$invalidate(2, iconDescription = $$new_props.iconDescription);
    if ("successDelay" in $$props) $$invalidate(4, successDelay = $$new_props.successDelay);
    if ("timeout" in $$props) timeout = $$new_props.timeout;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    status,
    description,
    iconDescription,
    $$restProps,
    successDelay,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var InlineLoading = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance96, create_fragment96, safe_not_equal, {
      status: 0,
      description: 1,
      iconDescription: 2,
      successDelay: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InlineLoading",
      options,
      id: create_fragment96.name
    });
  }
  get status() {
    throw new Error("<InlineLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set status(value) {
    throw new Error("<InlineLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<InlineLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<InlineLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<InlineLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<InlineLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get successDelay() {
    throw new Error("<InlineLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set successDelay(value) {
    throw new Error("<InlineLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InlineLoading_default = InlineLoading;

// node_modules/carbon-components-svelte/src/icons/Launch.svelte
var file92 = "node_modules/carbon-components-svelte/src/icons/Launch.svelte";
function create_if_block58(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file92, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block58.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment97(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block58(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M26,28H6a2.0027,2.0027,0,0,1-2-2V6A2.0027,2.0027,0,0,1,6,4H16V6H6V26H26V16h2V26A2.0027,2.0027,0,0,1,26,28Z");
      add_location(path0, file92, 24, 2, 579);
      attr_dev(path1, "d", "M20 2L20 4 26.586 4 18 12.586 19.414 14 28 5.414 28 12 30 12 30 2 20 2z");
      add_location(path1, file92, 26, 10, 710);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file92, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block58(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment97.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance97($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Launch", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Launch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance97, create_fragment97, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Launch",
      options,
      id: create_fragment97.name
    });
  }
  get size() {
    throw new Error("<Launch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Launch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Launch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Launch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Launch_default = Launch;

// node_modules/carbon-components-svelte/src/Link/OutboundLink.svelte
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: '(8:0) <Link   {...$$restProps}   on:click   on:mouseover   on:mouseenter   on:mouseleave   target=\\"_blank\\"   icon=\\"{Launch}\\" >',
    ctx
  });
  return block;
}
function create_fragment98(ctx) {
  let link;
  let current;
  const link_spread_levels = [
    /*$$restProps*/
    ctx[0],
    { target: "_blank" },
    { icon: Launch_default }
  ];
  let link_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < link_spread_levels.length; i += 1) {
    link_props = assign(link_props, link_spread_levels[i]);
  }
  link = new Link_default({ props: link_props, $$inline: true });
  link.$on(
    "click",
    /*click_handler*/
    ctx[2]
  );
  link.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[3]
  );
  link.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx[4]
  );
  link.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx[5]
  );
  const block = {
    c: function create() {
      create_component(link.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(link.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(link, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const link_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(link_spread_levels, [
        get_spread_object(
          /*$$restProps*/
          ctx2[0]
        ),
        link_spread_levels[1],
        link_spread_levels[2]
      ]) : {};
      if (dirty & /*$$scope*/
      64) {
        link_changes.$$scope = { dirty, ctx: ctx2 };
      }
      link.$set(link_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(link.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(link.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(link, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment98.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance98($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OutboundLink", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Link: Link_default, Launch: Launch_default });
  return [
    $$restProps,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    $$scope
  ];
}
var OutboundLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance98, create_fragment98, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OutboundLink",
      options,
      id: create_fragment98.name
    });
  }
};
var OutboundLink_default = OutboundLink;

// node_modules/carbon-components-svelte/src/ListItem/ListItem.svelte
var file93 = "node_modules/carbon-components-svelte/src/ListItem/ListItem.svelte";
function create_fragment99(ctx) {
  let li;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let li_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      if (default_slot) default_slot.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(li, li_data);
      toggle_class(li, "bx--list__item", true);
      add_location(li, file93, 2, 0, 124);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            li,
            "click",
            /*click_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseover",
            /*mouseover_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
      toggle_class(li, "bx--list__item", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment99.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance99($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListItem", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var ListItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance99, create_fragment99, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListItem",
      options,
      id: create_fragment99.name
    });
  }
};
var ListItem_default = ListItem;

// node_modules/carbon-components-svelte/src/LocalStorage/LocalStorage.svelte
function create_fragment100(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment100.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function clearAll() {
  localStorage.clear();
}
function instance100($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LocalStorage", slots, []);
  let { key = "local-storage-key" } = $$props;
  let { value = "" } = $$props;
  function clearItem() {
    localStorage.removeItem(key);
  }
  const dispatch = createEventDispatcher();
  let prevValue = value;
  function setItem() {
    if (typeof value === "object") {
      localStorage.setItem(key, JSON.stringify(value));
    } else {
      localStorage.setItem(key, value);
    }
  }
  onMount(() => {
    const item = localStorage.getItem(key);
    if (item != null) {
      try {
        $$invalidate(0, value = JSON.parse(item));
      } catch (e) {
        $$invalidate(0, value = item);
      }
    } else {
      setItem(value);
      dispatch("save");
    }
  });
  afterUpdate(() => {
    if (prevValue !== value) {
      setItem(value);
      dispatch("update", { prevValue, value });
    }
    prevValue = value;
  });
  const writable_props = ["key", "value"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<LocalStorage> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2) $$invalidate(1, key = $$props2.key);
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
  };
  $$self.$capture_state = () => ({
    key,
    value,
    clearItem,
    clearAll,
    onMount,
    afterUpdate,
    createEventDispatcher,
    dispatch,
    prevValue,
    setItem
  });
  $$self.$inject_state = ($$props2) => {
    if ("key" in $$props2) $$invalidate(1, key = $$props2.key);
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("prevValue" in $$props2) prevValue = $$props2.prevValue;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, key, clearItem, clearAll];
}
var LocalStorage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance100, create_fragment100, safe_not_equal, {
      key: 1,
      value: 0,
      clearItem: 2,
      clearAll: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LocalStorage",
      options,
      id: create_fragment100.name
    });
  }
  get key() {
    throw new Error("<LocalStorage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<LocalStorage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<LocalStorage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<LocalStorage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearItem() {
    return this.$$.ctx[2];
  }
  set clearItem(value) {
    throw new Error("<LocalStorage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearAll() {
    return clearAll;
  }
  set clearAll(value) {
    throw new Error("<LocalStorage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LocalStorage_default = LocalStorage;

// node_modules/carbon-components-svelte/src/MultiSelect/MultiSelect.svelte
var file94 = "node_modules/carbon-components-svelte/src/MultiSelect/MultiSelect.svelte";
function get_each_context11(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[74] = list[i];
  child_ctx[76] = i;
  return child_ctx;
}
var get_default_slot_changes9 = (dirty) => ({
  item: dirty[0] & /*filterable, sortedItems*/
  1073750016 | dirty[1] & /*filteredItems*/
  1,
  index: dirty[0] & /*filterable, sortedItems*/
  1073750016 | dirty[1] & /*filteredItems*/
  1
});
var get_default_slot_context9 = (ctx) => ({
  slot: "labelText",
  item: (
    /*item*/
    ctx[74]
  ),
  index: (
    /*i*/
    ctx[76]
  )
});
var get_titleText_slot_changes2 = (dirty) => ({});
var get_titleText_slot_context2 = (ctx) => ({});
function create_if_block_83(ctx) {
  let label_1;
  let current;
  const titleText_slot_template = (
    /*#slots*/
    ctx[46].titleText
  );
  const titleText_slot = create_slot(
    titleText_slot_template,
    ctx,
    /*$$scope*/
    ctx[68],
    get_titleText_slot_context2
  );
  const titleText_slot_or_fallback = titleText_slot || fallback_block_18(ctx);
  const block = {
    c: function create() {
      label_1 = element("label");
      if (titleText_slot_or_fallback) titleText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { for: true });
      var label_1_nodes = children(label_1);
      if (titleText_slot_or_fallback) titleText_slot_or_fallback.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label_1,
        "for",
        /*id*/
        ctx[27]
      );
      toggle_class(label_1, "bx--label", true);
      toggle_class(
        label_1,
        "bx--label--disabled",
        /*disabled*/
        ctx[12]
      );
      toggle_class(
        label_1,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[26]
      );
      add_location(label_1, file94, 296, 4, 8002);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      if (titleText_slot_or_fallback) {
        titleText_slot_or_fallback.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (titleText_slot) {
        if (titleText_slot.p && (!current || dirty[2] & /*$$scope*/
        64)) {
          update_slot_base(
            titleText_slot,
            titleText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[68],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[68]
            ) : get_slot_changes(
              titleText_slot_template,
              /*$$scope*/
              ctx2[68],
              dirty,
              get_titleText_slot_changes2
            ),
            get_titleText_slot_context2
          );
        }
      } else {
        if (titleText_slot_or_fallback && titleText_slot_or_fallback.p && (!current || dirty[0] & /*titleText*/
        262144)) {
          titleText_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      134217728) {
        attr_dev(
          label_1,
          "for",
          /*id*/
          ctx2[27]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      4096) {
        toggle_class(
          label_1,
          "bx--label--disabled",
          /*disabled*/
          ctx2[12]
        );
      }
      if (!current || dirty[0] & /*hideLabel*/
      67108864) {
        toggle_class(
          label_1,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[26]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(titleText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(titleText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label_1);
      }
      if (titleText_slot_or_fallback) titleText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_83.name,
    type: "if",
    source: "(296:2) {#if titleText || $$slots.titleText}",
    ctx
  });
  return block;
}
function fallback_block_18(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*titleText*/
        ctx[18]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*titleText*/
        ctx[18]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*titleText*/
      262144) set_data_dev(
        t,
        /*titleText*/
        ctx2[18]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_18.name,
    type: "fallback",
    source: "(303:29)          ",
    ctx
  });
  return block;
}
function create_if_block_73(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--list-box__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_73.name,
    type: "if",
    source: "(325:4) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_66(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--list-box__invalid-icon bx--list-box__invalid-icon--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningaltfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_66.name,
    type: "if",
    source: "(328:4) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_57(ctx) {
  let listboxselection;
  let current;
  listboxselection = new ListBoxSelection_default({
    props: {
      selectionCount: (
        /*checked*/
        ctx[32].length
      ),
      translateWithId: (
        /*translateWithIdSelection*/
        ctx[17]
      ),
      disabled: (
        /*disabled*/
        ctx[12]
      )
    },
    $$inline: true
  });
  listboxselection.$on(
    "clear",
    /*clear_handler*/
    ctx[53]
  );
  listboxselection.$on(
    "clear",
    /*clear_handler_1*/
    ctx[54]
  );
  const block = {
    c: function create() {
      create_component(listboxselection.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(listboxselection.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(listboxselection, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const listboxselection_changes = {};
      if (dirty[1] & /*checked*/
      2) listboxselection_changes.selectionCount = /*checked*/
      ctx2[32].length;
      if (dirty[0] & /*translateWithIdSelection*/
      131072) listboxselection_changes.translateWithId = /*translateWithIdSelection*/
      ctx2[17];
      if (dirty[0] & /*disabled*/
      4096) listboxselection_changes.disabled = /*disabled*/
      ctx2[12];
      listboxselection.$set(listboxselection_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(listboxselection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxselection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listboxselection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_57.name,
    type: "if",
    source: "(391:6) {#if checked.length > 0}",
    ctx
  });
  return block;
}
function create_if_block_215(ctx) {
  let input;
  let t0;
  let t1;
  let t2;
  let listboxmenuicon;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[39],
    { role: "combobox" },
    { tabindex: "0" },
    { autocomplete: "off" },
    { "aria-autocomplete": "list" },
    { "aria-expanded": (
      /*open*/
      ctx[2]
    ) },
    {
      "aria-activedescendant": (
        /*highlightedId*/
        ctx[7]
      )
    },
    { "aria-disabled": (
      /*disabled*/
      ctx[12]
    ) },
    { "aria-controls": (
      /*menuId*/
      ctx[35]
    ) },
    { disabled: (
      /*disabled*/
      ctx[12]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[15]
    ) },
    { id: (
      /*id*/
      ctx[27]
    ) },
    { name: (
      /*name*/
      ctx[28]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block0 = (
    /*invalid*/
    ctx[20] && create_if_block_48(ctx)
  );
  let if_block1 = (
    /*value*/
    ctx[1] && create_if_block_310(ctx)
  );
  listboxmenuicon = new ListBoxMenuIcon_default({
    props: {
      style: "pointer-events: " + /*open*/
      (ctx[2] ? "auto" : "none"),
      translateWithId: (
        /*translateWithId*/
        ctx[16]
      ),
      open: (
        /*open*/
        ctx[2]
      )
    },
    $$inline: true
  });
  listboxmenuicon.$on(
    "click",
    /*click_handler_1*/
    ctx[59]
  );
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      create_component(listboxmenuicon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        role: true,
        tabindex: true,
        autocomplete: true,
        "aria-autocomplete": true,
        "aria-expanded": true,
        "aria-activedescendant": true,
        "aria-disabled": true,
        "aria-controls": true,
        placeholder: true,
        id: true,
        name: true
      });
      t0 = claim_space(nodes);
      if (if_block0) if_block0.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      t2 = claim_space(nodes);
      claim_component(listboxmenuicon.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "bx--text-input", true);
      toggle_class(
        input,
        "bx--text-input--empty",
        /*value*/
        ctx[1] === ""
      );
      toggle_class(
        input,
        "bx--text-input--light",
        /*light*/
        ctx[14]
      );
      add_location(input, file94, 407, 8, 11050);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus) input.focus();
      ctx[55](input);
      set_input_value(
        input,
        /*value*/
        ctx[1]
      );
      insert_hydration_dev(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(listboxmenuicon, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[56]
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[47],
            false,
            false,
            false,
            false
          ),
          listen_dev(input, "keydown", stop_propagation(
            /*keydown_handler_1*/
            ctx[57]
          ), false, false, true, false),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[48],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[49],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[50],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "paste",
            /*paste_handler*/
            ctx[51],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[1] & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[39],
        { role: "combobox" },
        { tabindex: "0" },
        { autocomplete: "off" },
        { "aria-autocomplete": "list" },
        (!current || dirty[0] & /*open*/
        4) && { "aria-expanded": (
          /*open*/
          ctx2[2]
        ) },
        (!current || dirty[0] & /*highlightedId*/
        128) && {
          "aria-activedescendant": (
            /*highlightedId*/
            ctx2[7]
          )
        },
        (!current || dirty[0] & /*disabled*/
        4096) && { "aria-disabled": (
          /*disabled*/
          ctx2[12]
        ) },
        (!current || dirty[1] & /*menuId*/
        16) && { "aria-controls": (
          /*menuId*/
          ctx2[35]
        ) },
        (!current || dirty[0] & /*disabled*/
        4096) && { disabled: (
          /*disabled*/
          ctx2[12]
        ) },
        (!current || dirty[0] & /*placeholder*/
        32768) && { placeholder: (
          /*placeholder*/
          ctx2[15]
        ) },
        (!current || dirty[0] & /*id*/
        134217728) && { id: (
          /*id*/
          ctx2[27]
        ) },
        (!current || dirty[0] & /*name*/
        268435456) && { name: (
          /*name*/
          ctx2[28]
        ) }
      ]));
      if (dirty[0] & /*value*/
      2 && input.value !== /*value*/
      ctx2[1]) {
        set_input_value(
          input,
          /*value*/
          ctx2[1]
        );
      }
      toggle_class(input, "bx--text-input", true);
      toggle_class(
        input,
        "bx--text-input--empty",
        /*value*/
        ctx2[1] === ""
      );
      toggle_class(
        input,
        "bx--text-input--light",
        /*light*/
        ctx2[14]
      );
      if (
        /*invalid*/
        ctx2[20]
      ) {
        if (if_block0) {
          if (dirty[0] & /*invalid*/
          1048576) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_48(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*value*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*value*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_310(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const listboxmenuicon_changes = {};
      if (dirty[0] & /*open*/
      4) listboxmenuicon_changes.style = "pointer-events: " + /*open*/
      (ctx2[2] ? "auto" : "none");
      if (dirty[0] & /*translateWithId*/
      65536) listboxmenuicon_changes.translateWithId = /*translateWithId*/
      ctx2[16];
      if (dirty[0] & /*open*/
      4) listboxmenuicon_changes.open = /*open*/
      ctx2[2];
      listboxmenuicon.$set(listboxmenuicon_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(listboxmenuicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(listboxmenuicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
      ctx[55](null);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      destroy_component(listboxmenuicon, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_215.name,
    type: "if",
    source: "(407:6) {#if filterable}",
    ctx
  });
  return block;
}
function create_if_block_48(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--list-box__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_48.name,
    type: "if",
    source: "(457:8) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_310(ctx) {
  let listboxselection;
  let current;
  listboxselection = new ListBoxSelection_default({
    props: {
      translateWithId: (
        /*translateWithIdSelection*/
        ctx[17]
      ),
      disabled: (
        /*disabled*/
        ctx[12]
      ),
      open: (
        /*open*/
        ctx[2]
      )
    },
    $$inline: true
  });
  listboxselection.$on(
    "clear",
    /*clear_handler_2*/
    ctx[58]
  );
  const block = {
    c: function create() {
      create_component(listboxselection.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(listboxselection.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(listboxselection, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const listboxselection_changes = {};
      if (dirty[0] & /*translateWithIdSelection*/
      131072) listboxselection_changes.translateWithId = /*translateWithIdSelection*/
      ctx2[17];
      if (dirty[0] & /*disabled*/
      4096) listboxselection_changes.disabled = /*disabled*/
      ctx2[12];
      if (dirty[0] & /*open*/
      4) listboxselection_changes.open = /*open*/
      ctx2[2];
      listboxselection.$set(listboxselection_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(listboxselection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxselection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listboxselection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_310.name,
    type: "if",
    source: "(460:8) {#if value}",
    ctx
  });
  return block;
}
function create_if_block_123(ctx) {
  let span;
  let t0;
  let t1;
  let listboxmenuicon;
  let current;
  listboxmenuicon = new ListBoxMenuIcon_default({
    props: {
      open: (
        /*open*/
        ctx[2]
      ),
      translateWithId: (
        /*translateWithId*/
        ctx[16]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span = element("span");
      t0 = text(
        /*label*/
        ctx[25]
      );
      t1 = space();
      create_component(listboxmenuicon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*label*/
        ctx[25]
      );
      span_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      claim_component(listboxmenuicon.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--list-box__label", true);
      add_location(span, file94, 481, 8, 13370);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      insert_hydration_dev(target, t1, anchor);
      mount_component(listboxmenuicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*label*/
      33554432) set_data_dev(
        t0,
        /*label*/
        ctx2[25]
      );
      const listboxmenuicon_changes = {};
      if (dirty[0] & /*open*/
      4) listboxmenuicon_changes.open = /*open*/
      ctx2[2];
      if (dirty[0] & /*translateWithId*/
      65536) listboxmenuicon_changes.translateWithId = /*translateWithId*/
      ctx2[16];
      listboxmenuicon.$set(listboxmenuicon_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(listboxmenuicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxmenuicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
        detach_dev(t1);
      }
      destroy_component(listboxmenuicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_123.name,
    type: "if",
    source: "(481:6) {#if !filterable}",
    ctx
  });
  return block;
}
function create_default_slot_33(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*checked*/
    ctx[32].length > 0 && create_if_block_57(ctx)
  );
  let if_block1 = (
    /*filterable*/
    ctx[13] && create_if_block_215(ctx)
  );
  let if_block2 = !/*filterable*/
  ctx[13] && create_if_block_123(ctx);
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2) if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*checked*/
        ctx2[32].length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*checked*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_57(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*filterable*/
        ctx2[13]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*filterable*/
          8192) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_215(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!/*filterable*/
      ctx2[13]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*filterable*/
          8192) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_123(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(if_block2_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_33.name,
    type: "slot",
    source: `(333:4) <ListBoxField       role=\\"button\\"       tabindex=\\"0\\"       aria-expanded=\\"{open}\\"       on:click=\\"{() => {         if (disabled) return;         if (filterable) {           open = true;           inputRef.focus();         } else {           open = !open;         }       }}\\"       on:keydown=\\"{(e) => {         if (filterable) {           return;         }         const key = e.key;         if ([' ', 'ArrowUp', 'ArrowDown'].includes(key)) {           e.preventDefault();         }         if (key === ' ') {           open = !open;         } else if (key === 'Tab') {           if (selectionRef && checked.length > 0) {             selectionRef.focus();           } else {             open = false;             fieldRef.blur();           }         } else if (key === 'ArrowDown') {           change(1);         } else if (key === 'ArrowUp') {           change(-1);         } else if (key === 'Enter') {           if (highlightedIndex > -1) {             sortedItems = sortedItems.map((item, i) => {               if (i !== highlightedIndex) return item;               return { ...item, checked: !item.checked };             });           }         } else if (key === 'Escape') {           open = false;         }       }}\\"       on:focus=\\"{() => {         if (filterable) {           open = true;           if (inputRef) inputRef.focus();         }       }}\\"       on:blur=\\"{(e) => {         if (!filterable) dispatch('blur', e);       }}\\"       id=\\"{id}\\"       disabled=\\"{disabled}\\"       translateWithId=\\"{translateWithId}\\"     >`,
    ctx
  });
  return block;
}
function fallback_block19(ctx) {
  let t_value = (
    /*itemToString*/
    ctx[8](
      /*item*/
      ctx[74]
    ) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*itemToString, filterable, sortedItems*/
      1073750272 | dirty[1] & /*filteredItems*/
      1 && t_value !== (t_value = /*itemToString*/
      ctx2[8](
        /*item*/
        ctx2[74]
      ) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block19.name,
    type: "fallback",
    source: "(529:63)                  ",
    ctx
  });
  return block;
}
function create_labelText_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[46].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[68],
    get_default_slot_context9
  );
  const default_slot_or_fallback = default_slot || fallback_block19(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback) default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback) default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*filterable, sortedItems*/
        1073750016 | dirty[1] & /*filteredItems*/
        1 | dirty[2] & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[68],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[68]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[68],
              dirty,
              get_default_slot_changes9
            ),
            get_default_slot_context9
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*itemToString, filterable, sortedItems*/
        1073750272 | dirty[1] & /*filteredItems*/
        1)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_labelText_slot.name,
    type: "slot",
    source: "(529:14) ",
    ctx
  });
  return block;
}
function create_default_slot_25(ctx) {
  let checkbox;
  let t;
  let current;
  const checkbox_spread_levels = [
    { name: (
      /*item*/
      ctx[74].id
    ) },
    {
      title: (
        /*useTitleInItem*/
        ctx[19] ? (
          /*itemToString*/
          ctx[8](
            /*item*/
            ctx[74]
          )
        ) : void 0
      )
    },
    /*itemToInput*/
    ctx[9](
      /*item*/
      ctx[74]
    ),
    { readonly: true },
    { tabindex: "-1" },
    { id: "checkbox-" + /*item*/
    ctx[74].id },
    { checked: (
      /*item*/
      ctx[74].checked
    ) },
    { disabled: (
      /*item*/
      ctx[74].disabled
    ) }
  ];
  function blur_handler_2() {
    return (
      /*blur_handler_2*/
      ctx[64](
        /*i*/
        ctx[76]
      )
    );
  }
  let checkbox_props = {
    $$slots: { labelText: [create_labelText_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < checkbox_spread_levels.length; i += 1) {
    checkbox_props = assign(checkbox_props, checkbox_spread_levels[i]);
  }
  checkbox = new Checkbox_default({ props: checkbox_props, $$inline: true });
  checkbox.$on("blur", blur_handler_2);
  const block = {
    c: function create() {
      create_component(checkbox.$$.fragment);
      t = space();
    },
    l: function claim(nodes) {
      claim_component(checkbox.$$.fragment, nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(checkbox, target, anchor);
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const checkbox_changes = dirty[0] & /*filterable, sortedItems, useTitleInItem, itemToString, itemToInput*/
      1074275072 | dirty[1] & /*filteredItems*/
      1 ? get_spread_update(checkbox_spread_levels, [
        dirty[0] & /*filterable, sortedItems*/
        1073750016 | dirty[1] & /*filteredItems*/
        1 && { name: (
          /*item*/
          ctx[74].id
        ) },
        dirty[0] & /*useTitleInItem, itemToString, filterable, sortedItems*/
        1074274560 | dirty[1] & /*filteredItems*/
        1 && {
          title: (
            /*useTitleInItem*/
            ctx[19] ? (
              /*itemToString*/
              ctx[8](
                /*item*/
                ctx[74]
              )
            ) : void 0
          )
        },
        dirty[0] & /*itemToInput, filterable, sortedItems*/
        1073750528 | dirty[1] & /*filteredItems*/
        1 && get_spread_object(
          /*itemToInput*/
          ctx[9](
            /*item*/
            ctx[74]
          )
        ),
        checkbox_spread_levels[3],
        checkbox_spread_levels[4],
        dirty[0] & /*filterable, sortedItems*/
        1073750016 | dirty[1] & /*filteredItems*/
        1 && { id: "checkbox-" + /*item*/
        ctx[74].id },
        dirty[0] & /*filterable, sortedItems*/
        1073750016 | dirty[1] & /*filteredItems*/
        1 && { checked: (
          /*item*/
          ctx[74].checked
        ) },
        dirty[0] & /*filterable, sortedItems*/
        1073750016 | dirty[1] & /*filteredItems*/
        1 && { disabled: (
          /*item*/
          ctx[74].disabled
        ) }
      ]) : {};
      if (dirty[0] & /*itemToString, filterable, sortedItems*/
      1073750272 | dirty[1] & /*filteredItems*/
      1 | dirty[2] & /*$$scope*/
      64) {
        checkbox_changes.$$scope = { dirty, ctx };
      }
      checkbox.$set(checkbox_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(checkbox, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_25.name,
    type: "slot",
    source: '(493:10) <ListBoxMenuItem             id=\\"{item.id}\\"             role=\\"option\\"             aria-labelledby=\\"checkbox-{item.id}\\"             aria-selected=\\"{item.checked}\\"             active=\\"{item.checked}\\"             highlighted=\\"{highlightedIndex === i}\\"             disabled=\\"{item.disabled}\\"             on:click=\\"{(e) => {               if (item.disabled) {                 e.stopPropagation();                 return;               }               sortedItems = sortedItems.map((_) =>                 _.id === item.id ? { ..._, checked: !_.checked } : _               );               fieldRef.focus();             }}\\"             on:mouseenter=\\"{() => {               if (item.disabled) return;               highlightedIndex = i;             }}\\"           >',
    ctx
  });
  return block;
}
function create_each_block11(key_1, ctx) {
  let first;
  let listboxmenuitem;
  let current;
  function click_handler_3(...args) {
    return (
      /*click_handler_3*/
      ctx[65](
        /*item*/
        ctx[74],
        ...args
      )
    );
  }
  function mouseenter_handler() {
    return (
      /*mouseenter_handler*/
      ctx[66](
        /*item*/
        ctx[74],
        /*i*/
        ctx[76]
      )
    );
  }
  listboxmenuitem = new ListBoxMenuItem_default({
    props: {
      id: (
        /*item*/
        ctx[74].id
      ),
      role: "option",
      "aria-labelledby": "checkbox-" + /*item*/
      ctx[74].id,
      "aria-selected": (
        /*item*/
        ctx[74].checked
      ),
      active: (
        /*item*/
        ctx[74].checked
      ),
      highlighted: (
        /*highlightedIndex*/
        ctx[29] === /*i*/
        ctx[76]
      ),
      disabled: (
        /*item*/
        ctx[74].disabled
      ),
      $$slots: { default: [create_default_slot_25] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  listboxmenuitem.$on("click", click_handler_3);
  listboxmenuitem.$on("mouseenter", mouseenter_handler);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(listboxmenuitem.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(listboxmenuitem.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(listboxmenuitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const listboxmenuitem_changes = {};
      if (dirty[0] & /*filterable, sortedItems*/
      1073750016 | dirty[1] & /*filteredItems*/
      1) listboxmenuitem_changes.id = /*item*/
      ctx[74].id;
      if (dirty[0] & /*filterable, sortedItems*/
      1073750016 | dirty[1] & /*filteredItems*/
      1) listboxmenuitem_changes["aria-labelledby"] = "checkbox-" + /*item*/
      ctx[74].id;
      if (dirty[0] & /*filterable, sortedItems*/
      1073750016 | dirty[1] & /*filteredItems*/
      1) listboxmenuitem_changes["aria-selected"] = /*item*/
      ctx[74].checked;
      if (dirty[0] & /*filterable, sortedItems*/
      1073750016 | dirty[1] & /*filteredItems*/
      1) listboxmenuitem_changes.active = /*item*/
      ctx[74].checked;
      if (dirty[0] & /*highlightedIndex, filterable, sortedItems*/
      1610620928 | dirty[1] & /*filteredItems*/
      1) listboxmenuitem_changes.highlighted = /*highlightedIndex*/
      ctx[29] === /*i*/
      ctx[76];
      if (dirty[0] & /*filterable, sortedItems*/
      1073750016 | dirty[1] & /*filteredItems*/
      1) listboxmenuitem_changes.disabled = /*item*/
      ctx[74].disabled;
      if (dirty[0] & /*filterable, sortedItems, useTitleInItem, itemToString, itemToInput, open*/
      1074275076 | dirty[1] & /*filteredItems*/
      1 | dirty[2] & /*$$scope*/
      64) {
        listboxmenuitem_changes.$$scope = { dirty, ctx };
      }
      listboxmenuitem.$set(listboxmenuitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(listboxmenuitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxmenuitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(listboxmenuitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block11.name,
    type: "each",
    source: "(492:8) {#each filterable ? filteredItems : sortedItems as item, i (item.id)}",
    ctx
  });
  return block;
}
function create_default_slot_15(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*filterable*/
    ctx[13] ? (
      /*filteredItems*/
      ctx[31]
    ) : (
      /*sortedItems*/
      ctx[30]
    )
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[74].id
  );
  validate_each_keys(ctx, each_value, get_each_context11, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context11(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block11(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*filterable, sortedItems, highlightedIndex, fieldRef, useTitleInItem, itemToString, itemToInput, open*/
      1611146020 | dirty[1] & /*filteredItems*/
      1 | dirty[2] & /*$$scope*/
      64) {
        each_value = ensure_array_like_dev(
          /*filterable*/
          ctx2[13] ? (
            /*filteredItems*/
            ctx2[31]
          ) : (
            /*sortedItems*/
            ctx2[30]
          )
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context11, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block11, each_1_anchor, get_each_context11);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: '(487:6) <ListBoxMenu         aria-label=\\"{ariaLabel}\\"         id=\\"{id}\\"         aria-multiselectable=\\"true\\"       >',
    ctx
  });
  return block;
}
function create_default_slot14(ctx) {
  let t0;
  let t1;
  let listboxfield;
  let t2;
  let div;
  let listboxmenu;
  let current;
  let if_block0 = (
    /*invalid*/
    ctx[20] && create_if_block_73(ctx)
  );
  let if_block1 = !/*invalid*/
  ctx[20] && /*warn*/
  ctx[22] && create_if_block_66(ctx);
  listboxfield = new ListBoxField_default({
    props: {
      role: "button",
      tabindex: "0",
      "aria-expanded": (
        /*open*/
        ctx[2]
      ),
      id: (
        /*id*/
        ctx[27]
      ),
      disabled: (
        /*disabled*/
        ctx[12]
      ),
      translateWithId: (
        /*translateWithId*/
        ctx[16]
      ),
      $$slots: { default: [create_default_slot_33] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  listboxfield.$on(
    "click",
    /*click_handler_2*/
    ctx[60]
  );
  listboxfield.$on(
    "keydown",
    /*keydown_handler_2*/
    ctx[61]
  );
  listboxfield.$on(
    "focus",
    /*focus_handler_1*/
    ctx[62]
  );
  listboxfield.$on(
    "blur",
    /*blur_handler_1*/
    ctx[63]
  );
  listboxmenu = new ListBoxMenu_default({
    props: {
      "aria-label": (
        /*ariaLabel*/
        ctx[33]
      ),
      id: (
        /*id*/
        ctx[27]
      ),
      "aria-multiselectable": "true",
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      create_component(listboxfield.$$.fragment);
      t2 = space();
      div = element("div");
      create_component(listboxmenu.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      t1 = claim_space(nodes);
      claim_component(listboxfield.$$.fragment, nodes);
      t2 = claim_space(nodes);
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(listboxmenu.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(
        div,
        "display",
        /*open*/
        ctx[2] ? "block" : "none"
      );
      add_location(div, file94, 485, 4, 13540);
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(listboxfield, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, div, anchor);
      mount_component(listboxmenu, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*invalid*/
        ctx2[20]
      ) {
        if (if_block0) {
          if (dirty[0] & /*invalid*/
          1048576) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_73(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*invalid*/
      ctx2[20] && /*warn*/
      ctx2[22]) {
        if (if_block1) {
          if (dirty[0] & /*invalid, warn*/
          5242880) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_66(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const listboxfield_changes = {};
      if (dirty[0] & /*open*/
      4) listboxfield_changes["aria-expanded"] = /*open*/
      ctx2[2];
      if (dirty[0] & /*id*/
      134217728) listboxfield_changes.id = /*id*/
      ctx2[27];
      if (dirty[0] & /*disabled*/
      4096) listboxfield_changes.disabled = /*disabled*/
      ctx2[12];
      if (dirty[0] & /*translateWithId*/
      65536) listboxfield_changes.translateWithId = /*translateWithId*/
      ctx2[16];
      if (dirty[0] & /*open, translateWithId, label, filterable, translateWithIdSelection, disabled, value, invalid, highlightedId, placeholder, id, name, inputRef, light, sortedItems, selectedIds, fieldRef*/
      1511256239 | dirty[1] & /*$$restProps, menuId, checked*/
      274 | dirty[2] & /*$$scope*/
      64) {
        listboxfield_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listboxfield.$set(listboxfield_changes);
      const listboxmenu_changes = {};
      if (dirty[1] & /*ariaLabel*/
      4) listboxmenu_changes["aria-label"] = /*ariaLabel*/
      ctx2[33];
      if (dirty[0] & /*id*/
      134217728) listboxmenu_changes.id = /*id*/
      ctx2[27];
      if (dirty[0] & /*filterable, sortedItems, highlightedIndex, fieldRef, useTitleInItem, itemToString, itemToInput, open*/
      1611146020 | dirty[1] & /*filteredItems*/
      1 | dirty[2] & /*$$scope*/
      64) {
        listboxmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listboxmenu.$set(listboxmenu_changes);
      if (dirty[0] & /*open*/
      4) {
        set_style(
          div,
          "display",
          /*open*/
          ctx2[2] ? "block" : "none"
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(listboxfield.$$.fragment, local);
      transition_in(listboxmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(listboxfield.$$.fragment, local);
      transition_out(listboxmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(div);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      destroy_component(listboxfield, detaching);
      destroy_component(listboxmenu);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: `(308:2) <ListBox     role=\\"{undefined}\\"     disabled=\\"{disabled}\\"     invalid=\\"{invalid}\\"     invalidText=\\"{invalidText}\\"     open=\\"{open}\\"     light=\\"{light}\\"     size=\\"{size}\\"     warn=\\"{warn}\\"     warnText=\\"{warnText}\\"     class=\\"bx--multi-select {direction === 'top' &&       'bx--list-box--up'} {filterable && 'bx--combo-box'}       {filterable && 'bx--multi-select--filterable'}       {invalid && 'bx--multi-select--invalid'}       {inline && 'bx--multi-select--inline'}       {checked.length > 0 && 'bx--multi-select--selected'}\\"   >`,
    ctx
  });
  return block;
}
function create_if_block59(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[24]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[24]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(
        div,
        "bx--form__helper-text--disabled",
        /*disabled*/
        ctx[12]
      );
      add_location(div, file94, 538, 4, 15301);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*helperText*/
      16777216) set_data_dev(
        t,
        /*helperText*/
        ctx2[24]
      );
      if (dirty[0] & /*disabled*/
      4096) {
        toggle_class(
          div,
          "bx--form__helper-text--disabled",
          /*disabled*/
          ctx2[12]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block59.name,
    type: "if",
    source: "(538:2) {#if !inline && !invalid && !warn && helperText}",
    ctx
  });
  return block;
}
function create_fragment101(ctx) {
  let div;
  let t0;
  let listbox;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*titleText*/
    (ctx[18] || /*$$slots*/
    ctx[38].titleText) && create_if_block_83(ctx)
  );
  listbox = new ListBox_default({
    props: {
      role: void 0,
      disabled: (
        /*disabled*/
        ctx[12]
      ),
      invalid: (
        /*invalid*/
        ctx[20]
      ),
      invalidText: (
        /*invalidText*/
        ctx[21]
      ),
      open: (
        /*open*/
        ctx[2]
      ),
      light: (
        /*light*/
        ctx[14]
      ),
      size: (
        /*size*/
        ctx[10]
      ),
      warn: (
        /*warn*/
        ctx[22]
      ),
      warnText: (
        /*warnText*/
        ctx[23]
      ),
      class: "bx--multi-select " + /*direction*/
      (ctx[11] === "top" && "bx--list-box--up") + " " + /*filterable*/
      (ctx[13] && "bx--combo-box") + "\n      " + /*filterable*/
      (ctx[13] && "bx--multi-select--filterable") + "\n      " + /*invalid*/
      (ctx[20] && "bx--multi-select--invalid") + "\n      " + /*inline*/
      (ctx[34] && "bx--multi-select--inline") + "\n      " + /*checked*/
      (ctx[32].length > 0 && "bx--multi-select--selected"),
      $$slots: { default: [create_default_slot14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block1 = !/*inline*/
  ctx[34] && !/*invalid*/
  ctx[20] && !/*warn*/
  ctx[22] && /*helperText*/
  ctx[24] && create_if_block59(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      create_component(listbox.$$.fragment);
      t1 = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block0) if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      claim_component(listbox.$$.fragment, div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block1) if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--multi-select__wrapper", true);
      toggle_class(div, "bx--list-box__wrapper", true);
      toggle_class(
        div,
        "bx--multi-select__wrapper--inline",
        /*inline*/
        ctx[34]
      );
      toggle_class(
        div,
        "bx--list-box__wrapper--inline",
        /*inline*/
        ctx[34]
      );
      toggle_class(
        div,
        "bx--multi-select__wrapper--inline--invalid",
        /*inline*/
        ctx[34] && /*invalid*/
        ctx[20]
      );
      add_location(div, file94, 287, 0, 7664);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append_hydration_dev(div, t0);
      mount_component(listbox, div, null);
      append_hydration_dev(div, t1);
      if (if_block1) if_block1.m(div, null);
      ctx[67](div);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "click",
          /*click_handler*/
          ctx[52],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*titleText*/
        ctx2[18] || /*$$slots*/
        ctx2[38].titleText
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*titleText*/
          262144 | dirty[1] & /*$$slots*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_83(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const listbox_changes = {};
      if (dirty[0] & /*disabled*/
      4096) listbox_changes.disabled = /*disabled*/
      ctx2[12];
      if (dirty[0] & /*invalid*/
      1048576) listbox_changes.invalid = /*invalid*/
      ctx2[20];
      if (dirty[0] & /*invalidText*/
      2097152) listbox_changes.invalidText = /*invalidText*/
      ctx2[21];
      if (dirty[0] & /*open*/
      4) listbox_changes.open = /*open*/
      ctx2[2];
      if (dirty[0] & /*light*/
      16384) listbox_changes.light = /*light*/
      ctx2[14];
      if (dirty[0] & /*size*/
      1024) listbox_changes.size = /*size*/
      ctx2[10];
      if (dirty[0] & /*warn*/
      4194304) listbox_changes.warn = /*warn*/
      ctx2[22];
      if (dirty[0] & /*warnText*/
      8388608) listbox_changes.warnText = /*warnText*/
      ctx2[23];
      if (dirty[0] & /*direction, filterable, invalid*/
      1058816 | dirty[1] & /*inline, checked*/
      10) listbox_changes.class = "bx--multi-select " + /*direction*/
      (ctx2[11] === "top" && "bx--list-box--up") + " " + /*filterable*/
      (ctx2[13] && "bx--combo-box") + "\n      " + /*filterable*/
      (ctx2[13] && "bx--multi-select--filterable") + "\n      " + /*invalid*/
      (ctx2[20] && "bx--multi-select--invalid") + "\n      " + /*inline*/
      (ctx2[34] && "bx--multi-select--inline") + "\n      " + /*checked*/
      (ctx2[32].length > 0 && "bx--multi-select--selected");
      if (dirty[0] & /*open, id, filterable, sortedItems, highlightedIndex, fieldRef, useTitleInItem, itemToString, itemToInput, disabled, translateWithId, inputRef, selectionRef, label, translateWithIdSelection, value, invalid, highlightedId, placeholder, name, light, selectedIds, warn*/
      2052846575 | dirty[1] & /*ariaLabel, filteredItems, checked, $$restProps, menuId*/
      279 | dirty[2] & /*$$scope*/
      64) {
        listbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listbox.$set(listbox_changes);
      if (!/*inline*/
      ctx2[34] && !/*invalid*/
      ctx2[20] && !/*warn*/
      ctx2[22] && /*helperText*/
      ctx2[24]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block59(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty[1] & /*inline*/
      8) {
        toggle_class(
          div,
          "bx--multi-select__wrapper--inline",
          /*inline*/
          ctx2[34]
        );
      }
      if (!current || dirty[1] & /*inline*/
      8) {
        toggle_class(
          div,
          "bx--list-box__wrapper--inline",
          /*inline*/
          ctx2[34]
        );
      }
      if (!current || dirty[0] & /*invalid*/
      1048576 | dirty[1] & /*inline*/
      8) {
        toggle_class(
          div,
          "bx--multi-select__wrapper--inline--invalid",
          /*inline*/
          ctx2[34] && /*invalid*/
          ctx2[20]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(listbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(listbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0) if_block0.d();
      destroy_component(listbox);
      if (if_block1) if_block1.d();
      ctx[67](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment101.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance101($$self, $$props, $$invalidate) {
  let menuId;
  let inline;
  let ariaLabel;
  let sortedItems;
  let checked;
  let unchecked;
  let filteredItems;
  const omit_props_names = [
    "items",
    "itemToString",
    "itemToInput",
    "selectedIds",
    "value",
    "size",
    "type",
    "direction",
    "selectionFeedback",
    "disabled",
    "filterable",
    "filterItem",
    "open",
    "light",
    "locale",
    "placeholder",
    "sortItem",
    "translateWithId",
    "translateWithIdSelection",
    "titleText",
    "useTitleInItem",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "helperText",
    "label",
    "hideLabel",
    "id",
    "name",
    "inputRef",
    "multiSelectRef",
    "fieldRef",
    "selectionRef",
    "highlightedId"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MultiSelect", slots, ["titleText", "default"]);
  const $$slots = compute_slots(slots);
  let { items = [] } = $$props;
  let { itemToString = (item) => item.text || item.id } = $$props;
  let { itemToInput = (item) => {
  } } = $$props;
  let { selectedIds = [] } = $$props;
  let { value = "" } = $$props;
  let { size = void 0 } = $$props;
  let { type = "default" } = $$props;
  let { direction = "bottom" } = $$props;
  let { selectionFeedback = "top-after-reopen" } = $$props;
  let { disabled = false } = $$props;
  let { filterable = false } = $$props;
  let { filterItem = (item, value2) => item.text.toLowerCase().includes(value2.trim().toLowerCase()) } = $$props;
  let { open = false } = $$props;
  let { light = false } = $$props;
  let { locale = "en" } = $$props;
  let { placeholder = "" } = $$props;
  let { sortItem = (a, b) => a.text.localeCompare(b.text, locale, { numeric: true }) } = $$props;
  let { translateWithId = void 0 } = $$props;
  let { translateWithIdSelection = void 0 } = $$props;
  let { titleText = "" } = $$props;
  let { useTitleInItem = false } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { helperText = "" } = $$props;
  let { label = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { inputRef = null } = $$props;
  let { multiSelectRef = null } = $$props;
  let { fieldRef = null } = $$props;
  let { selectionRef = null } = $$props;
  let { highlightedId = null } = $$props;
  const dispatch = createEventDispatcher();
  let initialSorted = false;
  let highlightedIndex = -1;
  let prevChecked = [];
  setContext("MultiSelect", {
    declareRef: ({ key, ref }) => {
      switch (key) {
        case "field":
          $$invalidate(5, fieldRef = ref);
          break;
        case "selection":
          $$invalidate(6, selectionRef = ref);
          break;
      }
    }
  });
  function change(direction2) {
    let index = highlightedIndex + direction2;
    const length = filterable ? filteredItems.length : items.length;
    if (length === 0) return;
    if (index < 0) {
      index = length - 1;
    } else if (index >= length) {
      index = 0;
    }
    let disabled2 = items[index].disabled;
    while (disabled2) {
      index = index + direction2;
      if (index < 0) {
        index = items.length - 1;
      } else if (index >= items.length) {
        index = 0;
      }
      disabled2 = items[index].disabled;
    }
    $$invalidate(29, highlightedIndex = index);
  }
  function sort() {
    return [
      ...checked.length > 1 ? checked.sort(sortItem) : checked,
      ...unchecked.sort(sortItem)
    ];
  }
  afterUpdate(() => {
    if (checked.length !== prevChecked.length) {
      if (selectionFeedback === "top") {
        $$invalidate(30, sortedItems = sort());
      }
      prevChecked = checked;
      $$invalidate(0, selectedIds = checked.map(({ id: id2 }) => id2));
      dispatch("select", {
        selectedIds,
        selected: checked,
        unselected: unchecked
      });
    }
    if (!open) {
      if (!initialSorted || selectionFeedback !== "fixed") {
        $$invalidate(30, sortedItems = sort());
        initialSorted = true;
      }
      $$invalidate(29, highlightedIndex = -1);
      $$invalidate(1, value = "");
    }
    $$invalidate(40, items = sortedItems);
  });
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler = ({ target }) => {
    if (open && multiSelectRef && !multiSelectRef.contains(target)) {
      $$invalidate(2, open = false);
    }
  };
  function clear_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const clear_handler_1 = () => {
    $$invalidate(0, selectedIds = []);
    $$invalidate(30, sortedItems = sortedItems.map((item) => ({ ...item, checked: false })));
    if (fieldRef) fieldRef.blur();
  };
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputRef = $$value;
      $$invalidate(3, inputRef);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(1, value);
  }
  const keydown_handler_12 = ({ key }) => {
    if (key === "Enter") {
      if (highlightedId) {
        const filteredItemIndex = sortedItems.findIndex((item) => item.id === highlightedId);
        $$invalidate(30, sortedItems = sortedItems.map((item, i) => {
          if (i !== filteredItemIndex) return item;
          return { ...item, checked: !item.checked };
        }));
      }
    } else if (key === "Tab") {
      $$invalidate(2, open = false);
      inputRef.blur();
    } else if (key === "ArrowDown") {
      change(1);
    } else if (key === "ArrowUp") {
      change(-1);
    } else if (key === "Escape") {
      $$invalidate(2, open = false);
    } else if (key === " ") {
      if (!open) $$invalidate(2, open = true);
    }
  };
  const clear_handler_2 = () => {
    $$invalidate(1, value = "");
    $$invalidate(2, open = false);
  };
  const click_handler_13 = (e) => {
    e.stopPropagation();
    $$invalidate(2, open = !open);
  };
  const click_handler_2 = () => {
    if (disabled) return;
    if (filterable) {
      $$invalidate(2, open = true);
      inputRef.focus();
    } else {
      $$invalidate(2, open = !open);
    }
  };
  const keydown_handler_2 = (e) => {
    if (filterable) {
      return;
    }
    const key = e.key;
    if ([" ", "ArrowUp", "ArrowDown"].includes(key)) {
      e.preventDefault();
    }
    if (key === " ") {
      $$invalidate(2, open = !open);
    } else if (key === "Tab") {
      if (selectionRef && checked.length > 0) {
        selectionRef.focus();
      } else {
        $$invalidate(2, open = false);
        fieldRef.blur();
      }
    } else if (key === "ArrowDown") {
      change(1);
    } else if (key === "ArrowUp") {
      change(-1);
    } else if (key === "Enter") {
      if (highlightedIndex > -1) {
        $$invalidate(30, sortedItems = sortedItems.map((item, i) => {
          if (i !== highlightedIndex) return item;
          return { ...item, checked: !item.checked };
        }));
      }
    } else if (key === "Escape") {
      $$invalidate(2, open = false);
    }
  };
  const focus_handler_1 = () => {
    if (filterable) {
      $$invalidate(2, open = true);
      if (inputRef) inputRef.focus();
    }
  };
  const blur_handler_1 = (e) => {
    if (!filterable) dispatch("blur", e);
  };
  const blur_handler_2 = (i) => {
    if (i === filteredItems.length - 1) $$invalidate(2, open = false);
  };
  const click_handler_3 = (item, e) => {
    if (item.disabled) {
      e.stopPropagation();
      return;
    }
    $$invalidate(30, sortedItems = sortedItems.map((_) => _.id === item.id ? { ..._, checked: !_.checked } : _));
    fieldRef.focus();
  };
  const mouseenter_handler = (item, i) => {
    if (item.disabled) return;
    $$invalidate(29, highlightedIndex = i);
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      multiSelectRef = $$value;
      $$invalidate(4, multiSelectRef);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(73, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(39, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("items" in $$new_props) $$invalidate(40, items = $$new_props.items);
    if ("itemToString" in $$new_props) $$invalidate(8, itemToString = $$new_props.itemToString);
    if ("itemToInput" in $$new_props) $$invalidate(9, itemToInput = $$new_props.itemToInput);
    if ("selectedIds" in $$new_props) $$invalidate(0, selectedIds = $$new_props.selectedIds);
    if ("value" in $$new_props) $$invalidate(1, value = $$new_props.value);
    if ("size" in $$new_props) $$invalidate(10, size = $$new_props.size);
    if ("type" in $$new_props) $$invalidate(41, type = $$new_props.type);
    if ("direction" in $$new_props) $$invalidate(11, direction = $$new_props.direction);
    if ("selectionFeedback" in $$new_props) $$invalidate(42, selectionFeedback = $$new_props.selectionFeedback);
    if ("disabled" in $$new_props) $$invalidate(12, disabled = $$new_props.disabled);
    if ("filterable" in $$new_props) $$invalidate(13, filterable = $$new_props.filterable);
    if ("filterItem" in $$new_props) $$invalidate(43, filterItem = $$new_props.filterItem);
    if ("open" in $$new_props) $$invalidate(2, open = $$new_props.open);
    if ("light" in $$new_props) $$invalidate(14, light = $$new_props.light);
    if ("locale" in $$new_props) $$invalidate(44, locale = $$new_props.locale);
    if ("placeholder" in $$new_props) $$invalidate(15, placeholder = $$new_props.placeholder);
    if ("sortItem" in $$new_props) $$invalidate(45, sortItem = $$new_props.sortItem);
    if ("translateWithId" in $$new_props) $$invalidate(16, translateWithId = $$new_props.translateWithId);
    if ("translateWithIdSelection" in $$new_props) $$invalidate(17, translateWithIdSelection = $$new_props.translateWithIdSelection);
    if ("titleText" in $$new_props) $$invalidate(18, titleText = $$new_props.titleText);
    if ("useTitleInItem" in $$new_props) $$invalidate(19, useTitleInItem = $$new_props.useTitleInItem);
    if ("invalid" in $$new_props) $$invalidate(20, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props) $$invalidate(21, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props) $$invalidate(22, warn = $$new_props.warn);
    if ("warnText" in $$new_props) $$invalidate(23, warnText = $$new_props.warnText);
    if ("helperText" in $$new_props) $$invalidate(24, helperText = $$new_props.helperText);
    if ("label" in $$new_props) $$invalidate(25, label = $$new_props.label);
    if ("hideLabel" in $$new_props) $$invalidate(26, hideLabel = $$new_props.hideLabel);
    if ("id" in $$new_props) $$invalidate(27, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(28, name = $$new_props.name);
    if ("inputRef" in $$new_props) $$invalidate(3, inputRef = $$new_props.inputRef);
    if ("multiSelectRef" in $$new_props) $$invalidate(4, multiSelectRef = $$new_props.multiSelectRef);
    if ("fieldRef" in $$new_props) $$invalidate(5, fieldRef = $$new_props.fieldRef);
    if ("selectionRef" in $$new_props) $$invalidate(6, selectionRef = $$new_props.selectionRef);
    if ("highlightedId" in $$new_props) $$invalidate(7, highlightedId = $$new_props.highlightedId);
    if ("$$scope" in $$new_props) $$invalidate(68, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    items,
    itemToString,
    itemToInput,
    selectedIds,
    value,
    size,
    type,
    direction,
    selectionFeedback,
    disabled,
    filterable,
    filterItem,
    open,
    light,
    locale,
    placeholder,
    sortItem,
    translateWithId,
    translateWithIdSelection,
    titleText,
    useTitleInItem,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    label,
    hideLabel,
    id,
    name,
    inputRef,
    multiSelectRef,
    fieldRef,
    selectionRef,
    highlightedId,
    afterUpdate,
    createEventDispatcher,
    setContext,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    Checkbox: Checkbox_default,
    ListBox: ListBox_default,
    ListBoxField: ListBoxField_default,
    ListBoxMenu: ListBoxMenu_default,
    ListBoxMenuIcon: ListBoxMenuIcon_default,
    ListBoxMenuItem: ListBoxMenuItem_default,
    ListBoxSelection: ListBoxSelection_default,
    dispatch,
    initialSorted,
    highlightedIndex,
    prevChecked,
    change,
    sort,
    sortedItems,
    filteredItems,
    unchecked,
    checked,
    ariaLabel,
    inline,
    menuId
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(73, $$props = assign(assign({}, $$props), $$new_props));
    if ("items" in $$props) $$invalidate(40, items = $$new_props.items);
    if ("itemToString" in $$props) $$invalidate(8, itemToString = $$new_props.itemToString);
    if ("itemToInput" in $$props) $$invalidate(9, itemToInput = $$new_props.itemToInput);
    if ("selectedIds" in $$props) $$invalidate(0, selectedIds = $$new_props.selectedIds);
    if ("value" in $$props) $$invalidate(1, value = $$new_props.value);
    if ("size" in $$props) $$invalidate(10, size = $$new_props.size);
    if ("type" in $$props) $$invalidate(41, type = $$new_props.type);
    if ("direction" in $$props) $$invalidate(11, direction = $$new_props.direction);
    if ("selectionFeedback" in $$props) $$invalidate(42, selectionFeedback = $$new_props.selectionFeedback);
    if ("disabled" in $$props) $$invalidate(12, disabled = $$new_props.disabled);
    if ("filterable" in $$props) $$invalidate(13, filterable = $$new_props.filterable);
    if ("filterItem" in $$props) $$invalidate(43, filterItem = $$new_props.filterItem);
    if ("open" in $$props) $$invalidate(2, open = $$new_props.open);
    if ("light" in $$props) $$invalidate(14, light = $$new_props.light);
    if ("locale" in $$props) $$invalidate(44, locale = $$new_props.locale);
    if ("placeholder" in $$props) $$invalidate(15, placeholder = $$new_props.placeholder);
    if ("sortItem" in $$props) $$invalidate(45, sortItem = $$new_props.sortItem);
    if ("translateWithId" in $$props) $$invalidate(16, translateWithId = $$new_props.translateWithId);
    if ("translateWithIdSelection" in $$props) $$invalidate(17, translateWithIdSelection = $$new_props.translateWithIdSelection);
    if ("titleText" in $$props) $$invalidate(18, titleText = $$new_props.titleText);
    if ("useTitleInItem" in $$props) $$invalidate(19, useTitleInItem = $$new_props.useTitleInItem);
    if ("invalid" in $$props) $$invalidate(20, invalid = $$new_props.invalid);
    if ("invalidText" in $$props) $$invalidate(21, invalidText = $$new_props.invalidText);
    if ("warn" in $$props) $$invalidate(22, warn = $$new_props.warn);
    if ("warnText" in $$props) $$invalidate(23, warnText = $$new_props.warnText);
    if ("helperText" in $$props) $$invalidate(24, helperText = $$new_props.helperText);
    if ("label" in $$props) $$invalidate(25, label = $$new_props.label);
    if ("hideLabel" in $$props) $$invalidate(26, hideLabel = $$new_props.hideLabel);
    if ("id" in $$props) $$invalidate(27, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(28, name = $$new_props.name);
    if ("inputRef" in $$props) $$invalidate(3, inputRef = $$new_props.inputRef);
    if ("multiSelectRef" in $$props) $$invalidate(4, multiSelectRef = $$new_props.multiSelectRef);
    if ("fieldRef" in $$props) $$invalidate(5, fieldRef = $$new_props.fieldRef);
    if ("selectionRef" in $$props) $$invalidate(6, selectionRef = $$new_props.selectionRef);
    if ("highlightedId" in $$props) $$invalidate(7, highlightedId = $$new_props.highlightedId);
    if ("initialSorted" in $$props) initialSorted = $$new_props.initialSorted;
    if ("highlightedIndex" in $$props) $$invalidate(29, highlightedIndex = $$new_props.highlightedIndex);
    if ("prevChecked" in $$props) prevChecked = $$new_props.prevChecked;
    if ("sortedItems" in $$props) $$invalidate(30, sortedItems = $$new_props.sortedItems);
    if ("filteredItems" in $$props) $$invalidate(31, filteredItems = $$new_props.filteredItems);
    if ("unchecked" in $$props) unchecked = $$new_props.unchecked;
    if ("checked" in $$props) $$invalidate(32, checked = $$new_props.checked);
    if ("ariaLabel" in $$props) $$invalidate(33, ariaLabel = $$new_props.ariaLabel);
    if ("inline" in $$props) $$invalidate(34, inline = $$new_props.inline);
    if ("menuId" in $$props) $$invalidate(35, menuId = $$new_props.menuId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty[0] & /*id*/
    134217728) {
      $: $$invalidate(35, menuId = `menu-${id}`);
    }
    if ($$self.$$.dirty[1] & /*type*/
    1024) {
      $: $$invalidate(34, inline = type === "inline");
    }
    $: $$invalidate(33, ariaLabel = $$props["aria-label"] || "Choose an item");
    if ($$self.$$.dirty[0] & /*selectedIds*/
    1 | $$self.$$.dirty[1] & /*items*/
    512) {
      $: $$invalidate(30, sortedItems = items.map((item) => ({
        ...item,
        checked: selectedIds.includes(item.id)
      })));
    }
    if ($$self.$$.dirty[0] & /*sortedItems*/
    1073741824) {
      $: $$invalidate(32, checked = sortedItems.filter(({ checked: checked2 }) => checked2));
    }
    if ($$self.$$.dirty[0] & /*sortedItems*/
    1073741824) {
      $: unchecked = sortedItems.filter(({ checked: checked2 }) => !checked2);
    }
    if ($$self.$$.dirty[0] & /*sortedItems, value*/
    1073741826 | $$self.$$.dirty[1] & /*filterItem*/
    4096) {
      $: $$invalidate(31, filteredItems = sortedItems.filter((item) => filterItem(item, value)));
    }
    if ($$self.$$.dirty[0] & /*highlightedIndex, filterable, sortedItems*/
    1610620928 | $$self.$$.dirty[1] & /*filteredItems*/
    1) {
      $: $$invalidate(7, highlightedId = highlightedIndex > -1 ? ((_a = (filterable ? filteredItems : sortedItems)[highlightedIndex]) == null ? void 0 : _a.id) ?? null : null);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    selectedIds,
    value,
    open,
    inputRef,
    multiSelectRef,
    fieldRef,
    selectionRef,
    highlightedId,
    itemToString,
    itemToInput,
    size,
    direction,
    disabled,
    filterable,
    light,
    placeholder,
    translateWithId,
    translateWithIdSelection,
    titleText,
    useTitleInItem,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    label,
    hideLabel,
    id,
    name,
    highlightedIndex,
    sortedItems,
    filteredItems,
    checked,
    ariaLabel,
    inline,
    menuId,
    dispatch,
    change,
    $$slots,
    $$restProps,
    items,
    type,
    selectionFeedback,
    filterItem,
    locale,
    sortItem,
    slots,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    paste_handler,
    click_handler,
    clear_handler,
    clear_handler_1,
    input_binding,
    input_input_handler,
    keydown_handler_12,
    clear_handler_2,
    click_handler_13,
    click_handler_2,
    keydown_handler_2,
    focus_handler_1,
    blur_handler_1,
    blur_handler_2,
    click_handler_3,
    mouseenter_handler,
    div_binding,
    $$scope
  ];
}
var MultiSelect = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance101,
      create_fragment101,
      safe_not_equal,
      {
        items: 40,
        itemToString: 8,
        itemToInput: 9,
        selectedIds: 0,
        value: 1,
        size: 10,
        type: 41,
        direction: 11,
        selectionFeedback: 42,
        disabled: 12,
        filterable: 13,
        filterItem: 43,
        open: 2,
        light: 14,
        locale: 44,
        placeholder: 15,
        sortItem: 45,
        translateWithId: 16,
        translateWithIdSelection: 17,
        titleText: 18,
        useTitleInItem: 19,
        invalid: 20,
        invalidText: 21,
        warn: 22,
        warnText: 23,
        helperText: 24,
        label: 25,
        hideLabel: 26,
        id: 27,
        name: 28,
        inputRef: 3,
        multiSelectRef: 4,
        fieldRef: 5,
        selectionRef: 6,
        highlightedId: 7
      },
      null,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MultiSelect",
      options,
      id: create_fragment101.name
    });
  }
  get items() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemToString() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemToString(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemToInput() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemToInput(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedIds() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedIds(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionFeedback() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionFeedback(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterable() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterable(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterItem() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterItem(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get locale() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set locale(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortItem() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortItem(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithIdSelection() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithIdSelection(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleText() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleText(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useTitleInItem() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useTitleInItem(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputRef() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputRef(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiSelectRef() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiSelectRef(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fieldRef() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fieldRef(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionRef() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionRef(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get highlightedId() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highlightedId(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MultiSelect_default = MultiSelect;

// node_modules/carbon-components-svelte/src/Modal/Modal.svelte
var file95 = "node_modules/carbon-components-svelte/src/Modal/Modal.svelte";
function get_each_context12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[55] = list[i];
  return child_ctx;
}
var get_heading_slot_changes = (dirty) => ({});
var get_heading_slot_context = (ctx) => ({});
var get_label_slot_changes = (dirty) => ({});
var get_label_slot_context = (ctx) => ({});
function create_if_block_67(ctx) {
  let button_1;
  let close;
  let current;
  let mounted;
  let dispose;
  close = new Close_default({
    props: {
      size: 20,
      class: "bx--modal-close__icon",
      "aria-hidden": "true"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      button_1 = element("button");
      create_component(close.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button_1 = claim_element(nodes, "BUTTON", { type: true, "aria-label": true });
      var button_1_nodes = children(button_1);
      claim_component(close.$$.fragment, button_1_nodes);
      button_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button_1, "type", "button");
      attr_dev(
        button_1,
        "aria-label",
        /*iconDescription*/
        ctx[8]
      );
      toggle_class(button_1, "bx--modal-close", true);
      add_location(button_1, file95, 211, 8, 5864);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button_1, anchor);
      mount_component(close, button_1, null);
      ctx[37](button_1);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button_1,
          "click",
          /*click_handler_1*/
          ctx[38],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*iconDescription*/
      256) {
        attr_dev(
          button_1,
          "aria-label",
          /*iconDescription*/
          ctx2[8]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button_1);
      }
      destroy_component(close);
      ctx[37](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_67.name,
    type: "if",
    source: "(211:6) {#if passiveModal}",
    ctx
  });
  return block;
}
function create_if_block_58(ctx) {
  let h2;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[31].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[50],
    get_label_slot_context
  );
  const label_slot_or_fallback = label_slot || fallback_block_19(ctx);
  const block = {
    c: function create() {
      h2 = element("h2");
      if (label_slot_or_fallback) label_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      h2 = claim_element(nodes, "H2", { id: true });
      var h2_nodes = children(h2);
      if (label_slot_or_fallback) label_slot_or_fallback.l(h2_nodes);
      h2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        h2,
        "id",
        /*modalLabelId*/
        ctx[25]
      );
      toggle_class(h2, "bx--modal-header__label", true);
      add_location(h2, file95, 224, 8, 6233);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h2, anchor);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(h2, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[1] & /*$$scope*/
        524288)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[50],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[50]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[50],
              dirty,
              get_label_slot_changes
            ),
            get_label_slot_context
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty[0] & /*modalLabel*/
        128)) {
          label_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*modalLabelId*/
      33554432) {
        attr_dev(
          h2,
          "id",
          /*modalLabelId*/
          ctx2[25]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(label_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
      }
      if (label_slot_or_fallback) label_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_58.name,
    type: "if",
    source: "(224:6) {#if modalLabel}",
    ctx
  });
  return block;
}
function fallback_block_19(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*modalLabel*/
        ctx[7]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*modalLabel*/
        ctx[7]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*modalLabel*/
      128) set_data_dev(
        t,
        /*modalLabel*/
        ctx2[7]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_19.name,
    type: "fallback",
    source: "(226:29) {modalLabel}",
    ctx
  });
  return block;
}
function fallback_block20(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*modalHeading*/
        ctx[6]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*modalHeading*/
        ctx[6]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*modalHeading*/
      64) set_data_dev(
        t,
        /*modalHeading*/
        ctx2[6]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block20.name,
    type: "fallback",
    source: "(230:29) {modalHeading}",
    ctx
  });
  return block;
}
function create_if_block_49(ctx) {
  let button_1;
  let close;
  let current;
  let mounted;
  let dispose;
  close = new Close_default({
    props: {
      size: 20,
      class: "bx--modal-close__icon",
      "aria-hidden": "true"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      button_1 = element("button");
      create_component(close.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button_1 = claim_element(nodes, "BUTTON", { type: true, "aria-label": true });
      var button_1_nodes = children(button_1);
      claim_component(close.$$.fragment, button_1_nodes);
      button_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button_1, "type", "button");
      attr_dev(
        button_1,
        "aria-label",
        /*iconDescription*/
        ctx[8]
      );
      toggle_class(button_1, "bx--modal-close", true);
      add_location(button_1, file95, 232, 8, 6543);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button_1, anchor);
      mount_component(close, button_1, null);
      ctx[39](button_1);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button_1,
          "click",
          /*click_handler_2*/
          ctx[40],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*iconDescription*/
      256) {
        attr_dev(
          button_1,
          "aria-label",
          /*iconDescription*/
          ctx2[8]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button_1);
      }
      destroy_component(close);
      ctx[39](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_49.name,
    type: "if",
    source: "(232:6) {#if !passiveModal}",
    ctx
  });
  return block;
}
function create_if_block_311(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--modal-content--overflow-indicator", true);
      add_location(div, file95, 259, 6, 7455);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_311.name,
    type: "if",
    source: "(259:4) {#if hasScrollingContent}",
    ctx
  });
  return block;
}
function create_if_block60(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t;
  let button_1;
  let current;
  const if_block_creators = [create_if_block_124, create_if_block_216];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*secondaryButtons*/
      ctx2[16].length > 0
    ) return 0;
    if (
      /*secondaryButtonText*/
      ctx2[15]
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  button_1 = new Button_default({
    props: {
      kind: (
        /*danger*/
        ctx[3] ? "danger" : "primary"
      ),
      disabled: (
        /*primaryButtonDisabled*/
        ctx[12]
      ),
      icon: (
        /*primaryButtonIcon*/
        ctx[13]
      ),
      $$slots: { default: [create_default_slot15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button_1.$on(
    "click",
    /*click_handler_5*/
    ctx[43]
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block) if_block.c();
      t = space();
      create_component(button_1.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block) if_block.l(div_nodes);
      t = claim_space(div_nodes);
      claim_component(button_1.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--modal-footer", true);
      toggle_class(
        div,
        "bx--modal-footer--three-button",
        /*secondaryButtons*/
        ctx[16].length === 2
      );
      add_location(div, file95, 262, 6, 7560);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append_hydration_dev(div, t);
      mount_component(button_1, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, t);
        } else {
          if_block = null;
        }
      }
      const button_1_changes = {};
      if (dirty[0] & /*danger*/
      8) button_1_changes.kind = /*danger*/
      ctx2[3] ? "danger" : "primary";
      if (dirty[0] & /*primaryButtonDisabled*/
      4096) button_1_changes.disabled = /*primaryButtonDisabled*/
      ctx2[12];
      if (dirty[0] & /*primaryButtonIcon*/
      8192) button_1_changes.icon = /*primaryButtonIcon*/
      ctx2[13];
      if (dirty[0] & /*primaryButtonText*/
      2048 | dirty[1] & /*$$scope*/
      524288) {
        button_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button_1.$set(button_1_changes);
      if (!current || dirty[0] & /*secondaryButtons*/
      65536) {
        toggle_class(
          div,
          "bx--modal-footer--three-button",
          /*secondaryButtons*/
          ctx2[16].length === 2
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(button_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(button_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      destroy_component(button_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block60.name,
    type: "if",
    source: "(262:4) {#if !passiveModal}",
    ctx
  });
  return block;
}
function create_if_block_216(ctx) {
  let button_1;
  let current;
  button_1 = new Button_default({
    props: {
      kind: "secondary",
      $$slots: { default: [create_default_slot_26] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button_1.$on(
    "click",
    /*click_handler_4*/
    ctx[42]
  );
  const block = {
    c: function create() {
      create_component(button_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_1_changes = {};
      if (dirty[0] & /*secondaryButtonText*/
      32768 | dirty[1] & /*$$scope*/
      524288) {
        button_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button_1.$set(button_1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(button_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_216.name,
    type: "if",
    source: "(278:38) ",
    ctx
  });
  return block;
}
function create_if_block_124(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*secondaryButtons*/
    ctx[16]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block12(get_each_context12(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*dispatch, secondaryButtons*/
      67174400) {
        each_value = ensure_array_like_dev(
          /*secondaryButtons*/
          ctx2[16]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context12(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block12(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_124.name,
    type: "if",
    source: "(267:8) {#if secondaryButtons.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_26(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*secondaryButtonText*/
        ctx[15]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*secondaryButtonText*/
        ctx[15]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*secondaryButtonText*/
      32768) set_data_dev(
        t,
        /*secondaryButtonText*/
        ctx2[15]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_26.name,
    type: "slot",
    source: `(279:10) <Button             kind=\\"secondary\\"             on:click=\\"{() => {               dispatch('click:button--secondary', {                 text: secondaryButtonText,               });             }}\\"           >`,
    ctx
  });
  return block;
}
function create_default_slot_16(ctx) {
  let t0_value = (
    /*button*/
    ctx[55].text + ""
  );
  let t0;
  let t1;
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*secondaryButtons*/
      65536 && t0_value !== (t0_value = /*button*/
      ctx2[55].text + "")) set_data_dev(t0, t0_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16.name,
    type: "slot",
    source: `(269:12) <Button               kind=\\"secondary\\"               on:click=\\"{() => {                 dispatch('click:button--secondary', { text: button.text });               }}\\"             >`,
    ctx
  });
  return block;
}
function create_each_block12(ctx) {
  let button_1;
  let current;
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[41](
        /*button*/
        ctx[55]
      )
    );
  }
  button_1 = new Button_default({
    props: {
      kind: "secondary",
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button_1.$on("click", click_handler_3);
  const block = {
    c: function create() {
      create_component(button_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button_1, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const button_1_changes = {};
      if (dirty[0] & /*secondaryButtons*/
      65536 | dirty[1] & /*$$scope*/
      524288) {
        button_1_changes.$$scope = { dirty, ctx };
      }
      button_1.$set(button_1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(button_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block12.name,
    type: "each",
    source: "(268:10) {#each secondaryButtons as button}",
    ctx
  });
  return block;
}
function create_default_slot15(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*primaryButtonText*/
        ctx[11]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*primaryButtonText*/
        ctx[11]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*primaryButtonText*/
      2048) set_data_dev(
        t,
        /*primaryButtonText*/
        ctx2[11]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot15.name,
    type: "slot",
    source: `(290:8) <Button           kind=\\"{danger ? 'danger' : 'primary'}\\"           disabled=\\"{primaryButtonDisabled}\\"           icon=\\"{primaryButtonIcon}\\"           on:click=\\"{() => {             dispatch('submit');             dispatch('click:button--primary');           }}\\"         >`,
    ctx
  });
  return block;
}
function create_fragment102(ctx) {
  let div3;
  let div2;
  let div0;
  let t0;
  let t1;
  let h3;
  let t2;
  let t3;
  let div1;
  let div1_tabindex_value;
  let div1_role_value;
  let div1_aria_label_value;
  let div1_aria_labelledby_value;
  let t4;
  let t5;
  let div2_role_value;
  let div2_aria_describedby_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*passiveModal*/
    ctx[5] && create_if_block_67(ctx)
  );
  let if_block1 = (
    /*modalLabel*/
    ctx[7] && create_if_block_58(ctx)
  );
  const heading_slot_template = (
    /*#slots*/
    ctx[31].heading
  );
  const heading_slot = create_slot(
    heading_slot_template,
    ctx,
    /*$$scope*/
    ctx[50],
    get_heading_slot_context
  );
  const heading_slot_or_fallback = heading_slot || fallback_block20(ctx);
  let if_block2 = !/*passiveModal*/
  ctx[5] && create_if_block_49(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[31].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[50],
    null
  );
  let if_block3 = (
    /*hasScrollingContent*/
    ctx[10] && create_if_block_311(ctx)
  );
  let if_block4 = !/*passiveModal*/
  ctx[5] && create_if_block60(ctx);
  let div3_levels = [
    { role: "presentation" },
    { id: (
      /*id*/
      ctx[18]
    ) },
    /*$$restProps*/
    ctx[28]
  ];
  let div_data_3 = {};
  for (let i = 0; i < div3_levels.length; i += 1) {
    div_data_3 = assign(div_data_3, div3_levels[i]);
  }
  const block = {
    c: function create() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      h3 = element("h3");
      if (heading_slot_or_fallback) heading_slot_or_fallback.c();
      t2 = space();
      if (if_block2) if_block2.c();
      t3 = space();
      div1 = element("div");
      if (default_slot) default_slot.c();
      t4 = space();
      if (if_block3) if_block3.c();
      t5 = space();
      if (if_block4) if_block4.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { role: true, id: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", {
        tabindex: true,
        role: true,
        "aria-describedby": true,
        "aria-modal": true,
        "aria-label": true
      });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (if_block0) if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      if (if_block1) if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      h3 = claim_element(div0_nodes, "H3", { id: true });
      var h3_nodes = children(h3);
      if (heading_slot_or_fallback) heading_slot_or_fallback.l(h3_nodes);
      h3_nodes.forEach(detach_dev);
      t2 = claim_space(div0_nodes);
      if (if_block2) if_block2.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t3 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", {
        id: true,
        tabindex: true,
        role: true,
        "aria-label": true,
        "aria-labelledby": true
      });
      var div1_nodes = children(div1);
      if (default_slot) default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t4 = claim_space(div2_nodes);
      if (if_block3) if_block3.l(div2_nodes);
      t5 = claim_space(div2_nodes);
      if (if_block4) if_block4.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        h3,
        "id",
        /*modalHeadingId*/
        ctx[24]
      );
      toggle_class(h3, "bx--modal-header__heading", true);
      add_location(h3, file95, 228, 6, 6378);
      toggle_class(div0, "bx--modal-header", true);
      add_location(div0, file95, 209, 4, 5793);
      attr_dev(
        div1,
        "id",
        /*modalBodyId*/
        ctx[23]
      );
      attr_dev(div1, "tabindex", div1_tabindex_value = /*hasScrollingContent*/
      ctx[10] ? "0" : void 0);
      attr_dev(div1, "role", div1_role_value = /*hasScrollingContent*/
      ctx[10] ? "region" : void 0);
      attr_dev(div1, "aria-label", div1_aria_label_value = /*hasScrollingContent*/
      ctx[10] ? (
        /*ariaLabel*/
        ctx[22]
      ) : void 0);
      attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value = /*modalLabel*/
      ctx[7] ? (
        /*modalLabelId*/
        ctx[25]
      ) : (
        /*modalHeadingId*/
        ctx[24]
      ));
      toggle_class(div1, "bx--modal-content", true);
      toggle_class(
        div1,
        "bx--modal-content--with-form",
        /*hasForm*/
        ctx[9]
      );
      toggle_class(
        div1,
        "bx--modal-scroll-content",
        /*hasScrollingContent*/
        ctx[10]
      );
      add_location(div1, file95, 246, 4, 6955);
      attr_dev(div2, "tabindex", "-1");
      attr_dev(div2, "role", div2_role_value = /*alert*/
      ctx[4] ? (
        /*passiveModal*/
        ctx[5] ? "alert" : "alertdialog"
      ) : "dialog");
      attr_dev(div2, "aria-describedby", div2_aria_describedby_value = /*alert*/
      ctx[4] && !/*passiveModal*/
      ctx[5] ? (
        /*modalBodyId*/
        ctx[23]
      ) : void 0);
      attr_dev(div2, "aria-modal", "true");
      attr_dev(
        div2,
        "aria-label",
        /*ariaLabel*/
        ctx[22]
      );
      toggle_class(div2, "bx--modal-container", true);
      toggle_class(
        div2,
        "bx--modal-container--xs",
        /*size*/
        ctx[2] === "xs"
      );
      toggle_class(
        div2,
        "bx--modal-container--sm",
        /*size*/
        ctx[2] === "sm"
      );
      toggle_class(
        div2,
        "bx--modal-container--lg",
        /*size*/
        ctx[2] === "lg"
      );
      add_location(div2, file95, 194, 2, 5276);
      set_attributes(div3, div_data_3);
      toggle_class(div3, "bx--modal", true);
      toggle_class(div3, "bx--modal-tall", !/*passiveModal*/
      ctx[5]);
      toggle_class(
        div3,
        "is-visible",
        /*open*/
        ctx[0]
      );
      toggle_class(
        div3,
        "bx--modal--danger",
        /*danger*/
        ctx[3]
      );
      add_location(div3, file95, 135, 0, 3564);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div0);
      if (if_block0) if_block0.m(div0, null);
      append_hydration_dev(div0, t0);
      if (if_block1) if_block1.m(div0, null);
      append_hydration_dev(div0, t1);
      append_hydration_dev(div0, h3);
      if (heading_slot_or_fallback) {
        heading_slot_or_fallback.m(h3, null);
      }
      append_hydration_dev(div0, t2);
      if (if_block2) if_block2.m(div0, null);
      append_hydration_dev(div2, t3);
      append_hydration_dev(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_hydration_dev(div2, t4);
      if (if_block3) if_block3.m(div2, null);
      append_hydration_dev(div2, t5);
      if (if_block4) if_block4.m(div2, null);
      ctx[44](div2);
      ctx[46](div3);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div2,
            "click",
            /*click_handler_6*/
            ctx[45],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keydown",
            /*keydown_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keydown",
            /*keydown_handler_1*/
            ctx[47],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "click",
            /*click_handler*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "click",
            /*click_handler_7*/
            ctx[48],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "mouseover",
            /*mouseover_handler*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[35],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[36],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "transitionend",
            /*transitionend_handler*/
            ctx[49],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*passiveModal*/
        ctx2[5]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*passiveModal*/
          32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_67(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*modalLabel*/
        ctx2[7]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*modalLabel*/
          128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_58(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (heading_slot) {
        if (heading_slot.p && (!current || dirty[1] & /*$$scope*/
        524288)) {
          update_slot_base(
            heading_slot,
            heading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[50],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[50]
            ) : get_slot_changes(
              heading_slot_template,
              /*$$scope*/
              ctx2[50],
              dirty,
              get_heading_slot_changes
            ),
            get_heading_slot_context
          );
        }
      } else {
        if (heading_slot_or_fallback && heading_slot_or_fallback.p && (!current || dirty[0] & /*modalHeading*/
        64)) {
          heading_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*modalHeadingId*/
      16777216) {
        attr_dev(
          h3,
          "id",
          /*modalHeadingId*/
          ctx2[24]
        );
      }
      if (!/*passiveModal*/
      ctx2[5]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*passiveModal*/
          32) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_49(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[50],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[50]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[50],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*modalBodyId*/
      8388608) {
        attr_dev(
          div1,
          "id",
          /*modalBodyId*/
          ctx2[23]
        );
      }
      if (!current || dirty[0] & /*hasScrollingContent*/
      1024 && div1_tabindex_value !== (div1_tabindex_value = /*hasScrollingContent*/
      ctx2[10] ? "0" : void 0)) {
        attr_dev(div1, "tabindex", div1_tabindex_value);
      }
      if (!current || dirty[0] & /*hasScrollingContent*/
      1024 && div1_role_value !== (div1_role_value = /*hasScrollingContent*/
      ctx2[10] ? "region" : void 0)) {
        attr_dev(div1, "role", div1_role_value);
      }
      if (!current || dirty[0] & /*hasScrollingContent, ariaLabel*/
      4195328 && div1_aria_label_value !== (div1_aria_label_value = /*hasScrollingContent*/
      ctx2[10] ? (
        /*ariaLabel*/
        ctx2[22]
      ) : void 0)) {
        attr_dev(div1, "aria-label", div1_aria_label_value);
      }
      if (!current || dirty[0] & /*modalLabel, modalLabelId, modalHeadingId*/
      50331776 && div1_aria_labelledby_value !== (div1_aria_labelledby_value = /*modalLabel*/
      ctx2[7] ? (
        /*modalLabelId*/
        ctx2[25]
      ) : (
        /*modalHeadingId*/
        ctx2[24]
      ))) {
        attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value);
      }
      if (!current || dirty[0] & /*hasForm*/
      512) {
        toggle_class(
          div1,
          "bx--modal-content--with-form",
          /*hasForm*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*hasScrollingContent*/
      1024) {
        toggle_class(
          div1,
          "bx--modal-scroll-content",
          /*hasScrollingContent*/
          ctx2[10]
        );
      }
      if (
        /*hasScrollingContent*/
        ctx2[10]
      ) {
        if (if_block3) {
        } else {
          if_block3 = create_if_block_311(ctx2);
          if_block3.c();
          if_block3.m(div2, t5);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (!/*passiveModal*/
      ctx2[5]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & /*passiveModal*/
          32) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block60(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div2, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*alert, passiveModal*/
      48 && div2_role_value !== (div2_role_value = /*alert*/
      ctx2[4] ? (
        /*passiveModal*/
        ctx2[5] ? "alert" : "alertdialog"
      ) : "dialog")) {
        attr_dev(div2, "role", div2_role_value);
      }
      if (!current || dirty[0] & /*alert, passiveModal, modalBodyId*/
      8388656 && div2_aria_describedby_value !== (div2_aria_describedby_value = /*alert*/
      ctx2[4] && !/*passiveModal*/
      ctx2[5] ? (
        /*modalBodyId*/
        ctx2[23]
      ) : void 0)) {
        attr_dev(div2, "aria-describedby", div2_aria_describedby_value);
      }
      if (!current || dirty[0] & /*ariaLabel*/
      4194304) {
        attr_dev(
          div2,
          "aria-label",
          /*ariaLabel*/
          ctx2[22]
        );
      }
      if (!current || dirty[0] & /*size*/
      4) {
        toggle_class(
          div2,
          "bx--modal-container--xs",
          /*size*/
          ctx2[2] === "xs"
        );
      }
      if (!current || dirty[0] & /*size*/
      4) {
        toggle_class(
          div2,
          "bx--modal-container--sm",
          /*size*/
          ctx2[2] === "sm"
        );
      }
      if (!current || dirty[0] & /*size*/
      4) {
        toggle_class(
          div2,
          "bx--modal-container--lg",
          /*size*/
          ctx2[2] === "lg"
        );
      }
      set_attributes(div3, div_data_3 = get_spread_update(div3_levels, [
        { role: "presentation" },
        (!current || dirty[0] & /*id*/
        262144) && { id: (
          /*id*/
          ctx2[18]
        ) },
        dirty[0] & /*$$restProps*/
        268435456 && /*$$restProps*/
        ctx2[28]
      ]));
      toggle_class(div3, "bx--modal", true);
      toggle_class(div3, "bx--modal-tall", !/*passiveModal*/
      ctx2[5]);
      toggle_class(
        div3,
        "is-visible",
        /*open*/
        ctx2[0]
      );
      toggle_class(
        div3,
        "bx--modal--danger",
        /*danger*/
        ctx2[3]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(heading_slot_or_fallback, local);
      transition_in(if_block2);
      transition_in(default_slot, local);
      transition_in(if_block4);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(heading_slot_or_fallback, local);
      transition_out(if_block2);
      transition_out(default_slot, local);
      transition_out(if_block4);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (heading_slot_or_fallback) heading_slot_or_fallback.d(detaching);
      if (if_block2) if_block2.d();
      if (default_slot) default_slot.d(detaching);
      if (if_block3) if_block3.d();
      if (if_block4) if_block4.d();
      ctx[44](null);
      ctx[46](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment102.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance102($$self, $$props, $$invalidate) {
  let modalLabelId;
  let modalHeadingId;
  let modalBodyId;
  let ariaLabel;
  const omit_props_names = [
    "size",
    "open",
    "danger",
    "alert",
    "passiveModal",
    "modalHeading",
    "modalLabel",
    "modalAriaLabel",
    "iconDescription",
    "hasForm",
    "hasScrollingContent",
    "primaryButtonText",
    "primaryButtonDisabled",
    "primaryButtonIcon",
    "shouldSubmitOnEnter",
    "secondaryButtonText",
    "secondaryButtons",
    "selectorPrimaryFocus",
    "preventCloseOnClickOutside",
    "id",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $openStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, ["label", "heading", "default"]);
  let { size = void 0 } = $$props;
  let { open = false } = $$props;
  let { danger = false } = $$props;
  let { alert = false } = $$props;
  let { passiveModal = false } = $$props;
  let { modalHeading = void 0 } = $$props;
  let { modalLabel = void 0 } = $$props;
  let { modalAriaLabel = void 0 } = $$props;
  let { iconDescription = "Close the modal" } = $$props;
  let { hasForm = false } = $$props;
  let { hasScrollingContent = false } = $$props;
  let { primaryButtonText = "" } = $$props;
  let { primaryButtonDisabled = false } = $$props;
  let { primaryButtonIcon = void 0 } = $$props;
  let { shouldSubmitOnEnter = true } = $$props;
  let { secondaryButtonText = "" } = $$props;
  let { secondaryButtons = [] } = $$props;
  let { selectorPrimaryFocus = "[data-modal-primary-focus]" } = $$props;
  let { preventCloseOnClickOutside = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let buttonRef = null;
  let innerModal = null;
  let opened = false;
  let didClickInnerModal = false;
  function focus(element2) {
    const node = (element2 || innerModal).querySelector(selectorPrimaryFocus) || buttonRef;
    node.focus();
  }
  const openStore = writable(open);
  validate_store(openStore, "openStore");
  component_subscribe($$self, openStore, (value) => $$invalidate(52, $openStore = value));
  trackModal(openStore);
  afterUpdate(() => {
    if (opened) {
      if (!open) {
        opened = false;
        dispatch("close");
      }
    } else if (open) {
      opened = true;
      focus();
      dispatch("open");
    }
  });
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function button_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonRef = $$value;
      $$invalidate(19, buttonRef);
    });
  }
  const click_handler_13 = () => {
    $$invalidate(0, open = false);
  };
  function button_1_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonRef = $$value;
      $$invalidate(19, buttonRef);
    });
  }
  const click_handler_2 = () => {
    $$invalidate(0, open = false);
  };
  const click_handler_3 = (button) => {
    dispatch("click:button--secondary", { text: button.text });
  };
  const click_handler_4 = () => {
    dispatch("click:button--secondary", { text: secondaryButtonText });
  };
  const click_handler_5 = () => {
    dispatch("submit");
    dispatch("click:button--primary");
  };
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerModal = $$value;
      $$invalidate(20, innerModal);
    });
  }
  const click_handler_6 = () => {
    $$invalidate(21, didClickInnerModal = true);
  };
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const keydown_handler_12 = (e) => {
    if (open) {
      if (e.key === "Escape") {
        $$invalidate(0, open = false);
      } else if (e.key === "Tab") {
        const selectorTabbable = `
  a[href], area[href], input:not([disabled]):not([tabindex='-1']),
  button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),
  textarea:not([disabled]):not([tabindex='-1']),
  iframe, object, embed, *[tabindex]:not([tabindex='-1']):not([disabled]), *[contenteditable=true]
`;
        const tabbable = Array.from(ref.querySelectorAll(selectorTabbable));
        let index = tabbable.indexOf(document.activeElement);
        if (index === -1 && e.shiftKey) index = 0;
        index += tabbable.length + (e.shiftKey ? -1 : 1);
        index %= tabbable.length;
        tabbable[index].focus();
        e.preventDefault();
      } else if (shouldSubmitOnEnter && e.key === "Enter" && !primaryButtonDisabled) {
        dispatch("submit");
        dispatch("click:button--primary");
      }
    }
  };
  const click_handler_7 = () => {
    if (!didClickInnerModal && !preventCloseOnClickOutside) $$invalidate(0, open = false);
    $$invalidate(21, didClickInnerModal = false);
  };
  const transitionend_handler = (e) => {
    if (e.propertyName === "transform") {
      dispatch("transitionend", { open });
    }
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(54, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(28, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(2, size = $$new_props.size);
    if ("open" in $$new_props) $$invalidate(0, open = $$new_props.open);
    if ("danger" in $$new_props) $$invalidate(3, danger = $$new_props.danger);
    if ("alert" in $$new_props) $$invalidate(4, alert = $$new_props.alert);
    if ("passiveModal" in $$new_props) $$invalidate(5, passiveModal = $$new_props.passiveModal);
    if ("modalHeading" in $$new_props) $$invalidate(6, modalHeading = $$new_props.modalHeading);
    if ("modalLabel" in $$new_props) $$invalidate(7, modalLabel = $$new_props.modalLabel);
    if ("modalAriaLabel" in $$new_props) $$invalidate(29, modalAriaLabel = $$new_props.modalAriaLabel);
    if ("iconDescription" in $$new_props) $$invalidate(8, iconDescription = $$new_props.iconDescription);
    if ("hasForm" in $$new_props) $$invalidate(9, hasForm = $$new_props.hasForm);
    if ("hasScrollingContent" in $$new_props) $$invalidate(10, hasScrollingContent = $$new_props.hasScrollingContent);
    if ("primaryButtonText" in $$new_props) $$invalidate(11, primaryButtonText = $$new_props.primaryButtonText);
    if ("primaryButtonDisabled" in $$new_props) $$invalidate(12, primaryButtonDisabled = $$new_props.primaryButtonDisabled);
    if ("primaryButtonIcon" in $$new_props) $$invalidate(13, primaryButtonIcon = $$new_props.primaryButtonIcon);
    if ("shouldSubmitOnEnter" in $$new_props) $$invalidate(14, shouldSubmitOnEnter = $$new_props.shouldSubmitOnEnter);
    if ("secondaryButtonText" in $$new_props) $$invalidate(15, secondaryButtonText = $$new_props.secondaryButtonText);
    if ("secondaryButtons" in $$new_props) $$invalidate(16, secondaryButtons = $$new_props.secondaryButtons);
    if ("selectorPrimaryFocus" in $$new_props) $$invalidate(30, selectorPrimaryFocus = $$new_props.selectorPrimaryFocus);
    if ("preventCloseOnClickOutside" in $$new_props) $$invalidate(17, preventCloseOnClickOutside = $$new_props.preventCloseOnClickOutside);
    if ("id" in $$new_props) $$invalidate(18, id = $$new_props.id);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(50, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    open,
    danger,
    alert,
    passiveModal,
    modalHeading,
    modalLabel,
    modalAriaLabel,
    iconDescription,
    hasForm,
    hasScrollingContent,
    primaryButtonText,
    primaryButtonDisabled,
    primaryButtonIcon,
    shouldSubmitOnEnter,
    secondaryButtonText,
    secondaryButtons,
    selectorPrimaryFocus,
    preventCloseOnClickOutside,
    id,
    ref,
    createEventDispatcher,
    afterUpdate,
    Close: Close_default,
    Button: Button_default,
    trackModal,
    writable,
    dispatch,
    buttonRef,
    innerModal,
    opened,
    didClickInnerModal,
    focus,
    openStore,
    ariaLabel,
    modalBodyId,
    modalHeadingId,
    modalLabelId,
    $openStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(54, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(2, size = $$new_props.size);
    if ("open" in $$props) $$invalidate(0, open = $$new_props.open);
    if ("danger" in $$props) $$invalidate(3, danger = $$new_props.danger);
    if ("alert" in $$props) $$invalidate(4, alert = $$new_props.alert);
    if ("passiveModal" in $$props) $$invalidate(5, passiveModal = $$new_props.passiveModal);
    if ("modalHeading" in $$props) $$invalidate(6, modalHeading = $$new_props.modalHeading);
    if ("modalLabel" in $$props) $$invalidate(7, modalLabel = $$new_props.modalLabel);
    if ("modalAriaLabel" in $$props) $$invalidate(29, modalAriaLabel = $$new_props.modalAriaLabel);
    if ("iconDescription" in $$props) $$invalidate(8, iconDescription = $$new_props.iconDescription);
    if ("hasForm" in $$props) $$invalidate(9, hasForm = $$new_props.hasForm);
    if ("hasScrollingContent" in $$props) $$invalidate(10, hasScrollingContent = $$new_props.hasScrollingContent);
    if ("primaryButtonText" in $$props) $$invalidate(11, primaryButtonText = $$new_props.primaryButtonText);
    if ("primaryButtonDisabled" in $$props) $$invalidate(12, primaryButtonDisabled = $$new_props.primaryButtonDisabled);
    if ("primaryButtonIcon" in $$props) $$invalidate(13, primaryButtonIcon = $$new_props.primaryButtonIcon);
    if ("shouldSubmitOnEnter" in $$props) $$invalidate(14, shouldSubmitOnEnter = $$new_props.shouldSubmitOnEnter);
    if ("secondaryButtonText" in $$props) $$invalidate(15, secondaryButtonText = $$new_props.secondaryButtonText);
    if ("secondaryButtons" in $$props) $$invalidate(16, secondaryButtons = $$new_props.secondaryButtons);
    if ("selectorPrimaryFocus" in $$props) $$invalidate(30, selectorPrimaryFocus = $$new_props.selectorPrimaryFocus);
    if ("preventCloseOnClickOutside" in $$props) $$invalidate(17, preventCloseOnClickOutside = $$new_props.preventCloseOnClickOutside);
    if ("id" in $$props) $$invalidate(18, id = $$new_props.id);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("buttonRef" in $$props) $$invalidate(19, buttonRef = $$new_props.buttonRef);
    if ("innerModal" in $$props) $$invalidate(20, innerModal = $$new_props.innerModal);
    if ("opened" in $$props) opened = $$new_props.opened;
    if ("didClickInnerModal" in $$props) $$invalidate(21, didClickInnerModal = $$new_props.didClickInnerModal);
    if ("ariaLabel" in $$props) $$invalidate(22, ariaLabel = $$new_props.ariaLabel);
    if ("modalBodyId" in $$props) $$invalidate(23, modalBodyId = $$new_props.modalBodyId);
    if ("modalHeadingId" in $$props) $$invalidate(24, modalHeadingId = $$new_props.modalHeadingId);
    if ("modalLabelId" in $$props) $$invalidate(25, modalLabelId = $$new_props.modalLabelId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*open*/
    1) {
      $: set_store_value(openStore, $openStore = open, $openStore);
    }
    if ($$self.$$.dirty[0] & /*id*/
    262144) {
      $: $$invalidate(25, modalLabelId = `bx--modal-header__label--modal-${id}`);
    }
    if ($$self.$$.dirty[0] & /*id*/
    262144) {
      $: $$invalidate(24, modalHeadingId = `bx--modal-header__heading--modal-${id}`);
    }
    if ($$self.$$.dirty[0] & /*id*/
    262144) {
      $: $$invalidate(23, modalBodyId = `bx--modal-body--${id}`);
    }
    $: $$invalidate(22, ariaLabel = modalLabel || $$props["aria-label"] || modalAriaLabel || modalHeading);
  };
  $$props = exclude_internal_props($$props);
  return [
    open,
    ref,
    size,
    danger,
    alert,
    passiveModal,
    modalHeading,
    modalLabel,
    iconDescription,
    hasForm,
    hasScrollingContent,
    primaryButtonText,
    primaryButtonDisabled,
    primaryButtonIcon,
    shouldSubmitOnEnter,
    secondaryButtonText,
    secondaryButtons,
    preventCloseOnClickOutside,
    id,
    buttonRef,
    innerModal,
    didClickInnerModal,
    ariaLabel,
    modalBodyId,
    modalHeadingId,
    modalLabelId,
    dispatch,
    openStore,
    $$restProps,
    modalAriaLabel,
    selectorPrimaryFocus,
    slots,
    keydown_handler,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    button_1_binding,
    click_handler_13,
    button_1_binding_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    div2_binding,
    click_handler_6,
    div3_binding,
    keydown_handler_12,
    click_handler_7,
    transitionend_handler,
    $$scope
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance102,
      create_fragment102,
      safe_not_equal,
      {
        size: 2,
        open: 0,
        danger: 3,
        alert: 4,
        passiveModal: 5,
        modalHeading: 6,
        modalLabel: 7,
        modalAriaLabel: 29,
        iconDescription: 8,
        hasForm: 9,
        hasScrollingContent: 10,
        primaryButtonText: 11,
        primaryButtonDisabled: 12,
        primaryButtonIcon: 13,
        shouldSubmitOnEnter: 14,
        secondaryButtonText: 15,
        secondaryButtons: 16,
        selectorPrimaryFocus: 30,
        preventCloseOnClickOutside: 17,
        id: 18,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment102.name
    });
  }
  get size() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get danger() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set danger(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alert() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alert(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get passiveModal() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set passiveModal(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get modalHeading() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set modalHeading(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get modalLabel() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set modalLabel(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get modalAriaLabel() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set modalAriaLabel(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasForm() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasForm(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasScrollingContent() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasScrollingContent(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryButtonText() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryButtonText(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryButtonDisabled() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryButtonDisabled(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryButtonIcon() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryButtonIcon(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldSubmitOnEnter() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldSubmitOnEnter(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryButtonText() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryButtonText(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryButtons() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryButtons(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectorPrimaryFocus() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectorPrimaryFocus(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventCloseOnClickOutside() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventCloseOnClickOutside(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// node_modules/carbon-components-svelte/src/Notification/NotificationButton.svelte
var file96 = "node_modules/carbon-components-svelte/src/Notification/NotificationButton.svelte";
function create_fragment103(ctx) {
  let button;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*icon*/
    ctx[1]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        size: 20,
        title: (
          /*title*/
          ctx2[2]
        ),
        class: (
          /*notificationType*/
          (ctx2[0] === "toast" && "bx--toast-notification__close-icon") + " " + /*notificationType*/
          (ctx2[0] === "inline" && "bx--inline-notification__close-icon")
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  let button_levels = [
    { type: "button" },
    { "aria-label": (
      /*iconDescription*/
      ctx[3]
    ) },
    { title: (
      /*iconDescription*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (switch_instance) create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        title: true
      });
      var button_nodes = children(button);
      if (switch_instance) claim_component(switch_instance.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      toggle_class(
        button,
        "bx--toast-notification__close-button",
        /*notificationType*/
        ctx[0] === "toast"
      );
      toggle_class(
        button,
        "bx--inline-notification__close-button",
        /*notificationType*/
        ctx[0] === "inline"
      );
      add_location(button, file96, 26, 0, 563);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (switch_instance) mount_component(switch_instance, button, null);
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseover",
            /*mouseover_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*icon*/
      2 && switch_value !== (switch_value = /*icon*/
      ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, button, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*title*/
        4) switch_instance_changes.title = /*title*/
        ctx2[2];
        if (dirty & /*notificationType*/
        1) switch_instance_changes.class = /*notificationType*/
        (ctx2[0] === "toast" && "bx--toast-notification__close-icon") + " " + /*notificationType*/
        (ctx2[0] === "inline" && "bx--inline-notification__close-icon");
        switch_instance.$set(switch_instance_changes);
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & /*iconDescription*/
        8) && { "aria-label": (
          /*iconDescription*/
          ctx2[3]
        ) },
        (!current || dirty & /*iconDescription*/
        8) && { title: (
          /*iconDescription*/
          ctx2[3]
        ) },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
      toggle_class(
        button,
        "bx--toast-notification__close-button",
        /*notificationType*/
        ctx2[0] === "toast"
      );
      toggle_class(
        button,
        "bx--inline-notification__close-button",
        /*notificationType*/
        ctx2[0] === "inline"
      );
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (switch_instance) destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment103.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance103($$self, $$props, $$invalidate) {
  const omit_props_names = ["notificationType", "icon", "title", "iconDescription"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NotificationButton", slots, []);
  let { notificationType = "toast" } = $$props;
  let { icon = Close_default } = $$props;
  let { title = void 0 } = $$props;
  let { iconDescription = "Close icon" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("notificationType" in $$new_props) $$invalidate(0, notificationType = $$new_props.notificationType);
    if ("icon" in $$new_props) $$invalidate(1, icon = $$new_props.icon);
    if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    if ("iconDescription" in $$new_props) $$invalidate(3, iconDescription = $$new_props.iconDescription);
  };
  $$self.$capture_state = () => ({
    notificationType,
    icon,
    title,
    iconDescription,
    Close: Close_default
  });
  $$self.$inject_state = ($$new_props) => {
    if ("notificationType" in $$props) $$invalidate(0, notificationType = $$new_props.notificationType);
    if ("icon" in $$props) $$invalidate(1, icon = $$new_props.icon);
    if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    if ("iconDescription" in $$props) $$invalidate(3, iconDescription = $$new_props.iconDescription);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    notificationType,
    icon,
    title,
    iconDescription,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var NotificationButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance103, create_fragment103, safe_not_equal, {
      notificationType: 0,
      icon: 1,
      title: 2,
      iconDescription: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NotificationButton",
      options,
      id: create_fragment103.name
    });
  }
  get notificationType() {
    throw new Error("<NotificationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notificationType(value) {
    throw new Error("<NotificationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<NotificationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<NotificationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<NotificationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<NotificationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<NotificationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<NotificationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NotificationButton_default = NotificationButton;

// node_modules/carbon-components-svelte/src/icons/InformationFilled.svelte
var file97 = "node_modules/carbon-components-svelte/src/icons/InformationFilled.svelte";
function create_if_block61(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file97, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block61.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment104(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block61(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", {
        fill: true,
        d: true,
        "data-icon-path": true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "fill", "none");
      attr_dev(path0, "d", "M16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,13.875H17.125v-8H13v2.25h1.875v5.75H12v2.25h8Z");
      attr_dev(path0, "data-icon-path", "inner-path");
      add_location(path0, file97, 24, 2, 579);
      attr_dev(path1, "d", "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,6a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,16.125H12v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z");
      add_location(path1, file97, 27, 39, 745);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file97, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block61(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment104.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance104($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InformationFilled", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var InformationFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance104, create_fragment104, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InformationFilled",
      options,
      id: create_fragment104.name
    });
  }
  get size() {
    throw new Error("<InformationFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<InformationFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<InformationFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<InformationFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InformationFilled_default = InformationFilled;

// node_modules/carbon-components-svelte/src/icons/InformationSquareFilled.svelte
var file98 = "node_modules/carbon-components-svelte/src/icons/InformationSquareFilled.svelte";
function create_if_block62(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file98, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block62.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment105(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block62(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", {
        fill: true,
        d: true,
        "data-icon-path": true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "fill", "none");
      attr_dev(path0, "d", "M16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,13.875H17.125v-8H13v2.25h1.875v5.75H12v2.25h8Z");
      attr_dev(path0, "data-icon-path", "inner-path");
      add_location(path0, file98, 24, 2, 579);
      attr_dev(path1, "d", "M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,16.125H12v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z");
      add_location(path1, file98, 27, 39, 745);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file98, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block62(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment105.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance105($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InformationSquareFilled", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var InformationSquareFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance105, create_fragment105, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InformationSquareFilled",
      options,
      id: create_fragment105.name
    });
  }
  get size() {
    throw new Error("<InformationSquareFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<InformationSquareFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<InformationSquareFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<InformationSquareFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InformationSquareFilled_default = InformationSquareFilled;

// node_modules/carbon-components-svelte/src/Notification/NotificationIcon.svelte
function create_fragment106(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icons*/
    ctx[3][
      /*kind*/
      ctx[0]
    ]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        size: 20,
        title: (
          /*iconDescription*/
          ctx2[2]
        ),
        class: (
          /*notificationType*/
          (ctx2[1] === "toast" && "bx--toast-notification__icon") + " " + /*notificationType*/
          (ctx2[1] === "inline" && "bx--inline-notification__icon")
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*kind*/
      1 && switch_value !== (switch_value = /*icons*/
      ctx2[3][
        /*kind*/
        ctx2[0]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*iconDescription*/
        4) switch_instance_changes.title = /*iconDescription*/
        ctx2[2];
        if (dirty & /*notificationType*/
        2) switch_instance_changes.class = /*notificationType*/
        (ctx2[1] === "toast" && "bx--toast-notification__icon") + " " + /*notificationType*/
        (ctx2[1] === "inline" && "bx--inline-notification__icon");
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment106.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance106($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NotificationIcon", slots, []);
  let { kind = "error" } = $$props;
  let { notificationType = "toast" } = $$props;
  let { iconDescription } = $$props;
  const icons = {
    error: ErrorFilled_default,
    "info-square": InformationSquareFilled_default,
    info: InformationFilled_default,
    success: CheckmarkFilled_default,
    warning: WarningFilled_default,
    "warning-alt": WarningAltFilled_default
  };
  $$self.$$.on_mount.push(function() {
    if (iconDescription === void 0 && !("iconDescription" in $$props || $$self.$$.bound[$$self.$$.props["iconDescription"]])) {
      console.warn("<NotificationIcon> was created without expected prop 'iconDescription'");
    }
  });
  const writable_props = ["kind", "notificationType", "iconDescription"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<NotificationIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("kind" in $$props2) $$invalidate(0, kind = $$props2.kind);
    if ("notificationType" in $$props2) $$invalidate(1, notificationType = $$props2.notificationType);
    if ("iconDescription" in $$props2) $$invalidate(2, iconDescription = $$props2.iconDescription);
  };
  $$self.$capture_state = () => ({
    kind,
    notificationType,
    iconDescription,
    CheckmarkFilled: CheckmarkFilled_default,
    ErrorFilled: ErrorFilled_default,
    InformationFilled: InformationFilled_default,
    InformationSquareFilled: InformationSquareFilled_default,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    icons
  });
  $$self.$inject_state = ($$props2) => {
    if ("kind" in $$props2) $$invalidate(0, kind = $$props2.kind);
    if ("notificationType" in $$props2) $$invalidate(1, notificationType = $$props2.notificationType);
    if ("iconDescription" in $$props2) $$invalidate(2, iconDescription = $$props2.iconDescription);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [kind, notificationType, iconDescription, icons];
}
var NotificationIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance106, create_fragment106, safe_not_equal, {
      kind: 0,
      notificationType: 1,
      iconDescription: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NotificationIcon",
      options,
      id: create_fragment106.name
    });
  }
  get kind() {
    throw new Error("<NotificationIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<NotificationIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notificationType() {
    throw new Error("<NotificationIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notificationType(value) {
    throw new Error("<NotificationIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<NotificationIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<NotificationIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NotificationIcon_default = NotificationIcon;

// node_modules/carbon-components-svelte/src/Notification/ToastNotification.svelte
var file99 = "node_modules/carbon-components-svelte/src/Notification/ToastNotification.svelte";
var get_caption_slot_changes = (dirty) => ({});
var get_caption_slot_context = (ctx) => ({});
var get_subtitle_slot_changes = (dirty) => ({});
var get_subtitle_slot_context = (ctx) => ({});
var get_title_slot_changes3 = (dirty) => ({});
var get_title_slot_context3 = (ctx) => ({});
function create_if_block63(ctx) {
  let div3;
  let notificationicon;
  let t0;
  let div2;
  let h3;
  let t1;
  let div0;
  let t2;
  let div1;
  let t3;
  let t4;
  let current;
  let mounted;
  let dispose;
  notificationicon = new NotificationIcon_default({
    props: {
      kind: (
        /*kind*/
        ctx[0]
      ),
      iconDescription: (
        /*statusIconDescription*/
        ctx[6]
      )
    },
    $$inline: true
  });
  const title_slot_template = (
    /*#slots*/
    ctx[16].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_title_slot_context3
  );
  const title_slot_or_fallback = title_slot || fallback_block_24(ctx);
  const subtitle_slot_template = (
    /*#slots*/
    ctx[16].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_subtitle_slot_context
  );
  const subtitle_slot_or_fallback = subtitle_slot || fallback_block_110(ctx);
  const caption_slot_template = (
    /*#slots*/
    ctx[16].caption
  );
  const caption_slot = create_slot(
    caption_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_caption_slot_context
  );
  const caption_slot_or_fallback = caption_slot || fallback_block21(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  let if_block = !/*hideCloseButton*/
  ctx[8] && create_if_block_125(ctx);
  let div3_levels = [
    { role: (
      /*role*/
      ctx[2]
    ) },
    { kind: (
      /*kind*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[12]
  ];
  let div_data_3 = {};
  for (let i = 0; i < div3_levels.length; i += 1) {
    div_data_3 = assign(div_data_3, div3_levels[i]);
  }
  const block = {
    c: function create() {
      div3 = element("div");
      create_component(notificationicon.$$.fragment);
      t0 = space();
      div2 = element("div");
      h3 = element("h3");
      if (title_slot_or_fallback) title_slot_or_fallback.c();
      t1 = space();
      div0 = element("div");
      if (subtitle_slot_or_fallback) subtitle_slot_or_fallback.c();
      t2 = space();
      div1 = element("div");
      if (caption_slot_or_fallback) caption_slot_or_fallback.c();
      t3 = space();
      if (default_slot) default_slot.c();
      t4 = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { role: true, kind: true });
      var div3_nodes = children(div3);
      claim_component(notificationicon.$$.fragment, div3_nodes);
      t0 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", {});
      var div2_nodes = children(div2);
      h3 = claim_element(div2_nodes, "H3", {});
      var h3_nodes = children(h3);
      if (title_slot_or_fallback) title_slot_or_fallback.l(h3_nodes);
      h3_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div0 = claim_element(div2_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (subtitle_slot_or_fallback) subtitle_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", {});
      var div1_nodes = children(div1);
      if (caption_slot_or_fallback) caption_slot_or_fallback.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div2_nodes);
      if (default_slot) default_slot.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      t4 = claim_space(div3_nodes);
      if (if_block) if_block.l(div3_nodes);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(h3, "bx--toast-notification__title", true);
      add_location(h3, file99, 113, 6, 3170);
      toggle_class(div0, "bx--toast-notification__subtitle", true);
      add_location(div0, file99, 116, 6, 3280);
      toggle_class(div1, "bx--toast-notification__caption", true);
      add_location(div1, file99, 119, 6, 3401);
      toggle_class(div2, "bx--toast-notification__details", true);
      add_location(div2, file99, 112, 4, 3111);
      set_attributes(div3, div_data_3);
      toggle_class(div3, "bx--toast-notification", true);
      toggle_class(
        div3,
        "bx--toast-notification--low-contrast",
        /*lowContrast*/
        ctx[1]
      );
      toggle_class(
        div3,
        "bx--toast-notification--error",
        /*kind*/
        ctx[0] === "error"
      );
      toggle_class(
        div3,
        "bx--toast-notification--info",
        /*kind*/
        ctx[0] === "info"
      );
      toggle_class(
        div3,
        "bx--toast-notification--info-square",
        /*kind*/
        ctx[0] === "info-square"
      );
      toggle_class(
        div3,
        "bx--toast-notification--success",
        /*kind*/
        ctx[0] === "success"
      );
      toggle_class(
        div3,
        "bx--toast-notification--warning",
        /*kind*/
        ctx[0] === "warning"
      );
      toggle_class(
        div3,
        "bx--toast-notification--warning-alt",
        /*kind*/
        ctx[0] === "warning-alt"
      );
      set_style(
        div3,
        "width",
        /*fullWidth*/
        ctx[9] ? "100%" : void 0
      );
      add_location(div3, file99, 93, 2, 2342);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      mount_component(notificationicon, div3, null);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, h3);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(h3, null);
      }
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div0);
      if (subtitle_slot_or_fallback) {
        subtitle_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(div2, t2);
      append_hydration_dev(div2, div1);
      if (caption_slot_or_fallback) {
        caption_slot_or_fallback.m(div1, null);
      }
      append_hydration_dev(div2, t3);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      append_hydration_dev(div3, t4);
      if (if_block) if_block.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div3,
            "click",
            /*click_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "mouseover",
            /*mouseover_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const notificationicon_changes = {};
      if (dirty & /*kind*/
      1) notificationicon_changes.kind = /*kind*/
      ctx2[0];
      if (dirty & /*statusIconDescription*/
      64) notificationicon_changes.iconDescription = /*statusIconDescription*/
      ctx2[6];
      notificationicon.$set(notificationicon_changes);
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_title_slot_changes3
            ),
            get_title_slot_context3
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & /*title*/
        8)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_subtitle_slot_changes
            ),
            get_subtitle_slot_context
          );
        }
      } else {
        if (subtitle_slot_or_fallback && subtitle_slot_or_fallback.p && (!current || dirty & /*subtitle*/
        16)) {
          subtitle_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (caption_slot) {
        if (caption_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            caption_slot,
            caption_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              caption_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_caption_slot_changes
            ),
            get_caption_slot_context
          );
        }
      } else {
        if (caption_slot_or_fallback && caption_slot_or_fallback.p && (!current || dirty & /*caption*/
        32)) {
          caption_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!/*hideCloseButton*/
      ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*hideCloseButton*/
          256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_125(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div3, div_data_3 = get_spread_update(div3_levels, [
        (!current || dirty & /*role*/
        4) && { role: (
          /*role*/
          ctx2[2]
        ) },
        (!current || dirty & /*kind*/
        1) && { kind: (
          /*kind*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12]
      ]));
      toggle_class(div3, "bx--toast-notification", true);
      toggle_class(
        div3,
        "bx--toast-notification--low-contrast",
        /*lowContrast*/
        ctx2[1]
      );
      toggle_class(
        div3,
        "bx--toast-notification--error",
        /*kind*/
        ctx2[0] === "error"
      );
      toggle_class(
        div3,
        "bx--toast-notification--info",
        /*kind*/
        ctx2[0] === "info"
      );
      toggle_class(
        div3,
        "bx--toast-notification--info-square",
        /*kind*/
        ctx2[0] === "info-square"
      );
      toggle_class(
        div3,
        "bx--toast-notification--success",
        /*kind*/
        ctx2[0] === "success"
      );
      toggle_class(
        div3,
        "bx--toast-notification--warning",
        /*kind*/
        ctx2[0] === "warning"
      );
      toggle_class(
        div3,
        "bx--toast-notification--warning-alt",
        /*kind*/
        ctx2[0] === "warning-alt"
      );
      set_style(
        div3,
        "width",
        /*fullWidth*/
        ctx2[9] ? "100%" : void 0
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(notificationicon.$$.fragment, local);
      transition_in(title_slot_or_fallback, local);
      transition_in(subtitle_slot_or_fallback, local);
      transition_in(caption_slot_or_fallback, local);
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(notificationicon.$$.fragment, local);
      transition_out(title_slot_or_fallback, local);
      transition_out(subtitle_slot_or_fallback, local);
      transition_out(caption_slot_or_fallback, local);
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      destroy_component(notificationicon);
      if (title_slot_or_fallback) title_slot_or_fallback.d(detaching);
      if (subtitle_slot_or_fallback) subtitle_slot_or_fallback.d(detaching);
      if (caption_slot_or_fallback) caption_slot_or_fallback.d(detaching);
      if (default_slot) default_slot.d(detaching);
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block63.name,
    type: "if",
    source: "(93:0) {#if open}",
    ctx
  });
  return block;
}
function fallback_block_24(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*title*/
        ctx[3]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*title*/
        ctx[3]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      8) set_data_dev(
        t,
        /*title*/
        ctx2[3]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_24.name,
    type: "fallback",
    source: "(115:27) {title}",
    ctx
  });
  return block;
}
function fallback_block_110(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*subtitle*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*subtitle*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*subtitle*/
      16) set_data_dev(
        t,
        /*subtitle*/
        ctx2[4]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_110.name,
    type: "fallback",
    source: "(118:30) {subtitle}",
    ctx
  });
  return block;
}
function fallback_block21(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*caption*/
        ctx[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*caption*/
        ctx[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*caption*/
      32) set_data_dev(
        t,
        /*caption*/
        ctx2[5]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block21.name,
    type: "fallback",
    source: "(121:29) {caption}",
    ctx
  });
  return block;
}
function create_if_block_125(ctx) {
  let notificationbutton;
  let current;
  notificationbutton = new NotificationButton_default({
    props: {
      iconDescription: (
        /*closeButtonDescription*/
        ctx[7]
      )
    },
    $$inline: true
  });
  notificationbutton.$on(
    "click",
    /*close*/
    ctx[11]
  );
  const block = {
    c: function create() {
      create_component(notificationbutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(notificationbutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(notificationbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const notificationbutton_changes = {};
      if (dirty & /*closeButtonDescription*/
      128) notificationbutton_changes.iconDescription = /*closeButtonDescription*/
      ctx2[7];
      notificationbutton.$set(notificationbutton_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(notificationbutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(notificationbutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(notificationbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_125.name,
    type: "if",
    source: "(125:4) {#if !hideCloseButton}",
    ctx
  });
  return block;
}
function create_fragment107(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*open*/
    ctx[10] && create_if_block63(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*open*/
        ctx2[10]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block63(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment107.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance107($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "kind",
    "lowContrast",
    "timeout",
    "role",
    "title",
    "subtitle",
    "caption",
    "statusIconDescription",
    "closeButtonDescription",
    "hideCloseButton",
    "fullWidth"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToastNotification", slots, ["title", "subtitle", "caption", "default"]);
  let { kind = "error" } = $$props;
  let { lowContrast = false } = $$props;
  let { timeout = 0 } = $$props;
  let { role = "alert" } = $$props;
  let { title = "" } = $$props;
  let { subtitle = "" } = $$props;
  let { caption = "" } = $$props;
  let { statusIconDescription = kind + " icon" } = $$props;
  let { closeButtonDescription = "Close notification" } = $$props;
  let { hideCloseButton = false } = $$props;
  let { fullWidth = false } = $$props;
  const dispatch = createEventDispatcher();
  let open = true;
  let timeoutId = void 0;
  function close(closeFromTimeout) {
    clearTimeout(timeoutId);
    const shouldContinue = dispatch("close", { timeout: closeFromTimeout === true }, { cancelable: true });
    if (shouldContinue) {
      $$invalidate(10, open = false);
    }
  }
  onMount(() => {
    return () => {
      clearTimeout(timeoutId);
    };
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("kind" in $$new_props) $$invalidate(0, kind = $$new_props.kind);
    if ("lowContrast" in $$new_props) $$invalidate(1, lowContrast = $$new_props.lowContrast);
    if ("timeout" in $$new_props) $$invalidate(13, timeout = $$new_props.timeout);
    if ("role" in $$new_props) $$invalidate(2, role = $$new_props.role);
    if ("title" in $$new_props) $$invalidate(3, title = $$new_props.title);
    if ("subtitle" in $$new_props) $$invalidate(4, subtitle = $$new_props.subtitle);
    if ("caption" in $$new_props) $$invalidate(5, caption = $$new_props.caption);
    if ("statusIconDescription" in $$new_props) $$invalidate(6, statusIconDescription = $$new_props.statusIconDescription);
    if ("closeButtonDescription" in $$new_props) $$invalidate(7, closeButtonDescription = $$new_props.closeButtonDescription);
    if ("hideCloseButton" in $$new_props) $$invalidate(8, hideCloseButton = $$new_props.hideCloseButton);
    if ("fullWidth" in $$new_props) $$invalidate(9, fullWidth = $$new_props.fullWidth);
    if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    kind,
    lowContrast,
    timeout,
    role,
    title,
    subtitle,
    caption,
    statusIconDescription,
    closeButtonDescription,
    hideCloseButton,
    fullWidth,
    createEventDispatcher,
    onMount,
    NotificationButton: NotificationButton_default,
    NotificationIcon: NotificationIcon_default,
    dispatch,
    open,
    timeoutId,
    close
  });
  $$self.$inject_state = ($$new_props) => {
    if ("kind" in $$props) $$invalidate(0, kind = $$new_props.kind);
    if ("lowContrast" in $$props) $$invalidate(1, lowContrast = $$new_props.lowContrast);
    if ("timeout" in $$props) $$invalidate(13, timeout = $$new_props.timeout);
    if ("role" in $$props) $$invalidate(2, role = $$new_props.role);
    if ("title" in $$props) $$invalidate(3, title = $$new_props.title);
    if ("subtitle" in $$props) $$invalidate(4, subtitle = $$new_props.subtitle);
    if ("caption" in $$props) $$invalidate(5, caption = $$new_props.caption);
    if ("statusIconDescription" in $$props) $$invalidate(6, statusIconDescription = $$new_props.statusIconDescription);
    if ("closeButtonDescription" in $$props) $$invalidate(7, closeButtonDescription = $$new_props.closeButtonDescription);
    if ("hideCloseButton" in $$props) $$invalidate(8, hideCloseButton = $$new_props.hideCloseButton);
    if ("fullWidth" in $$props) $$invalidate(9, fullWidth = $$new_props.fullWidth);
    if ("open" in $$props) $$invalidate(10, open = $$new_props.open);
    if ("timeoutId" in $$props) $$invalidate(14, timeoutId = $$new_props.timeoutId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*timeoutId, open, timeout*/
    25600) {
      $: if (typeof window !== "undefined") {
        clearTimeout(timeoutId);
        if (open && timeout) {
          $$invalidate(14, timeoutId = setTimeout(() => close(true), timeout));
        }
      }
    }
  };
  return [
    kind,
    lowContrast,
    role,
    title,
    subtitle,
    caption,
    statusIconDescription,
    closeButtonDescription,
    hideCloseButton,
    fullWidth,
    open,
    close,
    $$restProps,
    timeout,
    timeoutId,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var ToastNotification = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance107, create_fragment107, safe_not_equal, {
      kind: 0,
      lowContrast: 1,
      timeout: 13,
      role: 2,
      title: 3,
      subtitle: 4,
      caption: 5,
      statusIconDescription: 6,
      closeButtonDescription: 7,
      hideCloseButton: 8,
      fullWidth: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToastNotification",
      options,
      id: create_fragment107.name
    });
  }
  get kind() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lowContrast() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lowContrast(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get timeout() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set timeout(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caption() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caption(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get statusIconDescription() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set statusIconDescription(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeButtonDescription() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeButtonDescription(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideCloseButton() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideCloseButton(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullWidth() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullWidth(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToastNotification_default = ToastNotification;

// node_modules/carbon-components-svelte/src/Notification/InlineNotification.svelte
var file100 = "node_modules/carbon-components-svelte/src/Notification/InlineNotification.svelte";
var get_actions_slot_changes = (dirty) => ({});
var get_actions_slot_context = (ctx) => ({});
var get_subtitle_slot_changes2 = (dirty) => ({});
var get_subtitle_slot_context2 = (ctx) => ({});
var get_title_slot_changes4 = (dirty) => ({});
var get_title_slot_context4 = (ctx) => ({});
function create_if_block64(ctx) {
  let div3;
  let div2;
  let notificationicon;
  let t0;
  let div1;
  let p;
  let t1;
  let div0;
  let t2;
  let t3;
  let t4;
  let current;
  let mounted;
  let dispose;
  notificationicon = new NotificationIcon_default({
    props: {
      notificationType: "inline",
      kind: (
        /*kind*/
        ctx[0]
      ),
      iconDescription: (
        /*statusIconDescription*/
        ctx[6]
      )
    },
    $$inline: true
  });
  const title_slot_template = (
    /*#slots*/
    ctx[13].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_title_slot_context4
  );
  const title_slot_or_fallback = title_slot || fallback_block_111(ctx);
  const subtitle_slot_template = (
    /*#slots*/
    ctx[13].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_subtitle_slot_context2
  );
  const subtitle_slot_or_fallback = subtitle_slot || fallback_block22(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const actions_slot_template = (
    /*#slots*/
    ctx[13].actions
  );
  const actions_slot = create_slot(
    actions_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_actions_slot_context
  );
  let if_block = !/*hideCloseButton*/
  ctx[5] && create_if_block_126(ctx);
  let div3_levels = [
    { role: (
      /*role*/
      ctx[2]
    ) },
    { kind: (
      /*kind*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[10]
  ];
  let div_data_3 = {};
  for (let i = 0; i < div3_levels.length; i += 1) {
    div_data_3 = assign(div_data_3, div3_levels[i]);
  }
  const block = {
    c: function create() {
      div3 = element("div");
      div2 = element("div");
      create_component(notificationicon.$$.fragment);
      t0 = space();
      div1 = element("div");
      p = element("p");
      if (title_slot_or_fallback) title_slot_or_fallback.c();
      t1 = space();
      div0 = element("div");
      if (subtitle_slot_or_fallback) subtitle_slot_or_fallback.c();
      t2 = space();
      if (default_slot) default_slot.c();
      t3 = space();
      if (actions_slot) actions_slot.c();
      t4 = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { role: true, kind: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", {});
      var div2_nodes = children(div2);
      claim_component(notificationicon.$$.fragment, div2_nodes);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", {});
      var div1_nodes = children(div1);
      p = claim_element(div1_nodes, "P", {});
      var p_nodes = children(p);
      if (title_slot_or_fallback) title_slot_or_fallback.l(p_nodes);
      p_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (subtitle_slot_or_fallback) subtitle_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (default_slot) default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      t3 = claim_space(div3_nodes);
      if (actions_slot) actions_slot.l(div3_nodes);
      t4 = claim_space(div3_nodes);
      if (if_block) if_block.l(div3_nodes);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(p, "bx--inline-notification__title", true);
      add_location(p, file100, 96, 8, 2684);
      toggle_class(div0, "bx--inline-notification__subtitle", true);
      add_location(div0, file100, 99, 8, 2799);
      toggle_class(div1, "bx--inline-notification__text-wrapper", true);
      add_location(div1, file100, 95, 6, 2617);
      toggle_class(div2, "bx--inline-notification__details", true);
      add_location(div2, file100, 89, 4, 2418);
      set_attributes(div3, div_data_3);
      toggle_class(div3, "bx--inline-notification", true);
      toggle_class(
        div3,
        "bx--inline-notification--low-contrast",
        /*lowContrast*/
        ctx[1]
      );
      toggle_class(
        div3,
        "bx--inline-notification--hide-close-button",
        /*hideCloseButton*/
        ctx[5]
      );
      toggle_class(
        div3,
        "bx--inline-notification--error",
        /*kind*/
        ctx[0] === "error"
      );
      toggle_class(
        div3,
        "bx--inline-notification--info",
        /*kind*/
        ctx[0] === "info"
      );
      toggle_class(
        div3,
        "bx--inline-notification--info-square",
        /*kind*/
        ctx[0] === "info-square"
      );
      toggle_class(
        div3,
        "bx--inline-notification--success",
        /*kind*/
        ctx[0] === "success"
      );
      toggle_class(
        div3,
        "bx--inline-notification--warning",
        /*kind*/
        ctx[0] === "warning"
      );
      toggle_class(
        div3,
        "bx--inline-notification--warning-alt",
        /*kind*/
        ctx[0] === "warning-alt"
      );
      add_location(div3, file100, 71, 2, 1700);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div2);
      mount_component(notificationicon, div2, null);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, p);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(p, null);
      }
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      if (subtitle_slot_or_fallback) {
        subtitle_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(div1, t2);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_hydration_dev(div3, t3);
      if (actions_slot) {
        actions_slot.m(div3, null);
      }
      append_hydration_dev(div3, t4);
      if (if_block) if_block.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div3,
            "click",
            /*click_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "mouseover",
            /*mouseover_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const notificationicon_changes = {};
      if (dirty & /*kind*/
      1) notificationicon_changes.kind = /*kind*/
      ctx2[0];
      if (dirty & /*statusIconDescription*/
      64) notificationicon_changes.iconDescription = /*statusIconDescription*/
      ctx2[6];
      notificationicon.$set(notificationicon_changes);
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_title_slot_changes4
            ),
            get_title_slot_context4
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & /*title*/
        8)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_subtitle_slot_changes2
            ),
            get_subtitle_slot_context2
          );
        }
      } else {
        if (subtitle_slot_or_fallback && subtitle_slot_or_fallback.p && (!current || dirty & /*subtitle*/
        16)) {
          subtitle_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (actions_slot) {
        if (actions_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            actions_slot,
            actions_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              actions_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_actions_slot_changes
            ),
            get_actions_slot_context
          );
        }
      }
      if (!/*hideCloseButton*/
      ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*hideCloseButton*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_126(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div3, div_data_3 = get_spread_update(div3_levels, [
        (!current || dirty & /*role*/
        4) && { role: (
          /*role*/
          ctx2[2]
        ) },
        (!current || dirty & /*kind*/
        1) && { kind: (
          /*kind*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10]
      ]));
      toggle_class(div3, "bx--inline-notification", true);
      toggle_class(
        div3,
        "bx--inline-notification--low-contrast",
        /*lowContrast*/
        ctx2[1]
      );
      toggle_class(
        div3,
        "bx--inline-notification--hide-close-button",
        /*hideCloseButton*/
        ctx2[5]
      );
      toggle_class(
        div3,
        "bx--inline-notification--error",
        /*kind*/
        ctx2[0] === "error"
      );
      toggle_class(
        div3,
        "bx--inline-notification--info",
        /*kind*/
        ctx2[0] === "info"
      );
      toggle_class(
        div3,
        "bx--inline-notification--info-square",
        /*kind*/
        ctx2[0] === "info-square"
      );
      toggle_class(
        div3,
        "bx--inline-notification--success",
        /*kind*/
        ctx2[0] === "success"
      );
      toggle_class(
        div3,
        "bx--inline-notification--warning",
        /*kind*/
        ctx2[0] === "warning"
      );
      toggle_class(
        div3,
        "bx--inline-notification--warning-alt",
        /*kind*/
        ctx2[0] === "warning-alt"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(notificationicon.$$.fragment, local);
      transition_in(title_slot_or_fallback, local);
      transition_in(subtitle_slot_or_fallback, local);
      transition_in(default_slot, local);
      transition_in(actions_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(notificationicon.$$.fragment, local);
      transition_out(title_slot_or_fallback, local);
      transition_out(subtitle_slot_or_fallback, local);
      transition_out(default_slot, local);
      transition_out(actions_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      destroy_component(notificationicon);
      if (title_slot_or_fallback) title_slot_or_fallback.d(detaching);
      if (subtitle_slot_or_fallback) subtitle_slot_or_fallback.d(detaching);
      if (default_slot) default_slot.d(detaching);
      if (actions_slot) actions_slot.d(detaching);
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block64.name,
    type: "if",
    source: "(71:0) {#if open}",
    ctx
  });
  return block;
}
function fallback_block_111(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*title*/
        ctx[3]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*title*/
        ctx[3]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      8) set_data_dev(
        t,
        /*title*/
        ctx2[3]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_111.name,
    type: "fallback",
    source: "(98:29) {title}",
    ctx
  });
  return block;
}
function fallback_block22(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*subtitle*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*subtitle*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*subtitle*/
      16) set_data_dev(
        t,
        /*subtitle*/
        ctx2[4]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block22.name,
    type: "fallback",
    source: "(101:32) {subtitle}",
    ctx
  });
  return block;
}
function create_if_block_126(ctx) {
  let notificationbutton;
  let current;
  notificationbutton = new NotificationButton_default({
    props: {
      iconDescription: (
        /*closeButtonDescription*/
        ctx[7]
      ),
      notificationType: "inline"
    },
    $$inline: true
  });
  notificationbutton.$on(
    "click",
    /*close*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(notificationbutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(notificationbutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(notificationbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const notificationbutton_changes = {};
      if (dirty & /*closeButtonDescription*/
      128) notificationbutton_changes.iconDescription = /*closeButtonDescription*/
      ctx2[7];
      notificationbutton.$set(notificationbutton_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(notificationbutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(notificationbutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(notificationbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_126.name,
    type: "if",
    source: "(107:4) {#if !hideCloseButton}",
    ctx
  });
  return block;
}
function create_fragment108(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*open*/
    ctx[8] && create_if_block64(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*open*/
        ctx2[8]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block64(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment108.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance108($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "kind",
    "lowContrast",
    "timeout",
    "role",
    "title",
    "subtitle",
    "hideCloseButton",
    "statusIconDescription",
    "closeButtonDescription"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InlineNotification", slots, ["title", "subtitle", "default", "actions"]);
  let { kind = "error" } = $$props;
  let { lowContrast = false } = $$props;
  let { timeout = 0 } = $$props;
  let { role = "alert" } = $$props;
  let { title = "" } = $$props;
  let { subtitle = "" } = $$props;
  let { hideCloseButton = false } = $$props;
  let { statusIconDescription = kind + " icon" } = $$props;
  let { closeButtonDescription = "Close notification" } = $$props;
  const dispatch = createEventDispatcher();
  let open = true;
  let timeoutId = void 0;
  function close(closeFromTimeout) {
    const shouldContinue = dispatch("close", { timeout: closeFromTimeout === true }, { cancelable: true });
    if (shouldContinue) {
      $$invalidate(8, open = false);
    }
  }
  onMount(() => {
    if (timeout) {
      timeoutId = setTimeout(() => close(true), timeout);
    }
    return () => {
      clearTimeout(timeoutId);
    };
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("kind" in $$new_props) $$invalidate(0, kind = $$new_props.kind);
    if ("lowContrast" in $$new_props) $$invalidate(1, lowContrast = $$new_props.lowContrast);
    if ("timeout" in $$new_props) $$invalidate(11, timeout = $$new_props.timeout);
    if ("role" in $$new_props) $$invalidate(2, role = $$new_props.role);
    if ("title" in $$new_props) $$invalidate(3, title = $$new_props.title);
    if ("subtitle" in $$new_props) $$invalidate(4, subtitle = $$new_props.subtitle);
    if ("hideCloseButton" in $$new_props) $$invalidate(5, hideCloseButton = $$new_props.hideCloseButton);
    if ("statusIconDescription" in $$new_props) $$invalidate(6, statusIconDescription = $$new_props.statusIconDescription);
    if ("closeButtonDescription" in $$new_props) $$invalidate(7, closeButtonDescription = $$new_props.closeButtonDescription);
    if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    kind,
    lowContrast,
    timeout,
    role,
    title,
    subtitle,
    hideCloseButton,
    statusIconDescription,
    closeButtonDescription,
    createEventDispatcher,
    onMount,
    NotificationIcon: NotificationIcon_default,
    NotificationButton: NotificationButton_default,
    dispatch,
    open,
    timeoutId,
    close
  });
  $$self.$inject_state = ($$new_props) => {
    if ("kind" in $$props) $$invalidate(0, kind = $$new_props.kind);
    if ("lowContrast" in $$props) $$invalidate(1, lowContrast = $$new_props.lowContrast);
    if ("timeout" in $$props) $$invalidate(11, timeout = $$new_props.timeout);
    if ("role" in $$props) $$invalidate(2, role = $$new_props.role);
    if ("title" in $$props) $$invalidate(3, title = $$new_props.title);
    if ("subtitle" in $$props) $$invalidate(4, subtitle = $$new_props.subtitle);
    if ("hideCloseButton" in $$props) $$invalidate(5, hideCloseButton = $$new_props.hideCloseButton);
    if ("statusIconDescription" in $$props) $$invalidate(6, statusIconDescription = $$new_props.statusIconDescription);
    if ("closeButtonDescription" in $$props) $$invalidate(7, closeButtonDescription = $$new_props.closeButtonDescription);
    if ("open" in $$props) $$invalidate(8, open = $$new_props.open);
    if ("timeoutId" in $$props) timeoutId = $$new_props.timeoutId;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    kind,
    lowContrast,
    role,
    title,
    subtitle,
    hideCloseButton,
    statusIconDescription,
    closeButtonDescription,
    open,
    close,
    $$restProps,
    timeout,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var InlineNotification = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance108, create_fragment108, safe_not_equal, {
      kind: 0,
      lowContrast: 1,
      timeout: 11,
      role: 2,
      title: 3,
      subtitle: 4,
      hideCloseButton: 5,
      statusIconDescription: 6,
      closeButtonDescription: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InlineNotification",
      options,
      id: create_fragment108.name
    });
  }
  get kind() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lowContrast() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lowContrast(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get timeout() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set timeout(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideCloseButton() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideCloseButton(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get statusIconDescription() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set statusIconDescription(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeButtonDescription() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeButtonDescription(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InlineNotification_default = InlineNotification;

// node_modules/carbon-components-svelte/src/Notification/NotificationActionButton.svelte
function create_default_slot16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot16.name,
    type: "slot",
    source: '(7:0) <Button   kind=\\"ghost\\"   size=\\"small\\"   {...$$restProps}   class=\\"bx--inline-notification__action-button {$$restProps.class}\\"   on:click   on:mouseover   on:mouseenter   on:mouseleave >',
    ctx
  });
  return block;
}
function create_fragment109(ctx) {
  let button;
  let current;
  const button_spread_levels = [
    { kind: "ghost" },
    { size: "small" },
    /*$$restProps*/
    ctx[0],
    {
      class: "bx--inline-notification__action-button " + /*$$restProps*/
      ctx[0].class
    }
  ];
  let button_props = {
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button_spread_levels.length; i += 1) {
    button_props = assign(button_props, button_spread_levels[i]);
  }
  button = new Button_default({ props: button_props, $$inline: true });
  button.$on(
    "click",
    /*click_handler*/
    ctx[2]
  );
  button.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[3]
  );
  button.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx[4]
  );
  button.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx[5]
  );
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const button_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(button_spread_levels, [
        button_spread_levels[0],
        button_spread_levels[1],
        get_spread_object(
          /*$$restProps*/
          ctx2[0]
        ),
        {
          class: "bx--inline-notification__action-button " + /*$$restProps*/
          ctx2[0].class
        }
      ]) : {};
      if (dirty & /*$$scope*/
      64) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment109.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance109($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NotificationActionButton", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Button: Button_default });
  return [
    $$restProps,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    $$scope
  ];
}
var NotificationActionButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance109, create_fragment109, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NotificationActionButton",
      options,
      id: create_fragment109.name
    });
  }
};
var NotificationActionButton_default = NotificationActionButton;

// node_modules/carbon-components-svelte/src/icons/Add.svelte
var file101 = "node_modules/carbon-components-svelte/src/icons/Add.svelte";
function create_if_block65(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file101, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block65.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment110(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block65(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 15L17 8 15 8 15 15 8 15 8 17 15 17 15 24 17 24 17 17 24 17 24 15z");
      add_location(path, file101, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file101, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block65(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment110.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance110($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Add", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Add = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance110, create_fragment110, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Add",
      options,
      id: create_fragment110.name
    });
  }
  get size() {
    throw new Error("<Add>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Add>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Add>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Add>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Add_default = Add;

// node_modules/carbon-components-svelte/src/icons/Subtract.svelte
var file102 = "node_modules/carbon-components-svelte/src/icons/Subtract.svelte";
function create_if_block66(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file102, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block66.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment111(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block66(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8 15H24V17H8z");
      add_location(path, file102, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file102, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block66(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment111.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance111($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Subtract", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Subtract = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance111, create_fragment111, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Subtract",
      options,
      id: create_fragment111.name
    });
  }
  get size() {
    throw new Error("<Subtract>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Subtract>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Subtract>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Subtract>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Subtract_default = Subtract;

// node_modules/carbon-components-svelte/src/icons/EditOff.svelte
var file103 = "node_modules/carbon-components-svelte/src/icons/EditOff.svelte";
function create_if_block67(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file103, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block67.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment112(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block67(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M30 28.6L3.4 2 2 3.4l10.1 10.1L4 21.6V28h6.4l8.1-8.1L28.6 30 30 28.6zM9.6 26H6v-3.6l7.5-7.5 3.6 3.6L9.6 26zM29.4 6.2L29.4 6.2l-3.6-3.6c-.8-.8-2-.8-2.8 0l0 0 0 0-8 8 1.4 1.4L20 8.4l3.6 3.6L20 15.6l1.4 1.4 8-8C30.2 8.2 30.2 7 29.4 6.2L29.4 6.2zM25 10.6L21.4 7l3-3L28 7.6 25 10.6z");
      add_location(path, file103, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file103, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block67(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment112.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance112($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EditOff", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var EditOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance112, create_fragment112, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EditOff",
      options,
      id: create_fragment112.name
    });
  }
  get size() {
    throw new Error("<EditOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<EditOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<EditOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<EditOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EditOff_default = EditOff;

// node_modules/carbon-components-svelte/src/NumberInput/NumberInput.svelte
var file104 = "node_modules/carbon-components-svelte/src/NumberInput/NumberInput.svelte";
var get_label_slot_changes2 = (dirty) => ({});
var get_label_slot_context2 = (ctx) => ({});
function create_if_block_74(ctx) {
  let label_1;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[34].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[33],
    get_label_slot_context2
  );
  const label_slot_or_fallback = label_slot || fallback_block23(ctx);
  const block = {
    c: function create() {
      label_1 = element("label");
      if (label_slot_or_fallback) label_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { for: true });
      var label_1_nodes = children(label_1);
      if (label_slot_or_fallback) label_slot_or_fallback.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label_1,
        "for",
        /*id*/
        ctx[18]
      );
      toggle_class(label_1, "bx--label", true);
      toggle_class(
        label_1,
        "bx--label--disabled",
        /*disabled*/
        ctx[8]
      );
      toggle_class(
        label_1,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[17]
      );
      add_location(label_1, file104, 176, 6, 4404);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[1] & /*$$scope*/
        4)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[33],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[33]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[33],
              dirty,
              get_label_slot_changes2
            ),
            get_label_slot_context2
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty[0] & /*label*/
        65536)) {
          label_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      262144) {
        attr_dev(
          label_1,
          "for",
          /*id*/
          ctx2[18]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      256) {
        toggle_class(
          label_1,
          "bx--label--disabled",
          /*disabled*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*hideLabel*/
      131072) {
        toggle_class(
          label_1,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[17]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(label_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label_1);
      }
      if (label_slot_or_fallback) label_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_74.name,
    type: "if",
    source: "(176:4) {#if $$slots.label || label}",
    ctx
  });
  return block;
}
function fallback_block23(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*label*/
        ctx[16]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*label*/
        ctx[16]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*label*/
      65536) set_data_dev(
        t,
        /*label*/
        ctx2[16]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block23.name,
    type: "fallback",
    source: "(183:27) {label}",
    ctx
  });
  return block;
}
function create_else_block24(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*invalid*/
    ctx[11] && create_if_block_68(ctx)
  );
  let if_block1 = !/*invalid*/
  ctx[11] && /*warn*/
  ctx[13] && create_if_block_59(ctx);
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*invalid*/
        ctx2[11]
      ) {
        if (if_block0) {
          if (dirty[0] & /*invalid*/
          2048) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_68(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*invalid*/
      ctx2[11] && /*warn*/
      ctx2[13]) {
        if (if_block1) {
          if (dirty[0] & /*invalid, warn*/
          10240) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_59(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block1_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block24.name,
    type: "else",
    source: "(217:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_410(ctx) {
  let editoff;
  let current;
  editoff = new EditOff_default({
    props: { class: "bx--text-input__readonly-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(editoff.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(editoff.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(editoff, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      transition_in(editoff.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(editoff.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(editoff, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_410.name,
    type: "if",
    source: "(215:6) {#if readonly}",
    ctx
  });
  return block;
}
function create_if_block_68(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--number__invalid" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_68.name,
    type: "if",
    source: "(218:8) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_59(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--number__invalid bx--number__invalid--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningaltfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_59.name,
    type: "if",
    source: "(221:8) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_312(ctx) {
  let div2;
  let button0;
  let subtract;
  let button0_title_value;
  let button0_aria_label_value;
  let t0;
  let div0;
  let t1;
  let button1;
  let add;
  let button1_title_value;
  let button1_aria_label_value;
  let t2;
  let div1;
  let current;
  let mounted;
  let dispose;
  subtract = new Subtract_default({
    props: { class: "down-icon" },
    $$inline: true
  });
  add = new Add_default({
    props: { class: "up-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      div2 = element("div");
      button0 = element("button");
      create_component(subtract.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = space();
      button1 = element("button");
      create_component(add.$$.fragment);
      t2 = space();
      div1 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      button0 = claim_element(div2_nodes, "BUTTON", {
        type: true,
        tabindex: true,
        title: true,
        "aria-label": true
      });
      var button0_nodes = children(button0);
      claim_component(subtract.$$.fragment, button0_nodes);
      button0_nodes.forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div0 = claim_element(div2_nodes, "DIV", {});
      children(div0).forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      button1 = claim_element(div2_nodes, "BUTTON", {
        type: true,
        tabindex: true,
        title: true,
        "aria-label": true
      });
      var button1_nodes = children(button1);
      claim_component(add.$$.fragment, button1_nodes);
      button1_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", {});
      children(div1).forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "type", "button");
      attr_dev(button0, "tabindex", "-1");
      attr_dev(button0, "title", button0_title_value = /*decrementLabel*/
      ctx[23] || /*iconDescription*/
      ctx[10]);
      attr_dev(button0, "aria-label", button0_aria_label_value = /*decrementLabel*/
      ctx[23] || /*iconDescription*/
      ctx[10]);
      button0.disabled = /*disabled*/
      ctx[8];
      toggle_class(button0, "bx--number__control-btn", true);
      toggle_class(button0, "down-icon", true);
      add_location(button0, file104, 228, 10, 5837);
      toggle_class(div0, "bx--number__rule-divider", true);
      add_location(div0, file104, 242, 10, 6302);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "tabindex", "-1");
      attr_dev(button1, "title", button1_title_value = /*incrementLabel*/
      ctx[24] || /*iconDescription*/
      ctx[10]);
      attr_dev(button1, "aria-label", button1_aria_label_value = /*incrementLabel*/
      ctx[24] || /*iconDescription*/
      ctx[10]);
      button1.disabled = /*disabled*/
      ctx[8];
      toggle_class(button1, "bx--number__control-btn", true);
      toggle_class(button1, "up-icon", true);
      add_location(button1, file104, 243, 10, 6364);
      toggle_class(div1, "bx--number__rule-divider", true);
      add_location(div1, file104, 257, 10, 6819);
      toggle_class(div2, "bx--number__controls", true);
      add_location(div2, file104, 227, 8, 5785);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, button0);
      mount_component(subtract, button0, null);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, button1);
      mount_component(add, button1, null);
      append_hydration_dev(div2, t2);
      append_hydration_dev(div2, div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler_1*/
            ctx[45],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_2*/
            ctx[46],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*decrementLabel, iconDescription*/
      8389632 && button0_title_value !== (button0_title_value = /*decrementLabel*/
      ctx2[23] || /*iconDescription*/
      ctx2[10])) {
        attr_dev(button0, "title", button0_title_value);
      }
      if (!current || dirty[0] & /*decrementLabel, iconDescription*/
      8389632 && button0_aria_label_value !== (button0_aria_label_value = /*decrementLabel*/
      ctx2[23] || /*iconDescription*/
      ctx2[10])) {
        attr_dev(button0, "aria-label", button0_aria_label_value);
      }
      if (!current || dirty[0] & /*disabled*/
      256) {
        prop_dev(
          button0,
          "disabled",
          /*disabled*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*incrementLabel, iconDescription*/
      16778240 && button1_title_value !== (button1_title_value = /*incrementLabel*/
      ctx2[24] || /*iconDescription*/
      ctx2[10])) {
        attr_dev(button1, "title", button1_title_value);
      }
      if (!current || dirty[0] & /*incrementLabel, iconDescription*/
      16778240 && button1_aria_label_value !== (button1_aria_label_value = /*incrementLabel*/
      ctx2[24] || /*iconDescription*/
      ctx2[10])) {
        attr_dev(button1, "aria-label", button1_aria_label_value);
      }
      if (!current || dirty[0] & /*disabled*/
      256) {
        prop_dev(
          button1,
          "disabled",
          /*disabled*/
          ctx2[8]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(subtract.$$.fragment, local);
      transition_in(add.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subtract.$$.fragment, local);
      transition_out(add.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(subtract);
      destroy_component(add);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_312.name,
    type: "if",
    source: "(227:6) {#if !hideSteppers}",
    ctx
  });
  return block;
}
function create_if_block_217(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[15]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[15]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(
        div,
        "bx--form__helper-text--disabled",
        /*disabled*/
        ctx[8]
      );
      add_location(div, file104, 262, 6, 6955);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*helperText*/
      32768) set_data_dev(
        t,
        /*helperText*/
        ctx2[15]
      );
      if (dirty[0] & /*disabled*/
      256) {
        toggle_class(
          div,
          "bx--form__helper-text--disabled",
          /*disabled*/
          ctx2[8]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_217.name,
    type: "if",
    source: "(262:4) {#if !error && !warn && helperText}",
    ctx
  });
  return block;
}
function create_if_block_127(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*invalidText*/
        ctx[12]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*invalidText*/
        ctx[12]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*errorId*/
        ctx[21]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file104, 270, 6, 7138);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*invalidText*/
      4096) set_data_dev(
        t,
        /*invalidText*/
        ctx2[12]
      );
      if (dirty[0] & /*errorId*/
      2097152) {
        attr_dev(
          div,
          "id",
          /*errorId*/
          ctx2[21]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_127.name,
    type: "if",
    source: "(270:4) {#if error}",
    ctx
  });
  return block;
}
function create_if_block68(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*warnText*/
        ctx[14]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*warnText*/
        ctx[14]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*errorId*/
        ctx[21]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file104, 275, 6, 7271);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*warnText*/
      16384) set_data_dev(
        t,
        /*warnText*/
        ctx2[14]
      );
      if (dirty[0] & /*errorId*/
      2097152) {
        attr_dev(
          div,
          "id",
          /*errorId*/
          ctx2[21]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block68.name,
    type: "if",
    source: "(275:4) {#if !error && warn}",
    ctx
  });
  return block;
}
function create_fragment113(ctx) {
  let div2;
  let div1;
  let t0;
  let div0;
  let input;
  let input_data_invalid_value;
  let input_aria_invalid_value;
  let input_aria_label_value;
  let input_value_value;
  let t1;
  let current_block_type_index;
  let if_block1;
  let t2;
  let t3;
  let t4;
  let t5;
  let div1_data_invalid_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    (ctx[28].label || /*label*/
    ctx[16]) && create_if_block_74(ctx)
  );
  let input_levels = [
    { type: "number" },
    { pattern: "[0-9]*" },
    { "aria-describedby": (
      /*errorId*/
      ctx[21]
    ) },
    {
      "data-invalid": input_data_invalid_value = /*error*/
      ctx[22] || void 0
    },
    {
      "aria-invalid": input_aria_invalid_value = /*error*/
      ctx[22] || void 0
    },
    {
      "aria-label": input_aria_label_value = /*label*/
      ctx[16] ? void 0 : (
        /*ariaLabel*/
        ctx[20]
      )
    },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { id: (
      /*id*/
      ctx[18]
    ) },
    { name: (
      /*name*/
      ctx[19]
    ) },
    { max: (
      /*max*/
      ctx[4]
    ) },
    { min: (
      /*min*/
      ctx[5]
    ) },
    { step: (
      /*step*/
      ctx[3]
    ) },
    {
      value: input_value_value = /*value*/
      ctx[0] ?? ""
    },
    { readOnly: (
      /*readonly*/
      ctx[7]
    ) },
    /*$$restProps*/
    ctx[29]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const if_block_creators = [create_if_block_410, create_else_block24];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*readonly*/
      ctx2[7]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block2 = !/*hideSteppers*/
  ctx[9] && create_if_block_312(ctx);
  let if_block3 = !/*error*/
  ctx[22] && !/*warn*/
  ctx[13] && /*helperText*/
  ctx[15] && create_if_block_217(ctx);
  let if_block4 = (
    /*error*/
    ctx[22] && create_if_block_127(ctx)
  );
  let if_block5 = !/*error*/
  ctx[22] && /*warn*/
  ctx[13] && create_if_block68(ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      div0 = element("div");
      input = element("input");
      t1 = space();
      if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      t3 = space();
      if (if_block3) if_block3.c();
      t4 = space();
      if (if_block4) if_block4.c();
      t5 = space();
      if (if_block5) if_block5.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { "data-invalid": true });
      var div1_nodes = children(div1);
      if (if_block0) if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", {
        type: true,
        pattern: true,
        "aria-describedby": true,
        "data-invalid": true,
        "aria-invalid": true,
        "aria-label": true,
        id: true,
        name: true,
        max: true,
        min: true,
        step: true
      });
      t1 = claim_space(div0_nodes);
      if_block1.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      if (if_block2) if_block2.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t3 = claim_space(div1_nodes);
      if (if_block3) if_block3.l(div1_nodes);
      t4 = claim_space(div1_nodes);
      if (if_block4) if_block4.l(div1_nodes);
      t5 = claim_space(div1_nodes);
      if (if_block5) if_block5.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file104, 189, 6, 4769);
      toggle_class(div0, "bx--number__input-wrapper", true);
      toggle_class(div0, "bx--number__input-wrapper--warning", !/*invalid*/
      ctx[11] && /*warn*/
      ctx[13]);
      add_location(div0, file104, 185, 4, 4637);
      attr_dev(div1, "data-invalid", div1_data_invalid_value = /*error*/
      ctx[22] || void 0);
      toggle_class(div1, "bx--number", true);
      toggle_class(div1, "bx--number--helpertext", true);
      toggle_class(
        div1,
        "bx--number--readonly",
        /*readonly*/
        ctx[7]
      );
      toggle_class(
        div1,
        "bx--number--light",
        /*light*/
        ctx[6]
      );
      toggle_class(
        div1,
        "bx--number--nolabel",
        /*hideLabel*/
        ctx[17]
      );
      toggle_class(
        div1,
        "bx--number--nosteppers",
        /*hideSteppers*/
        ctx[9]
      );
      toggle_class(
        div1,
        "bx--number--sm",
        /*size*/
        ctx[2] === "sm"
      );
      toggle_class(
        div1,
        "bx--number--xl",
        /*size*/
        ctx[2] === "xl"
      );
      add_location(div1, file104, 164, 2, 3982);
      toggle_class(div2, "bx--form-item", true);
      add_location(div2, file104, 157, 0, 3884);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      if (if_block0) if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, input);
      if (input.autofocus) input.focus();
      ctx[44](input);
      append_hydration_dev(div0, t1);
      if_blocks[current_block_type_index].m(div0, null);
      append_hydration_dev(div0, t2);
      if (if_block2) if_block2.m(div0, null);
      append_hydration_dev(div1, t3);
      if (if_block3) if_block3.m(div1, null);
      append_hydration_dev(div1, t4);
      if (if_block4) if_block4.m(div1, null);
      append_hydration_dev(div1, t5);
      if (if_block5) if_block5.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*onChange*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*onInput*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[39],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[40],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[41],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "paste",
            /*paste_handler*/
            ctx[43],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "click",
            /*click_handler*/
            ctx[35],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseover",
            /*mouseover_handler*/
            ctx[36],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[38],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[28].label || /*label*/
        ctx2[16]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*$$slots, label*/
          268500992) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_74(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "number" },
        { pattern: "[0-9]*" },
        (!current || dirty[0] & /*errorId*/
        2097152) && { "aria-describedby": (
          /*errorId*/
          ctx2[21]
        ) },
        (!current || dirty[0] & /*error*/
        4194304 && input_data_invalid_value !== (input_data_invalid_value = /*error*/
        ctx2[22] || void 0)) && { "data-invalid": input_data_invalid_value },
        (!current || dirty[0] & /*error*/
        4194304 && input_aria_invalid_value !== (input_aria_invalid_value = /*error*/
        ctx2[22] || void 0)) && { "aria-invalid": input_aria_invalid_value },
        (!current || dirty[0] & /*label, ariaLabel*/
        1114112 && input_aria_label_value !== (input_aria_label_value = /*label*/
        ctx2[16] ? void 0 : (
          /*ariaLabel*/
          ctx2[20]
        ))) && { "aria-label": input_aria_label_value },
        (!current || dirty[0] & /*disabled*/
        256) && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        (!current || dirty[0] & /*id*/
        262144) && { id: (
          /*id*/
          ctx2[18]
        ) },
        (!current || dirty[0] & /*name*/
        524288) && { name: (
          /*name*/
          ctx2[19]
        ) },
        (!current || dirty[0] & /*max*/
        16) && { max: (
          /*max*/
          ctx2[4]
        ) },
        (!current || dirty[0] & /*min*/
        32) && { min: (
          /*min*/
          ctx2[5]
        ) },
        (!current || dirty[0] & /*step*/
        8) && { step: (
          /*step*/
          ctx2[3]
        ) },
        (!current || dirty[0] & /*value*/
        1 && input_value_value !== (input_value_value = /*value*/
        ctx2[0] ?? "") && input.value !== input_value_value) && { value: input_value_value },
        (!current || dirty[0] & /*readonly*/
        128) && { readOnly: (
          /*readonly*/
          ctx2[7]
        ) },
        dirty[0] & /*$$restProps*/
        536870912 && /*$$restProps*/
        ctx2[29]
      ]));
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div0, t2);
      }
      if (!/*hideSteppers*/
      ctx2[9]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*hideSteppers*/
          512) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_312(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*invalid, warn*/
      10240) {
        toggle_class(div0, "bx--number__input-wrapper--warning", !/*invalid*/
        ctx2[11] && /*warn*/
        ctx2[13]);
      }
      if (!/*error*/
      ctx2[22] && !/*warn*/
      ctx2[13] && /*helperText*/
      ctx2[15]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_217(ctx2);
          if_block3.c();
          if_block3.m(div1, t4);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*error*/
        ctx2[22]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_127(ctx2);
          if_block4.c();
          if_block4.m(div1, t5);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (!/*error*/
      ctx2[22] && /*warn*/
      ctx2[13]) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block68(ctx2);
          if_block5.c();
          if_block5.m(div1, null);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (!current || dirty[0] & /*error*/
      4194304 && div1_data_invalid_value !== (div1_data_invalid_value = /*error*/
      ctx2[22] || void 0)) {
        attr_dev(div1, "data-invalid", div1_data_invalid_value);
      }
      if (!current || dirty[0] & /*readonly*/
      128) {
        toggle_class(
          div1,
          "bx--number--readonly",
          /*readonly*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*light*/
      64) {
        toggle_class(
          div1,
          "bx--number--light",
          /*light*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*hideLabel*/
      131072) {
        toggle_class(
          div1,
          "bx--number--nolabel",
          /*hideLabel*/
          ctx2[17]
        );
      }
      if (!current || dirty[0] & /*hideSteppers*/
      512) {
        toggle_class(
          div1,
          "bx--number--nosteppers",
          /*hideSteppers*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*size*/
      4) {
        toggle_class(
          div1,
          "bx--number--sm",
          /*size*/
          ctx2[2] === "sm"
        );
      }
      if (!current || dirty[0] & /*size*/
      4) {
        toggle_class(
          div1,
          "bx--number--xl",
          /*size*/
          ctx2[2] === "xl"
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block0) if_block0.d();
      ctx[44](null);
      if_blocks[current_block_type_index].d();
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      if (if_block4) if_block4.d();
      if (if_block5) if_block5.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment113.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function parse(raw) {
  return raw != "" ? Number(raw) : null;
}
function instance113($$self, $$props, $$invalidate) {
  let incrementLabel;
  let decrementLabel;
  let error;
  let errorId;
  let ariaLabel;
  const omit_props_names = [
    "size",
    "value",
    "step",
    "max",
    "min",
    "light",
    "readonly",
    "allowEmpty",
    "disabled",
    "hideSteppers",
    "iconDescription",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "helperText",
    "label",
    "hideLabel",
    "translateWithId",
    "translationIds",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NumberInput", slots, ["label"]);
  const $$slots = compute_slots(slots);
  let { size = void 0 } = $$props;
  let { value = null } = $$props;
  let { step = 1 } = $$props;
  let { max = void 0 } = $$props;
  let { min = void 0 } = $$props;
  let { light = false } = $$props;
  let { readonly: readonly2 = false } = $$props;
  let { allowEmpty = false } = $$props;
  let { disabled = false } = $$props;
  let { hideSteppers = false } = $$props;
  let { iconDescription = "" } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { helperText = "" } = $$props;
  let { label = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { translateWithId = (id2) => defaultTranslations[id2] } = $$props;
  const translationIds = {
    increment: "increment",
    decrement: "decrement"
  };
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  const defaultTranslations = {
    [translationIds.increment]: "Increment number",
    [translationIds.decrement]: "Decrement number"
  };
  const dispatch = createEventDispatcher();
  function updateValue(isIncrementing) {
    if (isIncrementing) {
      ref.stepUp();
    } else {
      ref.stepDown();
    }
    $$invalidate(0, value = +ref.value);
    dispatch("input", value);
    dispatch("change", value);
  }
  function onInput({ target }) {
    $$invalidate(0, value = parse(target.value));
    dispatch("input", value);
  }
  function onChange({ target }) {
    dispatch("change", parse(target.value));
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const click_handler_13 = () => {
    updateValue(false);
  };
  const click_handler_2 = () => {
    updateValue(true);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(49, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(29, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(2, size = $$new_props.size);
    if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    if ("step" in $$new_props) $$invalidate(3, step = $$new_props.step);
    if ("max" in $$new_props) $$invalidate(4, max = $$new_props.max);
    if ("min" in $$new_props) $$invalidate(5, min = $$new_props.min);
    if ("light" in $$new_props) $$invalidate(6, light = $$new_props.light);
    if ("readonly" in $$new_props) $$invalidate(7, readonly2 = $$new_props.readonly);
    if ("allowEmpty" in $$new_props) $$invalidate(30, allowEmpty = $$new_props.allowEmpty);
    if ("disabled" in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
    if ("hideSteppers" in $$new_props) $$invalidate(9, hideSteppers = $$new_props.hideSteppers);
    if ("iconDescription" in $$new_props) $$invalidate(10, iconDescription = $$new_props.iconDescription);
    if ("invalid" in $$new_props) $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props) $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props) $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$new_props) $$invalidate(14, warnText = $$new_props.warnText);
    if ("helperText" in $$new_props) $$invalidate(15, helperText = $$new_props.helperText);
    if ("label" in $$new_props) $$invalidate(16, label = $$new_props.label);
    if ("hideLabel" in $$new_props) $$invalidate(17, hideLabel = $$new_props.hideLabel);
    if ("translateWithId" in $$new_props) $$invalidate(31, translateWithId = $$new_props.translateWithId);
    if ("id" in $$new_props) $$invalidate(18, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(19, name = $$new_props.name);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(33, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    value,
    step,
    max,
    min,
    light,
    readonly: readonly2,
    allowEmpty,
    disabled,
    hideSteppers,
    iconDescription,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    label,
    hideLabel,
    translateWithId,
    translationIds,
    id,
    name,
    ref,
    createEventDispatcher,
    Add: Add_default,
    Subtract: Subtract_default,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    EditOff: EditOff_default,
    defaultTranslations,
    dispatch,
    updateValue,
    parse,
    onInput,
    onChange,
    ariaLabel,
    errorId,
    error,
    decrementLabel,
    incrementLabel
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(49, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(2, size = $$new_props.size);
    if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    if ("step" in $$props) $$invalidate(3, step = $$new_props.step);
    if ("max" in $$props) $$invalidate(4, max = $$new_props.max);
    if ("min" in $$props) $$invalidate(5, min = $$new_props.min);
    if ("light" in $$props) $$invalidate(6, light = $$new_props.light);
    if ("readonly" in $$props) $$invalidate(7, readonly2 = $$new_props.readonly);
    if ("allowEmpty" in $$props) $$invalidate(30, allowEmpty = $$new_props.allowEmpty);
    if ("disabled" in $$props) $$invalidate(8, disabled = $$new_props.disabled);
    if ("hideSteppers" in $$props) $$invalidate(9, hideSteppers = $$new_props.hideSteppers);
    if ("iconDescription" in $$props) $$invalidate(10, iconDescription = $$new_props.iconDescription);
    if ("invalid" in $$props) $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$props) $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$props) $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$props) $$invalidate(14, warnText = $$new_props.warnText);
    if ("helperText" in $$props) $$invalidate(15, helperText = $$new_props.helperText);
    if ("label" in $$props) $$invalidate(16, label = $$new_props.label);
    if ("hideLabel" in $$props) $$invalidate(17, hideLabel = $$new_props.hideLabel);
    if ("translateWithId" in $$props) $$invalidate(31, translateWithId = $$new_props.translateWithId);
    if ("id" in $$props) $$invalidate(18, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(19, name = $$new_props.name);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("ariaLabel" in $$props) $$invalidate(20, ariaLabel = $$new_props.ariaLabel);
    if ("errorId" in $$props) $$invalidate(21, errorId = $$new_props.errorId);
    if ("error" in $$props) $$invalidate(22, error = $$new_props.error);
    if ("decrementLabel" in $$props) $$invalidate(23, decrementLabel = $$new_props.decrementLabel);
    if ("incrementLabel" in $$props) $$invalidate(24, incrementLabel = $$new_props.incrementLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*translateWithId*/
    1) {
      $: $$invalidate(24, incrementLabel = translateWithId("increment"));
    }
    if ($$self.$$.dirty[1] & /*translateWithId*/
    1) {
      $: $$invalidate(23, decrementLabel = translateWithId("decrement"));
    }
    if ($$self.$$.dirty[0] & /*invalid, readonly, allowEmpty, value, max, min*/
    1073744049) {
      $: $$invalidate(22, error = invalid && !readonly2 || !allowEmpty && value == null || value > max || typeof value === "number" && value < min);
    }
    if ($$self.$$.dirty[0] & /*id*/
    262144) {
      $: $$invalidate(21, errorId = `error-${id}`);
    }
    $: $$invalidate(20, ariaLabel = $$props["aria-label"] || "Numeric input field with increment and decrement buttons");
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    ref,
    size,
    step,
    max,
    min,
    light,
    readonly2,
    disabled,
    hideSteppers,
    iconDescription,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    label,
    hideLabel,
    id,
    name,
    ariaLabel,
    errorId,
    error,
    decrementLabel,
    incrementLabel,
    updateValue,
    onInput,
    onChange,
    $$slots,
    $$restProps,
    allowEmpty,
    translateWithId,
    translationIds,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    paste_handler,
    input_binding,
    click_handler_13,
    click_handler_2
  ];
}
var NumberInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance113,
      create_fragment113,
      safe_not_equal,
      {
        size: 2,
        value: 0,
        step: 3,
        max: 4,
        min: 5,
        light: 6,
        readonly: 7,
        allowEmpty: 30,
        disabled: 8,
        hideSteppers: 9,
        iconDescription: 10,
        invalid: 11,
        invalidText: 12,
        warn: 13,
        warnText: 14,
        helperText: 15,
        label: 16,
        hideLabel: 17,
        translateWithId: 31,
        translationIds: 32,
        id: 18,
        name: 19,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NumberInput",
      options,
      id: create_fragment113.name
    });
  }
  get size() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowEmpty() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowEmpty(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideSteppers() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideSteppers(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translationIds() {
    return this.$$.ctx[32];
  }
  set translationIds(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NumberInput_default = NumberInput;

// node_modules/carbon-components-svelte/src/NumberInput/NumberInputSkeleton.svelte
var file105 = "node_modules/carbon-components-svelte/src/NumberInput/NumberInputSkeleton.svelte";
function create_if_block69(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file105, 16, 4, 352);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block69.name,
    type: "if",
    source: "(16:2) {#if !hideLabel}",
    ctx
  });
  return block;
}
function create_fragment114(ctx) {
  let div1;
  let t;
  let div0;
  let mounted;
  let dispose;
  let if_block = !/*hideLabel*/
  ctx[0] && create_if_block69(ctx);
  let div1_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block) if_block.c();
      t = space();
      div0 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      if (if_block) if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--number", true);
      toggle_class(div0, "bx--skeleton", true);
      add_location(div0, file105, 18, 2, 429);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file105, 7, 0, 214);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block) if_block.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseover",
            /*mouseover_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!/*hideLabel*/
      ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block69(ctx2);
          if_block.c();
          if_block.m(div1, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment114.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance114($$self, $$props, $$invalidate) {
  const omit_props_names = ["hideLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NumberInputSkeleton", slots, []);
  let { hideLabel = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("hideLabel" in $$new_props) $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  $$self.$capture_state = () => ({ hideLabel });
  $$self.$inject_state = ($$new_props) => {
    if ("hideLabel" in $$props) $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    hideLabel,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var NumberInputSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance114, create_fragment114, safe_not_equal, { hideLabel: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NumberInputSkeleton",
      options,
      id: create_fragment114.name
    });
  }
  get hideLabel() {
    throw new Error("<NumberInputSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<NumberInputSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NumberInputSkeleton_default = NumberInputSkeleton;

// node_modules/carbon-components-svelte/src/OrderedList/OrderedList.svelte
var file106 = "node_modules/carbon-components-svelte/src/OrderedList/OrderedList.svelte";
function create_fragment115(ctx) {
  let ol;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let ol_levels = [
    /*$$restProps*/
    ctx[3]
  ];
  let ol_data = {};
  for (let i = 0; i < ol_levels.length; i += 1) {
    ol_data = assign(ol_data, ol_levels[i]);
  }
  const block = {
    c: function create() {
      ol = element("ol");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ol = claim_element(nodes, "OL", {});
      var ol_nodes = children(ol);
      if (default_slot) default_slot.l(ol_nodes);
      ol_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(ol, ol_data);
      toggle_class(ol, "bx--list--ordered", !/*native*/
      ctx[1]);
      toggle_class(
        ol,
        "bx--list--ordered--native",
        /*native*/
        ctx[1]
      );
      toggle_class(
        ol,
        "bx--list--nested",
        /*nested*/
        ctx[0]
      );
      toggle_class(
        ol,
        "bx--list--expressive",
        /*expressive*/
        ctx[2]
      );
      add_location(ol, file106, 13, 0, 397);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ol, anchor);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            ol,
            "click",
            /*click_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ol,
            "mouseover",
            /*mouseover_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ol,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ol,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ol, ol_data = get_spread_update(ol_levels, [dirty & /*$$restProps*/
      8 && /*$$restProps*/
      ctx2[3]]));
      toggle_class(ol, "bx--list--ordered", !/*native*/
      ctx2[1]);
      toggle_class(
        ol,
        "bx--list--ordered--native",
        /*native*/
        ctx2[1]
      );
      toggle_class(
        ol,
        "bx--list--nested",
        /*nested*/
        ctx2[0]
      );
      toggle_class(
        ol,
        "bx--list--expressive",
        /*expressive*/
        ctx2[2]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ol);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment115.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance115($$self, $$props, $$invalidate) {
  const omit_props_names = ["nested", "native", "expressive"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OrderedList", slots, ["default"]);
  let { nested = false } = $$props;
  let { native = false } = $$props;
  let { expressive = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("nested" in $$new_props) $$invalidate(0, nested = $$new_props.nested);
    if ("native" in $$new_props) $$invalidate(1, native = $$new_props.native);
    if ("expressive" in $$new_props) $$invalidate(2, expressive = $$new_props.expressive);
    if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ nested, native, expressive });
  $$self.$inject_state = ($$new_props) => {
    if ("nested" in $$props) $$invalidate(0, nested = $$new_props.nested);
    if ("native" in $$props) $$invalidate(1, native = $$new_props.native);
    if ("expressive" in $$props) $$invalidate(2, expressive = $$new_props.expressive);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    nested,
    native,
    expressive,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var OrderedList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance115, create_fragment115, safe_not_equal, { nested: 0, native: 1, expressive: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OrderedList",
      options,
      id: create_fragment115.name
    });
  }
  get nested() {
    throw new Error("<OrderedList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nested(value) {
    throw new Error("<OrderedList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get native() {
    throw new Error("<OrderedList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set native(value) {
    throw new Error("<OrderedList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expressive() {
    throw new Error("<OrderedList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expressive(value) {
    throw new Error("<OrderedList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OrderedList_default = OrderedList;

// node_modules/carbon-components-svelte/src/icons/CaretLeft.svelte
var file107 = "node_modules/carbon-components-svelte/src/icons/CaretLeft.svelte";
function create_if_block70(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file107, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block70.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment116(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block70(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 24L10 16 20 8z");
      add_location(path, file107, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file107, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block70(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment116.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance116($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CaretLeft", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var CaretLeft = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance116, create_fragment116, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CaretLeft",
      options,
      id: create_fragment116.name
    });
  }
  get size() {
    throw new Error("<CaretLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CaretLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CaretLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CaretLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CaretLeft_default = CaretLeft;

// node_modules/carbon-components-svelte/src/Select/Select.svelte
var file108 = "node_modules/carbon-components-svelte/src/Select/Select.svelte";
var get_labelText_slot_changes8 = (dirty) => ({});
var get_labelText_slot_context8 = (ctx) => ({});
function create_if_block_102(ctx) {
  let label;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[26].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    get_labelText_slot_context8
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block24(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[5]
      );
      toggle_class(label, "bx--label", true);
      toggle_class(
        label,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[14]
      );
      toggle_class(
        label,
        "bx--label--disabled",
        /*disabled*/
        ctx[4]
      );
      add_location(label, file108, 136, 6, 3412);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & /*$$scope*/
        33554432)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              get_labelText_slot_changes8
            ),
            get_labelText_slot_context8
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & /*labelText*/
        8192)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      32) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*hideLabel*/
      16384) {
        toggle_class(
          label,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      16) {
        toggle_class(
          label,
          "bx--label--disabled",
          /*disabled*/
          ctx2[4]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_102.name,
    type: "if",
    source: "(136:4) {#if !noLabel}",
    ctx
  });
  return block;
}
function fallback_block24(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[13]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[13]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelText*/
      8192) set_data_dev(
        t,
        /*labelText*/
        ctx2[13]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block24.name,
    type: "fallback",
    source: "(143:31)            ",
    ctx
  });
  return block;
}
function create_if_block_69(ctx) {
  let div1;
  let div0;
  let select;
  let select_aria_describedby_value;
  let select_aria_invalid_value;
  let select_disabled_value;
  let select_required_value;
  let t0;
  let chevrondown;
  let t1;
  let div0_data_invalid_value;
  let t2;
  let t3;
  let if_block2_anchor;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[26].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  chevrondown = new ChevronDown_default({
    props: { class: "bx--select__arrow" },
    $$inline: true
  });
  let if_block0 = (
    /*invalid*/
    ctx[7] && create_if_block_92(ctx)
  );
  let if_block1 = (
    /*invalid*/
    ctx[7] && create_if_block_84(ctx)
  );
  let if_block2 = !/*invalid*/
  ctx[7] && !/*warn*/
  ctx[9] && /*helperText*/
  ctx[11] && create_if_block_75(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      select = element("select");
      if (default_slot) default_slot.c();
      t0 = space();
      create_component(chevrondown.$$.fragment);
      t1 = space();
      if (if_block0) if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { "data-invalid": true });
      var div0_nodes = children(div0);
      select = claim_element(div0_nodes, "SELECT", {
        "aria-describedby": true,
        "aria-invalid": true,
        id: true,
        name: true
      });
      var select_nodes = children(select);
      if (default_slot) default_slot.l(select_nodes);
      select_nodes.forEach(detach_dev);
      t0 = claim_space(div0_nodes);
      claim_component(chevrondown.$$.fragment, div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block0) if_block0.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (if_block1) if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (if_block2) if_block2.l(nodes);
      if_block2_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(select, "aria-describedby", select_aria_describedby_value = /*invalid*/
      ctx[7] ? (
        /*errorId*/
        ctx[16]
      ) : void 0);
      attr_dev(select, "aria-invalid", select_aria_invalid_value = /*invalid*/
      ctx[7] || void 0);
      select.disabled = select_disabled_value = /*disabled*/
      ctx[4] || void 0;
      select.required = select_required_value = /*required*/
      ctx[15] || void 0;
      attr_dev(
        select,
        "id",
        /*id*/
        ctx[5]
      );
      attr_dev(
        select,
        "name",
        /*name*/
        ctx[6]
      );
      toggle_class(select, "bx--select-input", true);
      toggle_class(
        select,
        "bx--select-input--sm",
        /*size*/
        ctx[1] === "sm"
      );
      toggle_class(
        select,
        "bx--select-input--xl",
        /*size*/
        ctx[1] === "xl"
      );
      add_location(select, file108, 153, 10, 3879);
      attr_dev(div0, "data-invalid", div0_data_invalid_value = /*invalid*/
      ctx[7] || void 0);
      toggle_class(div0, "bx--select-input__wrapper", true);
      add_location(div0, file108, 149, 8, 3755);
      toggle_class(div1, "bx--select-input--inline__wrapper", true);
      add_location(div1, file108, 148, 6, 3692);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, select);
      if (default_slot) {
        default_slot.m(select, null);
      }
      ctx[35](select);
      append_hydration_dev(div0, t0);
      mount_component(chevrondown, div0, null);
      append_hydration_dev(div0, t1);
      if (if_block0) if_block0.m(div0, null);
      append_hydration_dev(div1, t2);
      if (if_block1) if_block1.m(div1, null);
      insert_hydration_dev(target, t3, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*handleChange*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "change",
            /*change_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "input",
            /*input_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "focus",
            /*focus_handler*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "blur",
            /*blur_handler*/
            ctx[34],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*invalid, errorId*/
      65664 && select_aria_describedby_value !== (select_aria_describedby_value = /*invalid*/
      ctx2[7] ? (
        /*errorId*/
        ctx2[16]
      ) : void 0)) {
        attr_dev(select, "aria-describedby", select_aria_describedby_value);
      }
      if (!current || dirty[0] & /*invalid*/
      128 && select_aria_invalid_value !== (select_aria_invalid_value = /*invalid*/
      ctx2[7] || void 0)) {
        attr_dev(select, "aria-invalid", select_aria_invalid_value);
      }
      if (!current || dirty[0] & /*disabled*/
      16 && select_disabled_value !== (select_disabled_value = /*disabled*/
      ctx2[4] || void 0)) {
        prop_dev(select, "disabled", select_disabled_value);
      }
      if (!current || dirty[0] & /*required*/
      32768 && select_required_value !== (select_required_value = /*required*/
      ctx2[15] || void 0)) {
        prop_dev(select, "required", select_required_value);
      }
      if (!current || dirty[0] & /*id*/
      32) {
        attr_dev(
          select,
          "id",
          /*id*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*name*/
      64) {
        attr_dev(
          select,
          "name",
          /*name*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*size*/
      2) {
        toggle_class(
          select,
          "bx--select-input--sm",
          /*size*/
          ctx2[1] === "sm"
        );
      }
      if (!current || dirty[0] & /*size*/
      2) {
        toggle_class(
          select,
          "bx--select-input--xl",
          /*size*/
          ctx2[1] === "xl"
        );
      }
      if (
        /*invalid*/
        ctx2[7]
      ) {
        if (if_block0) {
          if (dirty[0] & /*invalid*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_92(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*invalid*/
      128 && div0_data_invalid_value !== (div0_data_invalid_value = /*invalid*/
      ctx2[7] || void 0)) {
        attr_dev(div0, "data-invalid", div0_data_invalid_value);
      }
      if (
        /*invalid*/
        ctx2[7]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_84(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!/*invalid*/
      ctx2[7] && !/*warn*/
      ctx2[9] && /*helperText*/
      ctx2[11]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_75(ctx2);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(chevrondown.$$.fragment, local);
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(chevrondown.$$.fragment, local);
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
        detach_dev(t3);
        detach_dev(if_block2_anchor);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[35](null);
      destroy_component(chevrondown);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_69.name,
    type: "if",
    source: "(148:4) {#if inline}",
    ctx
  });
  return block;
}
function create_if_block_92(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--select__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_92.name,
    type: "if",
    source: "(174:10) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_84(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*invalidText*/
        ctx[8]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*invalidText*/
        ctx[8]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*errorId*/
        ctx[16]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file108, 178, 10, 4708);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*invalidText*/
      256) set_data_dev(
        t,
        /*invalidText*/
        ctx2[8]
      );
      if (dirty[0] & /*errorId*/
      65536) {
        attr_dev(
          div,
          "id",
          /*errorId*/
          ctx2[16]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_84.name,
    type: "if",
    source: "(178:8) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_75(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[11]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[11]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(
        div,
        "bx--form__helper-text--disabled",
        /*disabled*/
        ctx[4]
      );
      add_location(div, file108, 184, 8, 4887);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*helperText*/
      2048) set_data_dev(
        t,
        /*helperText*/
        ctx2[11]
      );
      if (dirty[0] & /*disabled*/
      16) {
        toggle_class(
          div,
          "bx--form__helper-text--disabled",
          /*disabled*/
          ctx2[4]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_75.name,
    type: "if",
    source: "(184:6) {#if !invalid && !warn && helperText}",
    ctx
  });
  return block;
}
function create_if_block71(ctx) {
  let div;
  let select;
  let select_aria_describedby_value;
  let select_disabled_value;
  let select_required_value;
  let select_aria_invalid_value;
  let t0;
  let chevrondown;
  let t1;
  let t2;
  let div_data_invalid_value;
  let t3;
  let t4;
  let t5;
  let if_block4_anchor;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[26].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  chevrondown = new ChevronDown_default({
    props: { class: "bx--select__arrow" },
    $$inline: true
  });
  let if_block0 = (
    /*invalid*/
    ctx[7] && create_if_block_510(ctx)
  );
  let if_block1 = !/*invalid*/
  ctx[7] && /*warn*/
  ctx[9] && create_if_block_411(ctx);
  let if_block2 = !/*invalid*/
  ctx[7] && /*helperText*/
  ctx[11] && create_if_block_313(ctx);
  let if_block3 = (
    /*invalid*/
    ctx[7] && create_if_block_218(ctx)
  );
  let if_block4 = !/*invalid*/
  ctx[7] && /*warn*/
  ctx[9] && create_if_block_128(ctx);
  const block = {
    c: function create() {
      div = element("div");
      select = element("select");
      if (default_slot) default_slot.c();
      t0 = space();
      create_component(chevrondown.$$.fragment);
      t1 = space();
      if (if_block0) if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      if (if_block2) if_block2.c();
      t4 = space();
      if (if_block3) if_block3.c();
      t5 = space();
      if (if_block4) if_block4.c();
      if_block4_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-invalid": true });
      var div_nodes = children(div);
      select = claim_element(div_nodes, "SELECT", {
        id: true,
        name: true,
        "aria-describedby": true,
        "aria-invalid": true
      });
      var select_nodes = children(select);
      if (default_slot) default_slot.l(select_nodes);
      select_nodes.forEach(detach_dev);
      t0 = claim_space(div_nodes);
      claim_component(chevrondown.$$.fragment, div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block0) if_block0.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block1) if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (if_block2) if_block2.l(nodes);
      t4 = claim_space(nodes);
      if (if_block3) if_block3.l(nodes);
      t5 = claim_space(nodes);
      if (if_block4) if_block4.l(nodes);
      if_block4_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        select,
        "id",
        /*id*/
        ctx[5]
      );
      attr_dev(
        select,
        "name",
        /*name*/
        ctx[6]
      );
      attr_dev(select, "aria-describedby", select_aria_describedby_value = /*invalid*/
      ctx[7] ? (
        /*errorId*/
        ctx[16]
      ) : void 0);
      select.disabled = select_disabled_value = /*disabled*/
      ctx[4] || void 0;
      select.required = select_required_value = /*required*/
      ctx[15] || void 0;
      attr_dev(select, "aria-invalid", select_aria_invalid_value = /*invalid*/
      ctx[7] || void 0);
      toggle_class(select, "bx--select-input", true);
      toggle_class(
        select,
        "bx--select-input--sm",
        /*size*/
        ctx[1] === "sm"
      );
      toggle_class(
        select,
        "bx--select-input--xl",
        /*size*/
        ctx[1] === "xl"
      );
      add_location(select, file108, 197, 8, 5210);
      attr_dev(div, "data-invalid", div_data_invalid_value = /*invalid*/
      ctx[7] || void 0);
      toggle_class(div, "bx--select-input__wrapper", true);
      add_location(div, file108, 193, 6, 5094);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, select);
      if (default_slot) {
        default_slot.m(select, null);
      }
      ctx[36](select);
      append_hydration_dev(div, t0);
      mount_component(chevrondown, div, null);
      append_hydration_dev(div, t1);
      if (if_block0) if_block0.m(div, null);
      append_hydration_dev(div, t2);
      if (if_block1) if_block1.m(div, null);
      insert_hydration_dev(target, t3, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert_hydration_dev(target, t4, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert_hydration_dev(target, t5, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert_hydration_dev(target, if_block4_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*handleChange*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "change",
            /*change_handler_1*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "input",
            /*input_handler_1*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "focus",
            /*focus_handler_1*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "blur",
            /*blur_handler_1*/
            ctx[30],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*id*/
      32) {
        attr_dev(
          select,
          "id",
          /*id*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*name*/
      64) {
        attr_dev(
          select,
          "name",
          /*name*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*invalid, errorId*/
      65664 && select_aria_describedby_value !== (select_aria_describedby_value = /*invalid*/
      ctx2[7] ? (
        /*errorId*/
        ctx2[16]
      ) : void 0)) {
        attr_dev(select, "aria-describedby", select_aria_describedby_value);
      }
      if (!current || dirty[0] & /*disabled*/
      16 && select_disabled_value !== (select_disabled_value = /*disabled*/
      ctx2[4] || void 0)) {
        prop_dev(select, "disabled", select_disabled_value);
      }
      if (!current || dirty[0] & /*required*/
      32768 && select_required_value !== (select_required_value = /*required*/
      ctx2[15] || void 0)) {
        prop_dev(select, "required", select_required_value);
      }
      if (!current || dirty[0] & /*invalid*/
      128 && select_aria_invalid_value !== (select_aria_invalid_value = /*invalid*/
      ctx2[7] || void 0)) {
        attr_dev(select, "aria-invalid", select_aria_invalid_value);
      }
      if (!current || dirty[0] & /*size*/
      2) {
        toggle_class(
          select,
          "bx--select-input--sm",
          /*size*/
          ctx2[1] === "sm"
        );
      }
      if (!current || dirty[0] & /*size*/
      2) {
        toggle_class(
          select,
          "bx--select-input--xl",
          /*size*/
          ctx2[1] === "xl"
        );
      }
      if (
        /*invalid*/
        ctx2[7]
      ) {
        if (if_block0) {
          if (dirty[0] & /*invalid*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_510(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*invalid*/
      ctx2[7] && /*warn*/
      ctx2[9]) {
        if (if_block1) {
          if (dirty[0] & /*invalid, warn*/
          640) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_411(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*invalid*/
      128 && div_data_invalid_value !== (div_data_invalid_value = /*invalid*/
      ctx2[7] || void 0)) {
        attr_dev(div, "data-invalid", div_data_invalid_value);
      }
      if (!/*invalid*/
      ctx2[7] && /*helperText*/
      ctx2[11]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_313(ctx2);
          if_block2.c();
          if_block2.m(t4.parentNode, t4);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*invalid*/
        ctx2[7]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_218(ctx2);
          if_block3.c();
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (!/*invalid*/
      ctx2[7] && /*warn*/
      ctx2[9]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_128(ctx2);
          if_block4.c();
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(chevrondown.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(chevrondown.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(t5);
        detach_dev(if_block4_anchor);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[36](null);
      destroy_component(chevrondown);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d(detaching);
      if (if_block3) if_block3.d(detaching);
      if (if_block4) if_block4.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block71.name,
    type: "if",
    source: "(193:4) {#if !inline}",
    ctx
  });
  return block;
}
function create_if_block_510(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--select__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_510.name,
    type: "if",
    source: "(218:8) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_411(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--select__invalid-icon bx--select__invalid-icon--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningaltfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_411.name,
    type: "if",
    source: "(221:8) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_313(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[11]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[11]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(
        div,
        "bx--form__helper-text--disabled",
        /*disabled*/
        ctx[4]
      );
      add_location(div, file108, 227, 8, 6169);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*helperText*/
      2048) set_data_dev(
        t,
        /*helperText*/
        ctx2[11]
      );
      if (dirty[0] & /*disabled*/
      16) {
        toggle_class(
          div,
          "bx--form__helper-text--disabled",
          /*disabled*/
          ctx2[4]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_313.name,
    type: "if",
    source: "(227:6) {#if !invalid && helperText}",
    ctx
  });
  return block;
}
function create_if_block_218(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*invalidText*/
        ctx[8]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*invalidText*/
        ctx[8]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*errorId*/
        ctx[16]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file108, 235, 8, 6370);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*invalidText*/
      256) set_data_dev(
        t,
        /*invalidText*/
        ctx2[8]
      );
      if (dirty[0] & /*errorId*/
      65536) {
        attr_dev(
          div,
          "id",
          /*errorId*/
          ctx2[16]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_218.name,
    type: "if",
    source: "(235:6) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_128(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*warnText*/
        ctx[10]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*warnText*/
        ctx[10]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*errorId*/
        ctx[16]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file108, 240, 8, 6515);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*warnText*/
      1024) set_data_dev(
        t,
        /*warnText*/
        ctx2[10]
      );
      if (dirty[0] & /*errorId*/
      65536) {
        attr_dev(
          div,
          "id",
          /*errorId*/
          ctx2[16]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_128.name,
    type: "if",
    source: "(240:6) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_fragment117(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let current;
  let if_block0 = !/*noLabel*/
  ctx[12] && create_if_block_102(ctx);
  let if_block1 = (
    /*inline*/
    ctx[2] && create_if_block_69(ctx)
  );
  let if_block2 = !/*inline*/
  ctx[2] && create_if_block71(ctx);
  let div1_levels = [
    /*$$restProps*/
    ctx[22]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (if_block0) if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      if (if_block1) if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block2) if_block2.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--select", true);
      toggle_class(
        div0,
        "bx--select--inline",
        /*inline*/
        ctx[2]
      );
      toggle_class(
        div0,
        "bx--select--light",
        /*light*/
        ctx[3]
      );
      toggle_class(
        div0,
        "bx--select--invalid",
        /*invalid*/
        ctx[7]
      );
      toggle_class(
        div0,
        "bx--select--disabled",
        /*disabled*/
        ctx[4]
      );
      toggle_class(
        div0,
        "bx--select--warning",
        /*warn*/
        ctx[9]
      );
      add_location(div0, file108, 127, 2, 3145);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file108, 126, 0, 3091);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (if_block0) if_block0.m(div0, null);
      append_hydration_dev(div0, t0);
      if (if_block1) if_block1.m(div0, null);
      append_hydration_dev(div0, t1);
      if (if_block2) if_block2.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*noLabel*/
      ctx2[12]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*noLabel*/
          4096) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_102(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*inline*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*inline*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_69(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!/*inline*/
      ctx2[2]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*inline*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block71(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*inline*/
      4) {
        toggle_class(
          div0,
          "bx--select--inline",
          /*inline*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*light*/
      8) {
        toggle_class(
          div0,
          "bx--select--light",
          /*light*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*invalid*/
      128) {
        toggle_class(
          div0,
          "bx--select--invalid",
          /*invalid*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      16) {
        toggle_class(
          div0,
          "bx--select--disabled",
          /*disabled*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*warn*/
      512) {
        toggle_class(
          div0,
          "bx--select--warning",
          /*warn*/
          ctx2[9]
        );
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty[0] & /*$$restProps*/
      4194304 && /*$$restProps*/
      ctx2[22]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment117.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance117($$self, $$props, $$invalidate) {
  let errorId;
  const omit_props_names = [
    "selected",
    "size",
    "inline",
    "light",
    "disabled",
    "id",
    "name",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "helperText",
    "noLabel",
    "labelText",
    "hideLabel",
    "ref",
    "required"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $defaultValue;
  let $selectedValue;
  let $itemTypesByValue;
  let $defaultSelectId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Select", slots, ["labelText", "default"]);
  let { selected = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { inline = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { helperText = "" } = $$props;
  let { noLabel = false } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { ref = null } = $$props;
  let { required = false } = $$props;
  const dispatch = createEventDispatcher();
  const selectedValue = writable(selected);
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value) => $$invalidate(38, $selectedValue = value));
  const defaultSelectId = writable(null);
  validate_store(defaultSelectId, "defaultSelectId");
  component_subscribe($$self, defaultSelectId, (value) => $$invalidate(40, $defaultSelectId = value));
  const defaultValue = writable(null);
  validate_store(defaultValue, "defaultValue");
  component_subscribe($$self, defaultValue, (value) => $$invalidate(24, $defaultValue = value));
  const itemTypesByValue = writable({});
  validate_store(itemTypesByValue, "itemTypesByValue");
  component_subscribe($$self, itemTypesByValue, (value) => $$invalidate(39, $itemTypesByValue = value));
  setContext("Select", {
    selectedValue,
    setDefaultValue: (id2, value) => {
      if ($defaultValue === null) {
        defaultSelectId.set(id2);
        defaultValue.set(value);
      } else {
        if ($defaultSelectId === id2) {
          selectedValue.set(value);
        }
      }
      itemTypesByValue.update((types) => ({ ...types, [value]: typeof value }));
    }
  });
  const handleChange = ({ target }) => {
    let value = target.value;
    if ($itemTypesByValue[value] === "number") {
      value = Number(value);
    }
    selectedValue.set(value);
  };
  let prevSelected = void 0;
  afterUpdate(() => {
    $$invalidate(23, selected = $selectedValue);
    if (prevSelected !== void 0 && selected !== prevSelected) {
      dispatch("update", $selectedValue);
    }
    prevSelected = selected;
  });
  function change_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  function select_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props) $$invalidate(23, selected = $$new_props.selected);
    if ("size" in $$new_props) $$invalidate(1, size = $$new_props.size);
    if ("inline" in $$new_props) $$invalidate(2, inline = $$new_props.inline);
    if ("light" in $$new_props) $$invalidate(3, light = $$new_props.light);
    if ("disabled" in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
    if ("id" in $$new_props) $$invalidate(5, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(6, name = $$new_props.name);
    if ("invalid" in $$new_props) $$invalidate(7, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props) $$invalidate(8, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props) $$invalidate(9, warn = $$new_props.warn);
    if ("warnText" in $$new_props) $$invalidate(10, warnText = $$new_props.warnText);
    if ("helperText" in $$new_props) $$invalidate(11, helperText = $$new_props.helperText);
    if ("noLabel" in $$new_props) $$invalidate(12, noLabel = $$new_props.noLabel);
    if ("labelText" in $$new_props) $$invalidate(13, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props) $$invalidate(14, hideLabel = $$new_props.hideLabel);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("required" in $$new_props) $$invalidate(15, required = $$new_props.required);
    if ("$$scope" in $$new_props) $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    size,
    inline,
    light,
    disabled,
    id,
    name,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    noLabel,
    labelText,
    hideLabel,
    ref,
    required,
    createEventDispatcher,
    setContext,
    afterUpdate,
    writable,
    ChevronDown: ChevronDown_default,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    dispatch,
    selectedValue,
    defaultSelectId,
    defaultValue,
    itemTypesByValue,
    handleChange,
    prevSelected,
    errorId,
    $defaultValue,
    $selectedValue,
    $itemTypesByValue,
    $defaultSelectId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props) $$invalidate(23, selected = $$new_props.selected);
    if ("size" in $$props) $$invalidate(1, size = $$new_props.size);
    if ("inline" in $$props) $$invalidate(2, inline = $$new_props.inline);
    if ("light" in $$props) $$invalidate(3, light = $$new_props.light);
    if ("disabled" in $$props) $$invalidate(4, disabled = $$new_props.disabled);
    if ("id" in $$props) $$invalidate(5, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(6, name = $$new_props.name);
    if ("invalid" in $$props) $$invalidate(7, invalid = $$new_props.invalid);
    if ("invalidText" in $$props) $$invalidate(8, invalidText = $$new_props.invalidText);
    if ("warn" in $$props) $$invalidate(9, warn = $$new_props.warn);
    if ("warnText" in $$props) $$invalidate(10, warnText = $$new_props.warnText);
    if ("helperText" in $$props) $$invalidate(11, helperText = $$new_props.helperText);
    if ("noLabel" in $$props) $$invalidate(12, noLabel = $$new_props.noLabel);
    if ("labelText" in $$props) $$invalidate(13, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props) $$invalidate(14, hideLabel = $$new_props.hideLabel);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    if ("required" in $$props) $$invalidate(15, required = $$new_props.required);
    if ("prevSelected" in $$props) prevSelected = $$new_props.prevSelected;
    if ("errorId" in $$props) $$invalidate(16, errorId = $$new_props.errorId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*id*/
    32) {
      $: $$invalidate(16, errorId = `error-${id}`);
    }
    if ($$self.$$.dirty[0] & /*selected, $defaultValue*/
    25165824) {
      $: selectedValue.set(selected ?? $defaultValue);
    }
  };
  return [
    ref,
    size,
    inline,
    light,
    disabled,
    id,
    name,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    noLabel,
    labelText,
    hideLabel,
    required,
    errorId,
    selectedValue,
    defaultSelectId,
    defaultValue,
    itemTypesByValue,
    handleChange,
    $$restProps,
    selected,
    $defaultValue,
    $$scope,
    slots,
    change_handler_1,
    input_handler_1,
    focus_handler_1,
    blur_handler_1,
    change_handler,
    input_handler,
    focus_handler,
    blur_handler,
    select_binding,
    select_binding_1
  ];
}
var Select = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance117,
      create_fragment117,
      safe_not_equal,
      {
        selected: 23,
        size: 1,
        inline: 2,
        light: 3,
        disabled: 4,
        id: 5,
        name: 6,
        invalid: 7,
        invalidText: 8,
        warn: 9,
        warnText: 10,
        helperText: 11,
        noLabel: 12,
        labelText: 13,
        hideLabel: 14,
        ref: 0,
        required: 15
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select",
      options,
      id: create_fragment117.name
    });
  }
  get selected() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noLabel() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noLabel(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Select_default = Select;

// node_modules/carbon-components-svelte/src/Select/SelectItem.svelte
var file109 = "node_modules/carbon-components-svelte/src/Select/SelectItem.svelte";
function create_fragment118(ctx) {
  let option;
  let t_value = (
    /*text*/
    (ctx[1] || /*value*/
    ctx[0]) + ""
  );
  let t;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", { class: true, style: true });
      var option_nodes = children(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = /*value*/
      ctx[0];
      set_input_value(option, option.__value);
      option.disabled = /*disabled*/
      ctx[3];
      option.hidden = /*hidden*/
      ctx[2];
      option.selected = /*selected*/
      ctx[6];
      attr_dev(
        option,
        "class",
        /*className*/
        ctx[4]
      );
      attr_dev(
        option,
        "style",
        /*style*/
        ctx[5]
      );
      toggle_class(option, "bx--select-option", true);
      add_location(option, file109, 48, 0, 987);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*text, value*/
      3 && t_value !== (t_value = /*text*/
      (ctx2[1] || /*value*/
      ctx2[0]) + "")) set_data_dev(t, t_value);
      if (dirty & /*value*/
      1) {
        prop_dev(
          option,
          "__value",
          /*value*/
          ctx2[0]
        );
        set_input_value(option, option.__value);
      }
      if (dirty & /*disabled*/
      8) {
        prop_dev(
          option,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (dirty & /*hidden*/
      4) {
        prop_dev(
          option,
          "hidden",
          /*hidden*/
          ctx2[2]
        );
      }
      if (dirty & /*selected*/
      64) {
        prop_dev(
          option,
          "selected",
          /*selected*/
          ctx2[6]
        );
      }
      if (dirty & /*className*/
      16) {
        attr_dev(
          option,
          "class",
          /*className*/
          ctx2[4]
        );
      }
      if (dirty & /*style*/
      32) {
        attr_dev(
          option,
          "style",
          /*style*/
          ctx2[5]
        );
      }
      if (dirty & /*className*/
      16) {
        toggle_class(option, "bx--select-option", true);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment118.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance118($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectItem", slots, []);
  let { value = "" } = $$props;
  let { text: text2 = "" } = $$props;
  let { hidden = false } = $$props;
  let { disabled = false } = $$props;
  let { class: className = void 0 } = $$props;
  let { style = void 0 } = $$props;
  const id = "ccs-" + Math.random().toString(36);
  const ctx = getContext("Select") || getContext("TimePickerSelect");
  let selected = false;
  const unsubscribe = ctx.selectedValue.subscribe((currentValue) => {
    $$invalidate(6, selected = currentValue === value);
  });
  onMount(() => {
    return () => unsubscribe();
  });
  const writable_props = ["value", "text", "hidden", "disabled", "class", "style"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<SelectItem> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("text" in $$props2) $$invalidate(1, text2 = $$props2.text);
    if ("hidden" in $$props2) $$invalidate(2, hidden = $$props2.hidden);
    if ("disabled" in $$props2) $$invalidate(3, disabled = $$props2.disabled);
    if ("class" in $$props2) $$invalidate(4, className = $$props2.class);
    if ("style" in $$props2) $$invalidate(5, style = $$props2.style);
  };
  $$self.$capture_state = () => ({
    value,
    text: text2,
    hidden,
    disabled,
    className,
    style,
    getContext,
    onMount,
    id,
    ctx,
    selected,
    unsubscribe
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("text" in $$props2) $$invalidate(1, text2 = $$props2.text);
    if ("hidden" in $$props2) $$invalidate(2, hidden = $$props2.hidden);
    if ("disabled" in $$props2) $$invalidate(3, disabled = $$props2.disabled);
    if ("className" in $$props2) $$invalidate(4, className = $$props2.className);
    if ("style" in $$props2) $$invalidate(5, style = $$props2.style);
    if ("selected" in $$props2) $$invalidate(6, selected = $$props2.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & /*value*/
    1) {
      $: (_a = ctx == null ? void 0 : ctx.setDefaultValue) == null ? void 0 : _a.call(ctx, id, value);
    }
  };
  return [value, text2, hidden, disabled, className, style, selected];
}
var SelectItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance118, create_fragment118, safe_not_equal, {
      value: 0,
      text: 1,
      hidden: 2,
      disabled: 3,
      class: 4,
      style: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectItem",
      options,
      id: create_fragment118.name
    });
  }
  get value() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectItem_default = SelectItem;

// node_modules/carbon-components-svelte/src/Pagination/Pagination.svelte
var file110 = "node_modules/carbon-components-svelte/src/Pagination/Pagination.svelte";
function get_each_context13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i];
  child_ctx[30] = i;
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i];
  child_ctx[30] = i;
  return child_ctx;
}
function create_if_block_314(ctx) {
  let label;
  let t0;
  let label_id_value;
  let label_for_value;
  let t1;
  let select;
  let updating_selected;
  let current;
  function select_selected_binding(value) {
    ctx[22](value);
  }
  let select_props = {
    id: "bx--pagination-select-" + /*id*/
    ctx[14],
    class: "bx--select__item-count",
    hideLabel: true,
    noLabel: true,
    inline: true,
    $$slots: { default: [create_default_slot_17] },
    $$scope: { ctx }
  };
  if (
    /*pageSize*/
    ctx[1] !== void 0
  ) {
    select_props.selected = /*pageSize*/
    ctx[1];
  }
  select = new Select_default({ props: select_props, $$inline: true });
  binding_callbacks.push(() => bind(select, "selected", select_selected_binding));
  select.$on(
    "change",
    /*change_handler*/
    ctx[23]
  );
  const block = {
    c: function create() {
      label = element("label");
      t0 = text(
        /*itemsPerPageText*/
        ctx[5]
      );
      t1 = space();
      create_component(select.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { id: true, for: true });
      var label_nodes = children(label);
      t0 = claim_text(
        label_nodes,
        /*itemsPerPageText*/
        ctx[5]
      );
      label_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      claim_component(select.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label, "id", label_id_value = "bx--pagination-select-" + /*id*/
      ctx[14] + "-count-label");
      attr_dev(label, "for", label_for_value = "bx--pagination-select-" + /*id*/
      ctx[14]);
      toggle_class(label, "bx--pagination__text", true);
      add_location(label, file110, 99, 6, 2987);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, t0);
      insert_hydration_dev(target, t1, anchor);
      mount_component(select, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*itemsPerPageText*/
      32) set_data_dev(
        t0,
        /*itemsPerPageText*/
        ctx2[5]
      );
      if (!current || dirty[0] & /*id*/
      16384 && label_id_value !== (label_id_value = "bx--pagination-select-" + /*id*/
      ctx2[14] + "-count-label")) {
        attr_dev(label, "id", label_id_value);
      }
      if (!current || dirty[0] & /*id*/
      16384 && label_for_value !== (label_for_value = "bx--pagination-select-" + /*id*/
      ctx2[14])) {
        attr_dev(label, "for", label_for_value);
      }
      const select_changes = {};
      if (dirty[0] & /*id*/
      16384) select_changes.id = "bx--pagination-select-" + /*id*/
      ctx2[14];
      if (dirty[0] & /*pageSizes*/
      1024 | dirty[1] & /*$$scope*/
      2) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selected && dirty[0] & /*pageSize*/
      2) {
        updating_selected = true;
        select_changes.selected = /*pageSize*/
        ctx2[1];
        add_flush_callback(() => updating_selected = false);
      }
      select.$set(select_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
        detach_dev(t1);
      }
      destroy_component(select, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_314.name,
    type: "if",
    source: "(99:4) {#if !pageSizeInputDisabled}",
    ctx
  });
  return block;
}
function create_each_block_13(key_1, ctx) {
  let first;
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      value: (
        /*size*/
        ctx[28]
      ),
      text: (
        /*size*/
        ctx[28].toString()
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(selectitem.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(selectitem.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const selectitem_changes = {};
      if (dirty[0] & /*pageSizes*/
      1024) selectitem_changes.value = /*size*/
      ctx[28];
      if (dirty[0] & /*pageSizes*/
      1024) selectitem_changes.text = /*size*/
      ctx[28].toString();
      selectitem.$set(selectitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(selectitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_13.name,
    type: "each",
    source: "(118:8) {#each pageSizes as size, i (size)}",
    ctx
  });
  return block;
}
function create_default_slot_17(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like_dev(
    /*pageSizes*/
    ctx[10]
  );
  const get_key = (ctx2) => (
    /*size*/
    ctx2[28]
  );
  validate_each_keys(ctx, each_value_1, get_each_context_13, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_13(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_13(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*pageSizes*/
      1024) {
        each_value_1 = ensure_array_like_dev(
          /*pageSizes*/
          ctx2[10]
        );
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_13, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_13, each_1_anchor, get_each_context_13);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_17.name,
    type: "slot",
    source: `(107:6) <Select         id=\\"bx--pagination-select-{id}\\"         class=\\"bx--select__item-count\\"         hideLabel         noLabel         inline         on:change=\\"{() => {           dispatch('change', { pageSize });         }}\\"         bind:selected=\\"{pageSize}\\"       >`,
    ctx
  });
  return block;
}
function create_else_block_13(ctx) {
  let t_value = (
    /*itemRangeText*/
    ctx[7](
      Math.min(
        /*pageSize*/
        ctx[1] * /*page*/
        (ctx[0] - 1) + 1,
        /*totalItems*/
        ctx[2]
      ),
      Math.min(
        /*page*/
        ctx[0] * /*pageSize*/
        ctx[1],
        /*totalItems*/
        ctx[2]
      ),
      /*totalItems*/
      ctx[2]
    ) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*itemRangeText, pageSize, page, totalItems*/
      135 && t_value !== (t_value = /*itemRangeText*/
      ctx2[7](
        Math.min(
          /*pageSize*/
          ctx2[1] * /*page*/
          (ctx2[0] - 1) + 1,
          /*totalItems*/
          ctx2[2]
        ),
        Math.min(
          /*page*/
          ctx2[0] * /*pageSize*/
          ctx2[1],
          /*totalItems*/
          ctx2[2]
        ),
        /*totalItems*/
        ctx2[2]
      ) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_13.name,
    type: "else",
    source: "(126:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_219(ctx) {
  let t_value = (
    /*itemText*/
    ctx[6](
      /*pageSize*/
      ctx[1] * /*page*/
      (ctx[0] - 1) + 1,
      /*page*/
      ctx[0] * /*pageSize*/
      ctx[1]
    ) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*itemText, pageSize, page*/
      67 && t_value !== (t_value = /*itemText*/
      ctx2[6](
        /*pageSize*/
        ctx2[1] * /*page*/
        (ctx2[0] - 1) + 1,
        /*page*/
        ctx2[0] * /*pageSize*/
        ctx2[1]
      ) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_219.name,
    type: "if",
    source: "(124:6) {#if pagesUnknown}",
    ctx
  });
  return block;
}
function create_if_block72(ctx) {
  let select;
  let updating_selected;
  let t;
  let span;
  let current;
  function select_selected_binding_1(value) {
    ctx[24](value);
  }
  let select_props = {
    id: "bx--pagination-select-" + /*id*/
    (ctx[14] + 2),
    class: "bx--select__page-number",
    labelText: "Page number, of " + /*totalPages*/
    ctx[15] + " pages",
    inline: true,
    hideLabel: true,
    $$slots: { default: [create_default_slot17] },
    $$scope: { ctx }
  };
  if (
    /*page*/
    ctx[0] !== void 0
  ) {
    select_props.selected = /*page*/
    ctx[0];
  }
  select = new Select_default({ props: select_props, $$inline: true });
  binding_callbacks.push(() => bind(select, "selected", select_selected_binding_1));
  select.$on(
    "change",
    /*change_handler_1*/
    ctx[25]
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*pagesUnknown*/
      ctx2[11]
    ) return create_if_block_129;
    return create_else_block25;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      create_component(select.$$.fragment);
      t = space();
      span = element("span");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(select.$$.fragment, nodes);
      t = claim_space(nodes);
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--pagination__text", true);
      add_location(span, file110, 151, 6, 4503);
    },
    m: function mount(target, anchor) {
      mount_component(select, target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, span, anchor);
      if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const select_changes = {};
      if (dirty[0] & /*id*/
      16384) select_changes.id = "bx--pagination-select-" + /*id*/
      (ctx2[14] + 2);
      if (dirty[0] & /*totalPages*/
      32768) select_changes.labelText = "Page number, of " + /*totalPages*/
      ctx2[15] + " pages";
      if (dirty[0] & /*selectItems*/
      262144 | dirty[1] & /*$$scope*/
      2) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selected && dirty[0] & /*page*/
      1) {
        updating_selected = true;
        select_changes.selected = /*page*/
        ctx2[0];
        add_flush_callback(() => updating_selected = false);
      }
      select.$set(select_changes);
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(span, null);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(span);
      }
      destroy_component(select, detaching);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block72.name,
    type: "if",
    source: "(136:4) {#if !pageInputDisabled}",
    ctx
  });
  return block;
}
function create_each_block13(key_1, ctx) {
  let first;
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      value: (
        /*size*/
        ctx[28] + 1
      ),
      text: (
        /*size*/
        (ctx[28] + 1).toString()
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(selectitem.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(selectitem.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const selectitem_changes = {};
      if (dirty[0] & /*selectItems*/
      262144) selectitem_changes.value = /*size*/
      ctx[28] + 1;
      if (dirty[0] & /*selectItems*/
      262144) selectitem_changes.text = /*size*/
      (ctx[28] + 1).toString();
      selectitem.$set(selectitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(selectitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block13.name,
    type: "each",
    source: "(148:8) {#each selectItems as size, i (size)}",
    ctx
  });
  return block;
}
function create_default_slot17(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*selectItems*/
    ctx[18]
  );
  const get_key = (ctx2) => (
    /*size*/
    ctx2[28]
  );
  validate_each_keys(ctx, each_value, get_each_context13, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context13(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block13(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*selectItems*/
      262144) {
        each_value = ensure_array_like_dev(
          /*selectItems*/
          ctx2[18]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context13, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block13, each_1_anchor, get_each_context13);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot17.name,
    type: "slot",
    source: `(137:6) <Select         id=\\"bx--pagination-select-{id + 2}\\"         class=\\"bx--select__page-number\\"         labelText=\\"Page number, of {totalPages} pages\\"         inline         hideLabel         on:change=\\"{() => {           dispatch('change', { page });         }}\\"         bind:selected=\\"{page}\\"       >`,
    ctx
  });
  return block;
}
function create_else_block25(ctx) {
  let t_value = (
    /*pageRangeText*/
    ctx[13](
      /*page*/
      ctx[0],
      /*totalPages*/
      ctx[15]
    ) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*pageRangeText, page, totalPages*/
      40961 && t_value !== (t_value = /*pageRangeText*/
      ctx2[13](
        /*page*/
        ctx2[0],
        /*totalPages*/
        ctx2[15]
      ) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block25.name,
    type: "else",
    source: "(155:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_129(ctx) {
  let t_value = (
    /*pageText*/
    ctx[12](
      /*page*/
      ctx[0]
    ) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*pageText, page*/
      4097 && t_value !== (t_value = /*pageText*/
      ctx2[12](
        /*page*/
        ctx2[0]
      ) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_129.name,
    type: "if",
    source: "(153:8) {#if pagesUnknown}",
    ctx
  });
  return block;
}
function create_fragment119(ctx) {
  let div2;
  let div0;
  let t0;
  let span;
  let t1;
  let div1;
  let t2;
  let button0;
  let t3;
  let button1;
  let current;
  let if_block0 = !/*pageSizeInputDisabled*/
  ctx[9] && create_if_block_314(ctx);
  function select_block_type(ctx2, dirty) {
    if (
      /*pagesUnknown*/
      ctx2[11]
    ) return create_if_block_219;
    return create_else_block_13;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block1 = current_block_type(ctx);
  let if_block2 = !/*pageInputDisabled*/
  ctx[8] && create_if_block72(ctx);
  button0 = new Button_default({
    props: {
      kind: "ghost",
      tooltipAlignment: "center",
      tooltipPosition: "top",
      icon: CaretLeft_default,
      iconDescription: (
        /*backwardText*/
        ctx[4]
      ),
      disabled: (
        /*backButtonDisabled*/
        ctx[17]
      ),
      class: "bx--pagination__button bx--pagination__button--backward " + /*backButtonDisabled*/
      (ctx[17] ? "bx--pagination__button--no-index" : "")
    },
    $$inline: true
  });
  button0.$on(
    "click",
    /*click_handler*/
    ctx[26]
  );
  button1 = new Button_default({
    props: {
      kind: "ghost",
      tooltipAlignment: "end",
      tooltipPosition: "top",
      icon: CaretRight_default,
      iconDescription: (
        /*forwardText*/
        ctx[3]
      ),
      disabled: (
        /*forwardButtonDisabled*/
        ctx[16]
      ),
      class: "bx--pagination__button bx--pagination__button--forward " + /*forwardButtonDisabled*/
      (ctx[16] ? "bx--pagination__button--no-index" : "")
    },
    $$inline: true
  });
  button1.$on(
    "click",
    /*click_handler_1*/
    ctx[27]
  );
  let div2_levels = [
    { id: (
      /*id*/
      ctx[14]
    ) },
    /*$$restProps*/
    ctx[20]
  ];
  let div_data_2 = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      span = element("span");
      if_block1.c();
      t1 = space();
      div1 = element("div");
      if (if_block2) if_block2.c();
      t2 = space();
      create_component(button0.$$.fragment);
      t3 = space();
      create_component(button1.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { id: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (if_block0) if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      span = claim_element(div0_nodes, "SPAN", {});
      var span_nodes = children(span);
      if_block1.l(span_nodes);
      span_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", {});
      var div1_nodes = children(div1);
      if (if_block2) if_block2.l(div1_nodes);
      t2 = claim_space(div1_nodes);
      claim_component(button0.$$.fragment, div1_nodes);
      t3 = claim_space(div1_nodes);
      claim_component(button1.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--pagination__text", !/*pageSizeInputDisabled*/
      ctx[9]);
      add_location(span, file110, 122, 4, 3605);
      toggle_class(div0, "bx--pagination__left", true);
      add_location(div0, file110, 97, 2, 2906);
      toggle_class(div1, "bx--pagination__right", true);
      add_location(div1, file110, 134, 2, 3967);
      set_attributes(div2, div_data_2);
      toggle_class(div2, "bx--pagination", true);
      add_location(div2, file110, 96, 0, 2841);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      if (if_block0) if_block0.m(div0, null);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div0, span);
      if_block1.m(span, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      if (if_block2) if_block2.m(div1, null);
      append_hydration_dev(div1, t2);
      mount_component(button0, div1, null);
      append_hydration_dev(div1, t3);
      mount_component(button1, div1, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*pageSizeInputDisabled*/
      ctx2[9]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*pageSizeInputDisabled*/
          512) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_314(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(span, null);
        }
      }
      if (!current || dirty[0] & /*pageSizeInputDisabled*/
      512) {
        toggle_class(span, "bx--pagination__text", !/*pageSizeInputDisabled*/
        ctx2[9]);
      }
      if (!/*pageInputDisabled*/
      ctx2[8]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*pageInputDisabled*/
          256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block72(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const button0_changes = {};
      if (dirty[0] & /*backwardText*/
      16) button0_changes.iconDescription = /*backwardText*/
      ctx2[4];
      if (dirty[0] & /*backButtonDisabled*/
      131072) button0_changes.disabled = /*backButtonDisabled*/
      ctx2[17];
      if (dirty[0] & /*backButtonDisabled*/
      131072) button0_changes.class = "bx--pagination__button bx--pagination__button--backward " + /*backButtonDisabled*/
      (ctx2[17] ? "bx--pagination__button--no-index" : "");
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty[0] & /*forwardText*/
      8) button1_changes.iconDescription = /*forwardText*/
      ctx2[3];
      if (dirty[0] & /*forwardButtonDisabled*/
      65536) button1_changes.disabled = /*forwardButtonDisabled*/
      ctx2[16];
      if (dirty[0] & /*forwardButtonDisabled*/
      65536) button1_changes.class = "bx--pagination__button bx--pagination__button--forward " + /*forwardButtonDisabled*/
      (ctx2[16] ? "bx--pagination__button--no-index" : "");
      button1.$set(button1_changes);
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        (!current || dirty[0] & /*id*/
        16384) && { id: (
          /*id*/
          ctx2[14]
        ) },
        dirty[0] & /*$$restProps*/
        1048576 && /*$$restProps*/
        ctx2[20]
      ]));
      toggle_class(div2, "bx--pagination", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block2);
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block0) if_block0.d();
      if_block1.d();
      if (if_block2) if_block2.d();
      destroy_component(button0);
      destroy_component(button1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment119.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance119($$self, $$props, $$invalidate) {
  let totalPages;
  let selectItems;
  let backButtonDisabled;
  let forwardButtonDisabled;
  const omit_props_names = [
    "page",
    "totalItems",
    "disabled",
    "forwardText",
    "backwardText",
    "itemsPerPageText",
    "itemText",
    "itemRangeText",
    "pageInputDisabled",
    "pageSizeInputDisabled",
    "pageSize",
    "pageSizes",
    "pagesUnknown",
    "pageText",
    "pageRangeText",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pagination", slots, []);
  let { page = 1 } = $$props;
  let { totalItems = 0 } = $$props;
  let { disabled = false } = $$props;
  let { forwardText = "Next page" } = $$props;
  let { backwardText = "Previous page" } = $$props;
  let { itemsPerPageText = "Items per page:" } = $$props;
  let { itemText = (min, max) => `${min}–${max} item${max === 1 ? "" : "s"}` } = $$props;
  let { itemRangeText = (min, max, total) => `${min}–${max} of ${total} item${max === 1 ? "" : "s"}` } = $$props;
  let { pageInputDisabled = false } = $$props;
  let { pageSizeInputDisabled = false } = $$props;
  let { pageSize = 10 } = $$props;
  let { pageSizes = [10] } = $$props;
  let { pagesUnknown = false } = $$props;
  let { pageText = (page2) => `page ${page2}` } = $$props;
  let { pageRangeText = (current, total) => `of ${total} page${total === 1 ? "" : "s"}` } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  const dispatch = createEventDispatcher();
  afterUpdate(() => {
    if (page > totalPages) {
      $$invalidate(0, page = totalPages);
    }
  });
  function select_selected_binding(value) {
    pageSize = value;
    $$invalidate(1, pageSize);
  }
  const change_handler = () => {
    dispatch("change", { pageSize });
  };
  function select_selected_binding_1(value) {
    page = value;
    $$invalidate(0, page);
  }
  const change_handler_1 = () => {
    dispatch("change", { page });
  };
  const click_handler = () => {
    $$invalidate(0, page--, page);
    dispatch("click:button--previous", { page });
    dispatch("change", { page });
  };
  const click_handler_13 = () => {
    $$invalidate(0, page++, page);
    dispatch("click:button--next", { page });
    dispatch("change", { page });
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(20, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("page" in $$new_props) $$invalidate(0, page = $$new_props.page);
    if ("totalItems" in $$new_props) $$invalidate(2, totalItems = $$new_props.totalItems);
    if ("disabled" in $$new_props) $$invalidate(21, disabled = $$new_props.disabled);
    if ("forwardText" in $$new_props) $$invalidate(3, forwardText = $$new_props.forwardText);
    if ("backwardText" in $$new_props) $$invalidate(4, backwardText = $$new_props.backwardText);
    if ("itemsPerPageText" in $$new_props) $$invalidate(5, itemsPerPageText = $$new_props.itemsPerPageText);
    if ("itemText" in $$new_props) $$invalidate(6, itemText = $$new_props.itemText);
    if ("itemRangeText" in $$new_props) $$invalidate(7, itemRangeText = $$new_props.itemRangeText);
    if ("pageInputDisabled" in $$new_props) $$invalidate(8, pageInputDisabled = $$new_props.pageInputDisabled);
    if ("pageSizeInputDisabled" in $$new_props) $$invalidate(9, pageSizeInputDisabled = $$new_props.pageSizeInputDisabled);
    if ("pageSize" in $$new_props) $$invalidate(1, pageSize = $$new_props.pageSize);
    if ("pageSizes" in $$new_props) $$invalidate(10, pageSizes = $$new_props.pageSizes);
    if ("pagesUnknown" in $$new_props) $$invalidate(11, pagesUnknown = $$new_props.pagesUnknown);
    if ("pageText" in $$new_props) $$invalidate(12, pageText = $$new_props.pageText);
    if ("pageRangeText" in $$new_props) $$invalidate(13, pageRangeText = $$new_props.pageRangeText);
    if ("id" in $$new_props) $$invalidate(14, id = $$new_props.id);
  };
  $$self.$capture_state = () => ({
    page,
    totalItems,
    disabled,
    forwardText,
    backwardText,
    itemsPerPageText,
    itemText,
    itemRangeText,
    pageInputDisabled,
    pageSizeInputDisabled,
    pageSize,
    pageSizes,
    pagesUnknown,
    pageText,
    pageRangeText,
    id,
    afterUpdate,
    createEventDispatcher,
    CaretLeft: CaretLeft_default,
    CaretRight: CaretRight_default,
    Button: Button_default,
    Select: Select_default,
    SelectItem: SelectItem_default,
    dispatch,
    totalPages,
    forwardButtonDisabled,
    backButtonDisabled,
    selectItems
  });
  $$self.$inject_state = ($$new_props) => {
    if ("page" in $$props) $$invalidate(0, page = $$new_props.page);
    if ("totalItems" in $$props) $$invalidate(2, totalItems = $$new_props.totalItems);
    if ("disabled" in $$props) $$invalidate(21, disabled = $$new_props.disabled);
    if ("forwardText" in $$props) $$invalidate(3, forwardText = $$new_props.forwardText);
    if ("backwardText" in $$props) $$invalidate(4, backwardText = $$new_props.backwardText);
    if ("itemsPerPageText" in $$props) $$invalidate(5, itemsPerPageText = $$new_props.itemsPerPageText);
    if ("itemText" in $$props) $$invalidate(6, itemText = $$new_props.itemText);
    if ("itemRangeText" in $$props) $$invalidate(7, itemRangeText = $$new_props.itemRangeText);
    if ("pageInputDisabled" in $$props) $$invalidate(8, pageInputDisabled = $$new_props.pageInputDisabled);
    if ("pageSizeInputDisabled" in $$props) $$invalidate(9, pageSizeInputDisabled = $$new_props.pageSizeInputDisabled);
    if ("pageSize" in $$props) $$invalidate(1, pageSize = $$new_props.pageSize);
    if ("pageSizes" in $$props) $$invalidate(10, pageSizes = $$new_props.pageSizes);
    if ("pagesUnknown" in $$props) $$invalidate(11, pagesUnknown = $$new_props.pagesUnknown);
    if ("pageText" in $$props) $$invalidate(12, pageText = $$new_props.pageText);
    if ("pageRangeText" in $$props) $$invalidate(13, pageRangeText = $$new_props.pageRangeText);
    if ("id" in $$props) $$invalidate(14, id = $$new_props.id);
    if ("totalPages" in $$props) $$invalidate(15, totalPages = $$new_props.totalPages);
    if ("forwardButtonDisabled" in $$props) $$invalidate(16, forwardButtonDisabled = $$new_props.forwardButtonDisabled);
    if ("backButtonDisabled" in $$props) $$invalidate(17, backButtonDisabled = $$new_props.backButtonDisabled);
    if ("selectItems" in $$props) $$invalidate(18, selectItems = $$new_props.selectItems);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*pageSize, page*/
    3) {
      $: dispatch("update", { pageSize, page });
    }
    if ($$self.$$.dirty[0] & /*totalItems, pageSize*/
    6) {
      $: $$invalidate(15, totalPages = Math.max(Math.ceil(totalItems / pageSize), 1));
    }
    if ($$self.$$.dirty[0] & /*totalPages*/
    32768) {
      $: $$invalidate(18, selectItems = Array.from({ length: totalPages }, (_, i) => i));
    }
    if ($$self.$$.dirty[0] & /*disabled, page*/
    2097153) {
      $: $$invalidate(17, backButtonDisabled = disabled || page === 1);
    }
    if ($$self.$$.dirty[0] & /*disabled, page, totalPages*/
    2129921) {
      $: $$invalidate(16, forwardButtonDisabled = disabled || page === totalPages);
    }
  };
  return [
    page,
    pageSize,
    totalItems,
    forwardText,
    backwardText,
    itemsPerPageText,
    itemText,
    itemRangeText,
    pageInputDisabled,
    pageSizeInputDisabled,
    pageSizes,
    pagesUnknown,
    pageText,
    pageRangeText,
    id,
    totalPages,
    forwardButtonDisabled,
    backButtonDisabled,
    selectItems,
    dispatch,
    $$restProps,
    disabled,
    select_selected_binding,
    change_handler,
    select_selected_binding_1,
    change_handler_1,
    click_handler,
    click_handler_13
  ];
}
var Pagination = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance119,
      create_fragment119,
      safe_not_equal,
      {
        page: 0,
        totalItems: 2,
        disabled: 21,
        forwardText: 3,
        backwardText: 4,
        itemsPerPageText: 5,
        itemText: 6,
        itemRangeText: 7,
        pageInputDisabled: 8,
        pageSizeInputDisabled: 9,
        pageSize: 1,
        pageSizes: 10,
        pagesUnknown: 11,
        pageText: 12,
        pageRangeText: 13,
        id: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pagination",
      options,
      id: create_fragment119.name
    });
  }
  get page() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set page(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get totalItems() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set totalItems(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forwardText() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forwardText(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backwardText() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backwardText(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemsPerPageText() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemsPerPageText(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemText() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemText(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemRangeText() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemRangeText(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageInputDisabled() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageInputDisabled(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageSizeInputDisabled() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageSizeInputDisabled(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageSize() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageSize(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageSizes() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageSizes(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pagesUnknown() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pagesUnknown(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageText() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageText(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageRangeText() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageRangeText(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pagination_default = Pagination;

// node_modules/carbon-components-svelte/src/Pagination/PaginationSkeleton.svelte
var file111 = "node_modules/carbon-components-svelte/src/Pagination/PaginationSkeleton.svelte";
function create_fragment120(ctx) {
  let div2;
  let div0;
  let skeletontext0;
  let t0;
  let skeletontext1;
  let t1;
  let skeletontext2;
  let t2;
  let div1;
  let skeletontext3;
  let current;
  let mounted;
  let dispose;
  skeletontext0 = new SkeletonText_default({ props: { width: "70px" }, $$inline: true });
  skeletontext1 = new SkeletonText_default({ props: { width: "35px" }, $$inline: true });
  skeletontext2 = new SkeletonText_default({
    props: { width: "105px" },
    $$inline: true
  });
  skeletontext3 = new SkeletonText_default({ props: { width: "70px" }, $$inline: true });
  let div2_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let div_data_2 = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      create_component(skeletontext0.$$.fragment);
      t0 = space();
      create_component(skeletontext1.$$.fragment);
      t1 = space();
      create_component(skeletontext2.$$.fragment);
      t2 = space();
      div1 = element("div");
      create_component(skeletontext3.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", {});
      var div0_nodes = children(div0);
      claim_component(skeletontext0.$$.fragment, div0_nodes);
      t0 = claim_space(div0_nodes);
      claim_component(skeletontext1.$$.fragment, div0_nodes);
      t1 = claim_space(div0_nodes);
      claim_component(skeletontext2.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", {});
      var div1_nodes = children(div1);
      claim_component(skeletontext3.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--pagination__left", true);
      add_location(div0, file111, 15, 2, 350);
      toggle_class(div1, "bx--pagination__right", true);
      toggle_class(div1, "bx--pagination--inline", true);
      add_location(div1, file111, 20, 2, 506);
      set_attributes(div2, div_data_2);
      toggle_class(div2, "bx--pagination", true);
      toggle_class(div2, "bx--skeleton", true);
      add_location(div2, file111, 6, 0, 202);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      mount_component(skeletontext0, div0, null);
      append_hydration_dev(div0, t0);
      mount_component(skeletontext1, div0, null);
      append_hydration_dev(div0, t1);
      mount_component(skeletontext2, div0, null);
      append_hydration_dev(div2, t2);
      append_hydration_dev(div2, div1);
      mount_component(skeletontext3, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div2,
            "click",
            /*click_handler*/
            ctx[1],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseover",
            /*mouseover_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
      toggle_class(div2, "bx--pagination", true);
      toggle_class(div2, "bx--skeleton", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(skeletontext0.$$.fragment, local);
      transition_in(skeletontext1.$$.fragment, local);
      transition_in(skeletontext2.$$.fragment, local);
      transition_in(skeletontext3.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(skeletontext0.$$.fragment, local);
      transition_out(skeletontext1.$$.fragment, local);
      transition_out(skeletontext2.$$.fragment, local);
      transition_out(skeletontext3.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(skeletontext0);
      destroy_component(skeletontext1);
      destroy_component(skeletontext2);
      destroy_component(skeletontext3);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment120.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance120($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationSkeleton", slots, []);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  $$self.$capture_state = () => ({ SkeletonText: SkeletonText_default });
  return [
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var PaginationSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance120, create_fragment120, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationSkeleton",
      options,
      id: create_fragment120.name
    });
  }
};
var PaginationSkeleton_default = PaginationSkeleton;

// node_modules/carbon-components-svelte/src/PaginationNav/PaginationItem.svelte
var file112 = "node_modules/carbon-components-svelte/src/PaginationNav/PaginationItem.svelte";
function create_fragment121(ctx) {
  let li;
  let button;
  let span;
  let t0;
  let t1;
  let button_aria_current_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      li = element("li");
      button = element("button");
      span = element("span");
      if (default_slot) default_slot.c();
      t0 = space();
      t1 = text(
        /*page*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      button = claim_element(li_nodes, "BUTTON", {
        type: true,
        "data-page": true,
        "aria-current": true
      });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot) default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      t0 = claim_space(button_nodes);
      t1 = claim_text(
        button_nodes,
        /*page*/
        ctx[0]
      );
      button_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--pagination-nav__accessibility-label", true);
      add_location(span, file112, 17, 4, 429);
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "data-page",
        /*page*/
        ctx[0]
      );
      attr_dev(button, "aria-current", button_aria_current_value = /*active*/
      ctx[1] ? "page" : void 0);
      toggle_class(button, "bx--pagination-nav__page", true);
      toggle_class(
        button,
        "bx--pagination-nav__page--active",
        /*active*/
        ctx[1]
      );
      add_location(button, file112, 9, 2, 212);
      toggle_class(li, "bx--pagination-nav__list-item", true);
      add_location(li, file112, 8, 0, 160);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, button);
      append_hydration_dev(button, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      append_hydration_dev(button, t0);
      append_hydration_dev(button, t1);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[4],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*page*/
      1) set_data_dev(
        t1,
        /*page*/
        ctx2[0]
      );
      if (!current || dirty & /*page*/
      1) {
        attr_dev(
          button,
          "data-page",
          /*page*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*active*/
      2 && button_aria_current_value !== (button_aria_current_value = /*active*/
      ctx2[1] ? "page" : void 0)) {
        attr_dev(button, "aria-current", button_aria_current_value);
      }
      if (!current || dirty & /*active*/
      2) {
        toggle_class(
          button,
          "bx--pagination-nav__page--active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment121.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance121($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationItem", slots, ["default"]);
  let { page = 1 } = $$props;
  let { active = false } = $$props;
  const writable_props = ["page", "active"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<PaginationItem> was created with unknown prop '${key}'`);
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$props2) => {
    if ("page" in $$props2) $$invalidate(0, page = $$props2.page);
    if ("active" in $$props2) $$invalidate(1, active = $$props2.active);
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ page, active });
  $$self.$inject_state = ($$props2) => {
    if ("page" in $$props2) $$invalidate(0, page = $$props2.page);
    if ("active" in $$props2) $$invalidate(1, active = $$props2.active);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [page, active, $$scope, slots, click_handler];
}
var PaginationItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance121, create_fragment121, safe_not_equal, { page: 0, active: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationItem",
      options,
      id: create_fragment121.name
    });
  }
  get page() {
    throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set page(value) {
    throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PaginationItem_default = PaginationItem;

// node_modules/carbon-components-svelte/src/PaginationNav/PaginationOverflow.svelte
var file113 = "node_modules/carbon-components-svelte/src/PaginationNav/PaginationOverflow.svelte";
function get_each_context14(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_if_block_130(ctx) {
  let paginationitem;
  let current;
  paginationitem = new PaginationItem_default({
    props: {
      page: (
        /*fromIndex*/
        ctx[0] + 1
      ),
      $$slots: { default: [create_default_slot18] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  paginationitem.$on(
    "click",
    /*click_handler*/
    ctx[5]
  );
  const block = {
    c: function create() {
      create_component(paginationitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(paginationitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(paginationitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const paginationitem_changes = {};
      if (dirty & /*fromIndex*/
      1) paginationitem_changes.page = /*fromIndex*/
      ctx2[0] + 1;
      if (dirty & /*$$scope*/
      512) {
        paginationitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      paginationitem.$set(paginationitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(paginationitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(paginationitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(paginationitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_130.name,
    type: "if",
    source: "(47:22) ",
    ctx
  });
  return block;
}
function create_if_block73(ctx) {
  let li;
  let div1;
  let select;
  let option;
  let t;
  let div0;
  let overflowmenuhorizontal;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(Array.from({ length: (
    /*count*/
    ctx[1]
  ) }, func5));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block14(get_each_context14(ctx, each_value, i));
  }
  overflowmenuhorizontal = new OverflowMenuHorizontal_default({
    props: { class: "bx--pagination-nav__select-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      li = element("li");
      div1 = element("div");
      select = element("select");
      option = element("option");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      div0 = element("div");
      create_component(overflowmenuhorizontal.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      div1 = claim_element(li_nodes, "DIV", {});
      var div1_nodes = children(div1);
      select = claim_element(div1_nodes, "SELECT", { "aria-label": true });
      var select_nodes = children(select);
      option = claim_element(select_nodes, "OPTION", {});
      children(option).forEach(detach_dev);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      claim_component(overflowmenuhorizontal.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = "";
      set_input_value(option, option.__value);
      option.hidden = true;
      add_location(option, file113, 34, 8, 951);
      attr_dev(select, "aria-label", "Select Page number");
      toggle_class(select, "bx--pagination-nav__page", true);
      toggle_class(select, "bx--pagination-nav__page--select", true);
      add_location(select, file113, 24, 6, 624);
      toggle_class(div0, "bx--pagination-nav__select-icon-wrapper", true);
      add_location(div0, file113, 41, 6, 1218);
      toggle_class(div1, "bx--pagination-nav__select", true);
      add_location(div1, file113, 22, 4, 524);
      toggle_class(li, "bx--pagination-nav__list-item", true);
      add_location(li, file113, 21, 2, 470);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, div1);
      append_hydration_dev(div1, select);
      append_hydration_dev(select, option);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*value*/
        ctx[2]
      );
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      mount_component(overflowmenuhorizontal, div0, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          select,
          "change",
          /*change_handler*/
          ctx[4],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*fromIndex, Array, count*/
      3) {
        each_value = ensure_array_like_dev(Array.from({ length: (
          /*count*/
          ctx2[1]
        ) }, func5));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context14(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block14(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & /*value, fromIndex, Array, count*/
      7) {
        select_option(
          select,
          /*value*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(overflowmenuhorizontal.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(overflowmenuhorizontal.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      destroy_each(each_blocks, detaching);
      destroy_component(overflowmenuhorizontal);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block73.name,
    type: "if",
    source: "(21:0) {#if count > 1}",
    ctx
  });
  return block;
}
function create_default_slot18(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Page");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Page");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot18.name,
    type: "slot",
    source: `(48:2) <PaginationItem     page=\\"{fromIndex + 1}\\"     on:click=\\"{() => {       dispatch('select', { index: fromIndex });     }}\\"   >`,
    ctx
  });
  return block;
}
function create_each_block14(ctx) {
  let option;
  let t0_value = (
    /*fromIndex*/
    ctx[0] + /*i*/
    ctx[6] + 1 + ""
  );
  let t0;
  let t1;
  let option_value_value;
  let option_data_page_value;
  const block = {
    c: function create() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", { "data-page": true });
      var option_nodes = children(option);
      t0 = claim_text(option_nodes, t0_value);
      t1 = claim_space(option_nodes);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*fromIndex*/
      ctx[0] + /*i*/
      ctx[6] + 1;
      set_input_value(option, option.__value);
      attr_dev(option, "data-page", option_data_page_value = /*fromIndex*/
      ctx[0] + /*i*/
      ctx[6] + 1);
      add_location(option, file113, 36, 10, 1059);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t0);
      append_hydration_dev(option, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*fromIndex, count*/
      3 && t0_value !== (t0_value = /*fromIndex*/
      ctx2[0] + /*i*/
      ctx2[6] + 1 + "")) set_data_dev(t0, t0_value);
      if (dirty & /*fromIndex, count*/
      3 && option_value_value !== (option_value_value = /*fromIndex*/
      ctx2[0] + /*i*/
      ctx2[6] + 1)) {
        prop_dev(option, "__value", option_value_value);
        set_input_value(option, option.__value);
      }
      if (dirty & /*fromIndex, count*/
      3 && option_data_page_value !== (option_data_page_value = /*fromIndex*/
      ctx2[0] + /*i*/
      ctx2[6] + 1)) {
        attr_dev(option, "data-page", option_data_page_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block14.name,
    type: "each",
    source: "(36:8) {#each Array.from({ length: count }, (_, i) => i) as i}",
    ctx
  });
  return block;
}
function create_fragment122(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block73, create_if_block_130];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*count*/
      ctx2[1] > 1
    ) return 0;
    if (
      /*count*/
      ctx2[1] === 1
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment122.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func5 = (_, i) => i;
function instance122($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationOverflow", slots, []);
  let { fromIndex = 0 } = $$props;
  let { count = 0 } = $$props;
  const dispatch = createEventDispatcher();
  let value = "";
  const writable_props = ["fromIndex", "count"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<PaginationOverflow> was created with unknown prop '${key}'`);
  });
  const change_handler = ({ target }) => {
    $$invalidate(2, value = "");
    dispatch("select", { index: Number(target.value) });
  };
  const click_handler = () => {
    dispatch("select", { index: fromIndex });
  };
  $$self.$$set = ($$props2) => {
    if ("fromIndex" in $$props2) $$invalidate(0, fromIndex = $$props2.fromIndex);
    if ("count" in $$props2) $$invalidate(1, count = $$props2.count);
  };
  $$self.$capture_state = () => ({
    fromIndex,
    count,
    createEventDispatcher,
    OverflowMenuHorizontal: OverflowMenuHorizontal_default,
    PaginationItem: PaginationItem_default,
    dispatch,
    value
  });
  $$self.$inject_state = ($$props2) => {
    if ("fromIndex" in $$props2) $$invalidate(0, fromIndex = $$props2.fromIndex);
    if ("count" in $$props2) $$invalidate(1, count = $$props2.count);
    if ("value" in $$props2) $$invalidate(2, value = $$props2.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [fromIndex, count, value, dispatch, change_handler, click_handler];
}
var PaginationOverflow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance122, create_fragment122, safe_not_equal, { fromIndex: 0, count: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationOverflow",
      options,
      id: create_fragment122.name
    });
  }
  get fromIndex() {
    throw new Error("<PaginationOverflow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fromIndex(value) {
    throw new Error("<PaginationOverflow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get count() {
    throw new Error("<PaginationOverflow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<PaginationOverflow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PaginationOverflow_default = PaginationOverflow;

// node_modules/carbon-components-svelte/src/PaginationNav/PaginationNav.svelte
var file114 = "node_modules/carbon-components-svelte/src/PaginationNav/PaginationNav.svelte";
function get_each_context15(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
function create_if_block_131(ctx) {
  let paginationitem;
  let current;
  paginationitem = new PaginationItem_default({
    props: {
      page: 1,
      active: (
        /*page*/
        ctx[0] === 1
      ),
      $$slots: { default: [create_default_slot_27] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  paginationitem.$on(
    "click",
    /*click_handler_1*/
    ctx[15]
  );
  const block = {
    c: function create() {
      create_component(paginationitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(paginationitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(paginationitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const paginationitem_changes = {};
      if (dirty & /*page*/
      1) paginationitem_changes.active = /*page*/
      ctx2[0] === 1;
      if (dirty & /*$$scope, page*/
      16777217) {
        paginationitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      paginationitem.$set(paginationitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(paginationitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(paginationitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(paginationitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_131.name,
    type: "if",
    source: "(104:4) {#if fit > MIN || (fit <= MIN && page <= 1)}",
    ctx
  });
  return block;
}
function create_default_slot_27(ctx) {
  let t_value = (
    /*page*/
    ctx[0] === 1 ? "Active, Page" : "Page"
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*page*/
      1 && t_value !== (t_value = /*page*/
      ctx2[0] === 1 ? "Active, Page" : "Page")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_27.name,
    type: "slot",
    source: `(105:6) <PaginationItem         page=\\"{1}\\"         active=\\"{page === 1}\\"         on:click=\\"{() => {           page = 1;           dispatch('change', { page });         }}\\"       >`,
    ctx
  });
  return block;
}
function create_default_slot_18(ctx) {
  let t_value = (
    /*page*/
    ctx[0] === /*item*/
    ctx[21] ? "Active, Page" : "Page"
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*page, items*/
      1025 && t_value !== (t_value = /*page*/
      ctx2[0] === /*item*/
      ctx2[21] ? "Active, Page" : "Page")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_18.name,
    type: "slot",
    source: `(125:6) <PaginationItem         page=\\"{item + 1}\\"         active=\\"{page === item + 1}\\"         on:click=\\"{() => {           page = item + 1;           dispatch('change', { page });         }}\\"       >`,
    ctx
  });
  return block;
}
function create_each_block15(ctx) {
  let paginationitem;
  let current;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[17](
        /*item*/
        ctx[21]
      )
    );
  }
  paginationitem = new PaginationItem_default({
    props: {
      page: (
        /*item*/
        ctx[21] + 1
      ),
      active: (
        /*page*/
        ctx[0] === /*item*/
        ctx[21] + 1
      ),
      $$slots: { default: [create_default_slot_18] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  paginationitem.$on("click", click_handler_2);
  const block = {
    c: function create() {
      create_component(paginationitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(paginationitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(paginationitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const paginationitem_changes = {};
      if (dirty & /*items*/
      1024) paginationitem_changes.page = /*item*/
      ctx[21] + 1;
      if (dirty & /*page, items*/
      1025) paginationitem_changes.active = /*page*/
      ctx[0] === /*item*/
      ctx[21] + 1;
      if (dirty & /*$$scope, page, items*/
      16778241) {
        paginationitem_changes.$$scope = { dirty, ctx };
      }
      paginationitem.$set(paginationitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(paginationitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(paginationitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(paginationitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block15.name,
    type: "each",
    source: "(124:4) {#each items as item}",
    ctx
  });
  return block;
}
function create_if_block74(ctx) {
  let paginationitem;
  let current;
  paginationitem = new PaginationItem_default({
    props: {
      page: (
        /*total*/
        ctx[1]
      ),
      active: (
        /*page*/
        ctx[0] === /*total*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot19] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  paginationitem.$on(
    "click",
    /*click_handler_3*/
    ctx[19]
  );
  const block = {
    c: function create() {
      create_component(paginationitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(paginationitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(paginationitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const paginationitem_changes = {};
      if (dirty & /*total*/
      2) paginationitem_changes.page = /*total*/
      ctx2[1];
      if (dirty & /*page, total*/
      3) paginationitem_changes.active = /*page*/
      ctx2[0] === /*total*/
      ctx2[1];
      if (dirty & /*$$scope, page, total*/
      16777219) {
        paginationitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      paginationitem.$set(paginationitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(paginationitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(paginationitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(paginationitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block74.name,
    type: "if",
    source: "(144:4) {#if total > 1}",
    ctx
  });
  return block;
}
function create_default_slot19(ctx) {
  let t_value = (
    /*page*/
    ctx[0] === /*total*/
    ctx[1] ? "Active, Page" : "Page"
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*page, total*/
      3 && t_value !== (t_value = /*page*/
      ctx2[0] === /*total*/
      ctx2[1] ? "Active, Page" : "Page")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot19.name,
    type: "slot",
    source: `(145:6) <PaginationItem         page=\\"{total}\\"         active=\\"{page === total}\\"         on:click=\\"{() => {           page = total;           dispatch('change', { page });         }}\\"       >`,
    ctx
  });
  return block;
}
function create_fragment123(ctx) {
  let nav;
  let ul;
  let li0;
  let button0;
  let t0;
  let t1;
  let paginationoverflow0;
  let t2;
  let t3;
  let paginationoverflow1;
  let t4;
  let t5;
  let li1;
  let button1;
  let t6;
  let div;
  let t7;
  let t8_value = (
    /*page*/
    ctx[0] + 1 + ""
  );
  let t8;
  let t9;
  let t10;
  let current;
  button0 = new Button_default({
    props: {
      kind: "ghost",
      tooltipAlignment: "center",
      tooltipPosition: (
        /*tooltipPosition*/
        ctx[5] === "inside" ? "right" : (
          /*tooltipPosition*/
          ctx[5] === "outside" ? "left" : (
            /*tooltipPosition*/
            ctx[5]
          )
        )
      ),
      iconDescription: (
        /*backwardText*/
        ctx[4]
      ),
      disabled: !/*loop*/
      ctx[2] && /*page*/
      ctx[0] === 1,
      icon: CaretLeft_default
    },
    $$inline: true
  });
  button0.$on(
    "click",
    /*click_handler*/
    ctx[14]
  );
  let if_block0 = (
    /*fit*/
    (ctx[9] > MIN || /*fit*/
    ctx[9] <= MIN && /*page*/
    ctx[0] <= 1) && create_if_block_131(ctx)
  );
  paginationoverflow0 = new PaginationOverflow_default({
    props: {
      fromIndex: (
        /*startOffset*/
        ctx[8]
      ),
      count: (
        /*front*/
        ctx[6]
      )
    },
    $$inline: true
  });
  paginationoverflow0.$on(
    "select",
    /*select_handler*/
    ctx[16]
  );
  let each_value = ensure_array_like_dev(
    /*items*/
    ctx[10]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block15(get_each_context15(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  paginationoverflow1 = new PaginationOverflow_default({
    props: {
      fromIndex: (
        /*total*/
        ctx[1] - /*back*/
        ctx[7] - 1
      ),
      count: (
        /*back*/
        ctx[7]
      )
    },
    $$inline: true
  });
  paginationoverflow1.$on(
    "select",
    /*select_handler_1*/
    ctx[18]
  );
  let if_block1 = (
    /*total*/
    ctx[1] > 1 && create_if_block74(ctx)
  );
  button1 = new Button_default({
    props: {
      kind: "ghost",
      tooltipAlignment: "center",
      tooltipPosition: (
        /*tooltipPosition*/
        ctx[5] === "inside" ? "left" : (
          /*tooltipPosition*/
          ctx[5] === "outside" ? "right" : (
            /*tooltipPosition*/
            ctx[5]
          )
        )
      ),
      iconDescription: (
        /*forwardText*/
        ctx[3]
      ),
      disabled: !/*loop*/
      ctx[2] && /*page*/
      ctx[0] === /*total*/
      ctx[1],
      icon: CaretRight_default
    },
    $$inline: true
  });
  button1.$on(
    "click",
    /*click_handler_4*/
    ctx[20]
  );
  let nav_levels = [
    { "aria-label": "pagination" },
    /*$$restProps*/
    ctx[12]
  ];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      ul = element("ul");
      li0 = element("li");
      create_component(button0.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      create_component(paginationoverflow0.$$.fragment);
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      create_component(paginationoverflow1.$$.fragment);
      t4 = space();
      if (if_block1) if_block1.c();
      t5 = space();
      li1 = element("li");
      create_component(button1.$$.fragment);
      t6 = space();
      div = element("div");
      t7 = text("Page\n    ");
      t8 = text(t8_value);
      t9 = text("\n    of\n    ");
      t10 = text(
        /*total*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { "aria-label": true });
      var nav_nodes = children(nav);
      ul = claim_element(nav_nodes, "UL", {});
      var ul_nodes = children(ul);
      li0 = claim_element(ul_nodes, "LI", {});
      var li0_nodes = children(li0);
      claim_component(button0.$$.fragment, li0_nodes);
      li0_nodes.forEach(detach_dev);
      t0 = claim_space(ul_nodes);
      if (if_block0) if_block0.l(ul_nodes);
      t1 = claim_space(ul_nodes);
      claim_component(paginationoverflow0.$$.fragment, ul_nodes);
      t2 = claim_space(ul_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      t3 = claim_space(ul_nodes);
      claim_component(paginationoverflow1.$$.fragment, ul_nodes);
      t4 = claim_space(ul_nodes);
      if (if_block1) if_block1.l(ul_nodes);
      t5 = claim_space(ul_nodes);
      li1 = claim_element(ul_nodes, "LI", {});
      var li1_nodes = children(li1);
      claim_component(button1.$$.fragment, li1_nodes);
      li1_nodes.forEach(detach_dev);
      ul_nodes.forEach(detach_dev);
      t6 = claim_space(nav_nodes);
      div = claim_element(nav_nodes, "DIV", { "aria-live": true, "aria-atomic": true });
      var div_nodes = children(div);
      t7 = claim_text(div_nodes, "Page\n    ");
      t8 = claim_text(div_nodes, t8_value);
      t9 = claim_text(div_nodes, "\n    of\n    ");
      t10 = claim_text(
        div_nodes,
        /*total*/
        ctx[1]
      );
      div_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(li0, "bx--pagination-nav__list-item", true);
      add_location(li0, file114, 80, 4, 2257);
      toggle_class(li1, "bx--pagination-nav__list-item", true);
      add_location(li1, file114, 155, 4, 4237);
      toggle_class(ul, "bx--pagination-nav__list", true);
      add_location(ul, file114, 79, 2, 2208);
      attr_dev(div, "aria-live", "polite");
      attr_dev(div, "aria-atomic", "true");
      toggle_class(div, "bx--pagination-nav__accessibility-label", true);
      add_location(div, file114, 179, 2, 4909);
      set_attributes(nav, nav_data);
      toggle_class(nav, "bx--pagination-nav", true);
      add_location(nav, file114, 78, 0, 2125);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      append_hydration_dev(nav, ul);
      append_hydration_dev(ul, li0);
      mount_component(button0, li0, null);
      append_hydration_dev(ul, t0);
      if (if_block0) if_block0.m(ul, null);
      append_hydration_dev(ul, t1);
      mount_component(paginationoverflow0, ul, null);
      append_hydration_dev(ul, t2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      append_hydration_dev(ul, t3);
      mount_component(paginationoverflow1, ul, null);
      append_hydration_dev(ul, t4);
      if (if_block1) if_block1.m(ul, null);
      append_hydration_dev(ul, t5);
      append_hydration_dev(ul, li1);
      mount_component(button1, li1, null);
      append_hydration_dev(nav, t6);
      append_hydration_dev(nav, div);
      append_hydration_dev(div, t7);
      append_hydration_dev(div, t8);
      append_hydration_dev(div, t9);
      append_hydration_dev(div, t10);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const button0_changes = {};
      if (dirty & /*tooltipPosition*/
      32) button0_changes.tooltipPosition = /*tooltipPosition*/
      ctx2[5] === "inside" ? "right" : (
        /*tooltipPosition*/
        ctx2[5] === "outside" ? "left" : (
          /*tooltipPosition*/
          ctx2[5]
        )
      );
      if (dirty & /*backwardText*/
      16) button0_changes.iconDescription = /*backwardText*/
      ctx2[4];
      if (dirty & /*loop, page*/
      5) button0_changes.disabled = !/*loop*/
      ctx2[2] && /*page*/
      ctx2[0] === 1;
      button0.$set(button0_changes);
      if (
        /*fit*/
        ctx2[9] > MIN || /*fit*/
        ctx2[9] <= MIN && /*page*/
        ctx2[0] <= 1
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*fit, page*/
          513) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_131(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(ul, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const paginationoverflow0_changes = {};
      if (dirty & /*startOffset*/
      256) paginationoverflow0_changes.fromIndex = /*startOffset*/
      ctx2[8];
      if (dirty & /*front*/
      64) paginationoverflow0_changes.count = /*front*/
      ctx2[6];
      paginationoverflow0.$set(paginationoverflow0_changes);
      if (dirty & /*items, page, dispatch*/
      3073) {
        each_value = ensure_array_like_dev(
          /*items*/
          ctx2[10]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context15(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block15(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, t3);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      const paginationoverflow1_changes = {};
      if (dirty & /*total, back*/
      130) paginationoverflow1_changes.fromIndex = /*total*/
      ctx2[1] - /*back*/
      ctx2[7] - 1;
      if (dirty & /*back*/
      128) paginationoverflow1_changes.count = /*back*/
      ctx2[7];
      paginationoverflow1.$set(paginationoverflow1_changes);
      if (
        /*total*/
        ctx2[1] > 1
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*total*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block74(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(ul, t5);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const button1_changes = {};
      if (dirty & /*tooltipPosition*/
      32) button1_changes.tooltipPosition = /*tooltipPosition*/
      ctx2[5] === "inside" ? "left" : (
        /*tooltipPosition*/
        ctx2[5] === "outside" ? "right" : (
          /*tooltipPosition*/
          ctx2[5]
        )
      );
      if (dirty & /*forwardText*/
      8) button1_changes.iconDescription = /*forwardText*/
      ctx2[3];
      if (dirty & /*loop, page, total*/
      7) button1_changes.disabled = !/*loop*/
      ctx2[2] && /*page*/
      ctx2[0] === /*total*/
      ctx2[1];
      button1.$set(button1_changes);
      if ((!current || dirty & /*page*/
      1) && t8_value !== (t8_value = /*page*/
      ctx2[0] + 1 + "")) set_data_dev(t8, t8_value);
      if (!current || dirty & /*total*/
      2) set_data_dev(
        t10,
        /*total*/
        ctx2[1]
      );
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        { "aria-label": "pagination" },
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12]
      ]));
      toggle_class(nav, "bx--pagination-nav", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(button0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(paginationoverflow0.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(paginationoverflow1.$$.fragment, local);
      transition_in(if_block1);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(paginationoverflow0.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(paginationoverflow1.$$.fragment, local);
      transition_out(if_block1);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(nav);
      }
      destroy_component(button0);
      if (if_block0) if_block0.d();
      destroy_component(paginationoverflow0);
      destroy_each(each_blocks, detaching);
      destroy_component(paginationoverflow1);
      if (if_block1) if_block1.d();
      destroy_component(button1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment123.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var MIN = 4;
function instance123($$self, $$props, $$invalidate) {
  let fit;
  let startOffset;
  let items;
  const omit_props_names = ["page", "total", "shown", "loop", "forwardText", "backwardText", "tooltipPosition"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationNav", slots, []);
  let { page = 1 } = $$props;
  let { total = 10 } = $$props;
  let { shown = 10 } = $$props;
  let { loop = false } = $$props;
  let { forwardText = "Next page" } = $$props;
  let { backwardText = "Previous page" } = $$props;
  let { tooltipPosition = "bottom" } = $$props;
  const dispatch = createEventDispatcher();
  let front = 0;
  let back = 0;
  const click_handler = () => {
    if (page <= 1) {
      if (loop) $$invalidate(0, page = total);
    } else {
      $$invalidate(0, page--, page);
    }
    dispatch("click:button--previous", { page });
    dispatch("change", { page });
  };
  const click_handler_13 = () => {
    $$invalidate(0, page = 1);
    dispatch("change", { page });
  };
  const select_handler = ({ detail }) => {
    $$invalidate(0, page = detail.index);
    dispatch("change", { page });
  };
  const click_handler_2 = (item) => {
    $$invalidate(0, page = item + 1);
    dispatch("change", { page });
  };
  const select_handler_1 = ({ detail }) => {
    $$invalidate(0, page = detail.index);
    dispatch("change", { page });
  };
  const click_handler_3 = () => {
    $$invalidate(0, page = total);
    dispatch("change", { page });
  };
  const click_handler_4 = () => {
    if (page >= total) {
      if (loop) $$invalidate(0, page = 1);
    } else {
      $$invalidate(0, page++, page);
    }
    dispatch("click:button--next", { page });
    dispatch("change", { page });
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("page" in $$new_props) $$invalidate(0, page = $$new_props.page);
    if ("total" in $$new_props) $$invalidate(1, total = $$new_props.total);
    if ("shown" in $$new_props) $$invalidate(13, shown = $$new_props.shown);
    if ("loop" in $$new_props) $$invalidate(2, loop = $$new_props.loop);
    if ("forwardText" in $$new_props) $$invalidate(3, forwardText = $$new_props.forwardText);
    if ("backwardText" in $$new_props) $$invalidate(4, backwardText = $$new_props.backwardText);
    if ("tooltipPosition" in $$new_props) $$invalidate(5, tooltipPosition = $$new_props.tooltipPosition);
  };
  $$self.$capture_state = () => ({
    page,
    total,
    shown,
    loop,
    forwardText,
    backwardText,
    tooltipPosition,
    createEventDispatcher,
    CaretLeft: CaretLeft_default,
    CaretRight: CaretRight_default,
    PaginationItem: PaginationItem_default,
    PaginationOverflow: PaginationOverflow_default,
    Button: Button_default,
    dispatch,
    MIN,
    front,
    back,
    startOffset,
    items,
    fit
  });
  $$self.$inject_state = ($$new_props) => {
    if ("page" in $$props) $$invalidate(0, page = $$new_props.page);
    if ("total" in $$props) $$invalidate(1, total = $$new_props.total);
    if ("shown" in $$props) $$invalidate(13, shown = $$new_props.shown);
    if ("loop" in $$props) $$invalidate(2, loop = $$new_props.loop);
    if ("forwardText" in $$props) $$invalidate(3, forwardText = $$new_props.forwardText);
    if ("backwardText" in $$props) $$invalidate(4, backwardText = $$new_props.backwardText);
    if ("tooltipPosition" in $$props) $$invalidate(5, tooltipPosition = $$new_props.tooltipPosition);
    if ("front" in $$props) $$invalidate(6, front = $$new_props.front);
    if ("back" in $$props) $$invalidate(7, back = $$new_props.back);
    if ("startOffset" in $$props) $$invalidate(8, startOffset = $$new_props.startOffset);
    if ("items" in $$props) $$invalidate(10, items = $$new_props.items);
    if ("fit" in $$props) $$invalidate(9, fit = $$new_props.fit);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*shown*/
    8192) {
      $: $$invalidate(9, fit = shown >= MIN ? shown : MIN);
    }
    if ($$self.$$.dirty & /*fit, page*/
    513) {
      $: $$invalidate(8, startOffset = fit <= MIN && page > 1 ? 0 : 1);
    }
    if ($$self.$$.dirty & /*fit, total*/
    514) {
      $: if (fit >= total) {
        $$invalidate(6, front = 0);
        $$invalidate(7, back = 0);
      }
    }
    if ($$self.$$.dirty & /*fit, total, page, front, back*/
    707) {
      $: if (fit < total) {
        const split = Math.ceil(fit / 2) - 1;
        $$invalidate(6, front = page - split);
        $$invalidate(7, back = total - page - (fit - split) + 2);
        if (front <= 1) {
          $$invalidate(7, back -= front <= 0 ? Math.abs(front) + 1 : 0);
          $$invalidate(6, front = 0);
        }
        if (back <= 1) {
          $$invalidate(6, front -= back <= 0 ? Math.abs(back) + 1 : 0);
          $$invalidate(7, back = 0);
        }
      }
    }
    if ($$self.$$.dirty & /*total, startOffset, front, back*/
    450) {
      $: $$invalidate(10, items = Array.from({ length: total }).map((e, i) => i).slice(startOffset + front, (back + 1) * -1));
    }
  };
  return [
    page,
    total,
    loop,
    forwardText,
    backwardText,
    tooltipPosition,
    front,
    back,
    startOffset,
    fit,
    items,
    dispatch,
    $$restProps,
    shown,
    click_handler,
    click_handler_13,
    select_handler,
    click_handler_2,
    select_handler_1,
    click_handler_3,
    click_handler_4
  ];
}
var PaginationNav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance123, create_fragment123, safe_not_equal, {
      page: 0,
      total: 1,
      shown: 13,
      loop: 2,
      forwardText: 3,
      backwardText: 4,
      tooltipPosition: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationNav",
      options,
      id: create_fragment123.name
    });
  }
  get page() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set page(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get total() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set total(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shown() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shown(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forwardText() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forwardText(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backwardText() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backwardText(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipPosition() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipPosition(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PaginationNav_default = PaginationNav;

// node_modules/carbon-components-svelte/src/Popover/Popover.svelte
var file115 = "node_modules/carbon-components-svelte/src/Popover/Popover.svelte";
function create_fragment124(ctx) {
  let div1;
  let div0;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let div1_levels = [
    /*$$restProps*/
    ctx[9]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (default_slot) default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--popover-contents", true);
      add_location(div0, file115, 69, 2, 2166);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--popover", true);
      toggle_class(
        div1,
        "bx--popover--caret",
        /*caret*/
        ctx[2]
      );
      toggle_class(
        div1,
        "bx--popover--light",
        /*light*/
        ctx[4]
      );
      toggle_class(
        div1,
        "bx--popover--high-contrast",
        /*highContrast*/
        ctx[5]
      );
      toggle_class(
        div1,
        "bx--popover--top",
        /*align*/
        ctx[3] === "top"
      );
      toggle_class(
        div1,
        "bx--popover--top-left",
        /*align*/
        ctx[3] === "top-left"
      );
      toggle_class(
        div1,
        "bx--popover--top-right",
        /*align*/
        ctx[3] === "top-right"
      );
      toggle_class(
        div1,
        "bx--popover--bottom",
        /*align*/
        ctx[3] === "bottom"
      );
      toggle_class(
        div1,
        "bx--popover--bottom-left",
        /*align*/
        ctx[3] === "bottom-left"
      );
      toggle_class(
        div1,
        "bx--popover--bottom-right",
        /*align*/
        ctx[3] === "bottom-right"
      );
      toggle_class(
        div1,
        "bx--popover--left",
        /*align*/
        ctx[3] === "left"
      );
      toggle_class(
        div1,
        "bx--popover--left-bottom",
        /*align*/
        ctx[3] === "left-bottom"
      );
      toggle_class(
        div1,
        "bx--popover--left-top",
        /*align*/
        ctx[3] === "left-top"
      );
      toggle_class(
        div1,
        "bx--popover--right",
        /*align*/
        ctx[3] === "right"
      );
      toggle_class(
        div1,
        "bx--popover--right-bottom",
        /*align*/
        ctx[3] === "right-bottom"
      );
      toggle_class(
        div1,
        "bx--popover--right-top",
        /*align*/
        ctx[3] === "right-top"
      );
      toggle_class(
        div1,
        "bx--popover--open",
        /*open*/
        ctx[0]
      );
      toggle_class(
        div1,
        "bx--popover--relative",
        /*relative*/
        ctx[6]
      );
      set_style(
        div1,
        "position",
        /*relative*/
        ctx[6] ? "relative" : void 0
      );
      add_location(div1, file115, 46, 0, 1166);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[13](div1);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "click",
          /*click_handler*/
          ctx[12],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty & /*$$restProps*/
      512 && /*$$restProps*/
      ctx2[9]]));
      toggle_class(div1, "bx--popover", true);
      toggle_class(
        div1,
        "bx--popover--caret",
        /*caret*/
        ctx2[2]
      );
      toggle_class(
        div1,
        "bx--popover--light",
        /*light*/
        ctx2[4]
      );
      toggle_class(
        div1,
        "bx--popover--high-contrast",
        /*highContrast*/
        ctx2[5]
      );
      toggle_class(
        div1,
        "bx--popover--top",
        /*align*/
        ctx2[3] === "top"
      );
      toggle_class(
        div1,
        "bx--popover--top-left",
        /*align*/
        ctx2[3] === "top-left"
      );
      toggle_class(
        div1,
        "bx--popover--top-right",
        /*align*/
        ctx2[3] === "top-right"
      );
      toggle_class(
        div1,
        "bx--popover--bottom",
        /*align*/
        ctx2[3] === "bottom"
      );
      toggle_class(
        div1,
        "bx--popover--bottom-left",
        /*align*/
        ctx2[3] === "bottom-left"
      );
      toggle_class(
        div1,
        "bx--popover--bottom-right",
        /*align*/
        ctx2[3] === "bottom-right"
      );
      toggle_class(
        div1,
        "bx--popover--left",
        /*align*/
        ctx2[3] === "left"
      );
      toggle_class(
        div1,
        "bx--popover--left-bottom",
        /*align*/
        ctx2[3] === "left-bottom"
      );
      toggle_class(
        div1,
        "bx--popover--left-top",
        /*align*/
        ctx2[3] === "left-top"
      );
      toggle_class(
        div1,
        "bx--popover--right",
        /*align*/
        ctx2[3] === "right"
      );
      toggle_class(
        div1,
        "bx--popover--right-bottom",
        /*align*/
        ctx2[3] === "right-bottom"
      );
      toggle_class(
        div1,
        "bx--popover--right-top",
        /*align*/
        ctx2[3] === "right-top"
      );
      toggle_class(
        div1,
        "bx--popover--open",
        /*open*/
        ctx2[0]
      );
      toggle_class(
        div1,
        "bx--popover--relative",
        /*relative*/
        ctx2[6]
      );
      set_style(
        div1,
        "position",
        /*relative*/
        ctx2[6] ? "relative" : void 0
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[13](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment124.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance124($$self, $$props, $$invalidate) {
  const omit_props_names = ["open", "closeOnOutsideClick", "caret", "align", "light", "highContrast", "relative"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popover", slots, ["default"]);
  let { open = false } = $$props;
  let { closeOnOutsideClick = false } = $$props;
  let { caret = false } = $$props;
  let { align = "top" } = $$props;
  let { light = false } = $$props;
  let { highContrast = false } = $$props;
  let { relative = false } = $$props;
  const dispatch = createEventDispatcher();
  let ref = null;
  const click_handler = (e) => {
    if (!open) return;
    if (!ref.contains(e.target)) {
      dispatch("click:outside", { target: e.target });
      if (closeOnOutsideClick) $$invalidate(0, open = false);
    }
  };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(7, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("open" in $$new_props) $$invalidate(0, open = $$new_props.open);
    if ("closeOnOutsideClick" in $$new_props) $$invalidate(1, closeOnOutsideClick = $$new_props.closeOnOutsideClick);
    if ("caret" in $$new_props) $$invalidate(2, caret = $$new_props.caret);
    if ("align" in $$new_props) $$invalidate(3, align = $$new_props.align);
    if ("light" in $$new_props) $$invalidate(4, light = $$new_props.light);
    if ("highContrast" in $$new_props) $$invalidate(5, highContrast = $$new_props.highContrast);
    if ("relative" in $$new_props) $$invalidate(6, relative = $$new_props.relative);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    open,
    closeOnOutsideClick,
    caret,
    align,
    light,
    highContrast,
    relative,
    createEventDispatcher,
    dispatch,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("open" in $$props) $$invalidate(0, open = $$new_props.open);
    if ("closeOnOutsideClick" in $$props) $$invalidate(1, closeOnOutsideClick = $$new_props.closeOnOutsideClick);
    if ("caret" in $$props) $$invalidate(2, caret = $$new_props.caret);
    if ("align" in $$props) $$invalidate(3, align = $$new_props.align);
    if ("light" in $$props) $$invalidate(4, light = $$new_props.light);
    if ("highContrast" in $$props) $$invalidate(5, highContrast = $$new_props.highContrast);
    if ("relative" in $$props) $$invalidate(6, relative = $$new_props.relative);
    if ("ref" in $$props) $$invalidate(7, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    open,
    closeOnOutsideClick,
    caret,
    align,
    light,
    highContrast,
    relative,
    ref,
    dispatch,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    div1_binding
  ];
}
var Popover = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance124, create_fragment124, safe_not_equal, {
      open: 0,
      closeOnOutsideClick: 1,
      caret: 2,
      align: 3,
      light: 4,
      highContrast: 5,
      relative: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popover",
      options,
      id: create_fragment124.name
    });
  }
  get open() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnOutsideClick() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnOutsideClick(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caret() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caret(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get highContrast() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highContrast(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get relative() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set relative(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Popover_default = Popover;

// node_modules/carbon-components-svelte/src/ProgressBar/ProgressBar.svelte
var file116 = "node_modules/carbon-components-svelte/src/ProgressBar/ProgressBar.svelte";
var get_labelText_slot_changes9 = (dirty) => ({});
var get_labelText_slot_context9 = (ctx) => ({});
function fallback_block25(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelText*/
      16) set_data_dev(
        t,
        /*labelText*/
        ctx2[4]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block25.name,
    type: "fallback",
    source: "(80:27)        ",
    ctx
  });
  return block;
}
function create_if_block_133(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*statusIcons*/
    ctx[10][
      /*status*/
      ctx[2]
    ]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: { class: "bx--progress-bar__status-icon" },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*status*/
      4 && switch_value !== (switch_value = /*statusIcons*/
      ctx2[10][
        /*status*/
        ctx2[2]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_133.name,
    type: "if",
    source: '(83:4) {#if status === \\"error\\" || status === \\"finished\\"}',
    ctx
  });
  return block;
}
function create_if_block75(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[6]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[6]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*helperId*/
        ctx[11]
      );
      toggle_class(div, "bx--progress-bar__helper-text", true);
      add_location(div, file116, 105, 4, 2655);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*helperText*/
      64) set_data_dev(
        t,
        /*helperText*/
        ctx2[6]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block75.name,
    type: "if",
    source: "(105:2) {#if helperText}",
    ctx
  });
  return block;
}
function create_fragment125(ctx) {
  let div2;
  let label;
  let t0;
  let t1;
  let div1;
  let div0;
  let div1_aria_busy_value;
  let div1_aria_valuemin_value;
  let div1_aria_valuemax_value;
  let div1_aria_valuenow_value;
  let div1_aria_describedby_value;
  let t2;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[15].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_labelText_slot_context9
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block25(ctx);
  let if_block0 = (
    /*status*/
    (ctx[2] === "error" || /*status*/
    ctx[2] === "finished") && create_if_block_133(ctx)
  );
  let if_block1 = (
    /*helperText*/
    ctx[6] && create_if_block75(ctx)
  );
  let div2_levels = [
    /*$$restProps*/
    ctx[12]
  ];
  let div_data_2 = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      label = element("label");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      div1 = element("div");
      div0 = element("div");
      t2 = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      label = claim_element(div2_nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(label_nodes);
      t0 = claim_space(label_nodes);
      if (if_block0) if_block0.l(label_nodes);
      label_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", {
        role: true,
        id: true,
        "aria-busy": true,
        "aria-valuemin": true,
        "aria-valuemax": true,
        "aria-valuenow": true,
        "aria-describedby": true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      if (if_block1) if_block1.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[7]
      );
      toggle_class(label, "bx--progress-bar__label", true);
      toggle_class(
        label,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[5]
      );
      add_location(label, file116, 74, 2, 1776);
      toggle_class(div0, "bx--progress-bar__bar", true);
      set_style(
        div0,
        "transform",
        /*status*/
        ctx[2] === "active" && `scaleX(${/*capped*/
        ctx[8] / /*max*/
        ctx[0]})`
      );
      add_location(div0, file116, 99, 4, 2488);
      attr_dev(div1, "role", "progressbar");
      attr_dev(
        div1,
        "id",
        /*id*/
        ctx[7]
      );
      attr_dev(div1, "aria-busy", div1_aria_busy_value = /*status*/
      ctx[2] === "active");
      attr_dev(div1, "aria-valuemin", div1_aria_valuemin_value = /*indeterminate*/
      ctx[9] ? void 0 : 0);
      attr_dev(div1, "aria-valuemax", div1_aria_valuemax_value = /*indeterminate*/
      ctx[9] ? void 0 : (
        /*max*/
        ctx[0]
      ));
      attr_dev(div1, "aria-valuenow", div1_aria_valuenow_value = /*indeterminate*/
      ctx[9] ? void 0 : (
        /*capped*/
        ctx[8]
      ));
      attr_dev(div1, "aria-describedby", div1_aria_describedby_value = /*helperText*/
      ctx[6] ? (
        /*helperId*/
        ctx[11]
      ) : null);
      toggle_class(div1, "bx--progress-bar__track", true);
      add_location(div1, file116, 89, 2, 2140);
      set_attributes(div2, div_data_2);
      toggle_class(div2, "bx--progress-bar", true);
      toggle_class(
        div2,
        "bx--progress-bar--indeterminate",
        /*indeterminate*/
        ctx[9]
      );
      toggle_class(
        div2,
        "bx--progress-bar--big",
        /*size*/
        ctx[3] === "md"
      );
      toggle_class(
        div2,
        "bx--progress-bar--small",
        /*size*/
        ctx[3] === "sm"
      );
      toggle_class(
        div2,
        "bx--progress-bar--inline",
        /*kind*/
        ctx[1] === "inline"
      );
      toggle_class(
        div2,
        "bx--progress-bar--indented",
        /*kind*/
        ctx[1] === "indented"
      );
      toggle_class(
        div2,
        "bx--progress-bar--error",
        /*status*/
        ctx[2] === "error"
      );
      toggle_class(
        div2,
        "bx--progress-bar--finished",
        /*status*/
        ctx[2] === "finished"
      );
      add_location(div2, file116, 63, 0, 1328);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, label);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      append_hydration_dev(label, t0);
      if (if_block0) if_block0.m(label, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div2, t2);
      if (if_block1) if_block1.m(div2, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_labelText_slot_changes9
            ),
            get_labelText_slot_context9
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & /*labelText*/
        16)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (
        /*status*/
        ctx2[2] === "error" || /*status*/
        ctx2[2] === "finished"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*status*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_133(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(label, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*id*/
      128) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*hideLabel*/
      32) {
        toggle_class(
          label,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[5]
        );
      }
      if (dirty & /*status, capped, max*/
      261) {
        set_style(
          div0,
          "transform",
          /*status*/
          ctx2[2] === "active" && `scaleX(${/*capped*/
          ctx2[8] / /*max*/
          ctx2[0]})`
        );
      }
      if (!current || dirty & /*id*/
      128) {
        attr_dev(
          div1,
          "id",
          /*id*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*status*/
      4 && div1_aria_busy_value !== (div1_aria_busy_value = /*status*/
      ctx2[2] === "active")) {
        attr_dev(div1, "aria-busy", div1_aria_busy_value);
      }
      if (!current || dirty & /*indeterminate*/
      512 && div1_aria_valuemin_value !== (div1_aria_valuemin_value = /*indeterminate*/
      ctx2[9] ? void 0 : 0)) {
        attr_dev(div1, "aria-valuemin", div1_aria_valuemin_value);
      }
      if (!current || dirty & /*indeterminate, max*/
      513 && div1_aria_valuemax_value !== (div1_aria_valuemax_value = /*indeterminate*/
      ctx2[9] ? void 0 : (
        /*max*/
        ctx2[0]
      ))) {
        attr_dev(div1, "aria-valuemax", div1_aria_valuemax_value);
      }
      if (!current || dirty & /*indeterminate, capped*/
      768 && div1_aria_valuenow_value !== (div1_aria_valuenow_value = /*indeterminate*/
      ctx2[9] ? void 0 : (
        /*capped*/
        ctx2[8]
      ))) {
        attr_dev(div1, "aria-valuenow", div1_aria_valuenow_value);
      }
      if (!current || dirty & /*helperText*/
      64 && div1_aria_describedby_value !== (div1_aria_describedby_value = /*helperText*/
      ctx2[6] ? (
        /*helperId*/
        ctx2[11]
      ) : null)) {
        attr_dev(div1, "aria-describedby", div1_aria_describedby_value);
      }
      if (
        /*helperText*/
        ctx2[6]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block75(ctx2);
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [dirty & /*$$restProps*/
      4096 && /*$$restProps*/
      ctx2[12]]));
      toggle_class(div2, "bx--progress-bar", true);
      toggle_class(
        div2,
        "bx--progress-bar--indeterminate",
        /*indeterminate*/
        ctx2[9]
      );
      toggle_class(
        div2,
        "bx--progress-bar--big",
        /*size*/
        ctx2[3] === "md"
      );
      toggle_class(
        div2,
        "bx--progress-bar--small",
        /*size*/
        ctx2[3] === "sm"
      );
      toggle_class(
        div2,
        "bx--progress-bar--inline",
        /*kind*/
        ctx2[1] === "inline"
      );
      toggle_class(
        div2,
        "bx--progress-bar--indented",
        /*kind*/
        ctx2[1] === "indented"
      );
      toggle_class(
        div2,
        "bx--progress-bar--error",
        /*status*/
        ctx2[2] === "error"
      );
      toggle_class(
        div2,
        "bx--progress-bar--finished",
        /*status*/
        ctx2[2] === "finished"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment125.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance125($$self, $$props, $$invalidate) {
  let indeterminate;
  const omit_props_names = ["value", "max", "kind", "status", "size", "labelText", "hideLabel", "helperText", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressBar", slots, ["labelText"]);
  let { value = void 0 } = $$props;
  let { max = 100 } = $$props;
  let { kind = "default" } = $$props;
  let { status = "active" } = $$props;
  let { size = "md" } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { helperText = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  const statusIcons = {
    error: ErrorFilled_default,
    finished: CheckmarkFilled_default
  };
  let helperId = "ccs-" + Math.random().toString(36);
  let capped;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(13, value = $$new_props.value);
    if ("max" in $$new_props) $$invalidate(0, max = $$new_props.max);
    if ("kind" in $$new_props) $$invalidate(1, kind = $$new_props.kind);
    if ("status" in $$new_props) $$invalidate(2, status = $$new_props.status);
    if ("size" in $$new_props) $$invalidate(3, size = $$new_props.size);
    if ("labelText" in $$new_props) $$invalidate(4, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props) $$invalidate(5, hideLabel = $$new_props.hideLabel);
    if ("helperText" in $$new_props) $$invalidate(6, helperText = $$new_props.helperText);
    if ("id" in $$new_props) $$invalidate(7, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    max,
    kind,
    status,
    size,
    labelText,
    hideLabel,
    helperText,
    id,
    CheckmarkFilled: CheckmarkFilled_default,
    ErrorFilled: ErrorFilled_default,
    statusIcons,
    helperId,
    capped,
    indeterminate
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(13, value = $$new_props.value);
    if ("max" in $$props) $$invalidate(0, max = $$new_props.max);
    if ("kind" in $$props) $$invalidate(1, kind = $$new_props.kind);
    if ("status" in $$props) $$invalidate(2, status = $$new_props.status);
    if ("size" in $$props) $$invalidate(3, size = $$new_props.size);
    if ("labelText" in $$props) $$invalidate(4, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props) $$invalidate(5, hideLabel = $$new_props.hideLabel);
    if ("helperText" in $$props) $$invalidate(6, helperText = $$new_props.helperText);
    if ("id" in $$props) $$invalidate(7, id = $$new_props.id);
    if ("helperId" in $$props) $$invalidate(11, helperId = $$new_props.helperId);
    if ("capped" in $$props) $$invalidate(8, capped = $$new_props.capped);
    if ("indeterminate" in $$props) $$invalidate(9, indeterminate = $$new_props.indeterminate);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value, status*/
    8196) {
      $: $$invalidate(9, indeterminate = value === void 0 && status === "active");
    }
    if ($$self.$$.dirty & /*status, value, max*/
    8197) {
      $: {
        if (status === "error" || value < 0) {
          $$invalidate(8, capped = 0);
        } else if (value > max) {
          $$invalidate(8, capped = max);
        } else {
          $$invalidate(8, capped = value);
        }
      }
    }
  };
  return [
    max,
    kind,
    status,
    size,
    labelText,
    hideLabel,
    helperText,
    id,
    capped,
    indeterminate,
    statusIcons,
    helperId,
    $$restProps,
    value,
    $$scope,
    slots
  ];
}
var ProgressBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance125, create_fragment125, safe_not_equal, {
      value: 13,
      max: 0,
      kind: 1,
      status: 2,
      size: 3,
      labelText: 4,
      hideLabel: 5,
      helperText: 6,
      id: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressBar",
      options,
      id: create_fragment125.name
    });
  }
  get value() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get kind() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get status() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set status(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressBar_default = ProgressBar;

// node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressIndicator.svelte
var file117 = "node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressIndicator.svelte";
function create_fragment126(ctx) {
  let ul;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let ul_levels = [
    /*$$restProps*/
    ctx[3]
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {});
      var ul_nodes = children(ul);
      if (default_slot) default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--progress", true);
      toggle_class(
        ul,
        "bx--progress--vertical",
        /*vertical*/
        ctx[0]
      );
      toggle_class(
        ul,
        "bx--progress--space-equal",
        /*spaceEqually*/
        ctx[1] && !/*vertical*/
        ctx[0]
      );
      add_location(ul, file117, 67, 0, 1860);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            ul,
            "click",
            /*click_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseover",
            /*mouseover_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & /*$$restProps*/
      8 && /*$$restProps*/
      ctx2[3]]));
      toggle_class(ul, "bx--progress", true);
      toggle_class(
        ul,
        "bx--progress--vertical",
        /*vertical*/
        ctx2[0]
      );
      toggle_class(
        ul,
        "bx--progress--space-equal",
        /*spaceEqually*/
        ctx2[1] && !/*vertical*/
        ctx2[0]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment126.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance126($$self, $$props, $$invalidate) {
  const omit_props_names = ["currentIndex", "vertical", "spaceEqually", "preventChangeOnClick"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $stepsById;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressIndicator", slots, ["default"]);
  let { currentIndex = 0 } = $$props;
  let { vertical = false } = $$props;
  let { spaceEqually = false } = $$props;
  let { preventChangeOnClick = false } = $$props;
  const dispatch = createEventDispatcher();
  const steps = writable([]);
  const stepsById = derived(steps, (steps2) => steps2.reduce((a, c) => ({ ...a, [c.id]: c }), {}));
  validate_store(stepsById, "stepsById");
  component_subscribe($$self, stepsById, (value) => $$invalidate(12, $stepsById = value));
  const preventChangeOnClickStore = writable(preventChangeOnClick);
  setContext("ProgressIndicator", {
    steps,
    stepsById,
    preventChangeOnClick: {
      subscribe: preventChangeOnClickStore.subscribe
    },
    add: (step) => {
      steps.update((_) => {
        if (step.id in $stepsById) {
          return _.map((_step) => {
            if (_step.id === step.id) return { ..._step, ...step };
            return _step;
          });
        }
        return [
          ..._,
          {
            ...step,
            index: _.length,
            current: _.length === currentIndex,
            complete: step.complete
          }
        ];
      });
    },
    change: (index) => {
      if (preventChangeOnClick) return;
      $$invalidate(4, currentIndex = index);
      dispatch("change", index);
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("currentIndex" in $$new_props) $$invalidate(4, currentIndex = $$new_props.currentIndex);
    if ("vertical" in $$new_props) $$invalidate(0, vertical = $$new_props.vertical);
    if ("spaceEqually" in $$new_props) $$invalidate(1, spaceEqually = $$new_props.spaceEqually);
    if ("preventChangeOnClick" in $$new_props) $$invalidate(5, preventChangeOnClick = $$new_props.preventChangeOnClick);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    currentIndex,
    vertical,
    spaceEqually,
    preventChangeOnClick,
    createEventDispatcher,
    setContext,
    writable,
    derived,
    dispatch,
    steps,
    stepsById,
    preventChangeOnClickStore,
    $stepsById
  });
  $$self.$inject_state = ($$new_props) => {
    if ("currentIndex" in $$props) $$invalidate(4, currentIndex = $$new_props.currentIndex);
    if ("vertical" in $$props) $$invalidate(0, vertical = $$new_props.vertical);
    if ("spaceEqually" in $$props) $$invalidate(1, spaceEqually = $$new_props.spaceEqually);
    if ("preventChangeOnClick" in $$props) $$invalidate(5, preventChangeOnClick = $$new_props.preventChangeOnClick);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*currentIndex*/
    16) {
      $: steps.update((_) => _.map((step, i) => ({ ...step, current: i === currentIndex })));
    }
    if ($$self.$$.dirty & /*preventChangeOnClick*/
    32) {
      $: preventChangeOnClickStore.set(preventChangeOnClick);
    }
  };
  return [
    vertical,
    spaceEqually,
    stepsById,
    $$restProps,
    currentIndex,
    preventChangeOnClick,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var ProgressIndicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance126, create_fragment126, safe_not_equal, {
      currentIndex: 4,
      vertical: 0,
      spaceEqually: 1,
      preventChangeOnClick: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressIndicator",
      options,
      id: create_fragment126.name
    });
  }
  get currentIndex() {
    throw new Error("<ProgressIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set currentIndex(value) {
    throw new Error("<ProgressIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<ProgressIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<ProgressIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spaceEqually() {
    throw new Error("<ProgressIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spaceEqually(value) {
    throw new Error("<ProgressIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventChangeOnClick() {
    throw new Error("<ProgressIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventChangeOnClick(value) {
    throw new Error("<ProgressIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressIndicator_default = ProgressIndicator;

// node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressIndicatorSkeleton.svelte
var file118 = "node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressIndicatorSkeleton.svelte";
function get_each_context16(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  child_ctx[9] = i;
  return child_ctx;
}
function create_each_block16(key_1, ctx) {
  let li;
  let div;
  let svg;
  let path;
  let t0;
  let p;
  let t1;
  let span;
  let t2;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      li = element("li");
      div = element("div");
      svg = svg_element("svg");
      path = svg_element("path");
      t0 = space();
      p = element("p");
      t1 = space();
      span = element("span");
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      div = claim_element(li_nodes, "DIV", {});
      var div_nodes = children(div);
      svg = claim_svg_element(div_nodes, "svg", {});
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      t0 = claim_space(div_nodes);
      p = claim_element(div_nodes, "P", {});
      children(p).forEach(detach_dev);
      t1 = claim_space(div_nodes);
      span = claim_element(div_nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      t2 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M 7, 7 m -7, 0 a 7,7 0 1,0 14,0 a 7,7 0 1,0 -14,0");
      add_location(path, file118, 30, 10, 812);
      add_location(svg, file118, 29, 8, 796);
      toggle_class(p, "bx--progress-label", true);
      add_location(p, file118, 32, 8, 903);
      toggle_class(span, "bx--progress-line", true);
      add_location(span, file118, 33, 8, 953);
      toggle_class(div, "bx--progress-step-button", true);
      toggle_class(div, "bx--progress-step-button--unclickable", true);
      add_location(div, file118, 25, 6, 666);
      toggle_class(li, "bx--progress-step", true);
      toggle_class(li, "bx--progress-step--incomplete", true);
      add_location(li, file118, 21, 4, 560);
      this.first = li;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, div);
      append_hydration_dev(div, svg);
      append_hydration_dev(svg, path);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, p);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, span);
      append_hydration_dev(li, t2);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block16.name,
    type: "each",
    source: "(21:2) {#each Array.from({ length: count }, (_, i) => i) as item, i (item)}",
    ctx
  });
  return block;
}
function create_fragment127(ctx) {
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(Array.from({ length: (
    /*count*/
    ctx[1]
  ) }, func6));
  const get_key = (ctx2) => (
    /*item*/
    ctx2[7]
  );
  validate_each_keys(ctx, each_value, get_each_context16, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context16(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block16(key, child_ctx));
  }
  let ul_levels = [
    /*$$restProps*/
    ctx[2]
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {});
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--progress", true);
      toggle_class(
        ul,
        "bx--progress--vertical",
        /*vertical*/
        ctx[0]
      );
      toggle_class(ul, "bx--skeleton", true);
      add_location(ul, file118, 10, 0, 298);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      if (!mounted) {
        dispose = [
          listen_dev(
            ul,
            "click",
            /*click_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseover",
            /*mouseover_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*count*/
      2) {
        each_value = ensure_array_like_dev(Array.from({ length: (
          /*count*/
          ctx2[1]
        ) }, func6));
        validate_each_keys(ctx2, each_value, get_each_context16, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, destroy_block, create_each_block16, null, get_each_context16);
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & /*$$restProps*/
      4 && /*$$restProps*/
      ctx2[2]]));
      toggle_class(ul, "bx--progress", true);
      toggle_class(
        ul,
        "bx--progress--vertical",
        /*vertical*/
        ctx2[0]
      );
      toggle_class(ul, "bx--skeleton", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment127.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func6 = (_, i) => i;
function instance127($$self, $$props, $$invalidate) {
  const omit_props_names = ["vertical", "count"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressIndicatorSkeleton", slots, []);
  let { vertical = false } = $$props;
  let { count = 4 } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("vertical" in $$new_props) $$invalidate(0, vertical = $$new_props.vertical);
    if ("count" in $$new_props) $$invalidate(1, count = $$new_props.count);
  };
  $$self.$capture_state = () => ({ vertical, count });
  $$self.$inject_state = ($$new_props) => {
    if ("vertical" in $$props) $$invalidate(0, vertical = $$new_props.vertical);
    if ("count" in $$props) $$invalidate(1, count = $$new_props.count);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    vertical,
    count,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var ProgressIndicatorSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance127, create_fragment127, safe_not_equal, { vertical: 0, count: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressIndicatorSkeleton",
      options,
      id: create_fragment127.name
    });
  }
  get vertical() {
    throw new Error("<ProgressIndicatorSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<ProgressIndicatorSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get count() {
    throw new Error("<ProgressIndicatorSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<ProgressIndicatorSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressIndicatorSkeleton_default = ProgressIndicatorSkeleton;

// node_modules/carbon-components-svelte/src/icons/CheckmarkOutline.svelte
var file119 = "node_modules/carbon-components-svelte/src/icons/CheckmarkOutline.svelte";
function create_if_block76(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file119, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block76.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment128(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block76(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M14 21.414L9 16.413 10.413 15 14 18.586 21.585 11 23 12.415 14 21.414z");
      add_location(path0, file119, 24, 2, 579);
      attr_dev(path1, "d", "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z");
      add_location(path1, file119, 26, 10, 674);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file119, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block76(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment128.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance128($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckmarkOutline", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var CheckmarkOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance128, create_fragment128, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckmarkOutline",
      options,
      id: create_fragment128.name
    });
  }
  get size() {
    throw new Error("<CheckmarkOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CheckmarkOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CheckmarkOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CheckmarkOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CheckmarkOutline_default = CheckmarkOutline;

// node_modules/carbon-components-svelte/src/icons/Warning.svelte
var file120 = "node_modules/carbon-components-svelte/src/icons/Warning.svelte";
function create_if_block77(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file120, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block77.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment129(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block77(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z");
      add_location(path0, file120, 24, 2, 579);
      attr_dev(path1, "d", "M15 8H17V19H15zM16 22a1.5 1.5 0 101.5 1.5A1.5 1.5 0 0016 22z");
      add_location(path1, file120, 26, 10, 687);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file120, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block77(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment129.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance129($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Warning", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Warning = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance129, create_fragment129, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Warning",
      options,
      id: create_fragment129.name
    });
  }
  get size() {
    throw new Error("<Warning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Warning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Warning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Warning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Warning_default = Warning;

// node_modules/carbon-components-svelte/src/icons/CircleDash.svelte
var file121 = "node_modules/carbon-components-svelte/src/icons/CircleDash.svelte";
function create_if_block78(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file121, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block78.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment130(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block78(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.7 4.7a14.7 14.7 0 00-3 3.1L6.3 9A13.26 13.26 0 018.9 6.3zM4.6 12.3l-1.9-.6A12.51 12.51 0 002 16H4A11.48 11.48 0 014.6 12.3zM2.7 20.4a14.4 14.4 0 002 3.9l1.6-1.2a12.89 12.89 0 01-1.7-3.3zM7.8 27.3a14.4 14.4 0 003.9 2l.6-1.9A12.89 12.89 0 019 25.7zM11.7 2.7l.6 1.9A11.48 11.48 0 0116 4V2A12.51 12.51 0 0011.7 2.7zM24.2 27.3a15.18 15.18 0 003.1-3.1L25.7 23A11.53 11.53 0 0123 25.7zM27.4 19.7l1.9.6A15.47 15.47 0 0030 16H28A11.48 11.48 0 0127.4 19.7zM29.2 11.6a14.4 14.4 0 00-2-3.9L25.6 8.9a12.89 12.89 0 011.7 3.3zM24.1 4.6a14.4 14.4 0 00-3.9-2l-.6 1.9a12.89 12.89 0 013.3 1.7zM20.3 29.3l-.6-1.9A11.48 11.48 0 0116 28v2A21.42 21.42 0 0020.3 29.3z");
      add_location(path, file121, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file121, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block78(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment130.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance130($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CircleDash", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var CircleDash = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance130, create_fragment130, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CircleDash",
      options,
      id: create_fragment130.name
    });
  }
  get size() {
    throw new Error("<CircleDash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CircleDash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CircleDash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CircleDash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CircleDash_default = CircleDash;

// node_modules/carbon-components-svelte/src/icons/Incomplete.svelte
var file122 = "node_modules/carbon-components-svelte/src/icons/Incomplete.svelte";
function create_if_block79(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file122, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block79.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment131(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block79(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23.7642 6.8593l1.2851-1.5315A13.976 13.976 0 0020.8672 2.887l-.6836 1.8776A11.9729 11.9729 0 0123.7642 6.8593zM27.81 14l1.9677-.4128A13.8888 13.8888 0 0028.14 9.0457L26.4087 10A12.52 12.52 0 0127.81 14zM20.1836 27.2354l.6836 1.8776a13.976 13.976 0 004.1821-2.4408l-1.2851-1.5315A11.9729 11.9729 0 0120.1836 27.2354zM26.4087 22L28.14 23a14.14 14.14 0 001.6382-4.5872L27.81 18.0659A12.1519 12.1519 0 0126.4087 22zM16 30V2a14 14 0 000 28z");
      add_location(path, file122, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file122, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block79(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment131.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance131($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Incomplete", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Incomplete = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance131, create_fragment131, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Incomplete",
      options,
      id: create_fragment131.name
    });
  }
  get size() {
    throw new Error("<Incomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Incomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Incomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Incomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Incomplete_default = Incomplete;

// node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressStep.svelte
var file123 = "node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressStep.svelte";
var get_default_slot_changes10 = (dirty) => ({});
var get_default_slot_context10 = (ctx) => ({ props: { class: "bx--progress-label" } });
function create_else_block26(ctx) {
  let circledash;
  let current;
  circledash = new CircleDash_default({
    props: { title: (
      /*description*/
      ctx[4]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(circledash.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(circledash.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(circledash, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const circledash_changes = {};
      if (dirty & /*description*/
      16) circledash_changes.title = /*description*/
      ctx2[4];
      circledash.$set(circledash_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(circledash.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(circledash.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(circledash, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block26.name,
    type: "else",
    source: "(94:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_315(ctx) {
  let checkmarkoutline;
  let current;
  checkmarkoutline = new CheckmarkOutline_default({
    props: { title: (
      /*description*/
      ctx[4]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(checkmarkoutline.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(checkmarkoutline.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(checkmarkoutline, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkmarkoutline_changes = {};
      if (dirty & /*description*/
      16) checkmarkoutline_changes.title = /*description*/
      ctx2[4];
      checkmarkoutline.$set(checkmarkoutline_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(checkmarkoutline.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmarkoutline.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkmarkoutline, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_315.name,
    type: "if",
    source: "(92:23) ",
    ctx
  });
  return block;
}
function create_if_block_220(ctx) {
  let incomplete;
  let current;
  incomplete = new Incomplete_default({
    props: { title: (
      /*description*/
      ctx[4]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(incomplete.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(incomplete.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(incomplete, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const incomplete_changes = {};
      if (dirty & /*description*/
      16) incomplete_changes.title = /*description*/
      ctx2[4];
      incomplete.$set(incomplete_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(incomplete.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(incomplete.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(incomplete, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_220.name,
    type: "if",
    source: "(90:22) ",
    ctx
  });
  return block;
}
function create_if_block_134(ctx) {
  let warning;
  let current;
  warning = new Warning_default({
    props: {
      class: "bx--progress__warning",
      title: (
        /*description*/
        ctx[4]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warning.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warning.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warning, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const warning_changes = {};
      if (dirty & /*description*/
      16) warning_changes.title = /*description*/
      ctx2[4];
      warning.$set(warning_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warning.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warning.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warning, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_134.name,
    type: "if",
    source: "(88:4) {#if invalid}",
    ctx
  });
  return block;
}
function fallback_block26(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text(
        /*label*/
        ctx[5]
      );
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(
        p_nodes,
        /*label*/
        ctx[5]
      );
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(p, "bx--progress-label", true);
      add_location(p, file123, 98, 8, 2665);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*label*/
      32) set_data_dev(
        t,
        /*label*/
        ctx2[5]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block26.name,
    type: "fallback",
    source: "(98:54)          ",
    ctx
  });
  return block;
}
function create_if_block80(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text(
        /*secondaryLabel*/
        ctx[6]
      );
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(
        p_nodes,
        /*secondaryLabel*/
        ctx[6]
      );
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(p, "bx--progress-optional", true);
      add_location(p, file123, 101, 8, 2763);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*secondaryLabel*/
      64) set_data_dev(
        t,
        /*secondaryLabel*/
        ctx2[6]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block80.name,
    type: "if",
    source: "(101:6) {#if secondaryLabel}",
    ctx
  });
  return block;
}
function create_fragment132(ctx) {
  let li;
  let button;
  let current_block_type_index;
  let if_block0;
  let t0;
  let div;
  let t1;
  let t2;
  let span;
  let button_tabindex_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_134, create_if_block_220, create_if_block_315, create_else_block26];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*invalid*/
      ctx2[3]
    ) return 0;
    if (
      /*current*/
      ctx2[1]
    ) return 1;
    if (
      /*complete*/
      ctx2[0]
    ) return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context10
  );
  const default_slot_or_fallback = default_slot || fallback_block26(ctx);
  let if_block1 = (
    /*secondaryLabel*/
    ctx[6] && create_if_block80(ctx)
  );
  let li_levels = [
    { id: (
      /*id*/
      ctx[7]
    ) },
    /*$$restProps*/
    ctx[12]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      button = element("button");
      if_block0.c();
      t0 = space();
      div = element("div");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { id: true });
      var li_nodes = children(li);
      button = claim_element(li_nodes, "BUTTON", {
        type: true,
        "aria-disabled": true,
        tabindex: true
      });
      var button_nodes = children(button);
      if_block0.l(button_nodes);
      t0 = claim_space(button_nodes);
      div = claim_element(button_nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot_or_fallback) default_slot_or_fallback.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block1) if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t2 = claim_space(button_nodes);
      span = claim_element(button_nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--progress-text", true);
      add_location(div, file123, 96, 4, 2563);
      toggle_class(span, "bx--progress-line", true);
      add_location(span, file123, 104, 4, 2851);
      attr_dev(button, "type", "button");
      button.disabled = /*disabled*/
      ctx[2];
      attr_dev(
        button,
        "aria-disabled",
        /*disabled*/
        ctx[2]
      );
      attr_dev(button, "tabindex", button_tabindex_value = !/*current*/
      ctx[1] && !/*disabled*/
      ctx[2] ? "0" : "-1");
      toggle_class(button, "bx--progress-step-button", true);
      toggle_class(
        button,
        "bx--progress-step-button--unclickable",
        /*current*/
        ctx[1] || /*$preventChangeOnClick*/
        ctx[9]
      );
      add_location(button, file123, 63, 2, 1669);
      set_attributes(li, li_data);
      toggle_class(li, "bx--progress-step", true);
      toggle_class(
        li,
        "bx--progress-step--current",
        /*current*/
        ctx[1]
      );
      toggle_class(
        li,
        "bx--progress-step--complete",
        /*complete*/
        ctx[0]
      );
      toggle_class(li, "bx--progress-step--incomplete", !/*complete*/
      ctx[0] && !/*current*/
      ctx[1]);
      toggle_class(
        li,
        "bx--progress-step--disabled",
        /*disabled*/
        ctx[2]
      );
      add_location(li, file123, 54, 0, 1386);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, button);
      if_blocks[current_block_type_index].m(button, null);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, div);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      append_hydration_dev(div, t1);
      if (if_block1) if_block1.m(div, null);
      append_hydration_dev(button, t2);
      append_hydration_dev(button, span);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler_1*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseover",
            /*mouseover_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler_1*/
            ctx[21],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(button, t0);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes10
            ),
            get_default_slot_context10
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*label*/
        32)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (
        /*secondaryLabel*/
        ctx2[6]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block80(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*disabled*/
      4) {
        prop_dev(
          button,
          "disabled",
          /*disabled*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*disabled*/
      4) {
        attr_dev(
          button,
          "aria-disabled",
          /*disabled*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*current, disabled*/
      6 && button_tabindex_value !== (button_tabindex_value = !/*current*/
      ctx2[1] && !/*disabled*/
      ctx2[2] ? "0" : "-1")) {
        attr_dev(button, "tabindex", button_tabindex_value);
      }
      if (!current || dirty & /*current, $preventChangeOnClick*/
      514) {
        toggle_class(
          button,
          "bx--progress-step-button--unclickable",
          /*current*/
          ctx2[1] || /*$preventChangeOnClick*/
          ctx2[9]
        );
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty & /*id*/
        128) && { id: (
          /*id*/
          ctx2[7]
        ) },
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12]
      ]));
      toggle_class(li, "bx--progress-step", true);
      toggle_class(
        li,
        "bx--progress-step--current",
        /*current*/
        ctx2[1]
      );
      toggle_class(
        li,
        "bx--progress-step--complete",
        /*complete*/
        ctx2[0]
      );
      toggle_class(li, "bx--progress-step--incomplete", !/*complete*/
      ctx2[0] && !/*current*/
      ctx2[1]);
      toggle_class(
        li,
        "bx--progress-step--disabled",
        /*disabled*/
        ctx2[2]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if_blocks[current_block_type_index].d();
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      if (if_block1) if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment132.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance132($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "complete",
    "current",
    "disabled",
    "invalid",
    "description",
    "label",
    "secondaryLabel",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $preventChangeOnClick;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressStep", slots, ["default"]);
  let { complete = false } = $$props;
  let { current = false } = $$props;
  let { disabled = false } = $$props;
  let { invalid = false } = $$props;
  let { description = "" } = $$props;
  let { label = "" } = $$props;
  let { secondaryLabel = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let step = {};
  const { stepsById, add, change, preventChangeOnClick } = getContext("ProgressIndicator");
  validate_store(preventChangeOnClick, "preventChangeOnClick");
  component_subscribe($$self, preventChangeOnClick, (value) => $$invalidate(9, $preventChangeOnClick = value));
  const unsubscribe = stepsById.subscribe((value) => {
    if (value[id]) {
      $$invalidate(8, step = value[id]);
      $$invalidate(1, current = step.current);
      $$invalidate(0, complete = step.complete);
    }
  });
  onMount(() => {
    return () => {
      unsubscribe();
    };
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = () => {
    if (!step.complete) return;
    change(step.index);
  };
  const keydown_handler_12 = (e) => {
    if (!step.complete) return;
    if (e.key === " " || e.key === "Enter") {
      change(step.index);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("complete" in $$new_props) $$invalidate(0, complete = $$new_props.complete);
    if ("current" in $$new_props) $$invalidate(1, current = $$new_props.current);
    if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("invalid" in $$new_props) $$invalidate(3, invalid = $$new_props.invalid);
    if ("description" in $$new_props) $$invalidate(4, description = $$new_props.description);
    if ("label" in $$new_props) $$invalidate(5, label = $$new_props.label);
    if ("secondaryLabel" in $$new_props) $$invalidate(6, secondaryLabel = $$new_props.secondaryLabel);
    if ("id" in $$new_props) $$invalidate(7, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    complete,
    current,
    disabled,
    invalid,
    description,
    label,
    secondaryLabel,
    id,
    onMount,
    getContext,
    CheckmarkOutline: CheckmarkOutline_default,
    Warning: Warning_default,
    CircleDash: CircleDash_default,
    Incomplete: Incomplete_default,
    step,
    stepsById,
    add,
    change,
    preventChangeOnClick,
    unsubscribe,
    $preventChangeOnClick
  });
  $$self.$inject_state = ($$new_props) => {
    if ("complete" in $$props) $$invalidate(0, complete = $$new_props.complete);
    if ("current" in $$props) $$invalidate(1, current = $$new_props.current);
    if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("invalid" in $$props) $$invalidate(3, invalid = $$new_props.invalid);
    if ("description" in $$props) $$invalidate(4, description = $$new_props.description);
    if ("label" in $$props) $$invalidate(5, label = $$new_props.label);
    if ("secondaryLabel" in $$props) $$invalidate(6, secondaryLabel = $$new_props.secondaryLabel);
    if ("id" in $$props) $$invalidate(7, id = $$new_props.id);
    if ("step" in $$props) $$invalidate(8, step = $$new_props.step);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id, complete, disabled*/
    133) {
      $: add({ id, complete, disabled });
    }
  };
  return [
    complete,
    current,
    disabled,
    invalid,
    description,
    label,
    secondaryLabel,
    id,
    step,
    $preventChangeOnClick,
    change,
    preventChangeOnClick,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    click_handler_13,
    keydown_handler_12
  ];
}
var ProgressStep = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance132, create_fragment132, safe_not_equal, {
      complete: 0,
      current: 1,
      disabled: 2,
      invalid: 3,
      description: 4,
      label: 5,
      secondaryLabel: 6,
      id: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressStep",
      options,
      id: create_fragment132.name
    });
  }
  get complete() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set complete(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get current() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set current(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryLabel() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryLabel(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressStep_default = ProgressStep;

// node_modules/carbon-components-svelte/src/RadioButton/RadioButtonSkeleton.svelte
var file124 = "node_modules/carbon-components-svelte/src/RadioButton/RadioButtonSkeleton.svelte";
function create_fragment133(ctx) {
  let div1;
  let div0;
  let t;
  let span;
  let mounted;
  let dispose;
  let div1_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      children(div0).forEach(detach_dev);
      t = claim_space(div1_nodes);
      span = claim_element(div1_nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--radio-button", true);
      toggle_class(div0, "bx--skeleton", true);
      add_location(div0, file124, 10, 2, 244);
      toggle_class(span, "bx--radio-button__label", true);
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file124, 11, 2, 318);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--radio-button-wrapper", true);
      add_location(div1, file124, 2, 0, 116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, span);
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[1],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseover",
            /*mouseover_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
      toggle_class(div1, "bx--radio-button-wrapper", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment133.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance133($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioButtonSkeleton", slots, []);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var RadioButtonSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance133, create_fragment133, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioButtonSkeleton",
      options,
      id: create_fragment133.name
    });
  }
};
var RadioButtonSkeleton_default = RadioButtonSkeleton;

// node_modules/carbon-components-svelte/src/RadioButtonGroup/RadioButtonGroup.svelte
var file125 = "node_modules/carbon-components-svelte/src/RadioButtonGroup/RadioButtonGroup.svelte";
var get_legendText_slot_changes = (dirty) => ({});
var get_legendText_slot_context = (ctx) => ({});
function create_if_block81(ctx) {
  let legend;
  let current;
  const legendText_slot_template = (
    /*#slots*/
    ctx[15].legendText
  );
  const legendText_slot = create_slot(
    legendText_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_legendText_slot_context
  );
  const legendText_slot_or_fallback = legendText_slot || fallback_block27(ctx);
  const block = {
    c: function create() {
      legend = element("legend");
      if (legendText_slot_or_fallback) legendText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      legend = claim_element(nodes, "LEGEND", {});
      var legend_nodes = children(legend);
      if (legendText_slot_or_fallback) legendText_slot_or_fallback.l(legend_nodes);
      legend_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(legend, "bx--label", true);
      toggle_class(
        legend,
        "bx--visually-hidden",
        /*hideLegend*/
        ctx[2]
      );
      add_location(legend, file125, 113, 6, 2538);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, legend, anchor);
      if (legendText_slot_or_fallback) {
        legendText_slot_or_fallback.m(legend, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (legendText_slot) {
        if (legendText_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            legendText_slot,
            legendText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              legendText_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_legendText_slot_changes
            ),
            get_legendText_slot_context
          );
        }
      } else {
        if (legendText_slot_or_fallback && legendText_slot_or_fallback.p && (!current || dirty & /*legendText*/
        2)) {
          legendText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*hideLegend*/
      4) {
        toggle_class(
          legend,
          "bx--visually-hidden",
          /*hideLegend*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(legendText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(legendText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(legend);
      }
      if (legendText_slot_or_fallback) legendText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block81.name,
    type: "if",
    source: "(113:4) {#if legendText || $$slots.legendText}",
    ctx
  });
  return block;
}
function fallback_block27(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*legendText*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*legendText*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*legendText*/
      2) set_data_dev(
        t,
        /*legendText*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block27.name,
    type: "fallback",
    source: "(115:32) {legendText}",
    ctx
  });
  return block;
}
function create_fragment134(ctx) {
  let div;
  let fieldset;
  let t;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*legendText*/
    (ctx[1] || /*$$slots*/
    ctx[10].legendText) && create_if_block81(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  let div_levels = [
    { id: (
      /*id*/
      ctx[5]
    ) },
    /*$$restProps*/
    ctx[9]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      fieldset = element("fieldset");
      if (if_block) if_block.c();
      t = space();
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      fieldset = claim_element(div_nodes, "FIELDSET", {});
      var fieldset_nodes = children(fieldset);
      if (if_block) if_block.l(fieldset_nodes);
      t = claim_space(fieldset_nodes);
      if (default_slot) default_slot.l(fieldset_nodes);
      fieldset_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      fieldset.disabled = /*disabled*/
      ctx[0];
      toggle_class(fieldset, "bx--radio-button-group", true);
      toggle_class(
        fieldset,
        "bx--radio-button-group--vertical",
        /*orientation*/
        ctx[4] === "vertical"
      );
      toggle_class(
        fieldset,
        "bx--radio-button-group--label-left",
        /*labelPosition*/
        ctx[3] === "left"
      );
      toggle_class(
        fieldset,
        "bx--radio-button-group--label-right",
        /*labelPosition*/
        ctx[3] === "right"
      );
      add_location(fieldset, file125, 105, 2, 2183);
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      add_location(div, file125, 96, 0, 2054);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, fieldset);
      if (if_block) if_block.m(fieldset, null);
      append_hydration_dev(fieldset, t);
      if (default_slot) {
        default_slot.m(fieldset, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*legendText*/
        ctx2[1] || /*$$slots*/
        ctx2[10].legendText
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*legendText, $$slots*/
          1026) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block81(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(fieldset, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*disabled*/
      1) {
        prop_dev(
          fieldset,
          "disabled",
          /*disabled*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*orientation*/
      16) {
        toggle_class(
          fieldset,
          "bx--radio-button-group--vertical",
          /*orientation*/
          ctx2[4] === "vertical"
        );
      }
      if (!current || dirty & /*labelPosition*/
      8) {
        toggle_class(
          fieldset,
          "bx--radio-button-group--label-left",
          /*labelPosition*/
          ctx2[3] === "left"
        );
      }
      if (!current || dirty & /*labelPosition*/
      8) {
        toggle_class(
          fieldset,
          "bx--radio-button-group--label-right",
          /*labelPosition*/
          ctx2[3] === "right"
        );
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*id*/
        32) && { id: (
          /*id*/
          ctx2[5]
        ) },
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9]
      ]));
      toggle_class(div, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment134.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance134($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "selected",
    "disabled",
    "required",
    "name",
    "legendText",
    "hideLegend",
    "labelPosition",
    "orientation",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $groupRequired;
  let $groupName;
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioButtonGroup", slots, ["legendText", "default"]);
  const $$slots = compute_slots(slots);
  let { selected = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { required = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { legendText = "" } = $$props;
  let { hideLegend = false } = $$props;
  let { labelPosition = "right" } = $$props;
  let { orientation = "horizontal" } = $$props;
  let { id = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  const selectedValue = writable(selected);
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value) => $$invalidate(22, $selectedValue = value));
  const groupName = writable(name);
  validate_store(groupName, "groupName");
  component_subscribe($$self, groupName, (value) => $$invalidate(21, $groupName = value));
  const groupRequired = writable(required);
  validate_store(groupRequired, "groupRequired");
  component_subscribe($$self, groupRequired, (value) => $$invalidate(20, $groupRequired = value));
  setContext("RadioButtonGroup", {
    selectedValue,
    groupName: readonly(groupName),
    groupRequired: readonly(groupRequired),
    add: ({ checked, value }) => {
      if (checked) {
        selectedValue.set(value);
      }
    },
    update: (value) => {
      $$invalidate(11, selected = value);
    }
  });
  onMount(() => {
    set_store_value(selectedValue, $selectedValue = selected, $selectedValue);
  });
  beforeUpdate(() => {
    set_store_value(selectedValue, $selectedValue = selected, $selectedValue);
  });
  selectedValue.subscribe((value) => {
    $$invalidate(11, selected = value);
    dispatch("change", value);
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props) $$invalidate(11, selected = $$new_props.selected);
    if ("disabled" in $$new_props) $$invalidate(0, disabled = $$new_props.disabled);
    if ("required" in $$new_props) $$invalidate(12, required = $$new_props.required);
    if ("name" in $$new_props) $$invalidate(13, name = $$new_props.name);
    if ("legendText" in $$new_props) $$invalidate(1, legendText = $$new_props.legendText);
    if ("hideLegend" in $$new_props) $$invalidate(2, hideLegend = $$new_props.hideLegend);
    if ("labelPosition" in $$new_props) $$invalidate(3, labelPosition = $$new_props.labelPosition);
    if ("orientation" in $$new_props) $$invalidate(4, orientation = $$new_props.orientation);
    if ("id" in $$new_props) $$invalidate(5, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    disabled,
    required,
    name,
    legendText,
    hideLegend,
    labelPosition,
    orientation,
    id,
    beforeUpdate,
    createEventDispatcher,
    onMount,
    setContext,
    readonly,
    writable,
    dispatch,
    selectedValue,
    groupName,
    groupRequired,
    $groupRequired,
    $groupName,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props) $$invalidate(11, selected = $$new_props.selected);
    if ("disabled" in $$props) $$invalidate(0, disabled = $$new_props.disabled);
    if ("required" in $$props) $$invalidate(12, required = $$new_props.required);
    if ("name" in $$props) $$invalidate(13, name = $$new_props.name);
    if ("legendText" in $$props) $$invalidate(1, legendText = $$new_props.legendText);
    if ("hideLegend" in $$props) $$invalidate(2, hideLegend = $$new_props.hideLegend);
    if ("labelPosition" in $$props) $$invalidate(3, labelPosition = $$new_props.labelPosition);
    if ("orientation" in $$props) $$invalidate(4, orientation = $$new_props.orientation);
    if ("id" in $$props) $$invalidate(5, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*name*/
    8192) {
      $: set_store_value(groupName, $groupName = name, $groupName);
    }
    if ($$self.$$.dirty & /*required*/
    4096) {
      $: set_store_value(groupRequired, $groupRequired = required, $groupRequired);
    }
  };
  return [
    disabled,
    legendText,
    hideLegend,
    labelPosition,
    orientation,
    id,
    selectedValue,
    groupName,
    groupRequired,
    $$restProps,
    $$slots,
    selected,
    required,
    name,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var RadioButtonGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance134, create_fragment134, safe_not_equal, {
      selected: 11,
      disabled: 0,
      required: 12,
      name: 13,
      legendText: 1,
      hideLegend: 2,
      labelPosition: 3,
      orientation: 4,
      id: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioButtonGroup",
      options,
      id: create_fragment134.name
    });
  }
  get selected() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legendText() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legendText(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLegend() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLegend(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelPosition() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelPosition(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioButtonGroup_default = RadioButtonGroup;

// node_modules/carbon-components-svelte/src/UnorderedList/UnorderedList.svelte
var file126 = "node_modules/carbon-components-svelte/src/UnorderedList/UnorderedList.svelte";
function create_fragment135(ctx) {
  let ul;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let ul_levels = [
    /*$$restProps*/
    ctx[2]
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {});
      var ul_nodes = children(ul);
      if (default_slot) default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--list--unordered", true);
      toggle_class(
        ul,
        "bx--list--nested",
        /*nested*/
        ctx[0]
      );
      toggle_class(
        ul,
        "bx--list--expressive",
        /*expressive*/
        ctx[1]
      );
      add_location(ul, file126, 10, 0, 318);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            ul,
            "click",
            /*click_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseover",
            /*mouseover_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ul,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & /*$$restProps*/
      4 && /*$$restProps*/
      ctx2[2]]));
      toggle_class(ul, "bx--list--unordered", true);
      toggle_class(
        ul,
        "bx--list--nested",
        /*nested*/
        ctx2[0]
      );
      toggle_class(
        ul,
        "bx--list--expressive",
        /*expressive*/
        ctx2[1]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment135.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance135($$self, $$props, $$invalidate) {
  const omit_props_names = ["nested", "expressive"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UnorderedList", slots, ["default"]);
  let { nested = false } = $$props;
  let { expressive = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("nested" in $$new_props) $$invalidate(0, nested = $$new_props.nested);
    if ("expressive" in $$new_props) $$invalidate(1, expressive = $$new_props.expressive);
    if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ nested, expressive });
  $$self.$inject_state = ($$new_props) => {
    if ("nested" in $$props) $$invalidate(0, nested = $$new_props.nested);
    if ("expressive" in $$props) $$invalidate(1, expressive = $$new_props.expressive);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    nested,
    expressive,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var UnorderedList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance135, create_fragment135, safe_not_equal, { nested: 0, expressive: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UnorderedList",
      options,
      id: create_fragment135.name
    });
  }
  get nested() {
    throw new Error("<UnorderedList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nested(value) {
    throw new Error("<UnorderedList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expressive() {
    throw new Error("<UnorderedList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expressive(value) {
    throw new Error("<UnorderedList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UnorderedList_default = UnorderedList;

// node_modules/carbon-components-svelte/src/RecursiveList/RecursiveListItem.svelte
var file127 = "node_modules/carbon-components-svelte/src/RecursiveList/RecursiveListItem.svelte";
function create_if_block_221(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*text*/
        ctx[0]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*text*/
        ctx[0]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text*/
      1) set_data_dev(
        t,
        /*text*/
        ctx2[0]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_221.name,
    type: "if",
    source: "(15:2) {#if text && !href}",
    ctx
  });
  return block;
}
function create_if_block_135(ctx) {
  let a;
  let t_value = (
    /*text*/
    (ctx[0] || /*href*/
    ctx[1]) + ""
  );
  let t;
  const block = {
    c: function create() {
      a = element("a");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true });
      var a_nodes = children(a);
      t = claim_text(a_nodes, t_value);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        a,
        "href",
        /*href*/
        ctx[1]
      );
      toggle_class(a, "bx--link", true);
      add_location(a, file127, 15, 12, 315);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text, href*/
      3 && t_value !== (t_value = /*text*/
      (ctx2[0] || /*href*/
      ctx2[1]) + "")) set_data_dev(t, t_value);
      if (dirty & /*href*/
      2) {
        attr_dev(
          a,
          "href",
          /*href*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_135.name,
    type: "if",
    source: "(16:2) {#if href}",
    ctx
  });
  return block;
}
function create_if_block82(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*html*/
        ctx[2],
        target,
        anchor
      );
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*html*/
      4) html_tag.p(
        /*html*/
        ctx2[2]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block82.name,
    type: "if",
    source: "(17:2) {#if !text && html}",
    ctx
  });
  return block;
}
function create_default_slot20(ctx) {
  let t0;
  let t1;
  let t2;
  let current;
  let if_block0 = (
    /*text*/
    ctx[0] && !/*href*/
    ctx[1] && create_if_block_221(ctx)
  );
  let if_block1 = (
    /*href*/
    ctx[1] && create_if_block_135(ctx)
  );
  let if_block2 = !/*text*/
  ctx[0] && /*html*/
  ctx[2] && create_if_block82(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      t2 = space();
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2) if_block2.l(nodes);
      t2 = claim_space(nodes);
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*text*/
        ctx2[0] && !/*href*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_221(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*href*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_135(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!/*text*/
      ctx2[0] && /*html*/
      ctx2[2]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block82(ctx2);
          if_block2.c();
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot20.name,
    type: "slot",
    source: "(14:0) <ListItem>",
    ctx
  });
  return block;
}
function create_fragment136(ctx) {
  let listitem;
  let current;
  listitem = new ListItem_default({
    props: {
      $$slots: { default: [create_default_slot20] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(listitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(listitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(listitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const listitem_changes = {};
      if (dirty & /*$$scope, html, text, href*/
      23) {
        listitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listitem.$set(listitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(listitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment136.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance136($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RecursiveListItem", slots, ["default"]);
  let { text: text2 = "" } = $$props;
  let { href = "" } = $$props;
  let { html = "" } = $$props;
  const writable_props = ["text", "href", "html"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<RecursiveListItem> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2) $$invalidate(0, text2 = $$props2.text);
    if ("href" in $$props2) $$invalidate(1, href = $$props2.href);
    if ("html" in $$props2) $$invalidate(2, html = $$props2.html);
    if ("$$scope" in $$props2) $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ text: text2, href, html, ListItem: ListItem_default });
  $$self.$inject_state = ($$props2) => {
    if ("text" in $$props2) $$invalidate(0, text2 = $$props2.text);
    if ("href" in $$props2) $$invalidate(1, href = $$props2.href);
    if ("html" in $$props2) $$invalidate(2, html = $$props2.html);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [text2, href, html, slots, $$scope];
}
var RecursiveListItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance136, create_fragment136, safe_not_equal, { text: 0, href: 1, html: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RecursiveListItem",
      options,
      id: create_fragment136.name
    });
  }
  get text() {
    throw new Error("<RecursiveListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<RecursiveListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<RecursiveListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<RecursiveListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get html() {
    throw new Error("<RecursiveListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set html(value) {
    throw new Error("<RecursiveListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RecursiveListItem_default = RecursiveListItem;

// node_modules/carbon-components-svelte/src/RecursiveList/RecursiveList.svelte
function get_each_context17(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_else_block27(ctx) {
  let recursivelistitem;
  let current;
  const recursivelistitem_spread_levels = [
    /*child*/
    ctx[3]
  ];
  let recursivelistitem_props = {};
  for (let i = 0; i < recursivelistitem_spread_levels.length; i += 1) {
    recursivelistitem_props = assign(recursivelistitem_props, recursivelistitem_spread_levels[i]);
  }
  recursivelistitem = new RecursiveListItem_default({
    props: recursivelistitem_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(recursivelistitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(recursivelistitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(recursivelistitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const recursivelistitem_changes = dirty & /*children*/
      1 ? get_spread_update(recursivelistitem_spread_levels, [get_spread_object(
        /*child*/
        ctx2[3]
      )]) : {};
      recursivelistitem.$set(recursivelistitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(recursivelistitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(recursivelistitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(recursivelistitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block27.name,
    type: "else",
    source: "(34:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block83(ctx) {
  let recursivelistitem;
  let current;
  const recursivelistitem_spread_levels = [
    /*child*/
    ctx[3]
  ];
  let recursivelistitem_props = {
    $$slots: { default: [create_default_slot_19] },
    $$scope: { ctx }
  };
  for (let i = 0; i < recursivelistitem_spread_levels.length; i += 1) {
    recursivelistitem_props = assign(recursivelistitem_props, recursivelistitem_spread_levels[i]);
  }
  recursivelistitem = new RecursiveListItem_default({
    props: recursivelistitem_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(recursivelistitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(recursivelistitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(recursivelistitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const recursivelistitem_changes = dirty & /*children*/
      1 ? get_spread_update(recursivelistitem_spread_levels, [get_spread_object(
        /*child*/
        ctx2[3]
      )]) : {};
      if (dirty & /*$$scope, children, type*/
      67) {
        recursivelistitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      recursivelistitem.$set(recursivelistitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(recursivelistitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(recursivelistitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(recursivelistitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block83.name,
    type: "if",
    source: "(30:4) {#if Array.isArray(child.children)}",
    ctx
  });
  return block;
}
function create_default_slot_19(ctx) {
  let recursivelist;
  let t;
  let current;
  const recursivelist_spread_levels = [
    /*child*/
    ctx[3],
    { type: (
      /*type*/
      ctx[1]
    ) },
    { nested: true }
  ];
  let recursivelist_props = {};
  for (let i = 0; i < recursivelist_spread_levels.length; i += 1) {
    recursivelist_props = assign(recursivelist_props, recursivelist_spread_levels[i]);
  }
  recursivelist = new RecursiveList({
    props: recursivelist_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(recursivelist.$$.fragment);
      t = space();
    },
    l: function claim(nodes) {
      claim_component(recursivelist.$$.fragment, nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(recursivelist, target, anchor);
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const recursivelist_changes = dirty & /*children, type*/
      3 ? get_spread_update(recursivelist_spread_levels, [
        dirty & /*children*/
        1 && get_spread_object(
          /*child*/
          ctx2[3]
        ),
        dirty & /*type*/
        2 && { type: (
          /*type*/
          ctx2[1]
        ) },
        recursivelist_spread_levels[2]
      ]) : {};
      recursivelist.$set(recursivelist_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(recursivelist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(recursivelist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(recursivelist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_19.name,
    type: "slot",
    source: "(31:6) <RecursiveListItem {...child}>",
    ctx
  });
  return block;
}
function create_each_block17(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block83, create_else_block27];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*children*/
    1) show_if = null;
    if (show_if == null) show_if = !!Array.isArray(
      /*child*/
      ctx2[3].children
    );
    if (show_if) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block17.name,
    type: "each",
    source: "(29:2) {#each children as child}",
    ctx
  });
  return block;
}
function create_default_slot21(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*children*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block17(get_each_context17(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children, type, Array*/
      3) {
        each_value = ensure_array_like_dev(
          /*children*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context17(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block17(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot21.name,
    type: "slot",
    source: `(24:0) <svelte:component   this=\\"{type === 'unordered' ? UnorderedList : OrderedList}\\"   native=\\"{type === 'ordered-native'}\\"   {...$$restProps} >`,
    ctx
  });
  return block;
}
function create_fragment137(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      native: (
        /*type*/
        ctx[1] === "ordered-native"
      )
    },
    /*$$restProps*/
    ctx[2]
  ];
  var switch_value = (
    /*type*/
    ctx[1] === "unordered" ? UnorderedList_default : OrderedList_default
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot21] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty & /*type, $$restProps*/
    6) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty & /*type*/
        2 && {
          native: (
            /*type*/
            ctx2[1] === "ordered-native"
          )
        },
        dirty & /*$$restProps*/
        4 && get_spread_object(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*type*/
      2 && switch_value !== (switch_value = /*type*/
      ctx2[1] === "unordered" ? UnorderedList_default : OrderedList_default)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*type, $$restProps*/
        6 ? get_spread_update(switch_instance_spread_levels, [
          dirty & /*type*/
          2 && {
            native: (
              /*type*/
              ctx2[1] === "ordered-native"
            )
          },
          dirty & /*$$restProps*/
          4 && get_spread_object(
            /*$$restProps*/
            ctx2[2]
          )
        ]) : {};
        if (dirty & /*$$scope, children, type*/
        67) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment137.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance137($$self, $$props, $$invalidate) {
  const omit_props_names = ["children", "type"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RecursiveList", slots, []);
  let { children: children2 = [] } = $$props;
  let { type = "unordered" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("children" in $$new_props) $$invalidate(0, children2 = $$new_props.children);
    if ("type" in $$new_props) $$invalidate(1, type = $$new_props.type);
  };
  $$self.$capture_state = () => ({
    children: children2,
    type,
    UnorderedList: UnorderedList_default,
    OrderedList: OrderedList_default,
    RecursiveListItem: RecursiveListItem_default
  });
  $$self.$inject_state = ($$new_props) => {
    if ("children" in $$props) $$invalidate(0, children2 = $$new_props.children);
    if ("type" in $$props) $$invalidate(1, type = $$new_props.type);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [children2, type, $$restProps];
}
var RecursiveList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance137, create_fragment137, safe_not_equal, { children: 0, type: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RecursiveList",
      options,
      id: create_fragment137.name
    });
  }
  get children() {
    throw new Error("<RecursiveList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<RecursiveList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<RecursiveList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<RecursiveList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RecursiveList_default = RecursiveList;

// node_modules/carbon-components-svelte/src/Select/SelectSkeleton.svelte
var file128 = "node_modules/carbon-components-svelte/src/Select/SelectSkeleton.svelte";
function create_if_block84(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file128, 16, 4, 352);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block84.name,
    type: "if",
    source: "(16:2) {#if !hideLabel}",
    ctx
  });
  return block;
}
function create_fragment138(ctx) {
  let div2;
  let t;
  let div1;
  let div0;
  let mounted;
  let dispose;
  let if_block = !/*hideLabel*/
  ctx[0] && create_if_block84(ctx);
  let div2_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data_2 = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      if (if_block) if_block.c();
      t = space();
      div1 = element("div");
      div0 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      if (if_block) if_block.l(div2_nodes);
      t = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--select-input", true);
      add_location(div0, file128, 19, 4, 493);
      toggle_class(div1, "bx--select", true);
      toggle_class(div1, "bx--skeleton", true);
      add_location(div1, file128, 18, 2, 429);
      set_attributes(div2, div_data_2);
      toggle_class(div2, "bx--form-item", true);
      add_location(div2, file128, 7, 0, 214);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      if (if_block) if_block.m(div2, null);
      append_hydration_dev(div2, t);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if (!mounted) {
        dispose = [
          listen_dev(
            div2,
            "click",
            /*click_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseover",
            /*mouseover_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!/*hideLabel*/
      ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block84(ctx2);
          if_block.c();
          if_block.m(div2, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(div2, "bx--form-item", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment138.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance138($$self, $$props, $$invalidate) {
  const omit_props_names = ["hideLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectSkeleton", slots, []);
  let { hideLabel = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("hideLabel" in $$new_props) $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  $$self.$capture_state = () => ({ hideLabel });
  $$self.$inject_state = ($$new_props) => {
    if ("hideLabel" in $$props) $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    hideLabel,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var SelectSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance138, create_fragment138, safe_not_equal, { hideLabel: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectSkeleton",
      options,
      id: create_fragment138.name
    });
  }
  get hideLabel() {
    throw new Error("<SelectSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<SelectSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectSkeleton_default = SelectSkeleton;

// node_modules/carbon-components-svelte/src/Select/SelectItemGroup.svelte
var file129 = "node_modules/carbon-components-svelte/src/Select/SelectItemGroup.svelte";
function create_fragment139(ctx) {
  let optgroup;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let optgroup_levels = [
    { label: (
      /*label*/
      ctx[1]
    ) },
    { disabled: (
      /*disabled*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[2]
  ];
  let optgroup_data = {};
  for (let i = 0; i < optgroup_levels.length; i += 1) {
    optgroup_data = assign(optgroup_data, optgroup_levels[i]);
  }
  const block = {
    c: function create() {
      optgroup = element("optgroup");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      optgroup = claim_element(nodes, "OPTGROUP", { label: true });
      var optgroup_nodes = children(optgroup);
      if (default_slot) default_slot.l(optgroup_nodes);
      optgroup_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(optgroup, optgroup_data);
      toggle_class(optgroup, "bx--select-optgroup", true);
      add_location(optgroup, file129, 8, 0, 206);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, optgroup, anchor);
      if (default_slot) {
        default_slot.m(optgroup, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(optgroup, optgroup_data = get_spread_update(optgroup_levels, [
        (!current || dirty & /*label*/
        2) && { label: (
          /*label*/
          ctx2[1]
        ) },
        (!current || dirty & /*disabled*/
        1) && { disabled: (
          /*disabled*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      toggle_class(optgroup, "bx--select-optgroup", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(optgroup);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment139.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance139($$self, $$props, $$invalidate) {
  const omit_props_names = ["disabled", "label"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectItemGroup", slots, ["default"]);
  let { disabled = false } = $$props;
  let { label = "Provide label" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("disabled" in $$new_props) $$invalidate(0, disabled = $$new_props.disabled);
    if ("label" in $$new_props) $$invalidate(1, label = $$new_props.label);
    if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ disabled, label });
  $$self.$inject_state = ($$new_props) => {
    if ("disabled" in $$props) $$invalidate(0, disabled = $$new_props.disabled);
    if ("label" in $$props) $$invalidate(1, label = $$new_props.label);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [disabled, label, $$restProps, $$scope, slots];
}
var SelectItemGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance139, create_fragment139, safe_not_equal, { disabled: 0, label: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectItemGroup",
      options,
      id: create_fragment139.name
    });
  }
  get disabled() {
    throw new Error("<SelectItemGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<SelectItemGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<SelectItemGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<SelectItemGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectItemGroup_default = SelectItemGroup;

// node_modules/carbon-components-svelte/src/SkeletonPlaceholder/SkeletonPlaceholder.svelte
var file130 = "node_modules/carbon-components-svelte/src/SkeletonPlaceholder/SkeletonPlaceholder.svelte";
function create_fragment140(ctx) {
  let div;
  let mounted;
  let dispose;
  let div_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--skeleton__placeholder", true);
      add_location(div, file130, 2, 0, 116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[1],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
      toggle_class(div, "bx--skeleton__placeholder", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment140.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance140($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SkeletonPlaceholder", slots, []);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var SkeletonPlaceholder = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance140, create_fragment140, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SkeletonPlaceholder",
      options,
      id: create_fragment140.name
    });
  }
};
var SkeletonPlaceholder_default = SkeletonPlaceholder;

// node_modules/carbon-components-svelte/src/Slider/Slider.svelte
var file131 = "node_modules/carbon-components-svelte/src/Slider/Slider.svelte";
var get_labelText_slot_changes10 = (dirty) => ({});
var get_labelText_slot_context10 = (ctx) => ({});
function fallback_block28(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[16]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[16]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelText*/
      65536) set_data_dev(
        t,
        /*labelText*/
        ctx2[16]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block28.name,
    type: "fallback",
    source: "(162:27)        ",
    ctx
  });
  return block;
}
function create_fragment141(ctx) {
  let div5;
  let label;
  let t0;
  let div4;
  let span0;
  let t1_value = (
    /*minLabel*/
    (ctx[5] || /*min*/
    ctx[4]) + ""
  );
  let t1;
  let t2;
  let div3;
  let div0;
  let style_left = `${/*left*/
  ctx[21]}%`;
  let t3;
  let div1;
  let t4;
  let div2;
  let style_transform = `translate(0, -50%) scaleX(${/*left*/
  ctx[21] / 100})`;
  let t5;
  let span1;
  let t6_value = (
    /*maxLabel*/
    (ctx[3] || /*max*/
    ctx[2]) + ""
  );
  let t6;
  let t7;
  let input;
  let input_type_value;
  let input_id_value;
  let input_aria_labelledby_value;
  let input_aria_label_value;
  let input_data_invalid_value;
  let input_aria_invalid_value;
  let current;
  let mounted;
  let dispose;
  const labelText_slot_template = (
    /*#slots*/
    ctx[32].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    get_labelText_slot_context10
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block28(ctx);
  let div5_levels = [
    /*$$restProps*/
    ctx[27]
  ];
  let div_data_5 = {};
  for (let i = 0; i < div5_levels.length; i += 1) {
    div_data_5 = assign(div_data_5, div5_levels[i]);
  }
  const block = {
    c: function create() {
      div5 = element("div");
      label = element("label");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      t0 = space();
      div4 = element("div");
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      div3 = element("div");
      div0 = element("div");
      t3 = space();
      div1 = element("div");
      t4 = space();
      div2 = element("div");
      t5 = space();
      span1 = element("span");
      t6 = text(t6_value);
      t7 = space();
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      div5 = claim_element(nodes, "DIV", {});
      var div5_nodes = children(div5);
      label = claim_element(div5_nodes, "LABEL", { for: true, id: true });
      var label_nodes = children(label);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(label_nodes);
      label_nodes.forEach(detach_dev);
      t0 = claim_space(div5_nodes);
      div4 = claim_element(div5_nodes, "DIV", {});
      var div4_nodes = children(div4);
      span0 = claim_element(div4_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      t1 = claim_text(span0_nodes, t1_value);
      span0_nodes.forEach(detach_dev);
      t2 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { role: true, tabindex: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", {
        role: true,
        tabindex: true,
        "aria-valuemax": true,
        "aria-valuemin": true,
        "aria-valuenow": true,
        "aria-labelledby": true,
        id: true
      });
      children(div0).forEach(detach_dev);
      t3 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", {});
      children(div1).forEach(detach_dev);
      t4 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", {});
      children(div2).forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      t5 = claim_space(div4_nodes);
      span1 = claim_element(div4_nodes, "SPAN", {});
      var span1_nodes = children(span1);
      t6 = claim_text(span1_nodes, t6_value);
      span1_nodes.forEach(detach_dev);
      t7 = claim_space(div4_nodes);
      input = claim_element(div4_nodes, "INPUT", {
        type: true,
        id: true,
        name: true,
        "aria-labelledby": true,
        "aria-label": true,
        min: true,
        max: true,
        step: true,
        "data-invalid": true,
        "aria-invalid": true
      });
      div4_nodes.forEach(detach_dev);
      div5_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[14]
      );
      attr_dev(
        label,
        "id",
        /*labelId*/
        ctx[22]
      );
      toggle_class(label, "bx--label", true);
      toggle_class(
        label,
        "bx--label--disabled",
        /*disabled*/
        ctx[10]
      );
      toggle_class(
        label,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[17]
      );
      add_location(label, file131, 154, 2, 3276);
      toggle_class(span0, "bx--slider__range-label", true);
      add_location(span0, file131, 166, 4, 3590);
      attr_dev(div0, "role", "slider");
      attr_dev(div0, "tabindex", "0");
      attr_dev(
        div0,
        "aria-valuemax",
        /*max*/
        ctx[2]
      );
      attr_dev(
        div0,
        "aria-valuemin",
        /*min*/
        ctx[4]
      );
      attr_dev(
        div0,
        "aria-valuenow",
        /*value*/
        ctx[0]
      );
      attr_dev(
        div0,
        "aria-labelledby",
        /*labelId*/
        ctx[22]
      );
      attr_dev(
        div0,
        "id",
        /*id*/
        ctx[14]
      );
      toggle_class(div0, "bx--slider__thumb", true);
      set_style(div0, "left", style_left);
      add_location(div0, file131, 190, 6, 4314);
      toggle_class(div1, "bx--slider__track", true);
      add_location(div1, file131, 201, 6, 4598);
      toggle_class(div2, "bx--slider__filled-track", true);
      set_style(div2, "transform", style_transform);
      add_location(div2, file131, 202, 6, 4672);
      attr_dev(div3, "role", "presentation");
      attr_dev(div3, "tabindex", "-1");
      toggle_class(div3, "bx--slider", true);
      toggle_class(
        div3,
        "bx--slider--disabled",
        /*disabled*/
        ctx[10]
      );
      set_style(
        div3,
        "max-width",
        /*fullWidth*/
        ctx[13] ? "none" : void 0
      );
      add_location(div3, file131, 167, 4, 3664);
      toggle_class(span1, "bx--slider__range-label", true);
      add_location(span1, file131, 207, 4, 4820);
      attr_dev(input, "type", input_type_value = /*hideTextInput*/
      ctx[12] ? "hidden" : (
        /*inputType*/
        ctx[9]
      ));
      attr_dev(input, "id", input_id_value = "input-" + /*id*/
      ctx[14]);
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[18]
      );
      input.value = /*value*/
      ctx[0];
      attr_dev(input, "aria-labelledby", input_aria_labelledby_value = /*$$props*/
      ctx[28]["aria-label"] ? void 0 : (
        /*labelId*/
        ctx[22]
      ));
      attr_dev(input, "aria-label", input_aria_label_value = /*$$props*/
      ctx[28]["aria-label"] || "Slider number input");
      input.disabled = /*disabled*/
      ctx[10];
      input.required = /*required*/
      ctx[8];
      attr_dev(
        input,
        "min",
        /*min*/
        ctx[4]
      );
      attr_dev(
        input,
        "max",
        /*max*/
        ctx[2]
      );
      attr_dev(
        input,
        "step",
        /*step*/
        ctx[6]
      );
      attr_dev(input, "data-invalid", input_data_invalid_value = /*invalid*/
      ctx[15] || null);
      attr_dev(input, "aria-invalid", input_aria_invalid_value = /*invalid*/
      ctx[15] || null);
      toggle_class(input, "bx--text-input", true);
      toggle_class(input, "bx--slider-text-input", true);
      toggle_class(
        input,
        "bx--text-input--light",
        /*light*/
        ctx[11]
      );
      toggle_class(
        input,
        "bx--text-input--invalid",
        /*invalid*/
        ctx[15]
      );
      add_location(input, file131, 208, 4, 4894);
      toggle_class(div4, "bx--slider-container", true);
      set_style(
        div4,
        "width",
        /*fullWidth*/
        ctx[13] && "100%"
      );
      add_location(div4, file131, 165, 2, 3508);
      set_attributes(div5, div_data_5);
      toggle_class(div5, "bx--form-item", true);
      add_location(div5, file131, 146, 0, 3159);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div5, anchor);
      append_hydration_dev(div5, label);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      append_hydration_dev(div5, t0);
      append_hydration_dev(div5, div4);
      append_hydration_dev(div4, span0);
      append_hydration_dev(span0, t1);
      append_hydration_dev(div4, t2);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div3, t3);
      append_hydration_dev(div3, div1);
      ctx[37](div1);
      append_hydration_dev(div3, t4);
      append_hydration_dev(div3, div2);
      ctx[38](div3);
      append_hydration_dev(div4, t5);
      append_hydration_dev(div4, span1);
      append_hydration_dev(span1, t6);
      append_hydration_dev(div4, t7);
      append_hydration_dev(div4, input);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "mousemove",
            /*move*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "touchmove",
            /*move*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "mouseup",
            /*stopHolding*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "touchend",
            /*stopHolding*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "touchcancel",
            /*stopHolding*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "mousedown",
            /*startDragging*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "mousedown",
            /*startHolding*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "touchstart",
            /*startHolding*/
            ctx[24],
            { passive: true },
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keydown",
            /*keydown_handler*/
            ctx[39],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[40],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div5,
            "click",
            /*click_handler*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div5,
            "mouseover",
            /*mouseover_handler*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div5,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[35],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div5,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[36],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              get_labelText_slot_changes10
            ),
            get_labelText_slot_context10
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & /*labelText*/
        65536)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      16384) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*labelId*/
      4194304) {
        attr_dev(
          label,
          "id",
          /*labelId*/
          ctx2[22]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      1024) {
        toggle_class(
          label,
          "bx--label--disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*hideLabel*/
      131072) {
        toggle_class(
          label,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[17]
        );
      }
      if ((!current || dirty[0] & /*minLabel, min*/
      48) && t1_value !== (t1_value = /*minLabel*/
      (ctx2[5] || /*min*/
      ctx2[4]) + "")) set_data_dev(t1, t1_value);
      if (!current || dirty[0] & /*max*/
      4) {
        attr_dev(
          div0,
          "aria-valuemax",
          /*max*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*min*/
      16) {
        attr_dev(
          div0,
          "aria-valuemin",
          /*min*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*value*/
      1) {
        attr_dev(
          div0,
          "aria-valuenow",
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*labelId*/
      4194304) {
        attr_dev(
          div0,
          "aria-labelledby",
          /*labelId*/
          ctx2[22]
        );
      }
      if (!current || dirty[0] & /*id*/
      16384) {
        attr_dev(
          div0,
          "id",
          /*id*/
          ctx2[14]
        );
      }
      if (dirty[0] & /*left*/
      2097152 && style_left !== (style_left = `${/*left*/
      ctx2[21]}%`)) {
        set_style(div0, "left", style_left);
      }
      if (dirty[0] & /*left*/
      2097152 && style_transform !== (style_transform = `translate(0, -50%) scaleX(${/*left*/
      ctx2[21] / 100})`)) {
        set_style(div2, "transform", style_transform);
      }
      if (!current || dirty[0] & /*disabled*/
      1024) {
        toggle_class(
          div3,
          "bx--slider--disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*fullWidth*/
      8192) {
        set_style(
          div3,
          "max-width",
          /*fullWidth*/
          ctx2[13] ? "none" : void 0
        );
      }
      if ((!current || dirty[0] & /*maxLabel, max*/
      12) && t6_value !== (t6_value = /*maxLabel*/
      (ctx2[3] || /*max*/
      ctx2[2]) + "")) set_data_dev(t6, t6_value);
      if (!current || dirty[0] & /*hideTextInput, inputType*/
      4608 && input_type_value !== (input_type_value = /*hideTextInput*/
      ctx2[12] ? "hidden" : (
        /*inputType*/
        ctx2[9]
      ))) {
        attr_dev(input, "type", input_type_value);
      }
      if (!current || dirty[0] & /*id*/
      16384 && input_id_value !== (input_id_value = "input-" + /*id*/
      ctx2[14])) {
        attr_dev(input, "id", input_id_value);
      }
      if (!current || dirty[0] & /*name*/
      262144) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[18]
        );
      }
      if (!current || dirty[0] & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*$$props, labelId*/
      272629760 && input_aria_labelledby_value !== (input_aria_labelledby_value = /*$$props*/
      ctx2[28]["aria-label"] ? void 0 : (
        /*labelId*/
        ctx2[22]
      ))) {
        attr_dev(input, "aria-labelledby", input_aria_labelledby_value);
      }
      if (!current || dirty[0] & /*$$props*/
      268435456 && input_aria_label_value !== (input_aria_label_value = /*$$props*/
      ctx2[28]["aria-label"] || "Slider number input")) {
        attr_dev(input, "aria-label", input_aria_label_value);
      }
      if (!current || dirty[0] & /*disabled*/
      1024) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*required*/
      256) {
        prop_dev(
          input,
          "required",
          /*required*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*min*/
      16) {
        attr_dev(
          input,
          "min",
          /*min*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*max*/
      4) {
        attr_dev(
          input,
          "max",
          /*max*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*step*/
      64) {
        attr_dev(
          input,
          "step",
          /*step*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*invalid*/
      32768 && input_data_invalid_value !== (input_data_invalid_value = /*invalid*/
      ctx2[15] || null)) {
        attr_dev(input, "data-invalid", input_data_invalid_value);
      }
      if (!current || dirty[0] & /*invalid*/
      32768 && input_aria_invalid_value !== (input_aria_invalid_value = /*invalid*/
      ctx2[15] || null)) {
        attr_dev(input, "aria-invalid", input_aria_invalid_value);
      }
      if (!current || dirty[0] & /*light*/
      2048) {
        toggle_class(
          input,
          "bx--text-input--light",
          /*light*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*invalid*/
      32768) {
        toggle_class(
          input,
          "bx--text-input--invalid",
          /*invalid*/
          ctx2[15]
        );
      }
      if (dirty[0] & /*fullWidth*/
      8192) {
        set_style(
          div4,
          "width",
          /*fullWidth*/
          ctx2[13] && "100%"
        );
      }
      set_attributes(div5, div_data_5 = get_spread_update(div5_levels, [dirty[0] & /*$$restProps*/
      134217728 && /*$$restProps*/
      ctx2[27]]));
      toggle_class(div5, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div5);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
      ctx[37](null);
      ctx[38](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment141.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance141($$self, $$props, $$invalidate) {
  let labelId;
  let range;
  let left;
  const omit_props_names = [
    "value",
    "max",
    "maxLabel",
    "min",
    "minLabel",
    "step",
    "stepMultiplier",
    "required",
    "inputType",
    "disabled",
    "light",
    "hideTextInput",
    "fullWidth",
    "id",
    "invalid",
    "labelText",
    "hideLabel",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Slider", slots, ["labelText"]);
  let { value = 0 } = $$props;
  let { max = 100 } = $$props;
  let { maxLabel = "" } = $$props;
  let { min = 0 } = $$props;
  let { minLabel = "" } = $$props;
  let { step = 1 } = $$props;
  let { stepMultiplier = 4 } = $$props;
  let { required = false } = $$props;
  let { inputType = "number" } = $$props;
  let { disabled = false } = $$props;
  let { light = false } = $$props;
  let { hideTextInput = false } = $$props;
  let { fullWidth = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { invalid = false } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { name = "" } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let trackRef = null;
  let dragging = false;
  let holding = false;
  function startDragging() {
    $$invalidate(29, dragging = true);
  }
  function startHolding() {
    $$invalidate(30, holding = true);
  }
  function stopHolding() {
    $$invalidate(30, holding = false);
    $$invalidate(29, dragging = false);
  }
  function move() {
    if (holding) {
      startDragging();
    }
  }
  function calcValue(e) {
    if (disabled) return;
    const offsetX = e.touches ? e.touches[0].clientX : e.clientX;
    const { left: left2, width } = trackRef.getBoundingClientRect();
    let nextValue = min + Math.round((max - min) * ((offsetX - left2) / width) / step) * step;
    if (nextValue <= min) {
      nextValue = min;
    } else if (nextValue >= max) {
      nextValue = max;
    }
    $$invalidate(0, value = nextValue);
    dispatch("input", value);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      trackRef = $$value;
      $$invalidate(20, trackRef);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const keydown_handler = ({ shiftKey, key }) => {
    const keys = {
      ArrowDown: -1,
      ArrowLeft: -1,
      ArrowRight: 1,
      ArrowUp: 1
    };
    if (keys[key]) {
      $$invalidate(0, value += step * (shiftKey ? range / step / stepMultiplier : 1) * keys[key]);
    }
  };
  const change_handler = ({ target }) => {
    $$invalidate(0, value = Number(target.value));
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(28, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(27, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    if ("max" in $$new_props) $$invalidate(2, max = $$new_props.max);
    if ("maxLabel" in $$new_props) $$invalidate(3, maxLabel = $$new_props.maxLabel);
    if ("min" in $$new_props) $$invalidate(4, min = $$new_props.min);
    if ("minLabel" in $$new_props) $$invalidate(5, minLabel = $$new_props.minLabel);
    if ("step" in $$new_props) $$invalidate(6, step = $$new_props.step);
    if ("stepMultiplier" in $$new_props) $$invalidate(7, stepMultiplier = $$new_props.stepMultiplier);
    if ("required" in $$new_props) $$invalidate(8, required = $$new_props.required);
    if ("inputType" in $$new_props) $$invalidate(9, inputType = $$new_props.inputType);
    if ("disabled" in $$new_props) $$invalidate(10, disabled = $$new_props.disabled);
    if ("light" in $$new_props) $$invalidate(11, light = $$new_props.light);
    if ("hideTextInput" in $$new_props) $$invalidate(12, hideTextInput = $$new_props.hideTextInput);
    if ("fullWidth" in $$new_props) $$invalidate(13, fullWidth = $$new_props.fullWidth);
    if ("id" in $$new_props) $$invalidate(14, id = $$new_props.id);
    if ("invalid" in $$new_props) $$invalidate(15, invalid = $$new_props.invalid);
    if ("labelText" in $$new_props) $$invalidate(16, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props) $$invalidate(17, hideLabel = $$new_props.hideLabel);
    if ("name" in $$new_props) $$invalidate(18, name = $$new_props.name);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(31, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    max,
    maxLabel,
    min,
    minLabel,
    step,
    stepMultiplier,
    required,
    inputType,
    disabled,
    light,
    hideTextInput,
    fullWidth,
    id,
    invalid,
    labelText,
    hideLabel,
    name,
    ref,
    createEventDispatcher,
    dispatch,
    trackRef,
    dragging,
    holding,
    startDragging,
    startHolding,
    stopHolding,
    move,
    calcValue,
    range,
    left,
    labelId
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(28, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    if ("max" in $$props) $$invalidate(2, max = $$new_props.max);
    if ("maxLabel" in $$props) $$invalidate(3, maxLabel = $$new_props.maxLabel);
    if ("min" in $$props) $$invalidate(4, min = $$new_props.min);
    if ("minLabel" in $$props) $$invalidate(5, minLabel = $$new_props.minLabel);
    if ("step" in $$props) $$invalidate(6, step = $$new_props.step);
    if ("stepMultiplier" in $$props) $$invalidate(7, stepMultiplier = $$new_props.stepMultiplier);
    if ("required" in $$props) $$invalidate(8, required = $$new_props.required);
    if ("inputType" in $$props) $$invalidate(9, inputType = $$new_props.inputType);
    if ("disabled" in $$props) $$invalidate(10, disabled = $$new_props.disabled);
    if ("light" in $$props) $$invalidate(11, light = $$new_props.light);
    if ("hideTextInput" in $$props) $$invalidate(12, hideTextInput = $$new_props.hideTextInput);
    if ("fullWidth" in $$props) $$invalidate(13, fullWidth = $$new_props.fullWidth);
    if ("id" in $$props) $$invalidate(14, id = $$new_props.id);
    if ("invalid" in $$props) $$invalidate(15, invalid = $$new_props.invalid);
    if ("labelText" in $$props) $$invalidate(16, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props) $$invalidate(17, hideLabel = $$new_props.hideLabel);
    if ("name" in $$props) $$invalidate(18, name = $$new_props.name);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("trackRef" in $$props) $$invalidate(20, trackRef = $$new_props.trackRef);
    if ("dragging" in $$props) $$invalidate(29, dragging = $$new_props.dragging);
    if ("holding" in $$props) $$invalidate(30, holding = $$new_props.holding);
    if ("range" in $$props) $$invalidate(19, range = $$new_props.range);
    if ("left" in $$props) $$invalidate(21, left = $$new_props.left);
    if ("labelId" in $$props) $$invalidate(22, labelId = $$new_props.labelId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*id*/
    16384) {
      $: $$invalidate(22, labelId = `label-${id}`);
    }
    if ($$self.$$.dirty[0] & /*max, min*/
    20) {
      $: $$invalidate(19, range = max - min);
    }
    if ($$self.$$.dirty[0] & /*value, min, max, dragging, holding, disabled*/
    1610613781) {
      $: {
        if (value <= min) {
          $$invalidate(0, value = min);
        } else if (value >= max) {
          $$invalidate(0, value = max);
        }
        if (dragging) {
          calcValue(event);
          $$invalidate(29, dragging = false);
        }
        if (!holding && !disabled) {
          dispatch("change", value);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*value, min, range*/
    524305) {
      $: $$invalidate(21, left = (value - min) / range * 100);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    ref,
    max,
    maxLabel,
    min,
    minLabel,
    step,
    stepMultiplier,
    required,
    inputType,
    disabled,
    light,
    hideTextInput,
    fullWidth,
    id,
    invalid,
    labelText,
    hideLabel,
    name,
    range,
    trackRef,
    left,
    labelId,
    startDragging,
    startHolding,
    stopHolding,
    move,
    $$restProps,
    $$props,
    dragging,
    holding,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    div1_binding,
    div3_binding,
    keydown_handler,
    change_handler
  ];
}
var Slider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance141,
      create_fragment141,
      safe_not_equal,
      {
        value: 0,
        max: 2,
        maxLabel: 3,
        min: 4,
        minLabel: 5,
        step: 6,
        stepMultiplier: 7,
        required: 8,
        inputType: 9,
        disabled: 10,
        light: 11,
        hideTextInput: 12,
        fullWidth: 13,
        id: 14,
        invalid: 15,
        labelText: 16,
        hideLabel: 17,
        name: 18,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Slider",
      options,
      id: create_fragment141.name
    });
  }
  get value() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxLabel() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxLabel(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minLabel() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minLabel(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepMultiplier() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stepMultiplier(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputType() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputType(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideTextInput() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideTextInput(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullWidth() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullWidth(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Slider_default = Slider;

// node_modules/carbon-components-svelte/src/Slider/SliderSkeleton.svelte
var file132 = "node_modules/carbon-components-svelte/src/Slider/SliderSkeleton.svelte";
function create_if_block85(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file132, 16, 4, 352);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block85.name,
    type: "if",
    source: "(16:2) {#if !hideLabel}",
    ctx
  });
  return block;
}
function create_fragment142(ctx) {
  let div5;
  let t0;
  let div4;
  let span0;
  let t1;
  let div3;
  let div0;
  let t2;
  let div1;
  let t3;
  let div2;
  let t4;
  let span1;
  let mounted;
  let dispose;
  let if_block = !/*hideLabel*/
  ctx[0] && create_if_block85(ctx);
  let div5_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data_5 = {};
  for (let i = 0; i < div5_levels.length; i += 1) {
    div_data_5 = assign(div_data_5, div5_levels[i]);
  }
  const block = {
    c: function create() {
      div5 = element("div");
      if (if_block) if_block.c();
      t0 = space();
      div4 = element("div");
      span0 = element("span");
      t1 = space();
      div3 = element("div");
      div0 = element("div");
      t2 = space();
      div1 = element("div");
      t3 = space();
      div2 = element("div");
      t4 = space();
      span1 = element("span");
      this.h();
    },
    l: function claim(nodes) {
      div5 = claim_element(nodes, "DIV", {});
      var div5_nodes = children(div5);
      if (if_block) if_block.l(div5_nodes);
      t0 = claim_space(div5_nodes);
      div4 = claim_element(div5_nodes, "DIV", {});
      var div4_nodes = children(div4);
      span0 = claim_element(div4_nodes, "SPAN", {});
      children(span0).forEach(detach_dev);
      t1 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", {});
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", {});
      children(div0).forEach(detach_dev);
      t2 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", {});
      children(div1).forEach(detach_dev);
      t3 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", {});
      children(div2).forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      t4 = claim_space(div4_nodes);
      span1 = claim_element(div4_nodes, "SPAN", {});
      children(span1).forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      div5_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span0, "bx--slider__range-label", true);
      add_location(span0, file132, 19, 4, 503);
      toggle_class(div0, "bx--slider__track", true);
      add_location(div0, file132, 21, 6, 598);
      toggle_class(div1, "bx--slider__filled-track", true);
      add_location(div1, file132, 22, 6, 649);
      toggle_class(div2, "bx--slider__thumb", true);
      add_location(div2, file132, 23, 6, 707);
      toggle_class(div3, "bx--slider", true);
      add_location(div3, file132, 20, 4, 560);
      toggle_class(span1, "bx--slider__range-label", true);
      add_location(span1, file132, 25, 4, 767);
      toggle_class(div4, "bx--slider-container", true);
      toggle_class(div4, "bx--skeleton", true);
      add_location(div4, file132, 18, 2, 429);
      set_attributes(div5, div_data_5);
      toggle_class(div5, "bx--form-item", true);
      add_location(div5, file132, 7, 0, 214);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div5, anchor);
      if (if_block) if_block.m(div5, null);
      append_hydration_dev(div5, t0);
      append_hydration_dev(div5, div4);
      append_hydration_dev(div4, span0);
      append_hydration_dev(div4, t1);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div3, t2);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div3, t3);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div4, t4);
      append_hydration_dev(div4, span1);
      if (!mounted) {
        dispose = [
          listen_dev(
            div5,
            "click",
            /*click_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div5,
            "mouseover",
            /*mouseover_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div5,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div5,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!/*hideLabel*/
      ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block85(ctx2);
          if_block.c();
          if_block.m(div5, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div5, div_data_5 = get_spread_update(div5_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(div5, "bx--form-item", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div5);
      }
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment142.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance142($$self, $$props, $$invalidate) {
  const omit_props_names = ["hideLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SliderSkeleton", slots, []);
  let { hideLabel = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("hideLabel" in $$new_props) $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  $$self.$capture_state = () => ({ hideLabel });
  $$self.$inject_state = ($$new_props) => {
    if ("hideLabel" in $$props) $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    hideLabel,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var SliderSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance142, create_fragment142, safe_not_equal, { hideLabel: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SliderSkeleton",
      options,
      id: create_fragment142.name
    });
  }
  get hideLabel() {
    throw new Error("<SliderSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<SliderSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SliderSkeleton_default = SliderSkeleton;

// node_modules/carbon-components-svelte/src/StructuredList/StructuredList.svelte
var file133 = "node_modules/carbon-components-svelte/src/StructuredList/StructuredList.svelte";
function create_fragment143(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    { role: "table" },
    /*$$restProps*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { role: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--structured-list", true);
      toggle_class(
        div,
        "bx--structured-list--selection",
        /*selection*/
        ctx[2]
      );
      toggle_class(
        div,
        "bx--structured-list--condensed",
        /*condensed*/
        ctx[0]
      );
      toggle_class(
        div,
        "bx--structured-list--flush",
        /*flush*/
        ctx[1]
      );
      add_location(div, file133, 39, 0, 943);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [{ role: "table" }, dirty & /*$$restProps*/
      16 && /*$$restProps*/
      ctx2[4]]));
      toggle_class(div, "bx--structured-list", true);
      toggle_class(
        div,
        "bx--structured-list--selection",
        /*selection*/
        ctx2[2]
      );
      toggle_class(
        div,
        "bx--structured-list--condensed",
        /*condensed*/
        ctx2[0]
      );
      toggle_class(
        div,
        "bx--structured-list--flush",
        /*flush*/
        ctx2[1]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment143.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance143($$self, $$props, $$invalidate) {
  const omit_props_names = ["selected", "condensed", "flush", "selection"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StructuredList", slots, ["default"]);
  let { selected = void 0 } = $$props;
  let { condensed = false } = $$props;
  let { flush = false } = $$props;
  let { selection = false } = $$props;
  const dispatch = createEventDispatcher();
  const selectedValue = writable(selected);
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value) => $$invalidate(6, $selectedValue = value));
  setContext("StructuredListWrapper", {
    selectedValue,
    update: (value) => {
      selectedValue.set(value);
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props) $$invalidate(5, selected = $$new_props.selected);
    if ("condensed" in $$new_props) $$invalidate(0, condensed = $$new_props.condensed);
    if ("flush" in $$new_props) $$invalidate(1, flush = $$new_props.flush);
    if ("selection" in $$new_props) $$invalidate(2, selection = $$new_props.selection);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    condensed,
    flush,
    selection,
    createEventDispatcher,
    setContext,
    writable,
    dispatch,
    selectedValue,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props) $$invalidate(5, selected = $$new_props.selected);
    if ("condensed" in $$props) $$invalidate(0, condensed = $$new_props.condensed);
    if ("flush" in $$props) $$invalidate(1, flush = $$new_props.flush);
    if ("selection" in $$props) $$invalidate(2, selection = $$new_props.selection);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selectedValue*/
    64) {
      $: $$invalidate(5, selected = $selectedValue);
    }
    if ($$self.$$.dirty & /*$selectedValue*/
    64) {
      $: dispatch("change", $selectedValue);
    }
  };
  return [
    condensed,
    flush,
    selection,
    selectedValue,
    $$restProps,
    selected,
    $selectedValue,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var StructuredList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance143, create_fragment143, safe_not_equal, {
      selected: 5,
      condensed: 0,
      flush: 1,
      selection: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StructuredList",
      options,
      id: create_fragment143.name
    });
  }
  get selected() {
    throw new Error("<StructuredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<StructuredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get condensed() {
    throw new Error("<StructuredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set condensed(value) {
    throw new Error("<StructuredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flush() {
    throw new Error("<StructuredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flush(value) {
    throw new Error("<StructuredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selection() {
    throw new Error("<StructuredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selection(value) {
    throw new Error("<StructuredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StructuredList_default = StructuredList;

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListSkeleton.svelte
var file134 = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListSkeleton.svelte";
function get_each_context18(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function create_each_block18(key_1, ctx) {
  let div3;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let t2;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", {});
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", {});
      children(div0).forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", {});
      children(div1).forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", {});
      children(div2).forEach(detach_dev);
      t2 = claim_space(div3_nodes);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--structured-list-td", true);
      add_location(div0, file134, 29, 8, 917);
      toggle_class(div1, "bx--structured-list-td", true);
      add_location(div1, file134, 30, 8, 975);
      toggle_class(div2, "bx--structured-list-td", true);
      add_location(div2, file134, 31, 8, 1033);
      toggle_class(div3, "bx--structured-list-row", true);
      add_location(div3, file134, 28, 6, 864);
      this.first = div3;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div3, t2);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block18.name,
    type: "each",
    source: "(28:4) {#each Array.from({ length: rows }, (_, i) => i) as row, i (row)}",
    ctx
  });
  return block;
}
function create_fragment144(ctx) {
  let div6;
  let div4;
  let div3;
  let div0;
  let span0;
  let t0;
  let div1;
  let span1;
  let t1;
  let div2;
  let span2;
  let t2;
  let div5;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(Array.from({ length: (
    /*rows*/
    ctx[0]
  ) }, func7));
  const get_key = (ctx2) => (
    /*row*/
    ctx2[6]
  );
  validate_each_keys(ctx, each_value, get_each_context18, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context18(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block18(key, child_ctx));
  }
  let div6_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data_6 = {};
  for (let i = 0; i < div6_levels.length; i += 1) {
    div_data_6 = assign(div_data_6, div6_levels[i]);
  }
  const block = {
    c: function create() {
      div6 = element("div");
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      span0 = element("span");
      t0 = space();
      div1 = element("div");
      span1 = element("span");
      t1 = space();
      div2 = element("div");
      span2 = element("span");
      t2 = space();
      div5 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div6 = claim_element(nodes, "DIV", {});
      var div6_nodes = children(div6);
      div4 = claim_element(div6_nodes, "DIV", {});
      var div4_nodes = children(div4);
      div3 = claim_element(div4_nodes, "DIV", {});
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", {});
      var div0_nodes = children(div0);
      span0 = claim_element(div0_nodes, "SPAN", {});
      children(span0).forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", {});
      var div1_nodes = children(div1);
      span1 = claim_element(div1_nodes, "SPAN", {});
      children(span1).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", {});
      var div2_nodes = children(div2);
      span2 = claim_element(div2_nodes, "SPAN", {});
      children(span2).forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      t2 = claim_space(div6_nodes);
      div5 = claim_element(div6_nodes, "DIV", {});
      var div5_nodes = children(div5);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div5_nodes);
      }
      div5_nodes.forEach(detach_dev);
      div6_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span0, file134, 21, 49, 561);
      toggle_class(div0, "bx--structured-list-th", true);
      add_location(div0, file134, 21, 6, 518);
      add_location(span1, file134, 22, 49, 630);
      toggle_class(div1, "bx--structured-list-th", true);
      add_location(div1, file134, 22, 6, 587);
      add_location(span2, file134, 23, 49, 699);
      toggle_class(div2, "bx--structured-list-th", true);
      add_location(div2, file134, 23, 6, 656);
      toggle_class(div3, "bx--structured-list-row", true);
      toggle_class(div3, "bx--structured-list-row--header-row", true);
      add_location(div3, file134, 17, 4, 399);
      toggle_class(div4, "bx--structured-list-thead", true);
      add_location(div4, file134, 16, 2, 348);
      toggle_class(div5, "bx--structured-list-tbody", true);
      add_location(div5, file134, 26, 2, 741);
      set_attributes(div6, div_data_6);
      toggle_class(div6, "bx--skeleton", true);
      toggle_class(div6, "bx--structured-list", true);
      add_location(div6, file134, 7, 0, 195);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div6, anchor);
      append_hydration_dev(div6, div4);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, span0);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, span1);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, span2);
      append_hydration_dev(div6, t2);
      append_hydration_dev(div6, div5);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div5, null);
        }
      }
      if (!mounted) {
        dispose = [
          listen_dev(
            div6,
            "click",
            /*click_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div6,
            "mouseover",
            /*mouseover_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div6,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div6,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*rows*/
      1) {
        each_value = ensure_array_like_dev(Array.from({ length: (
          /*rows*/
          ctx2[0]
        ) }, func7));
        validate_each_keys(ctx2, each_value, get_each_context18, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div5, destroy_block, create_each_block18, null, get_each_context18);
      }
      set_attributes(div6, div_data_6 = get_spread_update(div6_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(div6, "bx--skeleton", true);
      toggle_class(div6, "bx--structured-list", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div6);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment144.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func7 = (_, i) => i;
function instance144($$self, $$props, $$invalidate) {
  const omit_props_names = ["rows"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StructuredListSkeleton", slots, []);
  let { rows = 5 } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("rows" in $$new_props) $$invalidate(0, rows = $$new_props.rows);
  };
  $$self.$capture_state = () => ({ rows });
  $$self.$inject_state = ($$new_props) => {
    if ("rows" in $$props) $$invalidate(0, rows = $$new_props.rows);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    rows,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var StructuredListSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance144, create_fragment144, safe_not_equal, { rows: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StructuredListSkeleton",
      options,
      id: create_fragment144.name
    });
  }
  get rows() {
    throw new Error("<StructuredListSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<StructuredListSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StructuredListSkeleton_default = StructuredListSkeleton;

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListBody.svelte
var file135 = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListBody.svelte";
function create_fragment145(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let div_levels = [
    { role: "rowgroup" },
    /*$$restProps*/
    ctx[0]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { role: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--structured-list-tbody", true);
      add_location(div, file135, 2, 0, 124);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [{ role: "rowgroup" }, dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
      toggle_class(div, "bx--structured-list-tbody", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment145.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance145($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StructuredListBody", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var StructuredListBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance145, create_fragment145, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StructuredListBody",
      options,
      id: create_fragment145.name
    });
  }
};
var StructuredListBody_default = StructuredListBody;

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListHead.svelte
var file136 = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListHead.svelte";
function create_fragment146(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let div_levels = [
    { role: "rowgroup" },
    /*$$restProps*/
    ctx[0]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { role: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--structured-list-thead", true);
      add_location(div, file136, 2, 0, 124);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [{ role: "rowgroup" }, dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
      toggle_class(div, "bx--structured-list-thead", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment146.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance146($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StructuredListHead", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var StructuredListHead = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance146, create_fragment146, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StructuredListHead",
      options,
      id: create_fragment146.name
    });
  }
};
var StructuredListHead_default = StructuredListHead;

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListCell.svelte
var file137 = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListCell.svelte";
function create_fragment147(ctx) {
  let div;
  let div_role_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    {
      role: div_role_value = /*head*/
      ctx[0] ? "columnheader" : "cell"
    },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { role: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(
        div,
        "bx--structured-list-th",
        /*head*/
        ctx[0]
      );
      toggle_class(div, "bx--structured-list-td", !/*head*/
      ctx[0]);
      toggle_class(
        div,
        "bx--structured-list-content--nowrap",
        /*noWrap*/
        ctx[1]
      );
      add_location(div, file137, 9, 0, 219);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*head*/
        1 && div_role_value !== (div_role_value = /*head*/
        ctx2[0] ? "columnheader" : "cell")) && { role: div_role_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      toggle_class(
        div,
        "bx--structured-list-th",
        /*head*/
        ctx2[0]
      );
      toggle_class(div, "bx--structured-list-td", !/*head*/
      ctx2[0]);
      toggle_class(
        div,
        "bx--structured-list-content--nowrap",
        /*noWrap*/
        ctx2[1]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment147.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance147($$self, $$props, $$invalidate) {
  const omit_props_names = ["head", "noWrap"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StructuredListCell", slots, ["default"]);
  let { head = false } = $$props;
  let { noWrap = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("head" in $$new_props) $$invalidate(0, head = $$new_props.head);
    if ("noWrap" in $$new_props) $$invalidate(1, noWrap = $$new_props.noWrap);
    if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ head, noWrap });
  $$self.$inject_state = ($$new_props) => {
    if ("head" in $$props) $$invalidate(0, head = $$new_props.head);
    if ("noWrap" in $$props) $$invalidate(1, noWrap = $$new_props.noWrap);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    head,
    noWrap,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var StructuredListCell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance147, create_fragment147, safe_not_equal, { head: 0, noWrap: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StructuredListCell",
      options,
      id: create_fragment147.name
    });
  }
  get head() {
    throw new Error("<StructuredListCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set head(value) {
    throw new Error("<StructuredListCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noWrap() {
    throw new Error("<StructuredListCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noWrap(value) {
    throw new Error("<StructuredListCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StructuredListCell_default = StructuredListCell;

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListRow.svelte
var file138 = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListRow.svelte";
function create_else_block28(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { role: "row" },
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { role: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--structured-list-row", true);
      toggle_class(
        div,
        "bx--structured-list-row--header-row",
        /*head*/
        ctx[0]
      );
      add_location(div, file138, 31, 2, 808);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler_1*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler_1*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler_1*/
            ctx[14],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [{ role: "row" }, dirty & /*$$restProps*/
      8 && /*$$restProps*/
      ctx2[3]]));
      toggle_class(div, "bx--structured-list-row", true);
      toggle_class(
        div,
        "bx--structured-list-row--header-row",
        /*head*/
        ctx2[0]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block28.name,
    type: "else",
    source: "(30:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block86(ctx) {
  let label_1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let label_1_levels = [
    { tabindex: (
      /*tabindex*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let label_data = {};
  for (let i = 0; i < label_1_levels.length; i += 1) {
    label_data = assign(label_data, label_1_levels[i]);
  }
  const block = {
    c: function create() {
      label_1 = element("label");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { tabindex: true });
      var label_1_nodes = children(label_1);
      if (default_slot) default_slot.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(label_1, label_data);
      toggle_class(label_1, "bx--structured-list-row", true);
      toggle_class(
        label_1,
        "bx--structured-list-row--header-row",
        /*head*/
        ctx[0]
      );
      add_location(label_1, file138, 16, 2, 480);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      if (default_slot) {
        default_slot.m(label_1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            label_1,
            "click",
            /*click_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label_1,
            "mouseover",
            /*mouseover_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label_1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label_1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label_1,
            "keydown",
            /*keydown_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label_1, label_data = get_spread_update(label_1_levels, [
        (!current || dirty & /*tabindex*/
        4) && { tabindex: (
          /*tabindex*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
      toggle_class(label_1, "bx--structured-list-row", true);
      toggle_class(
        label_1,
        "bx--structured-list-row--header-row",
        /*head*/
        ctx2[0]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label_1);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block86.name,
    type: "if",
    source: "(13:0) {#if label}",
    ctx
  });
  return block;
}
function create_fragment148(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block86, create_else_block28];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*label*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment148.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance148($$self, $$props, $$invalidate) {
  const omit_props_names = ["head", "label", "tabindex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StructuredListRow", slots, ["default"]);
  let { head = false } = $$props;
  let { label = false } = $$props;
  let { tabindex = "0" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("head" in $$new_props) $$invalidate(0, head = $$new_props.head);
    if ("label" in $$new_props) $$invalidate(1, label = $$new_props.label);
    if ("tabindex" in $$new_props) $$invalidate(2, tabindex = $$new_props.tabindex);
    if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ head, label, tabindex });
  $$self.$inject_state = ($$new_props) => {
    if ("head" in $$props) $$invalidate(0, head = $$new_props.head);
    if ("label" in $$props) $$invalidate(1, label = $$new_props.label);
    if ("tabindex" in $$props) $$invalidate(2, tabindex = $$new_props.tabindex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    head,
    label,
    tabindex,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1
  ];
}
var StructuredListRow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance148, create_fragment148, safe_not_equal, { head: 0, label: 1, tabindex: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StructuredListRow",
      options,
      id: create_fragment148.name
    });
  }
  get head() {
    throw new Error("<StructuredListRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set head(value) {
    throw new Error("<StructuredListRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<StructuredListRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<StructuredListRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<StructuredListRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<StructuredListRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StructuredListRow_default = StructuredListRow;

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListInput.svelte
var file139 = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListInput.svelte";
function create_fragment149(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "radio" },
    { tabindex: "-1" },
    { checked: (
      /*checked*/
      ctx[0]
    ) },
    { id: (
      /*id*/
      ctx[4]
    ) },
    { name: (
      /*name*/
      ctx[5]
    ) },
    { title: (
      /*title*/
      ctx[2]
    ) },
    { value: (
      /*value*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[8]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        tabindex: true,
        id: true,
        name: true,
        title: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "bx--structured-list-input", true);
      add_location(input, file139, 30, 0, 681);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus) input.focus();
      ctx[10](input);
      if (!mounted) {
        dispose = listen_dev(
          input,
          "change",
          /*change_handler*/
          ctx[11],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "radio" },
        { tabindex: "-1" },
        dirty & /*checked*/
        1 && { checked: (
          /*checked*/
          ctx2[0]
        ) },
        dirty & /*id*/
        16 && { id: (
          /*id*/
          ctx2[4]
        ) },
        dirty & /*name*/
        32 && { name: (
          /*name*/
          ctx2[5]
        ) },
        dirty & /*title*/
        4 && { title: (
          /*title*/
          ctx2[2]
        ) },
        dirty & /*value*/
        8 && { value: (
          /*value*/
          ctx2[3]
        ) },
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8]
      ]));
      toggle_class(input, "bx--structured-list-input", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment149.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance149($$self, $$props, $$invalidate) {
  const omit_props_names = ["checked", "title", "value", "id", "name", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StructuredListInput", slots, []);
  let { checked = false } = $$props;
  let { title = "title" } = $$props;
  let { value = "value" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = "" } = $$props;
  let { ref = null } = $$props;
  const { selectedValue, update } = getContext("StructuredListWrapper");
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value2) => $$invalidate(9, $selectedValue = value2));
  if (checked) {
    update(value);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const change_handler = () => {
    update(value);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
    if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    if ("value" in $$new_props) $$invalidate(3, value = $$new_props.value);
    if ("id" in $$new_props) $$invalidate(4, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(5, name = $$new_props.name);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    checked,
    title,
    value,
    id,
    name,
    ref,
    getContext,
    selectedValue,
    update,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("checked" in $$props) $$invalidate(0, checked = $$new_props.checked);
    if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    if ("value" in $$props) $$invalidate(3, value = $$new_props.value);
    if ("id" in $$props) $$invalidate(4, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(5, name = $$new_props.name);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selectedValue, value*/
    520) {
      $: $$invalidate(0, checked = $selectedValue === value);
    }
  };
  return [
    checked,
    ref,
    title,
    value,
    id,
    name,
    selectedValue,
    update,
    $$restProps,
    $selectedValue,
    input_binding,
    change_handler
  ];
}
var StructuredListInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance149, create_fragment149, safe_not_equal, {
      checked: 0,
      title: 2,
      value: 3,
      id: 4,
      name: 5,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StructuredListInput",
      options,
      id: create_fragment149.name
    });
  }
  get checked() {
    throw new Error("<StructuredListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<StructuredListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<StructuredListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<StructuredListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<StructuredListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<StructuredListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<StructuredListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<StructuredListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<StructuredListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<StructuredListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<StructuredListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<StructuredListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StructuredListInput_default = StructuredListInput;

// node_modules/carbon-components-svelte/src/Tabs/Tabs.svelte
var file140 = "node_modules/carbon-components-svelte/src/Tabs/Tabs.svelte";
var get_content_slot_changes = (dirty) => ({});
var get_content_slot_context = (ctx) => ({});
function create_if_block87(ctx) {
  let t_value = (
    /*currentTab*/
    ctx[3].label + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*currentTab*/
      8 && t_value !== (t_value = /*currentTab*/
      ctx2[3].label + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block87.name,
    type: "if",
    source: "(154:6) {#if currentTab}",
    ctx
  });
  return block;
}
function create_fragment150(ctx) {
  let div1;
  let div0;
  let a;
  let t0;
  let chevrondown;
  let div0_aria_label_value;
  let t1;
  let ul;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*currentTab*/
    ctx[3] && create_if_block87(ctx)
  );
  chevrondown = new ChevronDown_default({
    props: {
      "aria-hidden": "true",
      title: (
        /*iconDescription*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  let div1_levels = [
    { role: "navigation" },
    /*$$restProps*/
    ctx[10]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const content_slot_template = (
    /*#slots*/
    ctx[20].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_content_slot_context
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      a = element("a");
      if (if_block) if_block.c();
      t0 = space();
      create_component(chevrondown.$$.fragment);
      t1 = space();
      ul = element("ul");
      if (default_slot) default_slot.c();
      t2 = space();
      if (content_slot) content_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { role: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        role: true,
        tabindex: true,
        "aria-label": true
      });
      var div0_nodes = children(div0);
      a = claim_element(div0_nodes, "A", { tabindex: true, href: true });
      var a_nodes = children(a);
      if (if_block) if_block.l(a_nodes);
      a_nodes.forEach(detach_dev);
      t0 = claim_space(div0_nodes);
      claim_component(chevrondown.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      ul = claim_element(div1_nodes, "UL", { role: true });
      var ul_nodes = children(ul);
      if (default_slot) default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(nodes);
      if (content_slot) content_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "tabindex", "-1");
      attr_dev(
        a,
        "href",
        /*triggerHref*/
        ctx[2]
      );
      toggle_class(a, "bx--tabs-trigger-text", true);
      add_location(a, file140, 144, 4, 3338);
      attr_dev(div0, "role", "listbox");
      attr_dev(div0, "tabindex", "0");
      attr_dev(div0, "aria-label", div0_aria_label_value = /*$$props*/
      ctx[11]["aria-label"] || "listbox");
      toggle_class(div0, "bx--tabs-trigger", true);
      add_location(div0, file140, 131, 2, 3038);
      attr_dev(ul, "role", "tablist");
      toggle_class(ul, "bx--tabs__nav", true);
      toggle_class(
        ul,
        "bx--tabs__nav--hidden",
        /*dropdownHidden*/
        ctx[5]
      );
      add_location(ul, file140, 158, 2, 3782);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--tabs", true);
      toggle_class(
        div1,
        "bx--tabs--container",
        /*type*/
        ctx[0] === "container"
      );
      add_location(div1, file140, 125, 0, 2911);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, a);
      if (if_block) if_block.m(a, null);
      append_hydration_dev(div0, t0);
      mount_component(chevrondown, div0, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[26](ul);
      insert_hydration_dev(target, t2, anchor);
      if (content_slot) {
        content_slot.m(target, anchor);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(a, "click", prevent_default(
            /*click_handler*/
            ctx[22]
          ), false, true, false, false),
          listen_dev(a, "click", stop_propagation(prevent_default(
            /*click_handler_1*/
            ctx[23]
          )), false, true, true, false),
          listen_dev(
            div0,
            "click",
            /*click_handler_2*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "keypress",
            /*keypress_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "keypress",
            /*keypress_handler_1*/
            ctx[25],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*currentTab*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block87(ctx2);
          if_block.c();
          if_block.m(a, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty[0] & /*triggerHref*/
      4) {
        attr_dev(
          a,
          "href",
          /*triggerHref*/
          ctx2[2]
        );
      }
      const chevrondown_changes = {};
      if (dirty[0] & /*iconDescription*/
      2) chevrondown_changes.title = /*iconDescription*/
      ctx2[1];
      chevrondown.$set(chevrondown_changes);
      if (!current || dirty[0] & /*$$props*/
      2048 && div0_aria_label_value !== (div0_aria_label_value = /*$$props*/
      ctx2[11]["aria-label"] || "listbox")) {
        attr_dev(div0, "aria-label", div0_aria_label_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*dropdownHidden*/
      32) {
        toggle_class(
          ul,
          "bx--tabs__nav--hidden",
          /*dropdownHidden*/
          ctx2[5]
        );
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        { role: "navigation" },
        dirty[0] & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10]
      ]));
      toggle_class(div1, "bx--tabs", true);
      toggle_class(
        div1,
        "bx--tabs--container",
        /*type*/
        ctx2[0] === "container"
      );
      if (content_slot) {
        if (content_slot.p && (!current || dirty[0] & /*$$scope*/
        524288)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_content_slot_changes
            ),
            get_content_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(chevrondown.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(content_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevrondown.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(content_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
        detach_dev(t2);
      }
      if (if_block) if_block.d();
      destroy_component(chevrondown);
      if (default_slot) default_slot.d(detaching);
      ctx[26](null);
      if (content_slot) content_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment150.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance150($$self, $$props, $$invalidate) {
  let currentTab;
  let currentContent;
  const omit_props_names = ["selected", "type", "autoWidth", "iconDescription", "triggerHref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedTab;
  let $content;
  let $tabs;
  let $tabsById;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tabs", slots, ["default", "content"]);
  let { selected = 0 } = $$props;
  let { type = "default" } = $$props;
  let { autoWidth = false } = $$props;
  let { iconDescription = "Show menu options" } = $$props;
  let { triggerHref = "#" } = $$props;
  const dispatch = createEventDispatcher();
  const tabs = writable([]);
  validate_store(tabs, "tabs");
  component_subscribe($$self, tabs, (value) => $$invalidate(18, $tabs = value));
  const tabsById = derived(tabs, (_) => _.reduce((a, c) => ({ ...a, [c.id]: c }), {}));
  validate_store(tabsById, "tabsById");
  component_subscribe($$self, tabsById, (value) => $$invalidate(28, $tabsById = value));
  const useAutoWidth = writable(autoWidth);
  const selectedTab = writable(void 0);
  validate_store(selectedTab, "selectedTab");
  component_subscribe($$self, selectedTab, (value) => $$invalidate(16, $selectedTab = value));
  const content = writable([]);
  validate_store(content, "content");
  component_subscribe($$self, content, (value) => $$invalidate(17, $content = value));
  const contentById = derived(content, (_) => _.reduce((a, c) => ({ ...a, [c.id]: c }), {}));
  const selectedContent = writable(void 0);
  let refTabList = null;
  setContext("Tabs", {
    tabs,
    contentById,
    selectedTab,
    selectedContent,
    useAutoWidth,
    add: (data) => {
      tabs.update((_) => [..._, { ...data, index: _.length }]);
    },
    addContent: (data) => {
      content.update((_) => [..._, { ...data, index: _.length }]);
    },
    update: (id) => {
      $$invalidate(14, currentIndex = $tabsById[id].index);
    },
    change: async (direction) => {
      let index = currentIndex + direction;
      if (index < 0) {
        index = $tabs.length - 1;
      } else if (index >= $tabs.length) {
        index = 0;
      }
      let disabled = $tabs[index].disabled;
      while (disabled) {
        index = index + direction;
        if (index < 0) {
          index = $tabs.length - 1;
        } else if (index >= $tabs.length) {
          index = 0;
        }
        disabled = $tabs[index].disabled;
      }
      $$invalidate(14, currentIndex = index);
      await tick();
      const activeTab = refTabList == null ? void 0 : refTabList.querySelectorAll("[role='tab']")[currentIndex];
      activeTab == null ? void 0 : activeTab.focus();
    }
  });
  afterUpdate(() => {
    $$invalidate(12, selected = currentIndex);
    if (prevIndex > -1 && prevIndex !== currentIndex) {
      dispatch("change", currentIndex);
    }
    prevIndex = currentIndex;
  });
  let dropdownHidden = true;
  let currentIndex = selected;
  let prevIndex = -1;
  function keypress_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = () => {
    $$invalidate(5, dropdownHidden = !dropdownHidden);
  };
  const click_handler_2 = () => {
    $$invalidate(5, dropdownHidden = !dropdownHidden);
  };
  const keypress_handler_1 = () => {
    $$invalidate(5, dropdownHidden = !dropdownHidden);
  };
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refTabList = $$value;
      $$invalidate(4, refTabList);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props) $$invalidate(12, selected = $$new_props.selected);
    if ("type" in $$new_props) $$invalidate(0, type = $$new_props.type);
    if ("autoWidth" in $$new_props) $$invalidate(13, autoWidth = $$new_props.autoWidth);
    if ("iconDescription" in $$new_props) $$invalidate(1, iconDescription = $$new_props.iconDescription);
    if ("triggerHref" in $$new_props) $$invalidate(2, triggerHref = $$new_props.triggerHref);
    if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    type,
    autoWidth,
    iconDescription,
    triggerHref,
    createEventDispatcher,
    afterUpdate,
    setContext,
    tick,
    writable,
    derived,
    ChevronDown: ChevronDown_default,
    dispatch,
    tabs,
    tabsById,
    useAutoWidth,
    selectedTab,
    content,
    contentById,
    selectedContent,
    refTabList,
    dropdownHidden,
    currentIndex,
    prevIndex,
    currentContent,
    currentTab,
    $selectedTab,
    $content,
    $tabs,
    $tabsById
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props) $$invalidate(12, selected = $$new_props.selected);
    if ("type" in $$props) $$invalidate(0, type = $$new_props.type);
    if ("autoWidth" in $$props) $$invalidate(13, autoWidth = $$new_props.autoWidth);
    if ("iconDescription" in $$props) $$invalidate(1, iconDescription = $$new_props.iconDescription);
    if ("triggerHref" in $$props) $$invalidate(2, triggerHref = $$new_props.triggerHref);
    if ("refTabList" in $$props) $$invalidate(4, refTabList = $$new_props.refTabList);
    if ("dropdownHidden" in $$props) $$invalidate(5, dropdownHidden = $$new_props.dropdownHidden);
    if ("currentIndex" in $$props) $$invalidate(14, currentIndex = $$new_props.currentIndex);
    if ("prevIndex" in $$props) prevIndex = $$new_props.prevIndex;
    if ("currentContent" in $$props) $$invalidate(15, currentContent = $$new_props.currentContent);
    if ("currentTab" in $$props) $$invalidate(3, currentTab = $$new_props.currentTab);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*selected*/
    4096) {
      $: $$invalidate(14, currentIndex = selected);
    }
    if ($$self.$$.dirty[0] & /*$tabs, currentIndex*/
    278528) {
      $: $$invalidate(3, currentTab = $tabs[currentIndex] || void 0);
    }
    if ($$self.$$.dirty[0] & /*$content, currentIndex*/
    147456) {
      $: $$invalidate(15, currentContent = $content[currentIndex] || void 0);
    }
    if ($$self.$$.dirty[0] & /*currentTab, currentContent*/
    32776) {
      $: {
        if (currentTab) {
          selectedTab.set(currentTab.id);
        }
        if (currentContent) {
          selectedContent.set(currentContent.id);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*$selectedTab*/
    65536) {
      $: if ($selectedTab) {
        $$invalidate(5, dropdownHidden = true);
      }
    }
    if ($$self.$$.dirty[0] & /*autoWidth*/
    8192) {
      $: useAutoWidth.set(autoWidth);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    type,
    iconDescription,
    triggerHref,
    currentTab,
    refTabList,
    dropdownHidden,
    tabs,
    tabsById,
    selectedTab,
    content,
    $$restProps,
    $$props,
    selected,
    autoWidth,
    currentIndex,
    currentContent,
    $selectedTab,
    $content,
    $tabs,
    $$scope,
    slots,
    keypress_handler,
    click_handler,
    click_handler_13,
    click_handler_2,
    keypress_handler_1,
    ul_binding
  ];
}
var Tabs = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance150,
      create_fragment150,
      safe_not_equal,
      {
        selected: 12,
        type: 0,
        autoWidth: 13,
        iconDescription: 1,
        triggerHref: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tabs",
      options,
      id: create_fragment150.name
    });
  }
  get selected() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoWidth() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoWidth(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get triggerHref() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set triggerHref(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tabs_default = Tabs;

// node_modules/carbon-components-svelte/src/Tabs/Tab.svelte
var file141 = "node_modules/carbon-components-svelte/src/Tabs/Tab.svelte";
function fallback_block29(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*label*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*label*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*label*/
      2) set_data_dev(
        t,
        /*label*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block29.name,
    type: "fallback",
    source: "(72:10) {label}",
    ctx
  });
  return block;
}
function create_fragment151(ctx) {
  let li;
  let a;
  let a_tabindex_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block29(ctx);
  let li_levels = [
    { tabindex: "-1" },
    { role: "presentation" },
    /*$$restProps*/
    ctx[12]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { tabindex: true, role: true });
      var li_nodes = children(li);
      a = claim_element(li_nodes, "A", {
        role: true,
        tabindex: true,
        "aria-selected": true,
        "aria-disabled": true,
        id: true,
        href: true
      });
      var a_nodes = children(a);
      if (default_slot_or_fallback) default_slot_or_fallback.l(a_nodes);
      a_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "role", "tab");
      attr_dev(a, "tabindex", a_tabindex_value = /*disabled*/
      ctx[3] ? "-1" : (
        /*tabindex*/
        ctx[4]
      ));
      attr_dev(
        a,
        "aria-selected",
        /*selected*/
        ctx[6]
      );
      attr_dev(
        a,
        "aria-disabled",
        /*disabled*/
        ctx[3]
      );
      attr_dev(
        a,
        "id",
        /*id*/
        ctx[5]
      );
      attr_dev(
        a,
        "href",
        /*href*/
        ctx[2]
      );
      toggle_class(a, "bx--tabs__nav-link", true);
      set_style(
        a,
        "width",
        /*$useAutoWidth*/
        ctx[7] ? "auto" : void 0
      );
      add_location(a, file141, 60, 2, 1410);
      set_attributes(li, li_data);
      toggle_class(li, "bx--tabs__nav-item", true);
      toggle_class(
        li,
        "bx--tabs__nav-item--disabled",
        /*disabled*/
        ctx[3]
      );
      toggle_class(
        li,
        "bx--tabs__nav-item--selected",
        /*selected*/
        ctx[6]
      );
      add_location(li, file141, 32, 0, 794);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, a);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(a, null);
      }
      ctx[20](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(li, "click", prevent_default(
            /*click_handler*/
            ctx[16]
          ), false, true, false, false),
          listen_dev(li, "click", prevent_default(
            /*click_handler_1*/
            ctx[21]
          ), false, true, false, false),
          listen_dev(
            li,
            "mouseover",
            /*mouseover_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keydown",
            /*keydown_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*label*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*disabled, tabindex*/
      24 && a_tabindex_value !== (a_tabindex_value = /*disabled*/
      ctx2[3] ? "-1" : (
        /*tabindex*/
        ctx2[4]
      ))) {
        attr_dev(a, "tabindex", a_tabindex_value);
      }
      if (!current || dirty & /*selected*/
      64) {
        attr_dev(
          a,
          "aria-selected",
          /*selected*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*disabled*/
      8) {
        attr_dev(
          a,
          "aria-disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*id*/
      32) {
        attr_dev(
          a,
          "id",
          /*id*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*href*/
      4) {
        attr_dev(
          a,
          "href",
          /*href*/
          ctx2[2]
        );
      }
      if (dirty & /*$useAutoWidth*/
      128) {
        set_style(
          a,
          "width",
          /*$useAutoWidth*/
          ctx2[7] ? "auto" : void 0
        );
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        { tabindex: "-1" },
        { role: "presentation" },
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12]
      ]));
      toggle_class(li, "bx--tabs__nav-item", true);
      toggle_class(
        li,
        "bx--tabs__nav-item--disabled",
        /*disabled*/
        ctx2[3]
      );
      toggle_class(
        li,
        "bx--tabs__nav-item--selected",
        /*selected*/
        ctx2[6]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      ctx[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment151.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance151($$self, $$props, $$invalidate) {
  let selected;
  const omit_props_names = ["label", "href", "disabled", "tabindex", "id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedTab;
  let $useAutoWidth;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tab", slots, ["default"]);
  let { label = "" } = $$props;
  let { href = "#" } = $$props;
  let { disabled = false } = $$props;
  let { tabindex = "0" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const { selectedTab, useAutoWidth, add, update, change } = getContext("Tabs");
  validate_store(selectedTab, "selectedTab");
  component_subscribe($$self, selectedTab, (value) => $$invalidate(13, $selectedTab = value));
  validate_store(useAutoWidth, "useAutoWidth");
  component_subscribe($$self, useAutoWidth, (value) => $$invalidate(7, $useAutoWidth = value));
  add({ id, label, disabled });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const click_handler_13 = () => {
    if (!disabled) {
      update(id);
    }
  };
  const keydown_handler = ({ key }) => {
    if (!disabled) {
      if (key === "ArrowRight") {
        change(1);
      } else if (key === "ArrowLeft") {
        change(-1);
      } else if (key === " " || key === "Enter") {
        update(id);
      }
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("label" in $$new_props) $$invalidate(1, label = $$new_props.label);
    if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
    if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
    if ("tabindex" in $$new_props) $$invalidate(4, tabindex = $$new_props.tabindex);
    if ("id" in $$new_props) $$invalidate(5, id = $$new_props.id);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    label,
    href,
    disabled,
    tabindex,
    id,
    ref,
    getContext,
    selectedTab,
    useAutoWidth,
    add,
    update,
    change,
    selected,
    $selectedTab,
    $useAutoWidth
  });
  $$self.$inject_state = ($$new_props) => {
    if ("label" in $$props) $$invalidate(1, label = $$new_props.label);
    if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
    if ("disabled" in $$props) $$invalidate(3, disabled = $$new_props.disabled);
    if ("tabindex" in $$props) $$invalidate(4, tabindex = $$new_props.tabindex);
    if ("id" in $$props) $$invalidate(5, id = $$new_props.id);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    if ("selected" in $$props) $$invalidate(6, selected = $$new_props.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selectedTab, id*/
    8224) {
      $: $$invalidate(6, selected = $selectedTab === id);
    }
  };
  return [
    ref,
    label,
    href,
    disabled,
    tabindex,
    id,
    selected,
    $useAutoWidth,
    selectedTab,
    useAutoWidth,
    update,
    change,
    $$restProps,
    $selectedTab,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    a_binding,
    click_handler_13,
    keydown_handler
  ];
}
var Tab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance151, create_fragment151, safe_not_equal, {
      label: 1,
      href: 2,
      disabled: 3,
      tabindex: 4,
      id: 5,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tab",
      options,
      id: create_fragment151.name
    });
  }
  get label() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tab_default = Tab;

// node_modules/carbon-components-svelte/src/Tabs/TabContent.svelte
var file142 = "node_modules/carbon-components-svelte/src/Tabs/TabContent.svelte";
function create_fragment152(ctx) {
  let div;
  let div_aria_hidden_value;
  let div_hidden_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let div_levels = [
    { role: "tabpanel" },
    { "aria-labelledby": (
      /*tabId*/
      ctx[1]
    ) },
    {
      "aria-hidden": div_aria_hidden_value = !/*selected*/
      ctx[2]
    },
    {
      hidden: div_hidden_value = /*selected*/
      ctx[2] ? void 0 : ""
    },
    { id: (
      /*id*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        role: true,
        "aria-labelledby": true,
        "aria-hidden": true,
        id: true
      });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--tab-content", true);
      add_location(div, file142, 15, 0, 374);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "tabpanel" },
        (!current || dirty & /*tabId*/
        2) && { "aria-labelledby": (
          /*tabId*/
          ctx2[1]
        ) },
        (!current || dirty & /*selected*/
        4 && div_aria_hidden_value !== (div_aria_hidden_value = !/*selected*/
        ctx2[2])) && { "aria-hidden": div_aria_hidden_value },
        (!current || dirty & /*selected*/
        4 && div_hidden_value !== (div_hidden_value = /*selected*/
        ctx2[2] ? void 0 : "")) && { hidden: div_hidden_value },
        (!current || dirty & /*id*/
        1) && { id: (
          /*id*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
      toggle_class(div, "bx--tab-content", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment152.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance152($$self, $$props, $$invalidate) {
  let selected;
  let index;
  let tabId;
  const omit_props_names = ["id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $tabs;
  let $contentById;
  let $selectedContent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabContent", slots, ["default"]);
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  const { selectedContent, addContent, tabs, contentById } = getContext("Tabs");
  validate_store(selectedContent, "selectedContent");
  component_subscribe($$self, selectedContent, (value) => $$invalidate(10, $selectedContent = value));
  validate_store(tabs, "tabs");
  component_subscribe($$self, tabs, (value) => $$invalidate(8, $tabs = value));
  validate_store(contentById, "contentById");
  component_subscribe($$self, contentById, (value) => $$invalidate(9, $contentById = value));
  addContent({ id });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    id,
    getContext,
    selectedContent,
    addContent,
    tabs,
    contentById,
    index,
    tabId,
    selected,
    $tabs,
    $contentById,
    $selectedContent
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
    if ("index" in $$props) $$invalidate(7, index = $$new_props.index);
    if ("tabId" in $$props) $$invalidate(1, tabId = $$new_props.tabId);
    if ("selected" in $$props) $$invalidate(2, selected = $$new_props.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selectedContent, id*/
    1025) {
      $: $$invalidate(2, selected = $selectedContent === id);
    }
    if ($$self.$$.dirty & /*$contentById, id*/
    513) {
      $: $$invalidate(7, index = $contentById[id].index);
    }
    if ($$self.$$.dirty & /*$tabs, index*/
    384) {
      $: $$invalidate(1, tabId = $tabs[index].id);
    }
  };
  return [
    id,
    tabId,
    selected,
    selectedContent,
    tabs,
    contentById,
    $$restProps,
    index,
    $tabs,
    $contentById,
    $selectedContent,
    $$scope,
    slots
  ];
}
var TabContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance152, create_fragment152, safe_not_equal, { id: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabContent",
      options,
      id: create_fragment152.name
    });
  }
  get id() {
    throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabContent_default = TabContent;

// node_modules/carbon-components-svelte/src/Tabs/TabsSkeleton.svelte
var file143 = "node_modules/carbon-components-svelte/src/Tabs/TabsSkeleton.svelte";
function get_each_context19(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_each_block19(ctx) {
  let li;
  let div;
  let span;
  let t;
  const block = {
    c: function create() {
      li = element("li");
      div = element("div");
      span = element("span");
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      div = claim_element(li_nodes, "DIV", {});
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      t = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file143, 28, 10, 786);
      toggle_class(div, "bx--tabs__nav-link", true);
      add_location(div, file143, 27, 8, 736);
      toggle_class(li, "bx--tabs--scrollable__nav-item", true);
      add_location(li, file143, 26, 6, 677);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, div);
      append_hydration_dev(div, span);
      append_hydration_dev(li, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block19.name,
    type: "each",
    source: "(26:4) {#each Array.from({ length: count }, (_, i) => i) as item}",
    ctx
  });
  return block;
}
function create_fragment153(ctx) {
  let div;
  let ul;
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(Array.from({ length: (
    /*count*/
    ctx[0]
  ) }, func8));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block19(get_each_context19(ctx, each_value, i));
  }
  let div_levels = [
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      ul = claim_element(div_nodes, "UL", {});
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(ul, "bx--tabs--scrollable__nav", true);
      add_location(ul, file143, 24, 2, 562);
      set_attributes(div, div_data);
      toggle_class(div, "bx--tabs", true);
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--tabs--scrollable", true);
      toggle_class(
        div,
        "bx--tabs--scrollable--container",
        /*type*/
        ctx[1] === "container"
      );
      add_location(div, file143, 13, 0, 317);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*count*/
      1) {
        each_value = ensure_array_like_dev(Array.from({ length: (
          /*count*/
          ctx2[0]
        ) }, func8));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context19(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block19(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      4 && /*$$restProps*/
      ctx2[2]]));
      toggle_class(div, "bx--tabs", true);
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--tabs--scrollable", true);
      toggle_class(
        div,
        "bx--tabs--scrollable--container",
        /*type*/
        ctx2[1] === "container"
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment153.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func8 = (_, i) => i;
function instance153($$self, $$props, $$invalidate) {
  const omit_props_names = ["count", "type"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabsSkeleton", slots, []);
  let { count = 4 } = $$props;
  let { type = "default" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("count" in $$new_props) $$invalidate(0, count = $$new_props.count);
    if ("type" in $$new_props) $$invalidate(1, type = $$new_props.type);
  };
  $$self.$capture_state = () => ({ count, type });
  $$self.$inject_state = ($$new_props) => {
    if ("count" in $$props) $$invalidate(0, count = $$new_props.count);
    if ("type" in $$props) $$invalidate(1, type = $$new_props.type);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    count,
    type,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var TabsSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance153, create_fragment153, safe_not_equal, { count: 0, type: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabsSkeleton",
      options,
      id: create_fragment153.name
    });
  }
  get count() {
    throw new Error("<TabsSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<TabsSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<TabsSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<TabsSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabsSkeleton_default = TabsSkeleton;

// node_modules/carbon-components-svelte/src/Tag/TagSkeleton.svelte
var file144 = "node_modules/carbon-components-svelte/src/Tag/TagSkeleton.svelte";
function create_fragment154(ctx) {
  let span;
  let mounted;
  let dispose;
  let span_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      toggle_class(span, "bx--tag", true);
      toggle_class(
        span,
        "bx--tag--sm",
        /*size*/
        ctx[0] === "sm"
      );
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file144, 7, 0, 201);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            span,
            "click",
            /*click_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "mouseover",
            /*mouseover_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(span, span_data = get_spread_update(span_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(span, "bx--tag", true);
      toggle_class(
        span,
        "bx--tag--sm",
        /*size*/
        ctx2[0] === "sm"
      );
      toggle_class(span, "bx--skeleton", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment154.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance154($$self, $$props, $$invalidate) {
  const omit_props_names = ["size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TagSkeleton", slots, []);
  let { size = "default" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
  };
  $$self.$capture_state = () => ({ size });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    size,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var TagSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance154, create_fragment154, safe_not_equal, { size: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TagSkeleton",
      options,
      id: create_fragment154.name
    });
  }
  get size() {
    throw new Error("<TagSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TagSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TagSkeleton_default = TagSkeleton;

// node_modules/carbon-components-svelte/src/Tag/Tag.svelte
var file145 = "node_modules/carbon-components-svelte/src/Tag/Tag.svelte";
var get_icon_slot_changes_14 = (dirty) => ({});
var get_icon_slot_context_14 = (ctx) => ({});
var get_icon_slot_changes4 = (dirty) => ({});
var get_icon_slot_context4 = (ctx) => ({});
var get_default_slot_changes11 = (dirty) => ({});
var get_default_slot_context11 = (ctx) => ({ props: { class: "bx--tag__label" } });
function create_else_block29(ctx) {
  let div;
  let t;
  let span;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$$slots*/
    (ctx[11].icon || /*icon*/
    ctx[7]) && create_if_block_412(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let div_levels = [
    { id: (
      /*id*/
      ctx[8]
    ) },
    /*$$restProps*/
    ctx[10]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block) if_block.c();
      t = space();
      span = element("span");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      if (if_block) if_block.l(div_nodes);
      t = claim_space(div_nodes);
      span = claim_element(div_nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot) default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file145, 167, 4, 5004);
      set_attributes(div, div_data);
      toggle_class(div, "bx--tag", true);
      toggle_class(
        div,
        "bx--tag--disabled",
        /*disabled*/
        ctx[3]
      );
      toggle_class(
        div,
        "bx--tag--sm",
        /*size*/
        ctx[1] === "sm"
      );
      toggle_class(
        div,
        "bx--tag--red",
        /*type*/
        ctx[0] === "red"
      );
      toggle_class(
        div,
        "bx--tag--magenta",
        /*type*/
        ctx[0] === "magenta"
      );
      toggle_class(
        div,
        "bx--tag--purple",
        /*type*/
        ctx[0] === "purple"
      );
      toggle_class(
        div,
        "bx--tag--blue",
        /*type*/
        ctx[0] === "blue"
      );
      toggle_class(
        div,
        "bx--tag--cyan",
        /*type*/
        ctx[0] === "cyan"
      );
      toggle_class(
        div,
        "bx--tag--teal",
        /*type*/
        ctx[0] === "teal"
      );
      toggle_class(
        div,
        "bx--tag--green",
        /*type*/
        ctx[0] === "green"
      );
      toggle_class(
        div,
        "bx--tag--gray",
        /*type*/
        ctx[0] === "gray"
      );
      toggle_class(
        div,
        "bx--tag--cool-gray",
        /*type*/
        ctx[0] === "cool-gray"
      );
      toggle_class(
        div,
        "bx--tag--warm-gray",
        /*type*/
        ctx[0] === "warm-gray"
      );
      toggle_class(
        div,
        "bx--tag--high-contrast",
        /*type*/
        ctx[0] === "high-contrast"
      );
      toggle_class(
        div,
        "bx--tag--outline",
        /*type*/
        ctx[0] === "outline"
      );
      add_location(div, file145, 137, 2, 4010);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append_hydration_dev(div, t);
      append_hydration_dev(div, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler_3*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler_3*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler_3*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler_3*/
            ctx[25],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[11].icon || /*icon*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots, icon*/
          2176) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_412(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*id*/
        256) && { id: (
          /*id*/
          ctx2[8]
        ) },
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10]
      ]));
      toggle_class(div, "bx--tag", true);
      toggle_class(
        div,
        "bx--tag--disabled",
        /*disabled*/
        ctx2[3]
      );
      toggle_class(
        div,
        "bx--tag--sm",
        /*size*/
        ctx2[1] === "sm"
      );
      toggle_class(
        div,
        "bx--tag--red",
        /*type*/
        ctx2[0] === "red"
      );
      toggle_class(
        div,
        "bx--tag--magenta",
        /*type*/
        ctx2[0] === "magenta"
      );
      toggle_class(
        div,
        "bx--tag--purple",
        /*type*/
        ctx2[0] === "purple"
      );
      toggle_class(
        div,
        "bx--tag--blue",
        /*type*/
        ctx2[0] === "blue"
      );
      toggle_class(
        div,
        "bx--tag--cyan",
        /*type*/
        ctx2[0] === "cyan"
      );
      toggle_class(
        div,
        "bx--tag--teal",
        /*type*/
        ctx2[0] === "teal"
      );
      toggle_class(
        div,
        "bx--tag--green",
        /*type*/
        ctx2[0] === "green"
      );
      toggle_class(
        div,
        "bx--tag--gray",
        /*type*/
        ctx2[0] === "gray"
      );
      toggle_class(
        div,
        "bx--tag--cool-gray",
        /*type*/
        ctx2[0] === "cool-gray"
      );
      toggle_class(
        div,
        "bx--tag--warm-gray",
        /*type*/
        ctx2[0] === "warm-gray"
      );
      toggle_class(
        div,
        "bx--tag--high-contrast",
        /*type*/
        ctx2[0] === "high-contrast"
      );
      toggle_class(
        div,
        "bx--tag--outline",
        /*type*/
        ctx2[0] === "outline"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block29.name,
    type: "else",
    source: "(136:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_222(ctx) {
  let button;
  let t;
  let span;
  let button_tabindex_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$$slots*/
    (ctx[11].icon || /*icon*/
    ctx[7]) && create_if_block_316(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let button_levels = [
    { type: "button" },
    { id: (
      /*id*/
      ctx[8]
    ) },
    { disabled: (
      /*disabled*/
      ctx[3]
    ) },
    { "aria-disabled": (
      /*disabled*/
      ctx[3]
    ) },
    {
      tabindex: button_tabindex_value = /*disabled*/
      ctx[3] ? "-1" : void 0
    },
    /*$$restProps*/
    ctx[10]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (if_block) if_block.c();
      t = space();
      span = element("span");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        id: true,
        "aria-disabled": true,
        tabindex: true
      });
      var button_nodes = children(button);
      if (if_block) if_block.l(button_nodes);
      t = claim_space(button_nodes);
      span = claim_element(button_nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot) default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file145, 131, 4, 3893);
      set_attributes(button, button_data);
      toggle_class(button, "bx--tag", true);
      toggle_class(button, "bx--tag--interactive", true);
      toggle_class(
        button,
        "bx--tag--disabled",
        /*disabled*/
        ctx[3]
      );
      toggle_class(
        button,
        "bx--tag--sm",
        /*size*/
        ctx[1] === "sm"
      );
      toggle_class(
        button,
        "bx--tag--red",
        /*type*/
        ctx[0] === "red"
      );
      toggle_class(
        button,
        "bx--tag--magenta",
        /*type*/
        ctx[0] === "magenta"
      );
      toggle_class(
        button,
        "bx--tag--purple",
        /*type*/
        ctx[0] === "purple"
      );
      toggle_class(
        button,
        "bx--tag--blue",
        /*type*/
        ctx[0] === "blue"
      );
      toggle_class(
        button,
        "bx--tag--cyan",
        /*type*/
        ctx[0] === "cyan"
      );
      toggle_class(
        button,
        "bx--tag--teal",
        /*type*/
        ctx[0] === "teal"
      );
      toggle_class(
        button,
        "bx--tag--green",
        /*type*/
        ctx[0] === "green"
      );
      toggle_class(
        button,
        "bx--tag--gray",
        /*type*/
        ctx[0] === "gray"
      );
      toggle_class(
        button,
        "bx--tag--cool-gray",
        /*type*/
        ctx[0] === "cool-gray"
      );
      toggle_class(
        button,
        "bx--tag--warm-gray",
        /*type*/
        ctx[0] === "warm-gray"
      );
      toggle_class(
        button,
        "bx--tag--high-contrast",
        /*type*/
        ctx[0] === "high-contrast"
      );
      toggle_class(
        button,
        "bx--tag--outline",
        /*type*/
        ctx[0] === "outline"
      );
      add_location(button, file145, 96, 2, 2736);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (if_block) if_block.m(button, null);
      append_hydration_dev(button, t);
      append_hydration_dev(button, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler_2*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseover",
            /*mouseover_handler_2*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseenter",
            /*mouseenter_handler_2*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseleave",
            /*mouseleave_handler_2*/
            ctx[21],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[11].icon || /*icon*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots, icon*/
          2176) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_316(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(button, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & /*id*/
        256) && { id: (
          /*id*/
          ctx2[8]
        ) },
        (!current || dirty & /*disabled*/
        8) && { disabled: (
          /*disabled*/
          ctx2[3]
        ) },
        (!current || dirty & /*disabled*/
        8) && { "aria-disabled": (
          /*disabled*/
          ctx2[3]
        ) },
        (!current || dirty & /*disabled*/
        8 && button_tabindex_value !== (button_tabindex_value = /*disabled*/
        ctx2[3] ? "-1" : void 0)) && { tabindex: button_tabindex_value },
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10]
      ]));
      toggle_class(button, "bx--tag", true);
      toggle_class(button, "bx--tag--interactive", true);
      toggle_class(
        button,
        "bx--tag--disabled",
        /*disabled*/
        ctx2[3]
      );
      toggle_class(
        button,
        "bx--tag--sm",
        /*size*/
        ctx2[1] === "sm"
      );
      toggle_class(
        button,
        "bx--tag--red",
        /*type*/
        ctx2[0] === "red"
      );
      toggle_class(
        button,
        "bx--tag--magenta",
        /*type*/
        ctx2[0] === "magenta"
      );
      toggle_class(
        button,
        "bx--tag--purple",
        /*type*/
        ctx2[0] === "purple"
      );
      toggle_class(
        button,
        "bx--tag--blue",
        /*type*/
        ctx2[0] === "blue"
      );
      toggle_class(
        button,
        "bx--tag--cyan",
        /*type*/
        ctx2[0] === "cyan"
      );
      toggle_class(
        button,
        "bx--tag--teal",
        /*type*/
        ctx2[0] === "teal"
      );
      toggle_class(
        button,
        "bx--tag--green",
        /*type*/
        ctx2[0] === "green"
      );
      toggle_class(
        button,
        "bx--tag--gray",
        /*type*/
        ctx2[0] === "gray"
      );
      toggle_class(
        button,
        "bx--tag--cool-gray",
        /*type*/
        ctx2[0] === "cool-gray"
      );
      toggle_class(
        button,
        "bx--tag--warm-gray",
        /*type*/
        ctx2[0] === "warm-gray"
      );
      toggle_class(
        button,
        "bx--tag--high-contrast",
        /*type*/
        ctx2[0] === "high-contrast"
      );
      toggle_class(
        button,
        "bx--tag--outline",
        /*type*/
        ctx2[0] === "outline"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_222.name,
    type: "if",
    source: "(96:22) ",
    ctx
  });
  return block;
}
function create_if_block_136(ctx) {
  let div;
  let t;
  let button;
  let close;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context11
  );
  const default_slot_or_fallback = default_slot || fallback_block30(ctx);
  close = new Close_default({ $$inline: true });
  let div_levels = [
    { "aria-label": (
      /*title*/
      ctx[6]
    ) },
    { id: (
      /*id*/
      ctx[8]
    ) },
    /*$$restProps*/
    ctx[10]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      t = space();
      button = element("button");
      create_component(close.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "aria-label": true, id: true });
      var div_nodes = children(div);
      if (default_slot_or_fallback) default_slot_or_fallback.l(div_nodes);
      t = claim_space(div_nodes);
      button = claim_element(div_nodes, "BUTTON", {
        type: true,
        "aria-labelledby": true,
        title: true
      });
      var button_nodes = children(button);
      claim_component(close.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "aria-labelledby",
        /*id*/
        ctx[8]
      );
      button.disabled = /*disabled*/
      ctx[3];
      attr_dev(
        button,
        "title",
        /*title*/
        ctx[6]
      );
      toggle_class(button, "bx--tag__close-icon", true);
      add_location(button, file145, 78, 4, 2350);
      set_attributes(div, div_data);
      toggle_class(div, "bx--tag", true);
      toggle_class(
        div,
        "bx--tag--disabled",
        /*disabled*/
        ctx[3]
      );
      toggle_class(
        div,
        "bx--tag--filter",
        /*filter*/
        ctx[2]
      );
      toggle_class(
        div,
        "bx--tag--sm",
        /*size*/
        ctx[1] === "sm"
      );
      toggle_class(
        div,
        "bx--tag--red",
        /*type*/
        ctx[0] === "red"
      );
      toggle_class(
        div,
        "bx--tag--magenta",
        /*type*/
        ctx[0] === "magenta"
      );
      toggle_class(
        div,
        "bx--tag--purple",
        /*type*/
        ctx[0] === "purple"
      );
      toggle_class(
        div,
        "bx--tag--blue",
        /*type*/
        ctx[0] === "blue"
      );
      toggle_class(
        div,
        "bx--tag--cyan",
        /*type*/
        ctx[0] === "cyan"
      );
      toggle_class(
        div,
        "bx--tag--teal",
        /*type*/
        ctx[0] === "teal"
      );
      toggle_class(
        div,
        "bx--tag--green",
        /*type*/
        ctx[0] === "green"
      );
      toggle_class(
        div,
        "bx--tag--gray",
        /*type*/
        ctx[0] === "gray"
      );
      toggle_class(
        div,
        "bx--tag--cool-gray",
        /*type*/
        ctx[0] === "cool-gray"
      );
      toggle_class(
        div,
        "bx--tag--warm-gray",
        /*type*/
        ctx[0] === "warm-gray"
      );
      toggle_class(
        div,
        "bx--tag--high-contrast",
        /*type*/
        ctx[0] === "high-contrast"
      );
      toggle_class(
        div,
        "bx--tag--outline",
        /*type*/
        ctx[0] === "outline"
      );
      add_location(div, file145, 54, 2, 1433);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      append_hydration_dev(div, t);
      append_hydration_dev(div, button);
      mount_component(close, button, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", stop_propagation(
            /*click_handler_1*/
            ctx[14]
          ), false, false, true, false),
          listen_dev(button, "click", stop_propagation(
            /*click_handler_4*/
            ctx[30]
          ), false, false, true, false),
          listen_dev(
            button,
            "mouseover",
            /*mouseover_handler_1*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseleave",
            /*mouseleave_handler_1*/
            ctx[17],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes11
            ),
            get_default_slot_context11
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*type*/
        1)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*id*/
      256) {
        attr_dev(
          button,
          "aria-labelledby",
          /*id*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*disabled*/
      8) {
        prop_dev(
          button,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*title*/
      64) {
        attr_dev(
          button,
          "title",
          /*title*/
          ctx2[6]
        );
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*title*/
        64) && { "aria-label": (
          /*title*/
          ctx2[6]
        ) },
        (!current || dirty & /*id*/
        256) && { id: (
          /*id*/
          ctx2[8]
        ) },
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10]
      ]));
      toggle_class(div, "bx--tag", true);
      toggle_class(
        div,
        "bx--tag--disabled",
        /*disabled*/
        ctx2[3]
      );
      toggle_class(
        div,
        "bx--tag--filter",
        /*filter*/
        ctx2[2]
      );
      toggle_class(
        div,
        "bx--tag--sm",
        /*size*/
        ctx2[1] === "sm"
      );
      toggle_class(
        div,
        "bx--tag--red",
        /*type*/
        ctx2[0] === "red"
      );
      toggle_class(
        div,
        "bx--tag--magenta",
        /*type*/
        ctx2[0] === "magenta"
      );
      toggle_class(
        div,
        "bx--tag--purple",
        /*type*/
        ctx2[0] === "purple"
      );
      toggle_class(
        div,
        "bx--tag--blue",
        /*type*/
        ctx2[0] === "blue"
      );
      toggle_class(
        div,
        "bx--tag--cyan",
        /*type*/
        ctx2[0] === "cyan"
      );
      toggle_class(
        div,
        "bx--tag--teal",
        /*type*/
        ctx2[0] === "teal"
      );
      toggle_class(
        div,
        "bx--tag--green",
        /*type*/
        ctx2[0] === "green"
      );
      toggle_class(
        div,
        "bx--tag--gray",
        /*type*/
        ctx2[0] === "gray"
      );
      toggle_class(
        div,
        "bx--tag--cool-gray",
        /*type*/
        ctx2[0] === "cool-gray"
      );
      toggle_class(
        div,
        "bx--tag--warm-gray",
        /*type*/
        ctx2[0] === "warm-gray"
      );
      toggle_class(
        div,
        "bx--tag--high-contrast",
        /*type*/
        ctx2[0] === "high-contrast"
      );
      toggle_class(
        div,
        "bx--tag--outline",
        /*type*/
        ctx2[0] === "outline"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      destroy_component(close);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_136.name,
    type: "if",
    source: "(54:17) ",
    ctx
  });
  return block;
}
function create_if_block88(ctx) {
  let tagskeleton;
  let current;
  const tagskeleton_spread_levels = [
    { size: (
      /*size*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[10]
  ];
  let tagskeleton_props = {};
  for (let i = 0; i < tagskeleton_spread_levels.length; i += 1) {
    tagskeleton_props = assign(tagskeleton_props, tagskeleton_spread_levels[i]);
  }
  tagskeleton = new TagSkeleton_default({ props: tagskeleton_props, $$inline: true });
  tagskeleton.$on(
    "click",
    /*click_handler*/
    ctx[26]
  );
  tagskeleton.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[27]
  );
  tagskeleton.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx[28]
  );
  tagskeleton.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx[29]
  );
  const block = {
    c: function create() {
      create_component(tagskeleton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tagskeleton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tagskeleton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tagskeleton_changes = dirty & /*size, $$restProps*/
      1026 ? get_spread_update(tagskeleton_spread_levels, [
        dirty & /*size*/
        2 && { size: (
          /*size*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        1024 && get_spread_object(
          /*$$restProps*/
          ctx2[10]
        )
      ]) : {};
      tagskeleton.$set(tagskeleton_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(tagskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tagskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tagskeleton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block88.name,
    type: "if",
    source: "(45:0) {#if skeleton}",
    ctx
  });
  return block;
}
function create_if_block_412(ctx) {
  let div;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[13].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_icon_slot_context_14
  );
  const icon_slot_or_fallback = icon_slot || fallback_block_25(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback) icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (icon_slot_or_fallback) icon_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--tag__custom-icon", true);
      add_location(div, file145, 161, 6, 4847);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_icon_slot_changes_14
            ),
            get_icon_slot_context_14
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*icon*/
        128)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_412.name,
    type: "if",
    source: "(161:4) {#if $$slots.icon || icon}",
    ctx
  });
  return block;
}
function fallback_block_25(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[7]
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*icon*/
      128 && switch_value !== (switch_value = /*icon*/
      ctx2[7])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_25.name,
    type: "fallback",
    source: "(163:26)            ",
    ctx
  });
  return block;
}
function create_if_block_316(ctx) {
  let div;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[13].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_icon_slot_context4
  );
  const icon_slot_or_fallback = icon_slot || fallback_block_112(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback) icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (icon_slot_or_fallback) icon_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--tag__custom-icon", true);
      add_location(div, file145, 125, 6, 3736);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_icon_slot_changes4
            ),
            get_icon_slot_context4
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*icon*/
        128)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_316.name,
    type: "if",
    source: "(125:4) {#if $$slots.icon || icon}",
    ctx
  });
  return block;
}
function fallback_block_112(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[7]
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*icon*/
      128 && switch_value !== (switch_value = /*icon*/
      ctx2[7])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_112.name,
    type: "fallback",
    source: "(127:26)            ",
    ctx
  });
  return block;
}
function fallback_block30(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*type*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*type*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--tag__label", true);
      add_location(span, file145, 76, 6, 2284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*type*/
      1) set_data_dev(
        t,
        /*type*/
        ctx2[0]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block30.name,
    type: "fallback",
    source: "(76:48)        ",
    ctx
  });
  return block;
}
function create_fragment155(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block88, create_if_block_136, create_if_block_222, create_else_block29];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*skeleton*/
      ctx2[5]
    ) return 0;
    if (
      /*filter*/
      ctx2[2]
    ) return 1;
    if (
      /*interactive*/
      ctx2[4]
    ) return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment155.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance155($$self, $$props, $$invalidate) {
  const omit_props_names = ["type", "size", "filter", "disabled", "interactive", "skeleton", "title", "icon", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tag", slots, ["default", "icon"]);
  const $$slots = compute_slots(slots);
  let { type = void 0 } = $$props;
  let { size = "default" } = $$props;
  let { filter = false } = $$props;
  let { disabled = false } = $$props;
  let { interactive = false } = $$props;
  let { skeleton = false } = $$props;
  let { title = "Clear filter" } = $$props;
  let { icon = void 0 } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  const dispatch = createEventDispatcher();
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_3(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_3(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_3(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_3(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_4 = () => {
    dispatch("close");
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props) $$invalidate(0, type = $$new_props.type);
    if ("size" in $$new_props) $$invalidate(1, size = $$new_props.size);
    if ("filter" in $$new_props) $$invalidate(2, filter = $$new_props.filter);
    if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
    if ("interactive" in $$new_props) $$invalidate(4, interactive = $$new_props.interactive);
    if ("skeleton" in $$new_props) $$invalidate(5, skeleton = $$new_props.skeleton);
    if ("title" in $$new_props) $$invalidate(6, title = $$new_props.title);
    if ("icon" in $$new_props) $$invalidate(7, icon = $$new_props.icon);
    if ("id" in $$new_props) $$invalidate(8, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    type,
    size,
    filter,
    disabled,
    interactive,
    skeleton,
    title,
    icon,
    id,
    createEventDispatcher,
    Close: Close_default,
    TagSkeleton: TagSkeleton_default,
    dispatch
  });
  $$self.$inject_state = ($$new_props) => {
    if ("type" in $$props) $$invalidate(0, type = $$new_props.type);
    if ("size" in $$props) $$invalidate(1, size = $$new_props.size);
    if ("filter" in $$props) $$invalidate(2, filter = $$new_props.filter);
    if ("disabled" in $$props) $$invalidate(3, disabled = $$new_props.disabled);
    if ("interactive" in $$props) $$invalidate(4, interactive = $$new_props.interactive);
    if ("skeleton" in $$props) $$invalidate(5, skeleton = $$new_props.skeleton);
    if ("title" in $$props) $$invalidate(6, title = $$new_props.title);
    if ("icon" in $$props) $$invalidate(7, icon = $$new_props.icon);
    if ("id" in $$props) $$invalidate(8, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    type,
    size,
    filter,
    disabled,
    interactive,
    skeleton,
    title,
    icon,
    id,
    dispatch,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    click_handler_2,
    mouseover_handler_2,
    mouseenter_handler_2,
    mouseleave_handler_2,
    click_handler_3,
    mouseover_handler_3,
    mouseenter_handler_3,
    mouseleave_handler_3,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler_4
  ];
}
var Tag = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance155, create_fragment155, safe_not_equal, {
      type: 0,
      size: 1,
      filter: 2,
      disabled: 3,
      interactive: 4,
      skeleton: 5,
      title: 6,
      icon: 7,
      id: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tag",
      options,
      id: create_fragment155.name
    });
  }
  get type() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filter() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filter(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skeleton() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skeleton(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tag_default = Tag;

// node_modules/carbon-components-svelte/src/TextArea/TextArea.svelte
var file146 = "node_modules/carbon-components-svelte/src/TextArea/TextArea.svelte";
var get_labelText_slot_changes11 = (dirty) => ({});
var get_labelText_slot_context11 = (ctx) => ({});
function create_if_block_317(ctx) {
  let div;
  let label;
  let t;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[20].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_labelText_slot_context11
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block31(ctx);
  let if_block = (
    /*maxCount*/
    ctx[5] && create_if_block_413(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      label = element("label");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      t = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      label = claim_element(div_nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(label_nodes);
      label_nodes.forEach(detach_dev);
      t = claim_space(div_nodes);
      if (if_block) if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[14]
      );
      toggle_class(label, "bx--label", true);
      toggle_class(
        label,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[11]
      );
      toggle_class(
        label,
        "bx--label--disabled",
        /*disabled*/
        ctx[7]
      );
      add_location(label, file146, 75, 6, 1798);
      toggle_class(div, "bx--text-area__label-wrapper", true);
      add_location(div, file146, 74, 4, 1742);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, label);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      append_hydration_dev(div, t);
      if (if_block) if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & /*$$scope*/
        524288)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_labelText_slot_changes11
            ),
            get_labelText_slot_context11
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & /*labelText*/
        1024)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      16384) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*hideLabel*/
      2048) {
        toggle_class(
          label,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      128) {
        toggle_class(
          label,
          "bx--label--disabled",
          /*disabled*/
          ctx2[7]
        );
      }
      if (
        /*maxCount*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_413(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_317.name,
    type: "if",
    source: "(74:2) {#if (labelText || $$slots.labelText) && !hideLabel}",
    ctx
  });
  return block;
}
function fallback_block31(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[10]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[10]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelText*/
      1024) set_data_dev(
        t,
        /*labelText*/
        ctx2[10]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block31.name,
    type: "fallback",
    source: "(82:31)            ",
    ctx
  });
  return block;
}
function create_if_block_413(ctx) {
  let div;
  let t0_value = (
    /*value*/
    ctx[0].length + ""
  );
  let t0;
  let t1;
  let t2;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = text("/");
      t2 = text(
        /*maxCount*/
        ctx[5]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, t0_value);
      t1 = claim_text(div_nodes, "/");
      t2 = claim_text(
        div_nodes,
        /*maxCount*/
        ctx[5]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--label", true);
      toggle_class(
        div,
        "bx--label--disabled",
        /*disabled*/
        ctx[7]
      );
      add_location(div, file146, 86, 8, 2074);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*value*/
      1 && t0_value !== (t0_value = /*value*/
      ctx2[0].length + "")) set_data_dev(t0, t0_value);
      if (dirty[0] & /*maxCount*/
      32) set_data_dev(
        t2,
        /*maxCount*/
        ctx2[5]
      );
      if (dirty[0] & /*disabled*/
      128) {
        toggle_class(
          div,
          "bx--label--disabled",
          /*disabled*/
          ctx2[7]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_413.name,
    type: "if",
    source: "(86:6) {#if maxCount}",
    ctx
  });
  return block;
}
function create_if_block_223(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--text-area__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_223.name,
    type: "if",
    source: "(97:4) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_137(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[9]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[9]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(
        div,
        "bx--form__helper-text--disabled",
        /*disabled*/
        ctx[7]
      );
      add_location(div, file146, 125, 4, 3084);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*helperText*/
      512) set_data_dev(
        t,
        /*helperText*/
        ctx2[9]
      );
      if (dirty[0] & /*disabled*/
      128) {
        toggle_class(
          div,
          "bx--form__helper-text--disabled",
          /*disabled*/
          ctx2[7]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_137.name,
    type: "if",
    source: "(125:2) {#if !invalid && helperText}",
    ctx
  });
  return block;
}
function create_if_block89(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*invalidText*/
        ctx[13]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*invalidText*/
        ctx[13]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*errorId*/
        ctx[16]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file146, 133, 4, 3253);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*invalidText*/
      8192) set_data_dev(
        t,
        /*invalidText*/
        ctx2[13]
      );
      if (dirty[0] & /*errorId*/
      65536) {
        attr_dev(
          div,
          "id",
          /*errorId*/
          ctx2[16]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block89.name,
    type: "if",
    source: "(133:2) {#if invalid}",
    ctx
  });
  return block;
}
function create_fragment156(ctx) {
  let div1;
  let t0;
  let div0;
  let t1;
  let textarea;
  let textarea_aria_invalid_value;
  let textarea_aria_describedby_value;
  let textarea_maxlength_value;
  let div0_data_invalid_value;
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*labelText*/
    (ctx[10] || /*$$slots*/
    ctx[17].labelText) && !/*hideLabel*/
    ctx[11] && create_if_block_317(ctx)
  );
  let if_block1 = (
    /*invalid*/
    ctx[12] && create_if_block_223(ctx)
  );
  let textarea_levels = [
    {
      "aria-invalid": textarea_aria_invalid_value = /*invalid*/
      ctx[12] || void 0
    },
    {
      "aria-describedby": textarea_aria_describedby_value = /*invalid*/
      ctx[12] ? (
        /*errorId*/
        ctx[16]
      ) : void 0
    },
    { disabled: (
      /*disabled*/
      ctx[7]
    ) },
    { id: (
      /*id*/
      ctx[14]
    ) },
    { name: (
      /*name*/
      ctx[15]
    ) },
    { cols: (
      /*cols*/
      ctx[3]
    ) },
    { rows: (
      /*rows*/
      ctx[4]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[2]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[8]
    ) },
    {
      maxlength: textarea_maxlength_value = /*maxCount*/
      ctx[5] ?? void 0
    },
    /*$$restProps*/
    ctx[18]
  ];
  let textarea_data = {};
  for (let i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }
  let if_block2 = !/*invalid*/
  ctx[12] && /*helperText*/
  ctx[9] && create_if_block_137(ctx);
  let if_block3 = (
    /*invalid*/
    ctx[12] && create_if_block89(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      div0 = element("div");
      if (if_block1) if_block1.c();
      t1 = space();
      textarea = element("textarea");
      t2 = space();
      if (if_block2) if_block2.c();
      t3 = space();
      if (if_block3) if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      if (if_block0) if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { "data-invalid": true });
      var div0_nodes = children(div0);
      if (if_block1) if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      textarea = claim_element(div0_nodes, "TEXTAREA", {
        "aria-invalid": true,
        "aria-describedby": true,
        id: true,
        name: true,
        cols: true,
        rows: true,
        placeholder: true,
        maxlength: true
      });
      children(textarea).forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (if_block2) if_block2.l(div1_nodes);
      t3 = claim_space(div1_nodes);
      if (if_block3) if_block3.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(textarea, textarea_data);
      toggle_class(textarea, "bx--text-area", true);
      toggle_class(
        textarea,
        "bx--text-area--light",
        /*light*/
        ctx[6]
      );
      toggle_class(
        textarea,
        "bx--text-area--invalid",
        /*invalid*/
        ctx[12]
      );
      add_location(textarea, file146, 99, 4, 2413);
      attr_dev(div0, "data-invalid", div0_data_invalid_value = /*invalid*/
      ctx[12] || void 0);
      toggle_class(div0, "bx--text-area__wrapper", true);
      add_location(div0, file146, 92, 2, 2228);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file146, 66, 0, 1587);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0) if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      if (if_block1) if_block1.m(div0, null);
      append_hydration_dev(div0, t1);
      append_hydration_dev(div0, textarea);
      if (textarea.autofocus) textarea.focus();
      ctx[32](textarea);
      set_input_value(
        textarea,
        /*value*/
        ctx[0]
      );
      append_hydration_dev(div1, t2);
      if (if_block2) if_block2.m(div1, null);
      append_hydration_dev(div1, t3);
      if (if_block3) if_block3.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[33]
          ),
          listen_dev(
            textarea,
            "change",
            /*change_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "input",
            /*input_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "keydown",
            /*keydown_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "keyup",
            /*keyup_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "focus",
            /*focus_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "blur",
            /*blur_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "paste",
            /*paste_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseover",
            /*mouseover_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*labelText*/
        (ctx2[10] || /*$$slots*/
        ctx2[17].labelText) && !/*hideLabel*/
        ctx2[11]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*labelText, $$slots, hideLabel*/
          134144) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_317(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*invalid*/
        ctx2[12]
      ) {
        if (if_block1) {
          if (dirty[0] & /*invalid*/
          4096) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_223(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        (!current || dirty[0] & /*invalid*/
        4096 && textarea_aria_invalid_value !== (textarea_aria_invalid_value = /*invalid*/
        ctx2[12] || void 0)) && {
          "aria-invalid": textarea_aria_invalid_value
        },
        (!current || dirty[0] & /*invalid, errorId*/
        69632 && textarea_aria_describedby_value !== (textarea_aria_describedby_value = /*invalid*/
        ctx2[12] ? (
          /*errorId*/
          ctx2[16]
        ) : void 0)) && {
          "aria-describedby": textarea_aria_describedby_value
        },
        (!current || dirty[0] & /*disabled*/
        128) && { disabled: (
          /*disabled*/
          ctx2[7]
        ) },
        (!current || dirty[0] & /*id*/
        16384) && { id: (
          /*id*/
          ctx2[14]
        ) },
        (!current || dirty[0] & /*name*/
        32768) && { name: (
          /*name*/
          ctx2[15]
        ) },
        (!current || dirty[0] & /*cols*/
        8) && { cols: (
          /*cols*/
          ctx2[3]
        ) },
        (!current || dirty[0] & /*rows*/
        16) && { rows: (
          /*rows*/
          ctx2[4]
        ) },
        (!current || dirty[0] & /*placeholder*/
        4) && { placeholder: (
          /*placeholder*/
          ctx2[2]
        ) },
        (!current || dirty[0] & /*readonly*/
        256) && { readOnly: (
          /*readonly*/
          ctx2[8]
        ) },
        (!current || dirty[0] & /*maxCount*/
        32 && textarea_maxlength_value !== (textarea_maxlength_value = /*maxCount*/
        ctx2[5] ?? void 0)) && { maxlength: textarea_maxlength_value },
        dirty[0] & /*$$restProps*/
        262144 && /*$$restProps*/
        ctx2[18]
      ]));
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          textarea,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(textarea, "bx--text-area", true);
      toggle_class(
        textarea,
        "bx--text-area--light",
        /*light*/
        ctx2[6]
      );
      toggle_class(
        textarea,
        "bx--text-area--invalid",
        /*invalid*/
        ctx2[12]
      );
      if (!current || dirty[0] & /*invalid*/
      4096 && div0_data_invalid_value !== (div0_data_invalid_value = /*invalid*/
      ctx2[12] || void 0)) {
        attr_dev(div0, "data-invalid", div0_data_invalid_value);
      }
      if (!/*invalid*/
      ctx2[12] && /*helperText*/
      ctx2[9]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_137(ctx2);
          if_block2.c();
          if_block2.m(div1, t3);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*invalid*/
        ctx2[12]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block89(ctx2);
          if_block3.c();
          if_block3.m(div1, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      ctx[32](null);
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment156.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance156($$self, $$props, $$invalidate) {
  let errorId;
  const omit_props_names = [
    "value",
    "placeholder",
    "cols",
    "rows",
    "maxCount",
    "light",
    "disabled",
    "readonly",
    "helperText",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextArea", slots, ["labelText"]);
  const $$slots = compute_slots(slots);
  let { value = "" } = $$props;
  let { placeholder = "" } = $$props;
  let { cols = 50 } = $$props;
  let { rows = 4 } = $$props;
  let { maxCount = void 0 } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { readonly: readonly2 = false } = $$props;
  let { helperText = "" } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    if ("placeholder" in $$new_props) $$invalidate(2, placeholder = $$new_props.placeholder);
    if ("cols" in $$new_props) $$invalidate(3, cols = $$new_props.cols);
    if ("rows" in $$new_props) $$invalidate(4, rows = $$new_props.rows);
    if ("maxCount" in $$new_props) $$invalidate(5, maxCount = $$new_props.maxCount);
    if ("light" in $$new_props) $$invalidate(6, light = $$new_props.light);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("readonly" in $$new_props) $$invalidate(8, readonly2 = $$new_props.readonly);
    if ("helperText" in $$new_props) $$invalidate(9, helperText = $$new_props.helperText);
    if ("labelText" in $$new_props) $$invalidate(10, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props) $$invalidate(11, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$new_props) $$invalidate(12, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props) $$invalidate(13, invalidText = $$new_props.invalidText);
    if ("id" in $$new_props) $$invalidate(14, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(15, name = $$new_props.name);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    placeholder,
    cols,
    rows,
    maxCount,
    light,
    disabled,
    readonly: readonly2,
    helperText,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    id,
    name,
    ref,
    WarningFilled: WarningFilled_default,
    errorId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    if ("placeholder" in $$props) $$invalidate(2, placeholder = $$new_props.placeholder);
    if ("cols" in $$props) $$invalidate(3, cols = $$new_props.cols);
    if ("rows" in $$props) $$invalidate(4, rows = $$new_props.rows);
    if ("maxCount" in $$props) $$invalidate(5, maxCount = $$new_props.maxCount);
    if ("light" in $$props) $$invalidate(6, light = $$new_props.light);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("readonly" in $$props) $$invalidate(8, readonly2 = $$new_props.readonly);
    if ("helperText" in $$props) $$invalidate(9, helperText = $$new_props.helperText);
    if ("labelText" in $$props) $$invalidate(10, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props) $$invalidate(11, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$props) $$invalidate(12, invalid = $$new_props.invalid);
    if ("invalidText" in $$props) $$invalidate(13, invalidText = $$new_props.invalidText);
    if ("id" in $$props) $$invalidate(14, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(15, name = $$new_props.name);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("errorId" in $$props) $$invalidate(16, errorId = $$new_props.errorId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*id*/
    16384) {
      $: $$invalidate(16, errorId = `error-${id}`);
    }
  };
  return [
    value,
    ref,
    placeholder,
    cols,
    rows,
    maxCount,
    light,
    disabled,
    readonly2,
    helperText,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    id,
    name,
    errorId,
    $$slots,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    change_handler,
    input_handler,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    paste_handler,
    textarea_binding,
    textarea_input_handler
  ];
}
var TextArea = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance156,
      create_fragment156,
      safe_not_equal,
      {
        value: 0,
        placeholder: 2,
        cols: 3,
        rows: 4,
        maxCount: 5,
        light: 6,
        disabled: 7,
        readonly: 8,
        helperText: 9,
        labelText: 10,
        hideLabel: 11,
        invalid: 12,
        invalidText: 13,
        id: 14,
        name: 15,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextArea",
      options,
      id: create_fragment156.name
    });
  }
  get value() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cols() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cols(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxCount() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxCount(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextArea_default = TextArea;

// node_modules/carbon-components-svelte/src/TextArea/TextAreaSkeleton.svelte
var file147 = "node_modules/carbon-components-svelte/src/TextArea/TextAreaSkeleton.svelte";
function create_if_block90(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file147, 16, 4, 361);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block90.name,
    type: "if",
    source: "(16:2) {#if !hideLabel}",
    ctx
  });
  return block;
}
function create_fragment157(ctx) {
  let div1;
  let t;
  let div0;
  let mounted;
  let dispose;
  let if_block = !/*hideLabel*/
  ctx[0] && create_if_block90(ctx);
  let div1_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block) if_block.c();
      t = space();
      div0 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      if (if_block) if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--skeleton", true);
      toggle_class(div0, "bx--text-area", true);
      add_location(div0, file147, 18, 2, 438);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file147, 7, 0, 223);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block) if_block.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseover",
            /*mouseover_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!/*hideLabel*/
      ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block90(ctx2);
          if_block.c();
          if_block.m(div1, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment157.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance157($$self, $$props, $$invalidate) {
  const omit_props_names = ["hideLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextAreaSkeleton", slots, []);
  let { hideLabel = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("hideLabel" in $$new_props) $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  $$self.$capture_state = () => ({ hideLabel });
  $$self.$inject_state = ($$new_props) => {
    if ("hideLabel" in $$props) $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    hideLabel,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var TextAreaSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance157, create_fragment157, safe_not_equal, { hideLabel: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextAreaSkeleton",
      options,
      id: create_fragment157.name
    });
  }
  get hideLabel() {
    throw new Error("<TextAreaSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<TextAreaSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextAreaSkeleton_default = TextAreaSkeleton;

// node_modules/carbon-components-svelte/src/TextInput/TextInput.svelte
var file148 = "node_modules/carbon-components-svelte/src/TextInput/TextInput.svelte";
var get_labelText_slot_changes_12 = (dirty) => ({});
var get_labelText_slot_context_12 = (ctx) => ({});
var get_labelText_slot_changes12 = (dirty) => ({});
var get_labelText_slot_context12 = (ctx) => ({});
function create_if_block_103(ctx) {
  let div;
  let t;
  let current;
  let if_block0 = (
    /*labelText*/
    ctx[9] && create_if_block_1210(ctx)
  );
  let if_block1 = !/*isFluid*/
  ctx[22] && /*helperText*/
  ctx[6] && create_if_block_1110(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0) if_block0.c();
      t = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block0) if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1) if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--text-input__label-helper-wrapper", true);
      add_location(div, file148, 118, 4, 3022);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append_hydration_dev(div, t);
      if (if_block1) if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*labelText*/
        ctx2[9]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*labelText*/
          512) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1210(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*isFluid*/
      ctx2[22] && /*helperText*/
      ctx2[6]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1110(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_103.name,
    type: "if",
    source: "(118:2) {#if inline}",
    ctx
  });
  return block;
}
function create_if_block_1210(ctx) {
  let label;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[28].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    get_labelText_slot_context12
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block_113(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[7]
      );
      toggle_class(label, "bx--label", true);
      toggle_class(
        label,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[10]
      );
      toggle_class(
        label,
        "bx--label--disabled",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        label,
        "bx--label--inline",
        /*inline*/
        ctx[16]
      );
      toggle_class(
        label,
        "bx--label--inline--sm",
        /*size*/
        ctx[2] === "sm"
      );
      toggle_class(
        label,
        "bx--label--inline--xl",
        /*size*/
        ctx[2] === "xl"
      );
      add_location(label, file148, 120, 8, 3110);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & /*$$scope*/
        134217728)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              get_labelText_slot_changes12
            ),
            get_labelText_slot_context12
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & /*labelText*/
        512)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      128) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*hideLabel*/
      1024) {
        toggle_class(
          label,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      32) {
        toggle_class(
          label,
          "bx--label--disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*inline*/
      65536) {
        toggle_class(
          label,
          "bx--label--inline",
          /*inline*/
          ctx2[16]
        );
      }
      if (!current || dirty[0] & /*size*/
      4) {
        toggle_class(
          label,
          "bx--label--inline--sm",
          /*size*/
          ctx2[2] === "sm"
        );
      }
      if (!current || dirty[0] & /*size*/
      4) {
        toggle_class(
          label,
          "bx--label--inline--xl",
          /*size*/
          ctx2[2] === "xl"
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1210.name,
    type: "if",
    source: "(120:6) {#if labelText}",
    ctx
  });
  return block;
}
function fallback_block_113(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[9]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[9]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelText*/
      512) set_data_dev(
        t,
        /*labelText*/
        ctx2[9]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_113.name,
    type: "fallback",
    source: "(130:33)              ",
    ctx
  });
  return block;
}
function create_if_block_1110(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[6]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[6]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(
        div,
        "bx--form__helper-text--disabled",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        div,
        "bx--form__helper-text--inline",
        /*inline*/
        ctx[16]
      );
      add_location(div, file148, 135, 8, 3587);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*helperText*/
      64) set_data_dev(
        t,
        /*helperText*/
        ctx2[6]
      );
      if (dirty[0] & /*disabled*/
      32) {
        toggle_class(
          div,
          "bx--form__helper-text--disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*inline*/
      65536) {
        toggle_class(
          div,
          "bx--form__helper-text--inline",
          /*inline*/
          ctx2[16]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1110.name,
    type: "if",
    source: "(135:6) {#if !isFluid && helperText}",
    ctx
  });
  return block;
}
function create_if_block_93(ctx) {
  let label;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[28].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    get_labelText_slot_context_12
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block32(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[7]
      );
      toggle_class(label, "bx--label", true);
      toggle_class(
        label,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[10]
      );
      toggle_class(
        label,
        "bx--label--disabled",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        label,
        "bx--label--inline",
        /*inline*/
        ctx[16]
      );
      toggle_class(
        label,
        "bx--label--inline-sm",
        /*inline*/
        ctx[16] && /*size*/
        ctx[2] === "sm"
      );
      toggle_class(
        label,
        "bx--label--inline-xl",
        /*inline*/
        ctx[16] && /*size*/
        ctx[2] === "xl"
      );
      add_location(label, file148, 146, 4, 3892);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & /*$$scope*/
        134217728)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              get_labelText_slot_changes_12
            ),
            get_labelText_slot_context_12
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & /*labelText*/
        512)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      128) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*hideLabel*/
      1024) {
        toggle_class(
          label,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      32) {
        toggle_class(
          label,
          "bx--label--disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*inline*/
      65536) {
        toggle_class(
          label,
          "bx--label--inline",
          /*inline*/
          ctx2[16]
        );
      }
      if (!current || dirty[0] & /*inline, size*/
      65540) {
        toggle_class(
          label,
          "bx--label--inline-sm",
          /*inline*/
          ctx2[16] && /*size*/
          ctx2[2] === "sm"
        );
      }
      if (!current || dirty[0] & /*inline, size*/
      65540) {
        toggle_class(
          label,
          "bx--label--inline-xl",
          /*inline*/
          ctx2[16] && /*size*/
          ctx2[2] === "xl"
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_93.name,
    type: "if",
    source: "(146:2) {#if !inline && (labelText || $$slots.labelText)}",
    ctx
  });
  return block;
}
function fallback_block32(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[9]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[9]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelText*/
      512) set_data_dev(
        t,
        /*labelText*/
        ctx2[9]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block32.name,
    type: "fallback",
    source: "(156:29)          ",
    ctx
  });
  return block;
}
function create_else_block30(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*invalid*/
    ctx[11] && create_if_block_85(ctx)
  );
  let if_block1 = !/*invalid*/
  ctx[11] && /*warn*/
  ctx[13] && create_if_block_76(ctx);
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*invalid*/
        ctx2[11]
      ) {
        if (if_block0) {
          if (dirty[0] & /*invalid*/
          2048) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_85(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*invalid*/
      ctx2[11] && /*warn*/
      ctx2[13]) {
        if (if_block1) {
          if (dirty[0] & /*invalid, warn*/
          10240) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_76(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block1_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block30.name,
    type: "else",
    source: "(173:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_610(ctx) {
  let editoff;
  let current;
  editoff = new EditOff_default({
    props: { class: "bx--text-input__readonly-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(editoff.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(editoff.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(editoff, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      transition_in(editoff.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(editoff.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(editoff, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_610.name,
    type: "if",
    source: "(171:6) {#if readonly}",
    ctx
  });
  return block;
}
function create_if_block_85(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--text-input__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_85.name,
    type: "if",
    source: "(174:8) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_76(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--text-input__invalid-icon\n            bx--text-input__invalid-icon--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningaltfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_76.name,
    type: "if",
    source: "(177:8) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_511(ctx) {
  let hr;
  const block = {
    c: function create() {
      hr = element("hr");
      this.h();
    },
    l: function claim(nodes) {
      hr = claim_element(nodes, "HR", {});
      this.h();
    },
    h: function hydrate() {
      toggle_class(hr, "bx--text-input__divider", true);
      add_location(hr, file148, 218, 8, 6030);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, hr, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(hr);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_511.name,
    type: "if",
    source: "(218:6) {#if isFluid}",
    ctx
  });
  return block;
}
function create_if_block_414(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*invalidText*/
        ctx[12]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*invalidText*/
        ctx[12]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*errorId*/
        ctx[19]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file148, 221, 8, 6138);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*invalidText*/
      4096) set_data_dev(
        t,
        /*invalidText*/
        ctx2[12]
      );
      if (dirty[0] & /*errorId*/
      524288) {
        attr_dev(
          div,
          "id",
          /*errorId*/
          ctx2[19]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_414.name,
    type: "if",
    source: "(221:6) {#if isFluid && !inline && invalid}",
    ctx
  });
  return block;
}
function create_if_block_318(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*warnText*/
        ctx[14]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*warnText*/
        ctx[14]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*warnId*/
        ctx[18]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file148, 226, 8, 6293);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*warnText*/
      16384) set_data_dev(
        t,
        /*warnText*/
        ctx2[14]
      );
      if (dirty[0] & /*warnId*/
      262144) {
        attr_dev(
          div,
          "id",
          /*warnId*/
          ctx2[18]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_318.name,
    type: "if",
    source: "(226:6) {#if isFluid && !inline && warn}",
    ctx
  });
  return block;
}
function create_if_block_224(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[6]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[6]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*helperId*/
        ctx[20]
      );
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(
        div,
        "bx--form__helper-text--disabled",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        div,
        "bx--form__helper-text--inline",
        /*inline*/
        ctx[16]
      );
      add_location(div, file148, 230, 6, 6459);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*helperText*/
      64) set_data_dev(
        t,
        /*helperText*/
        ctx2[6]
      );
      if (dirty[0] & /*helperId*/
      1048576) {
        attr_dev(
          div,
          "id",
          /*helperId*/
          ctx2[20]
        );
      }
      if (dirty[0] & /*disabled*/
      32) {
        toggle_class(
          div,
          "bx--form__helper-text--disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*inline*/
      65536) {
        toggle_class(
          div,
          "bx--form__helper-text--inline",
          /*inline*/
          ctx2[16]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_224.name,
    type: "if",
    source: "(230:4) {#if !invalid && !warn && !isFluid && !inline && helperText}",
    ctx
  });
  return block;
}
function create_if_block_138(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*invalidText*/
        ctx[12]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*invalidText*/
        ctx[12]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*errorId*/
        ctx[19]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file148, 240, 6, 6735);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*invalidText*/
      4096) set_data_dev(
        t,
        /*invalidText*/
        ctx2[12]
      );
      if (dirty[0] & /*errorId*/
      524288) {
        attr_dev(
          div,
          "id",
          /*errorId*/
          ctx2[19]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_138.name,
    type: "if",
    source: "(240:4) {#if !isFluid && invalid}",
    ctx
  });
  return block;
}
function create_if_block91(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*warnText*/
        ctx[14]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*warnText*/
        ctx[14]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*warnId*/
        ctx[18]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file148, 245, 6, 6882);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*warnText*/
      16384) set_data_dev(
        t,
        /*warnText*/
        ctx2[14]
      );
      if (dirty[0] & /*warnId*/
      262144) {
        attr_dev(
          div,
          "id",
          /*warnId*/
          ctx2[18]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block91.name,
    type: "if",
    source: "(245:4) {#if !isFluid && !invalid && warn}",
    ctx
  });
  return block;
}
function create_fragment158(ctx) {
  let div2;
  let t0;
  let t1;
  let div1;
  let div0;
  let current_block_type_index;
  let if_block2;
  let t2;
  let input;
  let input_data_invalid_value;
  let input_aria_invalid_value;
  let input_data_warn_value;
  let input_aria_describedby_value;
  let t3;
  let t4;
  let t5;
  let div0_data_invalid_value;
  let div0_data_warn_value;
  let t6;
  let t7;
  let t8;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*inline*/
    ctx[16] && create_if_block_103(ctx)
  );
  let if_block1 = !/*inline*/
  ctx[16] && /*labelText*/
  (ctx[9] || /*$$slots*/
  ctx[26].labelText) && create_if_block_93(ctx);
  const if_block_creators = [create_if_block_610, create_else_block30];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*readonly*/
      ctx2[17]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let input_levels = [
    {
      "data-invalid": input_data_invalid_value = /*error*/
      ctx[21] || void 0
    },
    {
      "aria-invalid": input_aria_invalid_value = /*error*/
      ctx[21] || void 0
    },
    {
      "data-warn": input_data_warn_value = /*warn*/
      ctx[13] || void 0
    },
    {
      "aria-describedby": input_aria_describedby_value = /*error*/
      ctx[21] ? (
        /*errorId*/
        ctx[19]
      ) : (
        /*warn*/
        ctx[13] ? (
          /*warnId*/
          ctx[18]
        ) : (
          /*helperText*/
          ctx[6] ? (
            /*helperId*/
            ctx[20]
          ) : void 0
        )
      )
    },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    { id: (
      /*id*/
      ctx[7]
    ) },
    { name: (
      /*name*/
      ctx[8]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[3]
    ) },
    { required: (
      /*required*/
      ctx[15]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[17]
    ) },
    /*$$restProps*/
    ctx[25]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block3 = (
    /*isFluid*/
    ctx[22] && create_if_block_511(ctx)
  );
  let if_block4 = (
    /*isFluid*/
    ctx[22] && !/*inline*/
    ctx[16] && /*invalid*/
    ctx[11] && create_if_block_414(ctx)
  );
  let if_block5 = (
    /*isFluid*/
    ctx[22] && !/*inline*/
    ctx[16] && /*warn*/
    ctx[13] && create_if_block_318(ctx)
  );
  let if_block6 = !/*invalid*/
  ctx[11] && !/*warn*/
  ctx[13] && !/*isFluid*/
  ctx[22] && !/*inline*/
  ctx[16] && /*helperText*/
  ctx[6] && create_if_block_224(ctx);
  let if_block7 = !/*isFluid*/
  ctx[22] && /*invalid*/
  ctx[11] && create_if_block_138(ctx);
  let if_block8 = !/*isFluid*/
  ctx[22] && !/*invalid*/
  ctx[11] && /*warn*/
  ctx[13] && create_if_block91(ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      div1 = element("div");
      div0 = element("div");
      if_block2.c();
      t2 = space();
      input = element("input");
      t3 = space();
      if (if_block3) if_block3.c();
      t4 = space();
      if (if_block4) if_block4.c();
      t5 = space();
      if (if_block5) if_block5.c();
      t6 = space();
      if (if_block6) if_block6.c();
      t7 = space();
      if (if_block7) if_block7.c();
      t8 = space();
      if (if_block8) if_block8.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      if (if_block0) if_block0.l(div2_nodes);
      t0 = claim_space(div2_nodes);
      if (if_block1) if_block1.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { "data-invalid": true, "data-warn": true });
      var div0_nodes = children(div0);
      if_block2.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      input = claim_element(div0_nodes, "INPUT", {
        "data-invalid": true,
        "aria-invalid": true,
        "data-warn": true,
        "aria-describedby": true,
        id: true,
        name: true,
        placeholder: true
      });
      t3 = claim_space(div0_nodes);
      if (if_block3) if_block3.l(div0_nodes);
      t4 = claim_space(div0_nodes);
      if (if_block4) if_block4.l(div0_nodes);
      t5 = claim_space(div0_nodes);
      if (if_block5) if_block5.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t6 = claim_space(div1_nodes);
      if (if_block6) if_block6.l(div1_nodes);
      t7 = claim_space(div1_nodes);
      if (if_block7) if_block7.l(div1_nodes);
      t8 = claim_space(div1_nodes);
      if (if_block8) if_block8.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "bx--text-input", true);
      toggle_class(
        input,
        "bx--text-input--light",
        /*light*/
        ctx[4]
      );
      toggle_class(
        input,
        "bx--text-input--invalid",
        /*error*/
        ctx[21]
      );
      toggle_class(
        input,
        "bx--text-input--warning",
        /*warn*/
        ctx[13]
      );
      toggle_class(
        input,
        "bx--text-input--sm",
        /*size*/
        ctx[2] === "sm"
      );
      toggle_class(
        input,
        "bx--text-input--xl",
        /*size*/
        ctx[2] === "xl"
      );
      add_location(input, file148, 183, 6, 5038);
      attr_dev(div0, "data-invalid", div0_data_invalid_value = /*error*/
      ctx[21] || void 0);
      attr_dev(div0, "data-warn", div0_data_warn_value = /*warn*/
      ctx[13] || void 0);
      toggle_class(div0, "bx--text-input__field-wrapper", true);
      toggle_class(div0, "bx--text-input__field-wrapper--warning", !/*invalid*/
      ctx[11] && /*warn*/
      ctx[13]);
      add_location(div0, file148, 164, 4, 4427);
      toggle_class(div1, "bx--text-input__field-outer-wrapper", true);
      toggle_class(
        div1,
        "bx--text-input__field-outer-wrapper--inline",
        /*inline*/
        ctx[16]
      );
      add_location(div1, file148, 160, 2, 4294);
      toggle_class(div2, "bx--form-item", true);
      toggle_class(div2, "bx--text-input-wrapper", true);
      toggle_class(
        div2,
        "bx--text-input-wrapper--inline",
        /*inline*/
        ctx[16]
      );
      toggle_class(
        div2,
        "bx--text-input-wrapper--light",
        /*light*/
        ctx[4]
      );
      toggle_class(
        div2,
        "bx--text-input-wrapper--readonly",
        /*readonly*/
        ctx[17]
      );
      add_location(div2, file148, 106, 0, 2715);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      if (if_block0) if_block0.m(div2, null);
      append_hydration_dev(div2, t0);
      if (if_block1) if_block1.m(div2, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append_hydration_dev(div0, t2);
      append_hydration_dev(div0, input);
      if (input.autofocus) input.focus();
      ctx[38](input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      append_hydration_dev(div0, t3);
      if (if_block3) if_block3.m(div0, null);
      append_hydration_dev(div0, t4);
      if (if_block4) if_block4.m(div0, null);
      append_hydration_dev(div0, t5);
      if (if_block5) if_block5.m(div0, null);
      append_hydration_dev(div1, t6);
      if (if_block6) if_block6.m(div1, null);
      append_hydration_dev(div1, t7);
      if (if_block7) if_block7.m(div1, null);
      append_hydration_dev(div1, t8);
      if (if_block8) if_block8.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[39]
          ),
          listen_dev(
            input,
            "change",
            /*onChange*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*onInput*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[35],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[36],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "paste",
            /*paste_handler*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "click",
            /*click_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseover",
            /*mouseover_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*inline*/
        ctx2[16]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*inline*/
          65536) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_103(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*inline*/
      ctx2[16] && /*labelText*/
      (ctx2[9] || /*$$slots*/
      ctx2[26].labelText)) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*inline, labelText, $$slots*/
          67174912) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_93(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div0, t2);
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        (!current || dirty[0] & /*error*/
        2097152 && input_data_invalid_value !== (input_data_invalid_value = /*error*/
        ctx2[21] || void 0)) && { "data-invalid": input_data_invalid_value },
        (!current || dirty[0] & /*error*/
        2097152 && input_aria_invalid_value !== (input_aria_invalid_value = /*error*/
        ctx2[21] || void 0)) && { "aria-invalid": input_aria_invalid_value },
        (!current || dirty[0] & /*warn*/
        8192 && input_data_warn_value !== (input_data_warn_value = /*warn*/
        ctx2[13] || void 0)) && { "data-warn": input_data_warn_value },
        (!current || dirty[0] & /*error, errorId, warn, warnId, helperText, helperId*/
        3940416 && input_aria_describedby_value !== (input_aria_describedby_value = /*error*/
        ctx2[21] ? (
          /*errorId*/
          ctx2[19]
        ) : (
          /*warn*/
          ctx2[13] ? (
            /*warnId*/
            ctx2[18]
          ) : (
            /*helperText*/
            ctx2[6] ? (
              /*helperId*/
              ctx2[20]
            ) : void 0
          )
        ))) && {
          "aria-describedby": input_aria_describedby_value
        },
        (!current || dirty[0] & /*disabled*/
        32) && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        (!current || dirty[0] & /*id*/
        128) && { id: (
          /*id*/
          ctx2[7]
        ) },
        (!current || dirty[0] & /*name*/
        256) && { name: (
          /*name*/
          ctx2[8]
        ) },
        (!current || dirty[0] & /*placeholder*/
        8) && { placeholder: (
          /*placeholder*/
          ctx2[3]
        ) },
        (!current || dirty[0] & /*required*/
        32768) && { required: (
          /*required*/
          ctx2[15]
        ) },
        (!current || dirty[0] & /*readonly*/
        131072) && { readOnly: (
          /*readonly*/
          ctx2[17]
        ) },
        dirty[0] & /*$$restProps*/
        33554432 && /*$$restProps*/
        ctx2[25]
      ]));
      if (dirty[0] & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(input, "bx--text-input", true);
      toggle_class(
        input,
        "bx--text-input--light",
        /*light*/
        ctx2[4]
      );
      toggle_class(
        input,
        "bx--text-input--invalid",
        /*error*/
        ctx2[21]
      );
      toggle_class(
        input,
        "bx--text-input--warning",
        /*warn*/
        ctx2[13]
      );
      toggle_class(
        input,
        "bx--text-input--sm",
        /*size*/
        ctx2[2] === "sm"
      );
      toggle_class(
        input,
        "bx--text-input--xl",
        /*size*/
        ctx2[2] === "xl"
      );
      if (
        /*isFluid*/
        ctx2[22]
      ) {
        if (if_block3) {
        } else {
          if_block3 = create_if_block_511(ctx2);
          if_block3.c();
          if_block3.m(div0, t4);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*isFluid*/
        ctx2[22] && !/*inline*/
        ctx2[16] && /*invalid*/
        ctx2[11]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_414(ctx2);
          if_block4.c();
          if_block4.m(div0, t5);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (
        /*isFluid*/
        ctx2[22] && !/*inline*/
        ctx2[16] && /*warn*/
        ctx2[13]
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block_318(ctx2);
          if_block5.c();
          if_block5.m(div0, null);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (!current || dirty[0] & /*error*/
      2097152 && div0_data_invalid_value !== (div0_data_invalid_value = /*error*/
      ctx2[21] || void 0)) {
        attr_dev(div0, "data-invalid", div0_data_invalid_value);
      }
      if (!current || dirty[0] & /*warn*/
      8192 && div0_data_warn_value !== (div0_data_warn_value = /*warn*/
      ctx2[13] || void 0)) {
        attr_dev(div0, "data-warn", div0_data_warn_value);
      }
      if (!current || dirty[0] & /*invalid, warn*/
      10240) {
        toggle_class(div0, "bx--text-input__field-wrapper--warning", !/*invalid*/
        ctx2[11] && /*warn*/
        ctx2[13]);
      }
      if (!/*invalid*/
      ctx2[11] && !/*warn*/
      ctx2[13] && !/*isFluid*/
      ctx2[22] && !/*inline*/
      ctx2[16] && /*helperText*/
      ctx2[6]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
        } else {
          if_block6 = create_if_block_224(ctx2);
          if_block6.c();
          if_block6.m(div1, t7);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
      if (!/*isFluid*/
      ctx2[22] && /*invalid*/
      ctx2[11]) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
        } else {
          if_block7 = create_if_block_138(ctx2);
          if_block7.c();
          if_block7.m(div1, t8);
        }
      } else if (if_block7) {
        if_block7.d(1);
        if_block7 = null;
      }
      if (!/*isFluid*/
      ctx2[22] && !/*invalid*/
      ctx2[11] && /*warn*/
      ctx2[13]) {
        if (if_block8) {
          if_block8.p(ctx2, dirty);
        } else {
          if_block8 = create_if_block91(ctx2);
          if_block8.c();
          if_block8.m(div1, null);
        }
      } else if (if_block8) {
        if_block8.d(1);
        if_block8 = null;
      }
      if (!current || dirty[0] & /*inline*/
      65536) {
        toggle_class(
          div1,
          "bx--text-input__field-outer-wrapper--inline",
          /*inline*/
          ctx2[16]
        );
      }
      if (!current || dirty[0] & /*inline*/
      65536) {
        toggle_class(
          div2,
          "bx--text-input-wrapper--inline",
          /*inline*/
          ctx2[16]
        );
      }
      if (!current || dirty[0] & /*light*/
      16) {
        toggle_class(
          div2,
          "bx--text-input-wrapper--light",
          /*light*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*readonly*/
      131072) {
        toggle_class(
          div2,
          "bx--text-input-wrapper--readonly",
          /*readonly*/
          ctx2[17]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if_blocks[current_block_type_index].d();
      ctx[38](null);
      if (if_block3) if_block3.d();
      if (if_block4) if_block4.d();
      if (if_block5) if_block5.d();
      if (if_block6) if_block6.d();
      if (if_block7) if_block7.d();
      if (if_block8) if_block8.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment158.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance158($$self, $$props, $$invalidate) {
  let isFluid;
  let error;
  let helperId;
  let errorId;
  let warnId;
  const omit_props_names = [
    "size",
    "value",
    "placeholder",
    "light",
    "disabled",
    "helperText",
    "id",
    "name",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "ref",
    "required",
    "inline",
    "readonly"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextInput", slots, ["labelText"]);
  const $$slots = compute_slots(slots);
  let { size = void 0 } = $$props;
  let { value = "" } = $$props;
  let { placeholder = "" } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { helperText = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { ref = null } = $$props;
  let { required = false } = $$props;
  let { inline = false } = $$props;
  let { readonly: readonly2 = false } = $$props;
  const ctx = getContext("Form");
  const dispatch = createEventDispatcher();
  function parse2(raw) {
    if ($$restProps.type !== "number") return raw;
    return raw != "" ? Number(raw) : null;
  }
  const onInput = (e) => {
    $$invalidate(0, value = parse2(e.target.value));
    dispatch("input", value);
  };
  const onChange = (e) => {
    dispatch("change", parse2(e.target.value));
  };
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(2, size = $$new_props.size);
    if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    if ("placeholder" in $$new_props) $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("light" in $$new_props) $$invalidate(4, light = $$new_props.light);
    if ("disabled" in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
    if ("helperText" in $$new_props) $$invalidate(6, helperText = $$new_props.helperText);
    if ("id" in $$new_props) $$invalidate(7, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(8, name = $$new_props.name);
    if ("labelText" in $$new_props) $$invalidate(9, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props) $$invalidate(10, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$new_props) $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props) $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props) $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$new_props) $$invalidate(14, warnText = $$new_props.warnText);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("required" in $$new_props) $$invalidate(15, required = $$new_props.required);
    if ("inline" in $$new_props) $$invalidate(16, inline = $$new_props.inline);
    if ("readonly" in $$new_props) $$invalidate(17, readonly2 = $$new_props.readonly);
    if ("$$scope" in $$new_props) $$invalidate(27, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    value,
    placeholder,
    light,
    disabled,
    helperText,
    id,
    name,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    warn,
    warnText,
    ref,
    required,
    inline,
    readonly: readonly2,
    createEventDispatcher,
    getContext,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    EditOff: EditOff_default,
    ctx,
    dispatch,
    parse: parse2,
    onInput,
    onChange,
    warnId,
    errorId,
    helperId,
    error,
    isFluid
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props) $$invalidate(2, size = $$new_props.size);
    if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    if ("placeholder" in $$props) $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("light" in $$props) $$invalidate(4, light = $$new_props.light);
    if ("disabled" in $$props) $$invalidate(5, disabled = $$new_props.disabled);
    if ("helperText" in $$props) $$invalidate(6, helperText = $$new_props.helperText);
    if ("id" in $$props) $$invalidate(7, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(8, name = $$new_props.name);
    if ("labelText" in $$props) $$invalidate(9, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props) $$invalidate(10, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$props) $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$props) $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$props) $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$props) $$invalidate(14, warnText = $$new_props.warnText);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("required" in $$props) $$invalidate(15, required = $$new_props.required);
    if ("inline" in $$props) $$invalidate(16, inline = $$new_props.inline);
    if ("readonly" in $$props) $$invalidate(17, readonly2 = $$new_props.readonly);
    if ("warnId" in $$props) $$invalidate(18, warnId = $$new_props.warnId);
    if ("errorId" in $$props) $$invalidate(19, errorId = $$new_props.errorId);
    if ("helperId" in $$props) $$invalidate(20, helperId = $$new_props.helperId);
    if ("error" in $$props) $$invalidate(21, error = $$new_props.error);
    if ("isFluid" in $$props) $$invalidate(22, isFluid = $$new_props.isFluid);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*invalid, readonly*/
    133120) {
      $: $$invalidate(21, error = invalid && !readonly2);
    }
    if ($$self.$$.dirty[0] & /*id*/
    128) {
      $: $$invalidate(20, helperId = `helper-${id}`);
    }
    if ($$self.$$.dirty[0] & /*id*/
    128) {
      $: $$invalidate(19, errorId = `error-${id}`);
    }
    if ($$self.$$.dirty[0] & /*id*/
    128) {
      $: $$invalidate(18, warnId = `warn-${id}`);
    }
  };
  $: $$invalidate(22, isFluid = !!ctx && ctx.isFluid);
  return [
    value,
    ref,
    size,
    placeholder,
    light,
    disabled,
    helperText,
    id,
    name,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    warn,
    warnText,
    required,
    inline,
    readonly2,
    warnId,
    errorId,
    helperId,
    error,
    isFluid,
    onInput,
    onChange,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    paste_handler,
    input_binding,
    input_input_handler
  ];
}
var TextInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance158,
      create_fragment158,
      safe_not_equal,
      {
        size: 2,
        value: 0,
        placeholder: 3,
        light: 4,
        disabled: 5,
        helperText: 6,
        id: 7,
        name: 8,
        labelText: 9,
        hideLabel: 10,
        invalid: 11,
        invalidText: 12,
        warn: 13,
        warnText: 14,
        ref: 1,
        required: 15,
        inline: 16,
        readonly: 17
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextInput",
      options,
      id: create_fragment158.name
    });
  }
  get size() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextInput_default = TextInput;

// node_modules/carbon-components-svelte/src/TextInput/TextInputSkeleton.svelte
var file149 = "node_modules/carbon-components-svelte/src/TextInput/TextInputSkeleton.svelte";
function create_if_block92(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file149, 16, 4, 352);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block92.name,
    type: "if",
    source: "(16:2) {#if !hideLabel}",
    ctx
  });
  return block;
}
function create_fragment159(ctx) {
  let div1;
  let t;
  let div0;
  let mounted;
  let dispose;
  let if_block = !/*hideLabel*/
  ctx[0] && create_if_block92(ctx);
  let div1_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block) if_block.c();
      t = space();
      div0 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      if (if_block) if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--skeleton", true);
      toggle_class(div0, "bx--text-input", true);
      add_location(div0, file149, 18, 2, 429);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file149, 7, 0, 214);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block) if_block.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseover",
            /*mouseover_handler*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!/*hideLabel*/
      ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block92(ctx2);
          if_block.c();
          if_block.m(div1, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment159.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance159($$self, $$props, $$invalidate) {
  const omit_props_names = ["hideLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextInputSkeleton", slots, []);
  let { hideLabel = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("hideLabel" in $$new_props) $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  $$self.$capture_state = () => ({ hideLabel });
  $$self.$inject_state = ($$new_props) => {
    if ("hideLabel" in $$props) $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    hideLabel,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var TextInputSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance159, create_fragment159, safe_not_equal, { hideLabel: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextInputSkeleton",
      options,
      id: create_fragment159.name
    });
  }
  get hideLabel() {
    throw new Error("<TextInputSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<TextInputSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextInputSkeleton_default = TextInputSkeleton;

// node_modules/carbon-components-svelte/src/icons/View.svelte
var file150 = "node_modules/carbon-components-svelte/src/icons/View.svelte";
function create_if_block93(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file150, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block93.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment160(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block93(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M30.94,15.66A16.69,16.69,0,0,0,16,5,16.69,16.69,0,0,0,1.06,15.66a1,1,0,0,0,0,.68A16.69,16.69,0,0,0,16,27,16.69,16.69,0,0,0,30.94,16.34,1,1,0,0,0,30.94,15.66ZM16,25c-5.3,0-10.9-3.93-12.93-9C5.1,10.93,10.7,7,16,7s10.9,3.93,12.93,9C26.9,21.07,21.3,25,16,25Z");
      add_location(path0, file150, 24, 2, 579);
      attr_dev(path1, "d", "M16,10a6,6,0,1,0,6,6A6,6,0,0,0,16,10Zm0,10a4,4,0,1,1,4-4A4,4,0,0,1,16,20Z");
      add_location(path1, file150, 26, 10, 858);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file150, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block93(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment160.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance160($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("View", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var View = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance160, create_fragment160, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "View",
      options,
      id: create_fragment160.name
    });
  }
  get size() {
    throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var View_default = View;

// node_modules/carbon-components-svelte/src/icons/ViewOff.svelte
var file151 = "node_modules/carbon-components-svelte/src/icons/ViewOff.svelte";
function create_if_block94(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file151, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block94.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment161(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block94(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M5.24,22.51l1.43-1.42A14.06,14.06,0,0,1,3.07,16C5.1,10.93,10.7,7,16,7a12.38,12.38,0,0,1,4,.72l1.55-1.56A14.72,14.72,0,0,0,16,5,16.69,16.69,0,0,0,1.06,15.66a1,1,0,0,0,0,.68A16,16,0,0,0,5.24,22.51Z");
      add_location(path0, file151, 24, 2, 579);
      attr_dev(path1, "d", "M12 15.73a4 4 0 013.7-3.7l1.81-1.82a6 6 0 00-7.33 7.33zM30.94 15.66A16.4 16.4 0 0025.2 8.22L30 3.41 28.59 2 2 28.59 3.41 30l5.1-5.1A15.29 15.29 0 0016 27 16.69 16.69 0 0030.94 16.34 1 1 0 0030.94 15.66zM20 16a4 4 0 01-6 3.44L19.44 14A4 4 0 0120 16zm-4 9a13.05 13.05 0 01-6-1.58l2.54-2.54a6 6 0 008.35-8.35l2.87-2.87A14.54 14.54 0 0128.93 16C26.9 21.07 21.3 25 16 25z");
      add_location(path1, file151, 26, 10, 799);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file151, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block94(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment161.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance161($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ViewOff", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var ViewOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance161, create_fragment161, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ViewOff",
      options,
      id: create_fragment161.name
    });
  }
  get size() {
    throw new Error("<ViewOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ViewOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ViewOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ViewOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ViewOff_default = ViewOff;

// node_modules/carbon-components-svelte/src/TextInput/PasswordInput.svelte
var file152 = "node_modules/carbon-components-svelte/src/TextInput/PasswordInput.svelte";
var get_labelText_slot_changes_13 = (dirty) => ({});
var get_labelText_slot_context_13 = (ctx) => ({});
var get_labelText_slot_changes13 = (dirty) => ({});
var get_labelText_slot_context13 = (ctx) => ({});
function create_if_block_1111(ctx) {
  let label;
  let t;
  let if_block_anchor;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[28].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    get_labelText_slot_context13
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block_114(ctx);
  let if_block = !/*isFluid*/
  ctx[24] && /*helperText*/
  ctx[11] && create_if_block_1211(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      t = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(label_nodes);
      label_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[19]
      );
      toggle_class(label, "bx--label", true);
      toggle_class(
        label,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[13]
      );
      toggle_class(
        label,
        "bx--label--disabled",
        /*disabled*/
        ctx[10]
      );
      toggle_class(
        label,
        "bx--label--inline",
        /*inline*/
        ctx[18]
      );
      toggle_class(
        label,
        "bx--label--inline--sm",
        /*inline*/
        ctx[18] && /*size*/
        ctx[3] === "sm"
      );
      toggle_class(
        label,
        "bx--label--inline--xl",
        /*inline*/
        ctx[18] && /*size*/
        ctx[3] === "xl"
      );
      add_location(label, file152, 111, 4, 2866);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      insert_hydration_dev(target, t, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & /*$$scope*/
        134217728)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              get_labelText_slot_changes13
            ),
            get_labelText_slot_context13
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & /*labelText*/
        4096)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      524288) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[19]
        );
      }
      if (!current || dirty[0] & /*hideLabel*/
      8192) {
        toggle_class(
          label,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[13]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      1024) {
        toggle_class(
          label,
          "bx--label--disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*inline*/
      262144) {
        toggle_class(
          label,
          "bx--label--inline",
          /*inline*/
          ctx2[18]
        );
      }
      if (!current || dirty[0] & /*inline, size*/
      262152) {
        toggle_class(
          label,
          "bx--label--inline--sm",
          /*inline*/
          ctx2[18] && /*size*/
          ctx2[3] === "sm"
        );
      }
      if (!current || dirty[0] & /*inline, size*/
      262152) {
        toggle_class(
          label,
          "bx--label--inline--xl",
          /*inline*/
          ctx2[18] && /*size*/
          ctx2[3] === "xl"
        );
      }
      if (!/*isFluid*/
      ctx2[24] && /*helperText*/
      ctx2[11]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1211(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1111.name,
    type: "if",
    source: "(111:2) {#if inline}",
    ctx
  });
  return block;
}
function fallback_block_114(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[12]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[12]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelText*/
      4096) set_data_dev(
        t,
        /*labelText*/
        ctx2[12]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_114.name,
    type: "fallback",
    source: "(121:29)          ",
    ctx
  });
  return block;
}
function create_if_block_1211(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[11]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[11]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*helperId*/
        ctx[23]
      );
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(
        div,
        "bx--form__helper-text--disabled",
        /*disabled*/
        ctx[10]
      );
      toggle_class(
        div,
        "bx--form__helper-text--inline",
        /*inline*/
        ctx[18]
      );
      add_location(div, file152, 125, 6, 3299);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*helperText*/
      2048) set_data_dev(
        t,
        /*helperText*/
        ctx2[11]
      );
      if (dirty[0] & /*helperId*/
      8388608) {
        attr_dev(
          div,
          "id",
          /*helperId*/
          ctx2[23]
        );
      }
      if (dirty[0] & /*disabled*/
      1024) {
        toggle_class(
          div,
          "bx--form__helper-text--disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*inline*/
      262144) {
        toggle_class(
          div,
          "bx--form__helper-text--inline",
          /*inline*/
          ctx2[18]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1211.name,
    type: "if",
    source: "(125:4) {#if !isFluid && helperText}",
    ctx
  });
  return block;
}
function create_if_block_104(ctx) {
  let label;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[28].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    get_labelText_slot_context_13
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block33(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[19]
      );
      toggle_class(label, "bx--label", true);
      toggle_class(
        label,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[13]
      );
      toggle_class(
        label,
        "bx--label--disabled",
        /*disabled*/
        ctx[10]
      );
      toggle_class(
        label,
        "bx--label--inline",
        /*inline*/
        ctx[18]
      );
      toggle_class(
        label,
        "bx--label--inline--sm",
        /*inline*/
        ctx[18] && /*size*/
        ctx[3] === "sm"
      );
      toggle_class(
        label,
        "bx--label--inline--xl",
        /*inline*/
        ctx[18] && /*size*/
        ctx[3] === "xl"
      );
      add_location(label, file152, 136, 4, 3603);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & /*$$scope*/
        134217728)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              get_labelText_slot_changes_13
            ),
            get_labelText_slot_context_13
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & /*labelText*/
        4096)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      524288) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[19]
        );
      }
      if (!current || dirty[0] & /*hideLabel*/
      8192) {
        toggle_class(
          label,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[13]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      1024) {
        toggle_class(
          label,
          "bx--label--disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*inline*/
      262144) {
        toggle_class(
          label,
          "bx--label--inline",
          /*inline*/
          ctx2[18]
        );
      }
      if (!current || dirty[0] & /*inline, size*/
      262152) {
        toggle_class(
          label,
          "bx--label--inline--sm",
          /*inline*/
          ctx2[18] && /*size*/
          ctx2[3] === "sm"
        );
      }
      if (!current || dirty[0] & /*inline, size*/
      262152) {
        toggle_class(
          label,
          "bx--label--inline--xl",
          /*inline*/
          ctx2[18] && /*size*/
          ctx2[3] === "xl"
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_104.name,
    type: "if",
    source: "(136:2) {#if !inline && (labelText || $$slots.labelText)}",
    ctx
  });
  return block;
}
function fallback_block33(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[12]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[12]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelText*/
      4096) set_data_dev(
        t,
        /*labelText*/
        ctx2[12]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block33.name,
    type: "fallback",
    source: "(146:29)          ",
    ctx
  });
  return block;
}
function create_if_block_94(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--text-input__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_94.name,
    type: "if",
    source: "(160:6) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_86(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--text-input__invalid-icon\n            bx--text-input__invalid-icon--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningaltfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_86.name,
    type: "if",
    source: "(163:6) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_77(ctx) {
  let hr;
  let t0;
  let div;
  let t1;
  const block = {
    c: function create() {
      hr = element("hr");
      t0 = space();
      div = element("div");
      t1 = text(
        /*invalidText*/
        ctx[15]
      );
      this.h();
    },
    l: function claim(nodes) {
      hr = claim_element(nodes, "HR", { class: true });
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true, id: true });
      var div_nodes = children(div);
      t1 = claim_text(
        div_nodes,
        /*invalidText*/
        ctx[15]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(hr, "class", "bx--text-input__divider");
      add_location(hr, file152, 205, 8, 5624);
      attr_dev(div, "class", "bx--form-requirement");
      attr_dev(
        div,
        "id",
        /*errorId*/
        ctx[22]
      );
      add_location(div, file152, 206, 8, 5671);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, hr, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*invalidText*/
      32768) set_data_dev(
        t1,
        /*invalidText*/
        ctx2[15]
      );
      if (dirty[0] & /*errorId*/
      4194304) {
        attr_dev(
          div,
          "id",
          /*errorId*/
          ctx2[22]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(hr);
        detach_dev(t0);
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_77.name,
    type: "if",
    source: "(205:6) {#if isFluid && invalid}",
    ctx
  });
  return block;
}
function create_if_block_319(ctx) {
  let button;
  let t;
  let current_block_type_index;
  let if_block1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !/*disabled*/
  ctx[10] && create_if_block_512(ctx);
  const if_block_creators = [create_if_block_415, create_else_block31];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*type*/
      ctx2[1] === "text"
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      button = element("button");
      if (if_block0) if_block0.c();
      t = space();
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (if_block0) if_block0.l(button_nodes);
      t = claim_space(button_nodes);
      if_block1.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      button.disabled = /*disabled*/
      ctx[10];
      toggle_class(button, "bx--text-input--password__visibility__toggle", true);
      toggle_class(button, "bx--btn", true);
      toggle_class(button, "bx--btn--icon-only", true);
      toggle_class(
        button,
        "bx--btn--disabled",
        /*disabled*/
        ctx[10]
      );
      toggle_class(button, "bx--tooltip__trigger", true);
      toggle_class(button, "bx--tooltip--a11y", true);
      toggle_class(
        button,
        "bx--tooltip--top",
        /*tooltipPosition*/
        ctx[8] === "top"
      );
      toggle_class(
        button,
        "bx--tooltip--right",
        /*tooltipPosition*/
        ctx[8] === "right"
      );
      toggle_class(
        button,
        "bx--tooltip--bottom",
        /*tooltipPosition*/
        ctx[8] === "bottom"
      );
      toggle_class(
        button,
        "bx--tooltip--left",
        /*tooltipPosition*/
        ctx[8] === "left"
      );
      toggle_class(
        button,
        "bx--tooltip--align-start",
        /*tooltipAlignment*/
        ctx[7] === "start"
      );
      toggle_class(
        button,
        "bx--tooltip--align-center",
        /*tooltipAlignment*/
        ctx[7] === "center"
      );
      toggle_class(
        button,
        "bx--tooltip--align-end",
        /*tooltipAlignment*/
        ctx[7] === "end"
      );
      add_location(button, file152, 211, 8, 5814);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (if_block0) if_block0.m(button, null);
      append_hydration_dev(button, t);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_1*/
          ctx[42],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!/*disabled*/
      ctx2[10]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_512(ctx2);
          if_block0.c();
          if_block0.m(button, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
        }
        transition_in(if_block1, 1);
        if_block1.m(button, null);
      }
      if (!current || dirty[0] & /*disabled*/
      1024) {
        prop_dev(
          button,
          "disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      1024) {
        toggle_class(
          button,
          "bx--btn--disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*tooltipPosition*/
      256) {
        toggle_class(
          button,
          "bx--tooltip--top",
          /*tooltipPosition*/
          ctx2[8] === "top"
        );
      }
      if (!current || dirty[0] & /*tooltipPosition*/
      256) {
        toggle_class(
          button,
          "bx--tooltip--right",
          /*tooltipPosition*/
          ctx2[8] === "right"
        );
      }
      if (!current || dirty[0] & /*tooltipPosition*/
      256) {
        toggle_class(
          button,
          "bx--tooltip--bottom",
          /*tooltipPosition*/
          ctx2[8] === "bottom"
        );
      }
      if (!current || dirty[0] & /*tooltipPosition*/
      256) {
        toggle_class(
          button,
          "bx--tooltip--left",
          /*tooltipPosition*/
          ctx2[8] === "left"
        );
      }
      if (!current || dirty[0] & /*tooltipAlignment*/
      128) {
        toggle_class(
          button,
          "bx--tooltip--align-start",
          /*tooltipAlignment*/
          ctx2[7] === "start"
        );
      }
      if (!current || dirty[0] & /*tooltipAlignment*/
      128) {
        toggle_class(
          button,
          "bx--tooltip--align-center",
          /*tooltipAlignment*/
          ctx2[7] === "center"
        );
      }
      if (!current || dirty[0] & /*tooltipAlignment*/
      128) {
        toggle_class(
          button,
          "bx--tooltip--align-end",
          /*tooltipAlignment*/
          ctx2[7] === "end"
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (if_block0) if_block0.d();
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_319.name,
    type: "if",
    source: "(211:6) {#if !(isFluid && invalid)}",
    ctx
  });
  return block;
}
function create_if_block_512(ctx) {
  let span;
  function select_block_type(ctx2, dirty) {
    if (
      /*type*/
      ctx2[1] === "text"
    ) return create_if_block_611;
    return create_else_block_14;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      span = element("span");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--assistive-text", true);
      add_location(span, file152, 232, 12, 6798);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if_block.m(span, null);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(span, null);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_512.name,
    type: "if",
    source: "(232:10) {#if !disabled}",
    ctx
  });
  return block;
}
function create_else_block_14(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*showPasswordLabel*/
        ctx[6]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*showPasswordLabel*/
        ctx[6]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*showPasswordLabel*/
      64) set_data_dev(
        t,
        /*showPasswordLabel*/
        ctx2[6]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_14.name,
    type: "else",
    source: "(236:14) {:else}",
    ctx
  });
  return block;
}
function create_if_block_611(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*hidePasswordLabel*/
        ctx[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*hidePasswordLabel*/
        ctx[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*hidePasswordLabel*/
      32) set_data_dev(
        t,
        /*hidePasswordLabel*/
        ctx2[5]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_611.name,
    type: "if",
    source: '(234:14) {#if type === \\"text\\"}',
    ctx
  });
  return block;
}
function create_else_block31(ctx) {
  let view;
  let current;
  view = new View_default({
    props: { class: "bx--icon-visibility-on" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(view.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(view.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(view, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(view.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(view.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(view, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block31.name,
    type: "else",
    source: "(241:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block_415(ctx) {
  let viewoff;
  let current;
  viewoff = new ViewOff_default({
    props: { class: "bx--icon-visibility-off" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(viewoff.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(viewoff.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(viewoff, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(viewoff.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(viewoff.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(viewoff, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_415.name,
    type: "if",
    source: '(239:10) {#if type === \\"text\\"}',
    ctx
  });
  return block;
}
function create_if_block_225(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*invalidText*/
        ctx[15]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*invalidText*/
        ctx[15]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*errorId*/
        ctx[22]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file152, 247, 6, 7244);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*invalidText*/
      32768) set_data_dev(
        t,
        /*invalidText*/
        ctx2[15]
      );
      if (dirty[0] & /*errorId*/
      4194304) {
        attr_dev(
          div,
          "id",
          /*errorId*/
          ctx2[22]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_225.name,
    type: "if",
    source: "(247:4) {#if !isFluid && invalid}",
    ctx
  });
  return block;
}
function create_if_block_139(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[11]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[11]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(
        div,
        "bx--form__helper-text--disabled",
        /*disabled*/
        ctx[10]
      );
      toggle_class(
        div,
        "bx--form__helper-text--inline",
        /*inline*/
        ctx[18]
      );
      add_location(div, file152, 252, 6, 7417);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*helperText*/
      2048) set_data_dev(
        t,
        /*helperText*/
        ctx2[11]
      );
      if (dirty[0] & /*disabled*/
      1024) {
        toggle_class(
          div,
          "bx--form__helper-text--disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*inline*/
      262144) {
        toggle_class(
          div,
          "bx--form__helper-text--inline",
          /*inline*/
          ctx2[18]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_139.name,
    type: "if",
    source: "(252:4) {#if !invalid && !warn && !isFluid && !inline && helperText}",
    ctx
  });
  return block;
}
function create_if_block95(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*warnText*/
        ctx[17]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*warnText*/
        ctx[17]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*warnId*/
        ctx[21]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file152, 261, 6, 7678);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*warnText*/
      131072) set_data_dev(
        t,
        /*warnText*/
        ctx2[17]
      );
      if (dirty[0] & /*warnId*/
      2097152) {
        attr_dev(
          div,
          "id",
          /*warnId*/
          ctx2[21]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block95.name,
    type: "if",
    source: "(261:4) {#if !isFluid && !invalid && warn}",
    ctx
  });
  return block;
}
function create_fragment162(ctx) {
  let div2;
  let t0;
  let t1;
  let div1;
  let div0;
  let t2;
  let t3;
  let input;
  let input_data_invalid_value;
  let input_aria_invalid_value;
  let input_aria_describedby_value;
  let input_value_value;
  let t4;
  let t5;
  let div0_data_invalid_value;
  let t6;
  let t7;
  let t8;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*inline*/
    ctx[18] && create_if_block_1111(ctx)
  );
  let if_block1 = !/*inline*/
  ctx[18] && /*labelText*/
  (ctx[12] || /*$$slots*/
  ctx[25].labelText) && create_if_block_104(ctx);
  let if_block2 = (
    /*invalid*/
    ctx[14] && create_if_block_94(ctx)
  );
  let if_block3 = !/*invalid*/
  ctx[14] && /*warn*/
  ctx[16] && create_if_block_86(ctx);
  let input_levels = [
    {
      "data-invalid": input_data_invalid_value = /*invalid*/
      ctx[14] || void 0
    },
    {
      "aria-invalid": input_aria_invalid_value = /*invalid*/
      ctx[14] || void 0
    },
    {
      "aria-describedby": input_aria_describedby_value = /*invalid*/
      ctx[14] ? (
        /*errorId*/
        ctx[22]
      ) : (
        /*warn*/
        ctx[16] ? (
          /*warnId*/
          ctx[21]
        ) : (
          /*helperText*/
          ctx[11] ? (
            /*helperId*/
            ctx[23]
          ) : void 0
        )
      )
    },
    { id: (
      /*id*/
      ctx[19]
    ) },
    { name: (
      /*name*/
      ctx[20]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[4]
    ) },
    { type: (
      /*type*/
      ctx[1]
    ) },
    {
      value: input_value_value = /*value*/
      ctx[0] ?? ""
    },
    { disabled: (
      /*disabled*/
      ctx[10]
    ) },
    /*$$restProps*/
    ctx[26]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block4 = (
    /*isFluid*/
    ctx[24] && /*invalid*/
    ctx[14] && create_if_block_77(ctx)
  );
  let if_block5 = !/*isFluid*/
  (ctx[24] && /*invalid*/
  ctx[14]) && create_if_block_319(ctx);
  let if_block6 = !/*isFluid*/
  ctx[24] && /*invalid*/
  ctx[14] && create_if_block_225(ctx);
  let if_block7 = !/*invalid*/
  ctx[14] && !/*warn*/
  ctx[16] && !/*isFluid*/
  ctx[24] && !/*inline*/
  ctx[18] && /*helperText*/
  ctx[11] && create_if_block_139(ctx);
  let if_block8 = !/*isFluid*/
  ctx[24] && !/*invalid*/
  ctx[14] && /*warn*/
  ctx[16] && create_if_block95(ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      div1 = element("div");
      div0 = element("div");
      if (if_block2) if_block2.c();
      t2 = space();
      if (if_block3) if_block3.c();
      t3 = space();
      input = element("input");
      t4 = space();
      if (if_block4) if_block4.c();
      t5 = space();
      if (if_block5) if_block5.c();
      t6 = space();
      if (if_block6) if_block6.c();
      t7 = space();
      if (if_block7) if_block7.c();
      t8 = space();
      if (if_block8) if_block8.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      if (if_block0) if_block0.l(div2_nodes);
      t0 = claim_space(div2_nodes);
      if (if_block1) if_block1.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { "data-invalid": true });
      var div0_nodes = children(div0);
      if (if_block2) if_block2.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      if (if_block3) if_block3.l(div0_nodes);
      t3 = claim_space(div0_nodes);
      input = claim_element(div0_nodes, "INPUT", {
        "data-invalid": true,
        "aria-invalid": true,
        "aria-describedby": true,
        id: true,
        name: true,
        placeholder: true,
        type: true
      });
      t4 = claim_space(div0_nodes);
      if (if_block4) if_block4.l(div0_nodes);
      t5 = claim_space(div0_nodes);
      if (if_block5) if_block5.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t6 = claim_space(div1_nodes);
      if (if_block6) if_block6.l(div1_nodes);
      t7 = claim_space(div1_nodes);
      if (if_block7) if_block7.l(div1_nodes);
      t8 = claim_space(div1_nodes);
      if (if_block8) if_block8.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "bx--text-input", true);
      toggle_class(input, "bx--password-input", true);
      toggle_class(
        input,
        "bx--text-input--light",
        /*light*/
        ctx[9]
      );
      toggle_class(
        input,
        "bx--text-input--invalid",
        /*invalid*/
        ctx[14]
      );
      toggle_class(
        input,
        "bx--text-input--warning",
        /*warn*/
        ctx[16]
      );
      toggle_class(
        input,
        "bx--text-input--sm",
        /*size*/
        ctx[3] === "sm"
      );
      toggle_class(
        input,
        "bx--text-input--xl",
        /*size*/
        ctx[3] === "xl"
      );
      add_location(input, file152, 168, 6, 4582);
      attr_dev(div0, "data-invalid", div0_data_invalid_value = /*invalid*/
      ctx[14] || void 0);
      toggle_class(div0, "bx--text-input__field-wrapper", true);
      toggle_class(
        div0,
        "bx--text-input__field-wrapper--warning",
        /*warn*/
        ctx[16]
      );
      add_location(div0, file152, 154, 4, 4140);
      toggle_class(div1, "bx--text-input__field-outer-wrapper", true);
      toggle_class(
        div1,
        "bx--text-input__field-outer-wrapper--inline",
        /*inline*/
        ctx[18]
      );
      add_location(div1, file152, 150, 2, 4007);
      toggle_class(div2, "bx--form-item", true);
      toggle_class(div2, "bx--text-input-wrapper", true);
      toggle_class(div2, "bx--password-input-wrapper", !/*isFluid*/
      ctx[24]);
      toggle_class(
        div2,
        "bx--text-input-wrapper--light",
        /*light*/
        ctx[9]
      );
      toggle_class(
        div2,
        "bx--text-input-wrapper--inline",
        /*inline*/
        ctx[18]
      );
      add_location(div2, file152, 99, 0, 2565);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      if (if_block0) if_block0.m(div2, null);
      append_hydration_dev(div2, t0);
      if (if_block1) if_block1.m(div2, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if (if_block2) if_block2.m(div0, null);
      append_hydration_dev(div0, t2);
      if (if_block3) if_block3.m(div0, null);
      append_hydration_dev(div0, t3);
      append_hydration_dev(div0, input);
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      if (input.autofocus) input.focus();
      ctx[40](input);
      append_hydration_dev(div0, t4);
      if (if_block4) if_block4.m(div0, null);
      append_hydration_dev(div0, t5);
      if (if_block5) if_block5.m(div0, null);
      append_hydration_dev(div1, t6);
      if (if_block6) if_block6.m(div1, null);
      append_hydration_dev(div1, t7);
      if (if_block7) if_block7.m(div1, null);
      append_hydration_dev(div1, t8);
      if (if_block8) if_block8.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_1*/
            ctx[41],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[35],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[36],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[38],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "paste",
            /*paste_handler*/
            ctx[39],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "click",
            /*click_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseover",
            /*mouseover_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*inline*/
        ctx2[18]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*inline*/
          262144) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1111(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*inline*/
      ctx2[18] && /*labelText*/
      (ctx2[12] || /*$$slots*/
      ctx2[25].labelText)) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*inline, labelText, $$slots*/
          33820672) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_104(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*invalid*/
        ctx2[14]
      ) {
        if (if_block2) {
          if (dirty[0] & /*invalid*/
          16384) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_94(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!/*invalid*/
      ctx2[14] && /*warn*/
      ctx2[16]) {
        if (if_block3) {
          if (dirty[0] & /*invalid, warn*/
          81920) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_86(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        (!current || dirty[0] & /*invalid*/
        16384 && input_data_invalid_value !== (input_data_invalid_value = /*invalid*/
        ctx2[14] || void 0)) && { "data-invalid": input_data_invalid_value },
        (!current || dirty[0] & /*invalid*/
        16384 && input_aria_invalid_value !== (input_aria_invalid_value = /*invalid*/
        ctx2[14] || void 0)) && { "aria-invalid": input_aria_invalid_value },
        (!current || dirty[0] & /*invalid, errorId, warn, warnId, helperText, helperId*/
        14764032 && input_aria_describedby_value !== (input_aria_describedby_value = /*invalid*/
        ctx2[14] ? (
          /*errorId*/
          ctx2[22]
        ) : (
          /*warn*/
          ctx2[16] ? (
            /*warnId*/
            ctx2[21]
          ) : (
            /*helperText*/
            ctx2[11] ? (
              /*helperId*/
              ctx2[23]
            ) : void 0
          )
        ))) && {
          "aria-describedby": input_aria_describedby_value
        },
        (!current || dirty[0] & /*id*/
        524288) && { id: (
          /*id*/
          ctx2[19]
        ) },
        (!current || dirty[0] & /*name*/
        1048576) && { name: (
          /*name*/
          ctx2[20]
        ) },
        (!current || dirty[0] & /*placeholder*/
        16) && { placeholder: (
          /*placeholder*/
          ctx2[4]
        ) },
        (!current || dirty[0] & /*type*/
        2) && { type: (
          /*type*/
          ctx2[1]
        ) },
        (!current || dirty[0] & /*value*/
        1 && input_value_value !== (input_value_value = /*value*/
        ctx2[0] ?? "") && input.value !== input_value_value) && { value: input_value_value },
        (!current || dirty[0] & /*disabled*/
        1024) && { disabled: (
          /*disabled*/
          ctx2[10]
        ) },
        dirty[0] & /*$$restProps*/
        67108864 && /*$$restProps*/
        ctx2[26]
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      toggle_class(input, "bx--text-input", true);
      toggle_class(input, "bx--password-input", true);
      toggle_class(
        input,
        "bx--text-input--light",
        /*light*/
        ctx2[9]
      );
      toggle_class(
        input,
        "bx--text-input--invalid",
        /*invalid*/
        ctx2[14]
      );
      toggle_class(
        input,
        "bx--text-input--warning",
        /*warn*/
        ctx2[16]
      );
      toggle_class(
        input,
        "bx--text-input--sm",
        /*size*/
        ctx2[3] === "sm"
      );
      toggle_class(
        input,
        "bx--text-input--xl",
        /*size*/
        ctx2[3] === "xl"
      );
      if (
        /*isFluid*/
        ctx2[24] && /*invalid*/
        ctx2[14]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_77(ctx2);
          if_block4.c();
          if_block4.m(div0, t5);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (!/*isFluid*/
      (ctx2[24] && /*invalid*/
      ctx2[14])) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*isFluid, invalid*/
          16793600) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_319(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div0, null);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*invalid*/
      16384 && div0_data_invalid_value !== (div0_data_invalid_value = /*invalid*/
      ctx2[14] || void 0)) {
        attr_dev(div0, "data-invalid", div0_data_invalid_value);
      }
      if (!current || dirty[0] & /*warn*/
      65536) {
        toggle_class(
          div0,
          "bx--text-input__field-wrapper--warning",
          /*warn*/
          ctx2[16]
        );
      }
      if (!/*isFluid*/
      ctx2[24] && /*invalid*/
      ctx2[14]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
        } else {
          if_block6 = create_if_block_225(ctx2);
          if_block6.c();
          if_block6.m(div1, t7);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
      if (!/*invalid*/
      ctx2[14] && !/*warn*/
      ctx2[16] && !/*isFluid*/
      ctx2[24] && !/*inline*/
      ctx2[18] && /*helperText*/
      ctx2[11]) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
        } else {
          if_block7 = create_if_block_139(ctx2);
          if_block7.c();
          if_block7.m(div1, t8);
        }
      } else if (if_block7) {
        if_block7.d(1);
        if_block7 = null;
      }
      if (!/*isFluid*/
      ctx2[24] && !/*invalid*/
      ctx2[14] && /*warn*/
      ctx2[16]) {
        if (if_block8) {
          if_block8.p(ctx2, dirty);
        } else {
          if_block8 = create_if_block95(ctx2);
          if_block8.c();
          if_block8.m(div1, null);
        }
      } else if (if_block8) {
        if_block8.d(1);
        if_block8 = null;
      }
      if (!current || dirty[0] & /*inline*/
      262144) {
        toggle_class(
          div1,
          "bx--text-input__field-outer-wrapper--inline",
          /*inline*/
          ctx2[18]
        );
      }
      if (!current || dirty[0] & /*isFluid*/
      16777216) {
        toggle_class(div2, "bx--password-input-wrapper", !/*isFluid*/
        ctx2[24]);
      }
      if (!current || dirty[0] & /*light*/
      512) {
        toggle_class(
          div2,
          "bx--text-input-wrapper--light",
          /*light*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*inline*/
      262144) {
        toggle_class(
          div2,
          "bx--text-input-wrapper--inline",
          /*inline*/
          ctx2[18]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block5);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block5);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      ctx[40](null);
      if (if_block4) if_block4.d();
      if (if_block5) if_block5.d();
      if (if_block6) if_block6.d();
      if (if_block7) if_block7.d();
      if (if_block8) if_block8.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment162.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance162($$self, $$props, $$invalidate) {
  let isFluid;
  let helperId;
  let errorId;
  let warnId;
  const omit_props_names = [
    "size",
    "value",
    "type",
    "placeholder",
    "hidePasswordLabel",
    "showPasswordLabel",
    "tooltipAlignment",
    "tooltipPosition",
    "light",
    "disabled",
    "helperText",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "inline",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PasswordInput", slots, ["labelText"]);
  const $$slots = compute_slots(slots);
  let { size = void 0 } = $$props;
  let { value = "" } = $$props;
  let { type = "password" } = $$props;
  let { placeholder = "" } = $$props;
  let { hidePasswordLabel = "Hide password" } = $$props;
  let { showPasswordLabel = "Show password" } = $$props;
  let { tooltipAlignment = "center" } = $$props;
  let { tooltipPosition = "bottom" } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { helperText = "" } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { inline = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  const ctx = getContext("Form");
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(2, ref);
    });
  }
  const input_handler_1 = ({ target }) => {
    $$invalidate(0, value = target.value);
  };
  const click_handler_13 = () => {
    $$invalidate(1, type = type === "password" ? "text" : "password");
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(3, size = $$new_props.size);
    if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    if ("type" in $$new_props) $$invalidate(1, type = $$new_props.type);
    if ("placeholder" in $$new_props) $$invalidate(4, placeholder = $$new_props.placeholder);
    if ("hidePasswordLabel" in $$new_props) $$invalidate(5, hidePasswordLabel = $$new_props.hidePasswordLabel);
    if ("showPasswordLabel" in $$new_props) $$invalidate(6, showPasswordLabel = $$new_props.showPasswordLabel);
    if ("tooltipAlignment" in $$new_props) $$invalidate(7, tooltipAlignment = $$new_props.tooltipAlignment);
    if ("tooltipPosition" in $$new_props) $$invalidate(8, tooltipPosition = $$new_props.tooltipPosition);
    if ("light" in $$new_props) $$invalidate(9, light = $$new_props.light);
    if ("disabled" in $$new_props) $$invalidate(10, disabled = $$new_props.disabled);
    if ("helperText" in $$new_props) $$invalidate(11, helperText = $$new_props.helperText);
    if ("labelText" in $$new_props) $$invalidate(12, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props) $$invalidate(13, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$new_props) $$invalidate(14, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props) $$invalidate(15, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props) $$invalidate(16, warn = $$new_props.warn);
    if ("warnText" in $$new_props) $$invalidate(17, warnText = $$new_props.warnText);
    if ("inline" in $$new_props) $$invalidate(18, inline = $$new_props.inline);
    if ("id" in $$new_props) $$invalidate(19, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(20, name = $$new_props.name);
    if ("ref" in $$new_props) $$invalidate(2, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(27, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    value,
    type,
    placeholder,
    hidePasswordLabel,
    showPasswordLabel,
    tooltipAlignment,
    tooltipPosition,
    light,
    disabled,
    helperText,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    warn,
    warnText,
    inline,
    id,
    name,
    ref,
    getContext,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    View: View_default,
    ViewOff: ViewOff_default,
    ctx,
    warnId,
    errorId,
    helperId,
    isFluid
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props) $$invalidate(3, size = $$new_props.size);
    if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    if ("type" in $$props) $$invalidate(1, type = $$new_props.type);
    if ("placeholder" in $$props) $$invalidate(4, placeholder = $$new_props.placeholder);
    if ("hidePasswordLabel" in $$props) $$invalidate(5, hidePasswordLabel = $$new_props.hidePasswordLabel);
    if ("showPasswordLabel" in $$props) $$invalidate(6, showPasswordLabel = $$new_props.showPasswordLabel);
    if ("tooltipAlignment" in $$props) $$invalidate(7, tooltipAlignment = $$new_props.tooltipAlignment);
    if ("tooltipPosition" in $$props) $$invalidate(8, tooltipPosition = $$new_props.tooltipPosition);
    if ("light" in $$props) $$invalidate(9, light = $$new_props.light);
    if ("disabled" in $$props) $$invalidate(10, disabled = $$new_props.disabled);
    if ("helperText" in $$props) $$invalidate(11, helperText = $$new_props.helperText);
    if ("labelText" in $$props) $$invalidate(12, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props) $$invalidate(13, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$props) $$invalidate(14, invalid = $$new_props.invalid);
    if ("invalidText" in $$props) $$invalidate(15, invalidText = $$new_props.invalidText);
    if ("warn" in $$props) $$invalidate(16, warn = $$new_props.warn);
    if ("warnText" in $$props) $$invalidate(17, warnText = $$new_props.warnText);
    if ("inline" in $$props) $$invalidate(18, inline = $$new_props.inline);
    if ("id" in $$props) $$invalidate(19, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(20, name = $$new_props.name);
    if ("ref" in $$props) $$invalidate(2, ref = $$new_props.ref);
    if ("warnId" in $$props) $$invalidate(21, warnId = $$new_props.warnId);
    if ("errorId" in $$props) $$invalidate(22, errorId = $$new_props.errorId);
    if ("helperId" in $$props) $$invalidate(23, helperId = $$new_props.helperId);
    if ("isFluid" in $$props) $$invalidate(24, isFluid = $$new_props.isFluid);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*id*/
    524288) {
      $: $$invalidate(23, helperId = `helper-${id}`);
    }
    if ($$self.$$.dirty[0] & /*id*/
    524288) {
      $: $$invalidate(22, errorId = `error-${id}`);
    }
    if ($$self.$$.dirty[0] & /*id*/
    524288) {
      $: $$invalidate(21, warnId = `warn-${id}`);
    }
  };
  $: $$invalidate(24, isFluid = !!ctx && ctx.isFluid);
  return [
    value,
    type,
    ref,
    size,
    placeholder,
    hidePasswordLabel,
    showPasswordLabel,
    tooltipAlignment,
    tooltipPosition,
    light,
    disabled,
    helperText,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    warn,
    warnText,
    inline,
    id,
    name,
    warnId,
    errorId,
    helperId,
    isFluid,
    $$slots,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    change_handler,
    input_handler,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    paste_handler,
    input_binding,
    input_handler_1,
    click_handler_13
  ];
}
var PasswordInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance162,
      create_fragment162,
      safe_not_equal,
      {
        size: 3,
        value: 0,
        type: 1,
        placeholder: 4,
        hidePasswordLabel: 5,
        showPasswordLabel: 6,
        tooltipAlignment: 7,
        tooltipPosition: 8,
        light: 9,
        disabled: 10,
        helperText: 11,
        labelText: 12,
        hideLabel: 13,
        invalid: 14,
        invalidText: 15,
        warn: 16,
        warnText: 17,
        inline: 18,
        id: 19,
        name: 20,
        ref: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PasswordInput",
      options,
      id: create_fragment162.name
    });
  }
  get size() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidePasswordLabel() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidePasswordLabel(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showPasswordLabel() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showPasswordLabel(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipAlignment() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipAlignment(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipPosition() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipPosition(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PasswordInput_default = PasswordInput;

// node_modules/carbon-components-svelte/src/Toggle/Toggle.svelte
var file153 = "node_modules/carbon-components-svelte/src/Toggle/Toggle.svelte";
var get_labelB_slot_changes = (dirty) => ({});
var get_labelB_slot_context = (ctx) => ({});
var get_labelA_slot_changes = (dirty) => ({});
var get_labelA_slot_context = (ctx) => ({});
var get_labelText_slot_changes14 = (dirty) => ({});
var get_labelText_slot_context14 = (ctx) => ({});
function fallback_block_26(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelText*/
      32) set_data_dev(
        t,
        /*labelText*/
        ctx2[5]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_26.name,
    type: "fallback",
    source: "(87:29)          ",
    ctx
  });
  return block;
}
function fallback_block_115(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelA*/
        ctx[3]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelA*/
        ctx[3]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelA*/
      8) set_data_dev(
        t,
        /*labelA*/
        ctx2[3]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_115.name,
    type: "fallback",
    source: "(96:28)            ",
    ctx
  });
  return block;
}
function fallback_block34(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelB*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelB*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelB*/
      16) set_data_dev(
        t,
        /*labelB*/
        ctx2[4]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block34.name,
    type: "fallback",
    source: "(101:28)            ",
    ctx
  });
  return block;
}
function create_fragment163(ctx) {
  let div;
  let input;
  let t0;
  let label;
  let span0;
  let t1;
  let span3;
  let span1;
  let t2;
  let span2;
  let label_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const labelText_slot_template = (
    /*#slots*/
    ctx[12].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_labelText_slot_context14
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block_26(ctx);
  const labelA_slot_template = (
    /*#slots*/
    ctx[12].labelA
  );
  const labelA_slot = create_slot(
    labelA_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_labelA_slot_context
  );
  const labelA_slot_or_fallback = labelA_slot || fallback_block_115(ctx);
  const labelB_slot_template = (
    /*#slots*/
    ctx[12].labelB
  );
  const labelB_slot = create_slot(
    labelB_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_labelB_slot_context
  );
  const labelB_slot_or_fallback = labelB_slot || fallback_block34(ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[9]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t0 = space();
      label = element("label");
      span0 = element("span");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      t1 = space();
      span3 = element("span");
      span1 = element("span");
      if (labelA_slot_or_fallback) labelA_slot_or_fallback.c();
      t2 = space();
      span2 = element("span");
      if (labelB_slot_or_fallback) labelB_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", {
        role: true,
        type: true,
        id: true,
        name: true
      });
      t0 = claim_space(div_nodes);
      label = claim_element(div_nodes, "LABEL", { "aria-label": true, for: true });
      var label_nodes = children(label);
      span0 = claim_element(label_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(label_nodes);
      span3 = claim_element(label_nodes, "SPAN", {});
      var span3_nodes = children(span3);
      span1 = claim_element(span3_nodes, "SPAN", { "aria-hidden": true });
      var span1_nodes = children(span1);
      if (labelA_slot_or_fallback) labelA_slot_or_fallback.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      t2 = claim_space(span3_nodes);
      span2 = claim_element(span3_nodes, "SPAN", { "aria-hidden": true });
      var span2_nodes = children(span2);
      if (labelB_slot_or_fallback) labelB_slot_or_fallback.l(span2_nodes);
      span2_nodes.forEach(detach_dev);
      span3_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "role", "switch");
      attr_dev(input, "type", "checkbox");
      input.checked = /*toggled*/
      ctx[0];
      input.disabled = /*disabled*/
      ctx[2];
      attr_dev(
        input,
        "id",
        /*id*/
        ctx[7]
      );
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[8]
      );
      toggle_class(input, "bx--toggle-input", true);
      toggle_class(
        input,
        "bx--toggle-input--small",
        /*size*/
        ctx[1] === "sm"
      );
      add_location(input, file153, 57, 2, 1319);
      toggle_class(
        span0,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[6]
      );
      add_location(span0, file153, 85, 4, 1945);
      attr_dev(span1, "aria-hidden", "true");
      toggle_class(span1, "bx--toggle__text--off", true);
      add_location(span1, file153, 94, 6, 2183);
      attr_dev(span2, "aria-hidden", "true");
      toggle_class(span2, "bx--toggle__text--on", true);
      add_location(span2, file153, 99, 6, 2330);
      toggle_class(span3, "bx--toggle__switch", true);
      set_style(
        span3,
        "margin-top",
        /*hideLabel*/
        ctx[6] ? 0 : void 0
      );
      add_location(span3, file153, 90, 4, 2072);
      attr_dev(label, "aria-label", label_aria_label_value = /*labelText*/
      ctx[5] ? void 0 : (
        /*$$props*/
        ctx[10]["aria-label"] || "Toggle"
      ));
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[7]
      );
      toggle_class(label, "bx--toggle-input__label", true);
      add_location(label, file153, 80, 2, 1795);
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      set_style(div, "user-select", `none`);
      add_location(div, file153, 47, 0, 1116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, label);
      append_hydration_dev(label, span0);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span0, null);
      }
      append_hydration_dev(label, t1);
      append_hydration_dev(label, span3);
      append_hydration_dev(span3, span1);
      if (labelA_slot_or_fallback) {
        labelA_slot_or_fallback.m(span1, null);
      }
      append_hydration_dev(span3, t2);
      append_hydration_dev(span3, span2);
      if (labelB_slot_or_fallback) {
        labelB_slot_or_fallback.m(span2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*change_handler_1*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_1*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*toggled*/
      1) {
        prop_dev(
          input,
          "checked",
          /*toggled*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*disabled*/
      4) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*id*/
      128) {
        attr_dev(
          input,
          "id",
          /*id*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*name*/
      256) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*size*/
      2) {
        toggle_class(
          input,
          "bx--toggle-input--small",
          /*size*/
          ctx2[1] === "sm"
        );
      }
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_labelText_slot_changes14
            ),
            get_labelText_slot_context14
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & /*labelText*/
        32)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*hideLabel*/
      64) {
        toggle_class(
          span0,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[6]
        );
      }
      if (labelA_slot) {
        if (labelA_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            labelA_slot,
            labelA_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              labelA_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_labelA_slot_changes
            ),
            get_labelA_slot_context
          );
        }
      } else {
        if (labelA_slot_or_fallback && labelA_slot_or_fallback.p && (!current || dirty & /*labelA*/
        8)) {
          labelA_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (labelB_slot) {
        if (labelB_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            labelB_slot,
            labelB_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              labelB_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_labelB_slot_changes
            ),
            get_labelB_slot_context
          );
        }
      } else {
        if (labelB_slot_or_fallback && labelB_slot_or_fallback.p && (!current || dirty & /*labelB*/
        16)) {
          labelB_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (dirty & /*hideLabel*/
      64) {
        set_style(
          span3,
          "margin-top",
          /*hideLabel*/
          ctx2[6] ? 0 : void 0
        );
      }
      if (!current || dirty & /*labelText, $$props*/
      1056 && label_aria_label_value !== (label_aria_label_value = /*labelText*/
      ctx2[5] ? void 0 : (
        /*$$props*/
        ctx2[10]["aria-label"] || "Toggle"
      ))) {
        attr_dev(label, "aria-label", label_aria_label_value);
      }
      if (!current || dirty & /*id*/
      128) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[7]
        );
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      512 && /*$$restProps*/
      ctx2[9]]));
      toggle_class(div, "bx--form-item", true);
      set_style(div, "user-select", `none`);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      transition_in(labelA_slot_or_fallback, local);
      transition_in(labelB_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      transition_out(labelA_slot_or_fallback, local);
      transition_out(labelB_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
      if (labelA_slot_or_fallback) labelA_slot_or_fallback.d(detaching);
      if (labelB_slot_or_fallback) labelB_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment163.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance163($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "size",
    "toggled",
    "disabled",
    "labelA",
    "labelB",
    "labelText",
    "hideLabel",
    "id",
    "name"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toggle", slots, ["labelText", "labelA", "labelB"]);
  let { size = "default" } = $$props;
  let { toggled = false } = $$props;
  let { disabled = false } = $$props;
  let { labelA = "Off" } = $$props;
  let { labelB = "On" } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const change_handler_1 = () => {
    $$invalidate(0, toggled = !toggled);
  };
  const keyup_handler_1 = (e) => {
    if (e.key === " " || e.key === "Enter") {
      e.preventDefault();
      $$invalidate(0, toggled = !toggled);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(1, size = $$new_props.size);
    if ("toggled" in $$new_props) $$invalidate(0, toggled = $$new_props.toggled);
    if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("labelA" in $$new_props) $$invalidate(3, labelA = $$new_props.labelA);
    if ("labelB" in $$new_props) $$invalidate(4, labelB = $$new_props.labelB);
    if ("labelText" in $$new_props) $$invalidate(5, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props) $$invalidate(6, hideLabel = $$new_props.hideLabel);
    if ("id" in $$new_props) $$invalidate(7, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(8, name = $$new_props.name);
    if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    toggled,
    disabled,
    labelA,
    labelB,
    labelText,
    hideLabel,
    id,
    name,
    createEventDispatcher,
    dispatch
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(1, size = $$new_props.size);
    if ("toggled" in $$props) $$invalidate(0, toggled = $$new_props.toggled);
    if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("labelA" in $$props) $$invalidate(3, labelA = $$new_props.labelA);
    if ("labelB" in $$props) $$invalidate(4, labelB = $$new_props.labelB);
    if ("labelText" in $$props) $$invalidate(5, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props) $$invalidate(6, hideLabel = $$new_props.hideLabel);
    if ("id" in $$props) $$invalidate(7, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(8, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*toggled*/
    1) {
      $: dispatch("toggle", { toggled });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    toggled,
    size,
    disabled,
    labelA,
    labelB,
    labelText,
    hideLabel,
    id,
    name,
    $$restProps,
    $$props,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    change_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    change_handler_1,
    keyup_handler_1
  ];
}
var Toggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance163, create_fragment163, safe_not_equal, {
      size: 1,
      toggled: 0,
      disabled: 2,
      labelA: 3,
      labelB: 4,
      labelText: 5,
      hideLabel: 6,
      id: 7,
      name: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toggle",
      options,
      id: create_fragment163.name
    });
  }
  get size() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggled() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggled(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelA() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelA(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelB() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelB(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toggle_default = Toggle;

// node_modules/carbon-components-svelte/src/Theme/Theme.svelte
var { Object: Object_1, console: console_12 } = globals;
var get_default_slot_changes12 = (dirty) => ({ theme: dirty & /*theme*/
1 });
var get_default_slot_context12 = (ctx) => ({ theme: (
  /*theme*/
  ctx[0]
) });
function get_each_context20(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list[i];
  return child_ctx;
}
function create_if_block_226(ctx) {
  let localstorage;
  let updating_value;
  let current;
  function localstorage_value_binding(value) {
    ctx[9](value);
  }
  let localstorage_props = { key: (
    /*persistKey*/
    ctx[2]
  ) };
  if (
    /*theme*/
    ctx[0] !== void 0
  ) {
    localstorage_props.value = /*theme*/
    ctx[0];
  }
  localstorage = new LocalStorage_default({
    props: localstorage_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(localstorage, "value", localstorage_value_binding));
  const block = {
    c: function create() {
      create_component(localstorage.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(localstorage.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(localstorage, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const localstorage_changes = {};
      if (dirty & /*persistKey*/
      4) localstorage_changes.key = /*persistKey*/
      ctx2[2];
      if (!updating_value && dirty & /*theme*/
      1) {
        updating_value = true;
        localstorage_changes.value = /*theme*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      localstorage.$set(localstorage_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(localstorage.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(localstorage.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(localstorage, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_226.name,
    type: "if",
    source: "(98:0) {#if persist}",
    ctx
  });
  return block;
}
function create_if_block_140(ctx) {
  let select_1;
  let updating_selected;
  let current;
  const select_1_spread_levels = [
    /*select*/
    ctx[5]
  ];
  function select_1_selected_binding(value) {
    ctx[11](value);
  }
  let select_1_props = {
    $$slots: { default: [create_default_slot22] },
    $$scope: { ctx }
  };
  for (let i = 0; i < select_1_spread_levels.length; i += 1) {
    select_1_props = assign(select_1_props, select_1_spread_levels[i]);
  }
  if (
    /*theme*/
    ctx[0] !== void 0
  ) {
    select_1_props.selected = /*theme*/
    ctx[0];
  }
  select_1 = new Select_default({ props: select_1_props, $$inline: true });
  binding_callbacks.push(() => bind(select_1, "selected", select_1_selected_binding));
  const block = {
    c: function create() {
      create_component(select_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(select_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(select_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const select_1_changes = dirty & /*select*/
      32 ? get_spread_update(select_1_spread_levels, [get_spread_object(
        /*select*/
        ctx2[5]
      )]) : {};
      if (dirty & /*$$scope, select*/
      4128) {
        select_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selected && dirty & /*theme*/
      1) {
        updating_selected = true;
        select_1_changes.selected = /*theme*/
        ctx2[0];
        add_flush_callback(() => updating_selected = false);
      }
      select_1.$set(select_1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(select_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(select_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_140.name,
    type: "if",
    source: "(110:30) ",
    ctx
  });
  return block;
}
function create_if_block96(ctx) {
  let toggle_1;
  let current;
  const toggle_1_spread_levels = [
    /*toggle*/
    ctx[4],
    {
      toggled: (
        /*theme*/
        ctx[0] === /*toggle*/
        ctx[4].themes[1]
      )
    }
  ];
  let toggle_1_props = {};
  for (let i = 0; i < toggle_1_spread_levels.length; i += 1) {
    toggle_1_props = assign(toggle_1_props, toggle_1_spread_levels[i]);
  }
  toggle_1 = new Toggle_default({ props: toggle_1_props, $$inline: true });
  toggle_1.$on(
    "toggle",
    /*toggle_handler*/
    ctx[10]
  );
  const block = {
    c: function create() {
      create_component(toggle_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(toggle_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(toggle_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const toggle_1_changes = dirty & /*toggle, theme*/
      17 ? get_spread_update(toggle_1_spread_levels, [
        dirty & /*toggle*/
        16 && get_spread_object(
          /*toggle*/
          ctx2[4]
        ),
        {
          toggled: (
            /*theme*/
            ctx2[0] === /*toggle*/
            ctx2[4].themes[1]
          )
        }
      ]) : {};
      toggle_1.$set(toggle_1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(toggle_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toggle_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toggle_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block96.name,
    type: "if",
    source: '(102:0) {#if render === \\"toggle\\"}',
    ctx
  });
  return block;
}
function create_each_block20(key_1, ctx) {
  let first;
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      value: (
        /*theme*/
        ctx[0]
      ),
      text: (
        /*themes*/
        ctx[6][
          /*theme*/
          ctx[0]
        ]
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(selectitem.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(selectitem.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const selectitem_changes = {};
      if (dirty & /*select*/
      32) selectitem_changes.value = /*theme*/
      ctx[0];
      if (dirty & /*select*/
      32) selectitem_changes.text = /*themes*/
      ctx[6][
        /*theme*/
        ctx[0]
      ];
      selectitem.$set(selectitem_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(selectitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block20.name,
    type: "each",
    source: "(112:4) {#each select.themes as theme (theme)}",
    ctx
  });
  return block;
}
function create_default_slot22(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*select*/
    ctx[5].themes
  );
  const get_key = (ctx2) => (
    /*theme*/
    ctx2[0]
  );
  validate_each_keys(ctx, each_value, get_each_context20, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context20(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block20(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*select, themes*/
      96) {
        each_value = ensure_array_like_dev(
          /*select*/
          ctx2[5].themes
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context20, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block20, each_1_anchor, get_each_context20);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot22.name,
    type: "slot",
    source: '(111:2) <Select {...select} bind:selected=\\"{theme}\\">',
    ctx
  });
  return block;
}
function create_fragment164(ctx) {
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let current;
  let if_block0 = (
    /*persist*/
    ctx[1] && create_if_block_226(ctx)
  );
  const if_block_creators = [create_if_block96, create_if_block_140];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*render*/
      ctx2[3] === "toggle"
    ) return 0;
    if (
      /*render*/
      ctx2[3] === "select"
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context12
  );
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*persist*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*persist*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_226(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        } else {
          if_block1 = null;
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, theme*/
        4097)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes12
            ),
            get_default_slot_context12
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      if (if_block0) if_block0.d(detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment164.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance164($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Theme", slots, ["default"]);
  let { theme = "white" } = $$props;
  let { tokens = {} } = $$props;
  let { persist = false } = $$props;
  let { persistKey = "theme" } = $$props;
  let { render = void 0 } = $$props;
  let { toggle = {
    themes: ["white", "g100"],
    labelA: "",
    labelB: "",
    labelText: "Dark mode",
    hideLabel: false
  } } = $$props;
  const themes = {
    white: "White",
    g10: "Gray 10",
    g80: "Gray 80",
    g90: "Gray 90",
    g100: "Gray 100"
  };
  const themeKeys = Object.keys(themes);
  let { select = {
    themes: themeKeys,
    labelText: "Themes",
    hideLabel: false
  } } = $$props;
  const dispatch = createEventDispatcher();
  const writable_props = ["theme", "tokens", "persist", "persistKey", "render", "toggle", "select"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console_12.warn(`<Theme> was created with unknown prop '${key}'`);
  });
  function localstorage_value_binding(value) {
    theme = value;
    $$invalidate(0, theme);
  }
  const toggle_handler = ({ detail }) => {
    $$invalidate(0, theme = detail.toggled ? toggle.themes[1] : toggle.themes[0]);
  };
  function select_1_selected_binding(value) {
    theme = value;
    $$invalidate(0, theme);
  }
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2) $$invalidate(0, theme = $$props2.theme);
    if ("tokens" in $$props2) $$invalidate(7, tokens = $$props2.tokens);
    if ("persist" in $$props2) $$invalidate(1, persist = $$props2.persist);
    if ("persistKey" in $$props2) $$invalidate(2, persistKey = $$props2.persistKey);
    if ("render" in $$props2) $$invalidate(3, render = $$props2.render);
    if ("toggle" in $$props2) $$invalidate(4, toggle = $$props2.toggle);
    if ("select" in $$props2) $$invalidate(5, select = $$props2.select);
    if ("$$scope" in $$props2) $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    theme,
    tokens,
    persist,
    persistKey,
    render,
    toggle,
    themes,
    themeKeys,
    select,
    createEventDispatcher,
    Toggle: Toggle_default,
    Select: Select_default,
    SelectItem: SelectItem_default,
    LocalStorage: LocalStorage_default,
    dispatch
  });
  $$self.$inject_state = ($$props2) => {
    if ("theme" in $$props2) $$invalidate(0, theme = $$props2.theme);
    if ("tokens" in $$props2) $$invalidate(7, tokens = $$props2.tokens);
    if ("persist" in $$props2) $$invalidate(1, persist = $$props2.persist);
    if ("persistKey" in $$props2) $$invalidate(2, persistKey = $$props2.persistKey);
    if ("render" in $$props2) $$invalidate(3, render = $$props2.render);
    if ("toggle" in $$props2) $$invalidate(4, toggle = $$props2.toggle);
    if ("select" in $$props2) $$invalidate(5, select = $$props2.select);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tokens, theme*/
    129) {
      $: if (typeof window !== "undefined") {
        Object.entries(tokens).forEach(([token, value]) => {
          document.documentElement.style.setProperty(`--cds-${token}`, value);
        });
        if (theme in themes) {
          document.documentElement.setAttribute("theme", theme);
          dispatch("update", { theme });
        } else {
          console.warn(`[Theme.svelte] invalid theme "${theme}". Value must be one of: ${JSON.stringify(Object.keys(themes))}`);
        }
      }
    }
  };
  return [
    theme,
    persist,
    persistKey,
    render,
    toggle,
    select,
    themes,
    tokens,
    slots,
    localstorage_value_binding,
    toggle_handler,
    select_1_selected_binding,
    $$scope
  ];
}
var Theme = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance164, create_fragment164, safe_not_equal, {
      theme: 0,
      tokens: 7,
      persist: 1,
      persistKey: 2,
      render: 3,
      toggle: 4,
      select: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Theme",
      options,
      id: create_fragment164.name
    });
  }
  get theme() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tokens() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tokens(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persist() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persist(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persistKey() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persistKey(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get render() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set render(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get select() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set select(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Theme_default = Theme;

// node_modules/carbon-components-svelte/src/Tile/Tile.svelte
var file154 = "node_modules/carbon-components-svelte/src/Tile/Tile.svelte";
function create_fragment165(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "bx--tile", true);
      toggle_class(
        div,
        "bx--tile--light",
        /*light*/
        ctx[0]
      );
      add_location(div, file154, 7, 0, 215);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(div, "bx--tile", true);
      toggle_class(
        div,
        "bx--tile--light",
        /*light*/
        ctx2[0]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment165.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance165($$self, $$props, $$invalidate) {
  const omit_props_names = ["light"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tile", slots, ["default"]);
  let { light = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("light" in $$new_props) $$invalidate(0, light = $$new_props.light);
    if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ light });
  $$self.$inject_state = ($$new_props) => {
    if ("light" in $$props) $$invalidate(0, light = $$new_props.light);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    light,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var Tile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance165, create_fragment165, safe_not_equal, { light: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tile",
      options,
      id: create_fragment165.name
    });
  }
  get light() {
    throw new Error("<Tile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Tile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tile_default = Tile;

// node_modules/carbon-components-svelte/src/Tile/ClickableTile.svelte
function create_default_slot23(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot23.name,
    type: "slot",
    source: `(22:0) <Link   {...$$restProps}   disabled=\\"{disabled}\\"   class=\\"bx--tile bx--tile--clickable {clicked &&     'bx--tile--is-clicked'} {light && 'bx--tile--light'} {$$restProps.class}\\"   href=\\"{href}\\"   on:click   on:click=\\"{() => {     clicked = !clicked;   }}\\"   on:keydown   on:keydown=\\"{({ key }) => {     if (key === ' ' || key === 'Enter') {       clicked = !clicked;     }   }}\\"   on:mouseover   on:mouseenter   on:mouseleave >`,
    ctx
  });
  return block;
}
function create_fragment166(ctx) {
  let link;
  let current;
  const link_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { disabled: (
      /*disabled*/
      ctx[2]
    ) },
    {
      class: "bx--tile bx--tile--clickable " + /*clicked*/
      (ctx[0] && "bx--tile--is-clicked") + " " + /*light*/
      (ctx[1] && "bx--tile--light") + " " + /*$$restProps*/
      ctx[4].class
    },
    { href: (
      /*href*/
      ctx[3]
    ) }
  ];
  let link_props = {
    $$slots: { default: [create_default_slot23] },
    $$scope: { ctx }
  };
  for (let i = 0; i < link_spread_levels.length; i += 1) {
    link_props = assign(link_props, link_spread_levels[i]);
  }
  link = new Link_default({ props: link_props, $$inline: true });
  link.$on(
    "click",
    /*click_handler*/
    ctx[6]
  );
  link.$on(
    "click",
    /*click_handler_1*/
    ctx[7]
  );
  link.$on(
    "keydown",
    /*keydown_handler*/
    ctx[8]
  );
  link.$on(
    "keydown",
    /*keydown_handler_1*/
    ctx[9]
  );
  link.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[10]
  );
  link.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx[11]
  );
  link.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx[12]
  );
  const block = {
    c: function create() {
      create_component(link.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(link.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(link, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const link_changes = dirty & /*$$restProps, disabled, clicked, light, href*/
      31 ? get_spread_update(link_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        dirty & /*disabled*/
        4 && { disabled: (
          /*disabled*/
          ctx2[2]
        ) },
        dirty & /*clicked, light, $$restProps*/
        19 && {
          class: "bx--tile bx--tile--clickable " + /*clicked*/
          (ctx2[0] && "bx--tile--is-clicked") + " " + /*light*/
          (ctx2[1] && "bx--tile--light") + " " + /*$$restProps*/
          ctx2[4].class
        },
        dirty & /*href*/
        8 && { href: (
          /*href*/
          ctx2[3]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8192) {
        link_changes.$$scope = { dirty, ctx: ctx2 };
      }
      link.$set(link_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(link.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(link.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(link, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment166.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance166($$self, $$props, $$invalidate) {
  const omit_props_names = ["clicked", "light", "disabled", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ClickableTile", slots, ["default"]);
  let { clicked = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { href = void 0 } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = () => {
    $$invalidate(0, clicked = !clicked);
  };
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const keydown_handler_12 = ({ key }) => {
    if (key === " " || key === "Enter") {
      $$invalidate(0, clicked = !clicked);
    }
  };
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("clicked" in $$new_props) $$invalidate(0, clicked = $$new_props.clicked);
    if ("light" in $$new_props) $$invalidate(1, light = $$new_props.light);
    if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("href" in $$new_props) $$invalidate(3, href = $$new_props.href);
    if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ clicked, light, disabled, href, Link: Link_default });
  $$self.$inject_state = ($$new_props) => {
    if ("clicked" in $$props) $$invalidate(0, clicked = $$new_props.clicked);
    if ("light" in $$props) $$invalidate(1, light = $$new_props.light);
    if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("href" in $$props) $$invalidate(3, href = $$new_props.href);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    clicked,
    light,
    disabled,
    href,
    $$restProps,
    slots,
    click_handler,
    click_handler_13,
    keydown_handler,
    keydown_handler_12,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    $$scope
  ];
}
var ClickableTile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance166, create_fragment166, safe_not_equal, {
      clicked: 0,
      light: 1,
      disabled: 2,
      href: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ClickableTile",
      options,
      id: create_fragment166.name
    });
  }
  get clicked() {
    throw new Error("<ClickableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clicked(value) {
    throw new Error("<ClickableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<ClickableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<ClickableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ClickableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ClickableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<ClickableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<ClickableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ClickableTile_default = ClickableTile;

// node_modules/carbon-components-svelte/src/Tile/ExpandableTile.svelte
var file155 = "node_modules/carbon-components-svelte/src/Tile/ExpandableTile.svelte";
var get_below_slot_changes = (dirty) => ({});
var get_below_slot_context = (ctx) => ({});
var get_above_slot_changes = (dirty) => ({});
var get_above_slot_context = (ctx) => ({});
function create_fragment167(ctx) {
  let button;
  let div3;
  let div0;
  let span0;
  let t0;
  let div1;
  let span1;
  let t1_value = (
    /*expanded*/
    (ctx[0] ? (
      /*tileExpandedLabel*/
      ctx[7]
    ) : (
      /*tileCollapsedLabel*/
      ctx[8]
    )) + ""
  );
  let t1;
  let t2;
  let chevrondown;
  let t3;
  let div2;
  let span2;
  let button_title_value;
  let current;
  let mounted;
  let dispose;
  const above_slot_template = (
    /*#slots*/
    ctx[14].above
  );
  const above_slot = create_slot(
    above_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_above_slot_context
  );
  chevrondown = new ChevronDown_default({ $$inline: true });
  const below_slot_template = (
    /*#slots*/
    ctx[14].below
  );
  const below_slot = create_slot(
    below_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_below_slot_context
  );
  let button_levels = [
    { type: "button" },
    { id: (
      /*id*/
      ctx[10]
    ) },
    { "aria-expanded": (
      /*expanded*/
      ctx[0]
    ) },
    { tabindex: (
      /*tabindex*/
      ctx[9]
    ) },
    {
      title: button_title_value = /*expanded*/
      ctx[0] ? (
        /*tileExpandedIconText*/
        ctx[6]
      ) : (
        /*tileCollapsedIconText*/
        ctx[5]
      )
    },
    /*$$restProps*/
    ctx[12]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      div3 = element("div");
      div0 = element("div");
      span0 = element("span");
      if (above_slot) above_slot.c();
      t0 = space();
      div1 = element("div");
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      create_component(chevrondown.$$.fragment);
      t3 = space();
      div2 = element("div");
      span2 = element("span");
      if (below_slot) below_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        id: true,
        "aria-expanded": true,
        tabindex: true,
        title: true
      });
      var button_nodes = children(button);
      div3 = claim_element(button_nodes, "DIV", {});
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", {});
      var div0_nodes = children(div0);
      span0 = claim_element(div0_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      if (above_slot) above_slot.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", {});
      var div1_nodes = children(div1);
      span1 = claim_element(div1_nodes, "SPAN", {});
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, t1_value);
      span1_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      claim_component(chevrondown.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", {});
      var div2_nodes = children(div2);
      span2 = claim_element(div2_nodes, "SPAN", {});
      var span2_nodes = children(span2);
      if (below_slot) below_slot.l(span2_nodes);
      span2_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span0, "bx--tile-content__above-the-fold", true);
      add_location(span0, file155, 89, 6, 2387);
      toggle_class(div0, "bx--tile-content", true);
      add_location(div0, file155, 88, 4, 2320);
      add_location(span1, file155, 94, 6, 2546);
      toggle_class(div1, "bx--tile__chevron", true);
      add_location(div1, file155, 93, 4, 2501);
      toggle_class(span2, "bx--tile-content__below-the-fold", true);
      add_location(span2, file155, 98, 6, 2692);
      toggle_class(div2, "bx--tile-content", true);
      add_location(div2, file155, 97, 4, 2648);
      add_location(div3, file155, 87, 2, 2310);
      set_attributes(button, button_data);
      toggle_class(button, "bx--tile", true);
      toggle_class(button, "bx--tile--expandable", true);
      toggle_class(
        button,
        "bx--tile--is-expanded",
        /*expanded*/
        ctx[0]
      );
      toggle_class(
        button,
        "bx--tile--light",
        /*light*/
        ctx[4]
      );
      set_style(
        button,
        "max-height",
        /*expanded*/
        ctx[0] ? "none" : `${/*tileMaxHeight*/
        ctx[1] + /*tilePadding*/
        ctx[2]}px`
      );
      add_location(button, file155, 65, 0, 1766);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, div3);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, span0);
      if (above_slot) {
        above_slot.m(span0, null);
      }
      ctx[20](div0);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, span1);
      append_hydration_dev(span1, t1);
      append_hydration_dev(div1, t2);
      mount_component(chevrondown, div1, null);
      append_hydration_dev(div3, t3);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, span2);
      if (below_slot) {
        below_slot.m(span2, null);
      }
      if (button.autofocus) button.focus();
      ctx[21](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler_1*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keypress",
            /*keypress_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseover",
            /*mouseover_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (above_slot) {
        if (above_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            above_slot,
            above_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              above_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_above_slot_changes
            ),
            get_above_slot_context
          );
        }
      }
      if ((!current || dirty & /*expanded, tileExpandedLabel, tileCollapsedLabel*/
      385) && t1_value !== (t1_value = /*expanded*/
      (ctx2[0] ? (
        /*tileExpandedLabel*/
        ctx2[7]
      ) : (
        /*tileCollapsedLabel*/
        ctx2[8]
      )) + "")) set_data_dev(t1, t1_value);
      if (below_slot) {
        if (below_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            below_slot,
            below_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              below_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_below_slot_changes
            ),
            get_below_slot_context
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & /*id*/
        1024) && { id: (
          /*id*/
          ctx2[10]
        ) },
        (!current || dirty & /*expanded*/
        1) && { "aria-expanded": (
          /*expanded*/
          ctx2[0]
        ) },
        (!current || dirty & /*tabindex*/
        512) && { tabindex: (
          /*tabindex*/
          ctx2[9]
        ) },
        (!current || dirty & /*expanded, tileExpandedIconText, tileCollapsedIconText*/
        97 && button_title_value !== (button_title_value = /*expanded*/
        ctx2[0] ? (
          /*tileExpandedIconText*/
          ctx2[6]
        ) : (
          /*tileCollapsedIconText*/
          ctx2[5]
        ))) && { title: button_title_value },
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12]
      ]));
      toggle_class(button, "bx--tile", true);
      toggle_class(button, "bx--tile--expandable", true);
      toggle_class(
        button,
        "bx--tile--is-expanded",
        /*expanded*/
        ctx2[0]
      );
      toggle_class(
        button,
        "bx--tile--light",
        /*light*/
        ctx2[4]
      );
      set_style(
        button,
        "max-height",
        /*expanded*/
        ctx2[0] ? "none" : `${/*tileMaxHeight*/
        ctx2[1] + /*tilePadding*/
        ctx2[2]}px`
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(above_slot, local);
      transition_in(chevrondown.$$.fragment, local);
      transition_in(below_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(above_slot, local);
      transition_out(chevrondown.$$.fragment, local);
      transition_out(below_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (above_slot) above_slot.d(detaching);
      ctx[20](null);
      destroy_component(chevrondown);
      if (below_slot) below_slot.d(detaching);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment167.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance167($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "expanded",
    "light",
    "tileMaxHeight",
    "tilePadding",
    "tileCollapsedIconText",
    "tileExpandedIconText",
    "tileExpandedLabel",
    "tileCollapsedLabel",
    "tabindex",
    "id",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ExpandableTile", slots, ["above", "below"]);
  let { expanded = false } = $$props;
  let { light = false } = $$props;
  let { tileMaxHeight = 0 } = $$props;
  let { tilePadding = 0 } = $$props;
  let { tileCollapsedIconText = "Interact to expand Tile" } = $$props;
  let { tileExpandedIconText = "Interact to collapse Tile" } = $$props;
  let { tileExpandedLabel = "" } = $$props;
  let { tileCollapsedLabel = "" } = $$props;
  let { tabindex = "0" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  let refAbove = null;
  onMount(() => {
    const resizeObserver = new ResizeObserver(([elem]) => {
      $$invalidate(1, tileMaxHeight = elem.contentRect.height);
    });
    resizeObserver.observe(refAbove);
    return () => {
      resizeObserver.disconnect();
    };
  });
  afterUpdate(() => {
    if (tileMaxHeight === 0) {
      $$invalidate(1, tileMaxHeight = refAbove.getBoundingClientRect().height);
    }
    const style = getComputedStyle(ref);
    $$invalidate(2, tilePadding = parseInt(style.getPropertyValue("padding-top"), 10) + parseInt(style.getPropertyValue("padding-bottom"), 10));
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keypress_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refAbove = $$value;
      $$invalidate(11, refAbove);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  const click_handler_13 = () => {
    $$invalidate(0, expanded = !expanded);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("expanded" in $$new_props) $$invalidate(0, expanded = $$new_props.expanded);
    if ("light" in $$new_props) $$invalidate(4, light = $$new_props.light);
    if ("tileMaxHeight" in $$new_props) $$invalidate(1, tileMaxHeight = $$new_props.tileMaxHeight);
    if ("tilePadding" in $$new_props) $$invalidate(2, tilePadding = $$new_props.tilePadding);
    if ("tileCollapsedIconText" in $$new_props) $$invalidate(5, tileCollapsedIconText = $$new_props.tileCollapsedIconText);
    if ("tileExpandedIconText" in $$new_props) $$invalidate(6, tileExpandedIconText = $$new_props.tileExpandedIconText);
    if ("tileExpandedLabel" in $$new_props) $$invalidate(7, tileExpandedLabel = $$new_props.tileExpandedLabel);
    if ("tileCollapsedLabel" in $$new_props) $$invalidate(8, tileCollapsedLabel = $$new_props.tileCollapsedLabel);
    if ("tabindex" in $$new_props) $$invalidate(9, tabindex = $$new_props.tabindex);
    if ("id" in $$new_props) $$invalidate(10, id = $$new_props.id);
    if ("ref" in $$new_props) $$invalidate(3, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    expanded,
    light,
    tileMaxHeight,
    tilePadding,
    tileCollapsedIconText,
    tileExpandedIconText,
    tileExpandedLabel,
    tileCollapsedLabel,
    tabindex,
    id,
    ref,
    afterUpdate,
    onMount,
    ChevronDown: ChevronDown_default,
    refAbove
  });
  $$self.$inject_state = ($$new_props) => {
    if ("expanded" in $$props) $$invalidate(0, expanded = $$new_props.expanded);
    if ("light" in $$props) $$invalidate(4, light = $$new_props.light);
    if ("tileMaxHeight" in $$props) $$invalidate(1, tileMaxHeight = $$new_props.tileMaxHeight);
    if ("tilePadding" in $$props) $$invalidate(2, tilePadding = $$new_props.tilePadding);
    if ("tileCollapsedIconText" in $$props) $$invalidate(5, tileCollapsedIconText = $$new_props.tileCollapsedIconText);
    if ("tileExpandedIconText" in $$props) $$invalidate(6, tileExpandedIconText = $$new_props.tileExpandedIconText);
    if ("tileExpandedLabel" in $$props) $$invalidate(7, tileExpandedLabel = $$new_props.tileExpandedLabel);
    if ("tileCollapsedLabel" in $$props) $$invalidate(8, tileCollapsedLabel = $$new_props.tileCollapsedLabel);
    if ("tabindex" in $$props) $$invalidate(9, tabindex = $$new_props.tabindex);
    if ("id" in $$props) $$invalidate(10, id = $$new_props.id);
    if ("ref" in $$props) $$invalidate(3, ref = $$new_props.ref);
    if ("refAbove" in $$props) $$invalidate(11, refAbove = $$new_props.refAbove);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    expanded,
    tileMaxHeight,
    tilePadding,
    ref,
    light,
    tileCollapsedIconText,
    tileExpandedIconText,
    tileExpandedLabel,
    tileCollapsedLabel,
    tabindex,
    id,
    refAbove,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    keypress_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    div0_binding,
    button_binding,
    click_handler_13
  ];
}
var ExpandableTile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance167, create_fragment167, safe_not_equal, {
      expanded: 0,
      light: 4,
      tileMaxHeight: 1,
      tilePadding: 2,
      tileCollapsedIconText: 5,
      tileExpandedIconText: 6,
      tileExpandedLabel: 7,
      tileCollapsedLabel: 8,
      tabindex: 9,
      id: 10,
      ref: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ExpandableTile",
      options,
      id: create_fragment167.name
    });
  }
  get expanded() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tileMaxHeight() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tileMaxHeight(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tilePadding() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tilePadding(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tileCollapsedIconText() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tileCollapsedIconText(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tileExpandedIconText() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tileExpandedIconText(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tileExpandedLabel() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tileExpandedLabel(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tileCollapsedLabel() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tileCollapsedLabel(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ExpandableTile_default = ExpandableTile;

// node_modules/carbon-components-svelte/src/Tile/SelectableTile.svelte
var file156 = "node_modules/carbon-components-svelte/src/Tile/SelectableTile.svelte";
function create_fragment168(ctx) {
  let input;
  let t0;
  let label;
  let span0;
  let checkmarkfilled;
  let t1;
  let span1;
  let label_tabindex_value;
  let current;
  let mounted;
  let dispose;
  checkmarkfilled = new CheckmarkFilled_default({
    props: {
      "aria-label": (
        /*iconDescription*/
        ctx[7]
      ),
      title: (
        /*iconDescription*/
        ctx[7]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let label_levels = [
    { for: (
      /*id*/
      ctx[8]
    ) },
    {
      tabindex: label_tabindex_value = /*disabled*/
      ctx[3] ? void 0 : (
        /*tabindex*/
        ctx[6]
      )
    },
    /*$$restProps*/
    ctx[10]
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      label = element("label");
      span0 = element("span");
      create_component(checkmarkfilled.$$.fragment);
      t1 = space();
      span1 = element("span");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        tabindex: true,
        id: true,
        name: true,
        title: true
      });
      t0 = claim_space(nodes);
      label = claim_element(nodes, "LABEL", { for: true, tabindex: true });
      var label_nodes = children(label);
      span0 = claim_element(label_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      claim_component(checkmarkfilled.$$.fragment, span0_nodes);
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(label_nodes);
      span1 = claim_element(label_nodes, "SPAN", {});
      var span1_nodes = children(span1);
      if (default_slot) default_slot.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      attr_dev(input, "tabindex", "-1");
      input.checked = /*selected*/
      ctx[0];
      attr_dev(
        input,
        "id",
        /*id*/
        ctx[8]
      );
      input.value = /*value*/
      ctx[5];
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[9]
      );
      attr_dev(
        input,
        "title",
        /*title*/
        ctx[4]
      );
      input.disabled = /*disabled*/
      ctx[3];
      toggle_class(input, "bx--tile-input", true);
      add_location(input, file156, 47, 0, 1174);
      toggle_class(span0, "bx--tile__checkmark", true);
      add_location(span0, file156, 88, 2, 2158);
      toggle_class(span1, "bx--tile-content", true);
      add_location(span1, file156, 91, 2, 2293);
      set_attributes(label, label_data);
      toggle_class(label, "bx--tile", true);
      toggle_class(label, "bx--tile--selectable", true);
      toggle_class(
        label,
        "bx--tile--is-selected",
        /*selected*/
        ctx[0]
      );
      toggle_class(
        label,
        "bx--tile--light",
        /*light*/
        ctx[2]
      );
      toggle_class(
        label,
        "bx--tile--disabled",
        /*disabled*/
        ctx[3]
      );
      add_location(label, file156, 62, 0, 1560);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      ctx[18](input);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, span0);
      mount_component(checkmarkfilled, span0, null);
      append_hydration_dev(label, t1);
      append_hydration_dev(label, span1);
      if (default_slot) {
        default_slot.m(span1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            label,
            "click",
            /*click_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(label, "click", prevent_default(
            /*click_handler_1*/
            ctx[19]
          ), false, true, false, false),
          listen_dev(
            label,
            "mouseover",
            /*mouseover_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "keydown",
            /*keydown_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "keydown",
            /*keydown_handler_1*/
            ctx[20],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*selected*/
      1) {
        prop_dev(
          input,
          "checked",
          /*selected*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*id*/
      256) {
        attr_dev(
          input,
          "id",
          /*id*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*value*/
      32) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*name*/
      512) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[9]
        );
      }
      if (!current || dirty & /*title*/
      16) {
        attr_dev(
          input,
          "title",
          /*title*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*disabled*/
      8) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      const checkmarkfilled_changes = {};
      if (dirty & /*iconDescription*/
      128) checkmarkfilled_changes["aria-label"] = /*iconDescription*/
      ctx2[7];
      if (dirty & /*iconDescription*/
      128) checkmarkfilled_changes.title = /*iconDescription*/
      ctx2[7];
      checkmarkfilled.$set(checkmarkfilled_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & /*id*/
        256) && { for: (
          /*id*/
          ctx2[8]
        ) },
        (!current || dirty & /*disabled, tabindex*/
        72 && label_tabindex_value !== (label_tabindex_value = /*disabled*/
        ctx2[3] ? void 0 : (
          /*tabindex*/
          ctx2[6]
        ))) && { tabindex: label_tabindex_value },
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10]
      ]));
      toggle_class(label, "bx--tile", true);
      toggle_class(label, "bx--tile--selectable", true);
      toggle_class(
        label,
        "bx--tile--is-selected",
        /*selected*/
        ctx2[0]
      );
      toggle_class(
        label,
        "bx--tile--light",
        /*light*/
        ctx2[2]
      );
      toggle_class(
        label,
        "bx--tile--disabled",
        /*disabled*/
        ctx2[3]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(checkmarkfilled.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmarkfilled.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
        detach_dev(t0);
        detach_dev(label);
      }
      ctx[18](null);
      destroy_component(checkmarkfilled);
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment168.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance168($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "selected",
    "light",
    "disabled",
    "title",
    "value",
    "tabindex",
    "iconDescription",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectableTile", slots, ["default"]);
  let { selected = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { title = "title" } = $$props;
  let { value = "value" } = $$props;
  let { tabindex = "0" } = $$props;
  let { iconDescription = "Tile checkmark" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = "" } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const click_handler_13 = () => {
    if (disabled) return;
    $$invalidate(0, selected = !selected);
  };
  const keydown_handler_12 = (e) => {
    if (disabled) return;
    if (e.key === " " || e.key === "Enter") {
      e.preventDefault();
      $$invalidate(0, selected = !selected);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props) $$invalidate(0, selected = $$new_props.selected);
    if ("light" in $$new_props) $$invalidate(2, light = $$new_props.light);
    if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
    if ("title" in $$new_props) $$invalidate(4, title = $$new_props.title);
    if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
    if ("tabindex" in $$new_props) $$invalidate(6, tabindex = $$new_props.tabindex);
    if ("iconDescription" in $$new_props) $$invalidate(7, iconDescription = $$new_props.iconDescription);
    if ("id" in $$new_props) $$invalidate(8, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(9, name = $$new_props.name);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    light,
    disabled,
    title,
    value,
    tabindex,
    iconDescription,
    id,
    name,
    ref,
    createEventDispatcher,
    CheckmarkFilled: CheckmarkFilled_default,
    dispatch
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props) $$invalidate(0, selected = $$new_props.selected);
    if ("light" in $$props) $$invalidate(2, light = $$new_props.light);
    if ("disabled" in $$props) $$invalidate(3, disabled = $$new_props.disabled);
    if ("title" in $$props) $$invalidate(4, title = $$new_props.title);
    if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
    if ("tabindex" in $$props) $$invalidate(6, tabindex = $$new_props.tabindex);
    if ("iconDescription" in $$props) $$invalidate(7, iconDescription = $$new_props.iconDescription);
    if ("id" in $$props) $$invalidate(8, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(9, name = $$new_props.name);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*disabled, selected, id*/
    265) {
      $: if (!disabled) dispatch(selected ? "select" : "deselect", id);
    }
  };
  return [
    selected,
    ref,
    light,
    disabled,
    title,
    value,
    tabindex,
    iconDescription,
    id,
    name,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    input_binding,
    click_handler_13,
    keydown_handler_12
  ];
}
var SelectableTile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance168, create_fragment168, safe_not_equal, {
      selected: 0,
      light: 2,
      disabled: 3,
      title: 4,
      value: 5,
      tabindex: 6,
      iconDescription: 7,
      id: 8,
      name: 9,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectableTile",
      options,
      id: create_fragment168.name
    });
  }
  get selected() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectableTile_default = SelectableTile;

// node_modules/carbon-components-svelte/src/Tile/RadioTile.svelte
var file157 = "node_modules/carbon-components-svelte/src/Tile/RadioTile.svelte";
function create_fragment169(ctx) {
  let input;
  let input_name_value;
  let input_tabindex_value;
  let input_required_value;
  let t0;
  let label;
  let span0;
  let checkmarkfilled;
  let t1;
  let span1;
  let current;
  let mounted;
  let dispose;
  checkmarkfilled = new CheckmarkFilled_default({
    props: {
      "aria-label": (
        /*iconDescription*/
        ctx[6]
      ),
      title: (
        /*iconDescription*/
        ctx[6]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  let label_levels = [
    { for: (
      /*id*/
      ctx[7]
    ) },
    /*$$restProps*/
    ctx[15]
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      label = element("label");
      span0 = element("span");
      create_component(checkmarkfilled.$$.fragment);
      t1 = space();
      span1 = element("span");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        id: true,
        name: true,
        tabindex: true
      });
      t0 = claim_space(nodes);
      label = claim_element(nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      span0 = claim_element(label_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      claim_component(checkmarkfilled.$$.fragment, span0_nodes);
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(label_nodes);
      span1 = claim_element(label_nodes, "SPAN", {});
      var span1_nodes = children(span1);
      if (default_slot) default_slot.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "radio");
      attr_dev(
        input,
        "id",
        /*id*/
        ctx[7]
      );
      attr_dev(input, "name", input_name_value = /*$groupName*/
      ctx[9] ?? /*name*/
      ctx[8]);
      input.value = /*value*/
      ctx[4];
      input.checked = /*checked*/
      ctx[0];
      attr_dev(input, "tabindex", input_tabindex_value = /*disabled*/
      ctx[2] ? void 0 : (
        /*tabindex*/
        ctx[5]
      ));
      input.disabled = /*disabled*/
      ctx[2];
      input.required = input_required_value = /*$groupRequired*/
      ctx[10] ?? /*required*/
      ctx[3];
      toggle_class(input, "bx--tile-input", true);
      add_location(input, file157, 48, 0, 1257);
      toggle_class(span0, "bx--tile__checkmark", true);
      add_location(span0, file157, 87, 2, 2167);
      toggle_class(span1, "bx--tile-content", true);
      add_location(span1, file157, 90, 2, 2302);
      set_attributes(label, label_data);
      toggle_class(label, "bx--tile", true);
      toggle_class(label, "bx--tile--selectable", true);
      toggle_class(
        label,
        "bx--tile--is-selected",
        /*checked*/
        ctx[0]
      );
      toggle_class(
        label,
        "bx--tile--light",
        /*light*/
        ctx[1]
      );
      toggle_class(
        label,
        "bx--tile--disabled",
        /*disabled*/
        ctx[2]
      );
      add_location(label, file157, 74, 0, 1886);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, span0);
      mount_component(checkmarkfilled, span0, null);
      append_hydration_dev(label, t1);
      append_hydration_dev(label, span1);
      if (default_slot) {
        default_slot.m(span1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_1*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_1*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "click",
            /*click_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "mouseover",
            /*mouseover_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*id*/
      128) {
        attr_dev(
          input,
          "id",
          /*id*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*$groupName, name*/
      768 && input_name_value !== (input_name_value = /*$groupName*/
      ctx2[9] ?? /*name*/
      ctx2[8])) {
        attr_dev(input, "name", input_name_value);
      }
      if (!current || dirty & /*value*/
      16) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*checked*/
      1) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*disabled, tabindex*/
      36 && input_tabindex_value !== (input_tabindex_value = /*disabled*/
      ctx2[2] ? void 0 : (
        /*tabindex*/
        ctx2[5]
      ))) {
        attr_dev(input, "tabindex", input_tabindex_value);
      }
      if (!current || dirty & /*disabled*/
      4) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$groupRequired, required*/
      1032 && input_required_value !== (input_required_value = /*$groupRequired*/
      ctx2[10] ?? /*required*/
      ctx2[3])) {
        prop_dev(input, "required", input_required_value);
      }
      const checkmarkfilled_changes = {};
      if (dirty & /*iconDescription*/
      64) checkmarkfilled_changes["aria-label"] = /*iconDescription*/
      ctx2[6];
      if (dirty & /*iconDescription*/
      64) checkmarkfilled_changes.title = /*iconDescription*/
      ctx2[6];
      checkmarkfilled.$set(checkmarkfilled_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & /*id*/
        128) && { for: (
          /*id*/
          ctx2[7]
        ) },
        dirty & /*$$restProps*/
        32768 && /*$$restProps*/
        ctx2[15]
      ]));
      toggle_class(label, "bx--tile", true);
      toggle_class(label, "bx--tile--selectable", true);
      toggle_class(
        label,
        "bx--tile--is-selected",
        /*checked*/
        ctx2[0]
      );
      toggle_class(
        label,
        "bx--tile--light",
        /*light*/
        ctx2[1]
      );
      toggle_class(
        label,
        "bx--tile--disabled",
        /*disabled*/
        ctx2[2]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(checkmarkfilled.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmarkfilled.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
        detach_dev(t0);
        detach_dev(label);
      }
      destroy_component(checkmarkfilled);
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment169.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance169($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "checked",
    "light",
    "disabled",
    "required",
    "value",
    "tabindex",
    "iconDescription",
    "id",
    "name"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedValue;
  let $groupName;
  let $groupRequired;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioTile", slots, ["default"]);
  let { checked = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { required = false } = $$props;
  let { value = "" } = $$props;
  let { tabindex = "0" } = $$props;
  let { iconDescription = "Tile checkmark" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  const { add, update, selectedValue, groupName, groupRequired } = getContext("TileGroup") ?? {
    groupName: readable(void 0),
    groupRequired: readable(void 0),
    selectedValue: readable(checked ? value : void 0)
  };
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value2) => $$invalidate(16, $selectedValue = value2));
  validate_store(groupName, "groupName");
  component_subscribe($$self, groupName, (value2) => $$invalidate(9, $groupName = value2));
  validate_store(groupRequired, "groupRequired");
  component_subscribe($$self, groupRequired, (value2) => $$invalidate(10, $groupRequired = value2));
  add({ value, checked });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const change_handler_1 = () => {
    if (disabled) return;
    update(value);
  };
  const keydown_handler_12 = (e) => {
    if (disabled) return;
    if (e.key === " " || e.key === "Enter") {
      e.preventDefault();
      update(value);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
    if ("light" in $$new_props) $$invalidate(1, light = $$new_props.light);
    if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("required" in $$new_props) $$invalidate(3, required = $$new_props.required);
    if ("value" in $$new_props) $$invalidate(4, value = $$new_props.value);
    if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    if ("iconDescription" in $$new_props) $$invalidate(6, iconDescription = $$new_props.iconDescription);
    if ("id" in $$new_props) $$invalidate(7, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(8, name = $$new_props.name);
    if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    checked,
    light,
    disabled,
    required,
    value,
    tabindex,
    iconDescription,
    id,
    name,
    getContext,
    readable,
    CheckmarkFilled: CheckmarkFilled_default,
    add,
    update,
    selectedValue,
    groupName,
    groupRequired,
    $selectedValue,
    $groupName,
    $groupRequired
  });
  $$self.$inject_state = ($$new_props) => {
    if ("checked" in $$props) $$invalidate(0, checked = $$new_props.checked);
    if ("light" in $$props) $$invalidate(1, light = $$new_props.light);
    if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("required" in $$props) $$invalidate(3, required = $$new_props.required);
    if ("value" in $$props) $$invalidate(4, value = $$new_props.value);
    if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    if ("iconDescription" in $$props) $$invalidate(6, iconDescription = $$new_props.iconDescription);
    if ("id" in $$props) $$invalidate(7, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(8, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value, $selectedValue*/
    65552) {
      $: $$invalidate(0, checked = value === $selectedValue);
    }
  };
  return [
    checked,
    light,
    disabled,
    required,
    value,
    tabindex,
    iconDescription,
    id,
    name,
    $groupName,
    $groupRequired,
    update,
    selectedValue,
    groupName,
    groupRequired,
    $$restProps,
    $selectedValue,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    change_handler,
    keydown_handler,
    change_handler_1,
    keydown_handler_12
  ];
}
var RadioTile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance169, create_fragment169, safe_not_equal, {
      checked: 0,
      light: 1,
      disabled: 2,
      required: 3,
      value: 4,
      tabindex: 5,
      iconDescription: 6,
      id: 7,
      name: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioTile",
      options,
      id: create_fragment169.name
    });
  }
  get checked() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioTile_default = RadioTile;

// node_modules/carbon-components-svelte/src/Tile/TileGroup.svelte
var file158 = "node_modules/carbon-components-svelte/src/Tile/TileGroup.svelte";
function create_if_block97(ctx) {
  let legend_1;
  let t;
  const block = {
    c: function create() {
      legend_1 = element("legend");
      t = text(
        /*legend*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      legend_1 = claim_element(nodes, "LEGEND", {});
      var legend_1_nodes = children(legend_1);
      t = claim_text(
        legend_1_nodes,
        /*legend*/
        ctx[1]
      );
      legend_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(legend_1, "bx--label", true);
      add_location(legend_1, file158, 60, 4, 1402);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, legend_1, anchor);
      append_hydration_dev(legend_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*legend*/
      2) set_data_dev(
        t,
        /*legend*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(legend_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block97.name,
    type: "if",
    source: "(60:2) {#if legend}",
    ctx
  });
  return block;
}
function create_fragment170(ctx) {
  let fieldset;
  let t;
  let div;
  let current;
  let if_block = (
    /*legend*/
    ctx[1] && create_if_block97(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let fieldset_levels = [
    { disabled: (
      /*disabled*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[5]
  ];
  let fieldset_data = {};
  for (let i = 0; i < fieldset_levels.length; i += 1) {
    fieldset_data = assign(fieldset_data, fieldset_levels[i]);
  }
  const block = {
    c: function create() {
      fieldset = element("fieldset");
      if (if_block) if_block.c();
      t = space();
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      fieldset = claim_element(nodes, "FIELDSET", {});
      var fieldset_nodes = children(fieldset);
      if (if_block) if_block.l(fieldset_nodes);
      t = claim_space(fieldset_nodes);
      div = claim_element(fieldset_nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      fieldset_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file158, 62, 2, 1463);
      set_attributes(fieldset, fieldset_data);
      toggle_class(fieldset, "bx--tile-group", true);
      add_location(fieldset, file158, 58, 0, 1303);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, fieldset, anchor);
      if (if_block) if_block.m(fieldset, null);
      append_hydration_dev(fieldset, t);
      append_hydration_dev(fieldset, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*legend*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block97(ctx2);
          if_block.c();
          if_block.m(fieldset, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(fieldset, fieldset_data = get_spread_update(fieldset_levels, [
        (!current || dirty & /*disabled*/
        1) && { disabled: (
          /*disabled*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      toggle_class(fieldset, "bx--tile-group", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(fieldset);
      }
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment170.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance170($$self, $$props, $$invalidate) {
  const omit_props_names = ["selected", "disabled", "required", "name", "legend"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $groupRequired;
  let $groupName;
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TileGroup", slots, ["default"]);
  let { selected = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { required = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { legend = "" } = $$props;
  const dispatch = createEventDispatcher();
  const selectedValue = writable(selected);
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value) => $$invalidate(9, $selectedValue = value));
  const groupName = writable(name);
  validate_store(groupName, "groupName");
  component_subscribe($$self, groupName, (value) => $$invalidate(13, $groupName = value));
  const groupRequired = writable(required);
  validate_store(groupRequired, "groupRequired");
  component_subscribe($$self, groupRequired, (value) => $$invalidate(12, $groupRequired = value));
  setContext("TileGroup", {
    selectedValue,
    groupName: readonly(groupName),
    groupRequired: readonly(groupRequired),
    add: ({ checked, value }) => {
      if (checked) {
        selectedValue.set(value);
      }
    },
    update: (value) => {
      selectedValue.set(value);
      dispatch("select", value);
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props) $$invalidate(6, selected = $$new_props.selected);
    if ("disabled" in $$new_props) $$invalidate(0, disabled = $$new_props.disabled);
    if ("required" in $$new_props) $$invalidate(7, required = $$new_props.required);
    if ("name" in $$new_props) $$invalidate(8, name = $$new_props.name);
    if ("legend" in $$new_props) $$invalidate(1, legend = $$new_props.legend);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    disabled,
    required,
    name,
    legend,
    createEventDispatcher,
    setContext,
    writable,
    readonly,
    dispatch,
    selectedValue,
    groupName,
    groupRequired,
    $groupRequired,
    $groupName,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props) $$invalidate(6, selected = $$new_props.selected);
    if ("disabled" in $$props) $$invalidate(0, disabled = $$new_props.disabled);
    if ("required" in $$props) $$invalidate(7, required = $$new_props.required);
    if ("name" in $$props) $$invalidate(8, name = $$new_props.name);
    if ("legend" in $$props) $$invalidate(1, legend = $$new_props.legend);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selectedValue*/
    512) {
      $: $$invalidate(6, selected = $selectedValue);
    }
    if ($$self.$$.dirty & /*selected*/
    64) {
      $: selectedValue.set(selected);
    }
    if ($$self.$$.dirty & /*name*/
    256) {
      $: set_store_value(groupName, $groupName = name, $groupName);
    }
    if ($$self.$$.dirty & /*required*/
    128) {
      $: set_store_value(groupRequired, $groupRequired = required, $groupRequired);
    }
  };
  return [
    disabled,
    legend,
    selectedValue,
    groupName,
    groupRequired,
    $$restProps,
    selected,
    required,
    name,
    $selectedValue,
    $$scope,
    slots
  ];
}
var TileGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance170, create_fragment170, safe_not_equal, {
      selected: 6,
      disabled: 0,
      required: 7,
      name: 8,
      legend: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TileGroup",
      options,
      id: create_fragment170.name
    });
  }
  get selected() {
    throw new Error("<TileGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<TileGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TileGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TileGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<TileGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<TileGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<TileGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<TileGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<TileGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<TileGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TileGroup_default = TileGroup;

// node_modules/carbon-components-svelte/src/TimePicker/TimePicker.svelte
var file159 = "node_modules/carbon-components-svelte/src/TimePicker/TimePicker.svelte";
var get_labelText_slot_changes15 = (dirty) => ({});
var get_labelText_slot_context15 = (ctx) => ({});
function create_if_block_141(ctx) {
  let label;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[17].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_labelText_slot_context15
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block35(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[12]
      );
      toggle_class(label, "bx--label", true);
      toggle_class(
        label,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[9]
      );
      toggle_class(
        label,
        "bx--label--disabled",
        /*disabled*/
        ctx[7]
      );
      add_location(label, file159, 73, 8, 1875);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_labelText_slot_changes15
            ),
            get_labelText_slot_context15
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & /*labelText*/
        256)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*id*/
      4096) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[12]
        );
      }
      if (!current || dirty & /*hideLabel*/
      512) {
        toggle_class(
          label,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[9]
        );
      }
      if (!current || dirty & /*disabled*/
      128) {
        toggle_class(
          label,
          "bx--label--disabled",
          /*disabled*/
          ctx2[7]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_141.name,
    type: "if",
    source: "(73:6) {#if labelText || $$slots.labelText}",
    ctx
  });
  return block;
}
function fallback_block35(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[8]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[8]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelText*/
      256) set_data_dev(
        t,
        /*labelText*/
        ctx2[8]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block35.name,
    type: "fallback",
    source: "(80:33)              ",
    ctx
  });
  return block;
}
function create_if_block98(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*invalidText*/
        ctx[11]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*invalidText*/
        ctx[11]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file159, 112, 4, 2836);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*invalidText*/
      2048) set_data_dev(
        t,
        /*invalidText*/
        ctx2[11]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block98.name,
    type: "if",
    source: "(112:2) {#if invalid}",
    ctx
  });
  return block;
}
function create_fragment171(ctx) {
  let div2;
  let div1;
  let div0;
  let t0;
  let input;
  let input_data_invalid_value;
  let t1;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*labelText*/
    (ctx[8] || /*$$slots*/
    ctx[14].labelText) && create_if_block_141(ctx)
  );
  let input_levels = [
    { type: "text" },
    {
      "data-invalid": input_data_invalid_value = /*invalid*/
      ctx[10] || void 0
    },
    { pattern: (
      /*pattern*/
      ctx[4]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[3]
    ) },
    { maxlength: (
      /*maxlength*/
      ctx[5]
    ) },
    { id: (
      /*id*/
      ctx[12]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { disabled: (
      /*disabled*/
      ctx[7]
    ) },
    /*$$restProps*/
    ctx[15]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let if_block1 = (
    /*invalid*/
    ctx[10] && create_if_block98(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      input = element("input");
      t1 = space();
      if (default_slot) default_slot.c();
      t2 = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (if_block0) if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      input = claim_element(div0_nodes, "INPUT", {
        type: true,
        "data-invalid": true,
        pattern: true,
        placeholder: true,
        maxlength: true,
        id: true,
        name: true
      });
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (default_slot) default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      if (if_block1) if_block1.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "bx--time-picker__input-field", true);
      toggle_class(input, "bx--text-input", true);
      toggle_class(
        input,
        "bx--text-input--light",
        /*light*/
        ctx[6]
      );
      toggle_class(
        input,
        "bx--text-input--invalid",
        /*invalid*/
        ctx[10]
      );
      add_location(input, file159, 84, 6, 2158);
      toggle_class(div0, "bx--time-picker__input", true);
      add_location(div0, file159, 71, 4, 1780);
      toggle_class(div1, "bx--time-picker", true);
      toggle_class(
        div1,
        "bx--time-picker--light",
        /*light*/
        ctx[6]
      );
      toggle_class(
        div1,
        "bx--time-picker--invalid",
        /*invalid*/
        ctx[10]
      );
      toggle_class(
        div1,
        "bx--time-picker--sm",
        /*size*/
        ctx[2] === "sm"
      );
      toggle_class(
        div1,
        "bx--time-picker--xl",
        /*size*/
        ctx[2] === "xl"
      );
      toggle_class(
        div1,
        "bx--select--light",
        /*light*/
        ctx[6]
      );
      add_location(div1, file159, 63, 2, 1508);
      toggle_class(div2, "bx--form-item", true);
      add_location(div2, file159, 56, 0, 1410);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if (if_block0) if_block0.m(div0, null);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div0, input);
      if (input.autofocus) input.focus();
      ctx[29](input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      append_hydration_dev(div1, t1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_hydration_dev(div2, t2);
      if (if_block1) if_block1.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[30]
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "paste",
            /*paste_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "click",
            /*click_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseover",
            /*mouseover_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*labelText*/
        ctx2[8] || /*$$slots*/
        ctx2[14].labelText
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*labelText, $$slots*/
          16640) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_141(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        (!current || dirty & /*invalid*/
        1024 && input_data_invalid_value !== (input_data_invalid_value = /*invalid*/
        ctx2[10] || void 0)) && { "data-invalid": input_data_invalid_value },
        (!current || dirty & /*pattern*/
        16) && { pattern: (
          /*pattern*/
          ctx2[4]
        ) },
        (!current || dirty & /*placeholder*/
        8) && { placeholder: (
          /*placeholder*/
          ctx2[3]
        ) },
        (!current || dirty & /*maxlength*/
        32) && { maxlength: (
          /*maxlength*/
          ctx2[5]
        ) },
        (!current || dirty & /*id*/
        4096) && { id: (
          /*id*/
          ctx2[12]
        ) },
        (!current || dirty & /*name*/
        8192) && { name: (
          /*name*/
          ctx2[13]
        ) },
        (!current || dirty & /*disabled*/
        128) && { disabled: (
          /*disabled*/
          ctx2[7]
        ) },
        dirty & /*$$restProps*/
        32768 && /*$$restProps*/
        ctx2[15]
      ]));
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(input, "bx--time-picker__input-field", true);
      toggle_class(input, "bx--text-input", true);
      toggle_class(
        input,
        "bx--text-input--light",
        /*light*/
        ctx2[6]
      );
      toggle_class(
        input,
        "bx--text-input--invalid",
        /*invalid*/
        ctx2[10]
      );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*light*/
      64) {
        toggle_class(
          div1,
          "bx--time-picker--light",
          /*light*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*invalid*/
      1024) {
        toggle_class(
          div1,
          "bx--time-picker--invalid",
          /*invalid*/
          ctx2[10]
        );
      }
      if (!current || dirty & /*size*/
      4) {
        toggle_class(
          div1,
          "bx--time-picker--sm",
          /*size*/
          ctx2[2] === "sm"
        );
      }
      if (!current || dirty & /*size*/
      4) {
        toggle_class(
          div1,
          "bx--time-picker--xl",
          /*size*/
          ctx2[2] === "xl"
        );
      }
      if (!current || dirty & /*light*/
      64) {
        toggle_class(
          div1,
          "bx--select--light",
          /*light*/
          ctx2[6]
        );
      }
      if (
        /*invalid*/
        ctx2[10]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block98(ctx2);
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block0) if_block0.d();
      ctx[29](null);
      if (default_slot) default_slot.d(detaching);
      if (if_block1) if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment171.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance171($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "size",
    "value",
    "placeholder",
    "pattern",
    "maxlength",
    "light",
    "disabled",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TimePicker", slots, ["labelText", "default"]);
  const $$slots = compute_slots(slots);
  let { size = void 0 } = $$props;
  let { value = "" } = $$props;
  let { placeholder = "hh:mm" } = $$props;
  let { pattern = "(1[012]|[1-9]):[0-5][0-9](\\s)?" } = $$props;
  let { maxlength = 5 } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(2, size = $$new_props.size);
    if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    if ("placeholder" in $$new_props) $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("pattern" in $$new_props) $$invalidate(4, pattern = $$new_props.pattern);
    if ("maxlength" in $$new_props) $$invalidate(5, maxlength = $$new_props.maxlength);
    if ("light" in $$new_props) $$invalidate(6, light = $$new_props.light);
    if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("labelText" in $$new_props) $$invalidate(8, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props) $$invalidate(9, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$new_props) $$invalidate(10, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props) $$invalidate(11, invalidText = $$new_props.invalidText);
    if ("id" in $$new_props) $$invalidate(12, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(13, name = $$new_props.name);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    value,
    placeholder,
    pattern,
    maxlength,
    light,
    disabled,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    id,
    name,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props) $$invalidate(2, size = $$new_props.size);
    if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    if ("placeholder" in $$props) $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("pattern" in $$props) $$invalidate(4, pattern = $$new_props.pattern);
    if ("maxlength" in $$props) $$invalidate(5, maxlength = $$new_props.maxlength);
    if ("light" in $$props) $$invalidate(6, light = $$new_props.light);
    if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    if ("labelText" in $$props) $$invalidate(8, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props) $$invalidate(9, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$props) $$invalidate(10, invalid = $$new_props.invalid);
    if ("invalidText" in $$props) $$invalidate(11, invalidText = $$new_props.invalidText);
    if ("id" in $$props) $$invalidate(12, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(13, name = $$new_props.name);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    value,
    ref,
    size,
    placeholder,
    pattern,
    maxlength,
    light,
    disabled,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    id,
    name,
    $$slots,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    change_handler,
    input_handler,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    paste_handler,
    input_binding,
    input_input_handler
  ];
}
var TimePicker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance171, create_fragment171, safe_not_equal, {
      size: 2,
      value: 0,
      placeholder: 3,
      pattern: 4,
      maxlength: 5,
      light: 6,
      disabled: 7,
      labelText: 8,
      hideLabel: 9,
      invalid: 10,
      invalidText: 11,
      id: 12,
      name: 13,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TimePicker",
      options,
      id: create_fragment171.name
    });
  }
  get size() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pattern() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pattern(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxlength() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxlength(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TimePicker_default = TimePicker;

// node_modules/carbon-components-svelte/src/TimePicker/TimePickerSelect.svelte
var file160 = "node_modules/carbon-components-svelte/src/TimePicker/TimePickerSelect.svelte";
var get_labelText_slot_changes16 = (dirty) => ({});
var get_labelText_slot_context16 = (ctx) => ({});
function create_if_block99(ctx) {
  let label;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[12].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_labelText_slot_context16
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block36(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[5]
      );
      toggle_class(label, "bx--label", true);
      toggle_class(label, "bx--visually-hidden", true);
      add_location(label, file160, 52, 4, 1269);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_labelText_slot_changes16
            ),
            get_labelText_slot_context16
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & /*labelText*/
        16)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*id*/
      32) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[5]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block99.name,
    type: "if",
    source: "(52:2) {#if labelText || $$slots.labelText}",
    ctx
  });
  return block;
}
function fallback_block36(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelText*/
      16) set_data_dev(
        t,
        /*labelText*/
        ctx2[4]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block36.name,
    type: "fallback",
    source: "(58:29)          ",
    ctx
  });
  return block;
}
function create_fragment172(ctx) {
  let div;
  let t0;
  let select;
  let t1;
  let chevrondown;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*labelText*/
    (ctx[4] || /*$$slots*/
    ctx[9].labelText) && create_if_block99(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  chevrondown = new ChevronDown_default({
    props: {
      "aria-label": (
        /*iconDescription*/
        ctx[3]
      ),
      title: (
        /*iconDescription*/
        ctx[3]
      ),
      class: "bx--select__arrow"
    },
    $$inline: true
  });
  let div_levels = [
    /*$$restProps*/
    ctx[8]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block) if_block.c();
      t0 = space();
      select = element("select");
      if (default_slot) default_slot.c();
      t1 = space();
      create_component(chevrondown.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block) if_block.l(div_nodes);
      t0 = claim_space(div_nodes);
      select = claim_element(div_nodes, "SELECT", { id: true, name: true });
      var select_nodes = children(select);
      if (default_slot) default_slot.l(select_nodes);
      select_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      claim_component(chevrondown.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        select,
        "id",
        /*id*/
        ctx[5]
      );
      attr_dev(
        select,
        "name",
        /*name*/
        ctx[6]
      );
      select.disabled = /*disabled*/
      ctx[2];
      toggle_class(select, "bx--select-input", true);
      add_location(select, file160, 63, 2, 1500);
      set_attributes(div, div_data);
      toggle_class(div, "bx--select", true);
      toggle_class(div, "bx--time-picker__select", true);
      add_location(div, file160, 42, 0, 1073);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, select);
      if (default_slot) {
        default_slot.m(select, null);
      }
      select_option(
        select,
        /*value*/
        ctx[0]
      );
      ctx[17](select);
      append_hydration_dev(div, t1);
      mount_component(chevrondown, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*change_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*labelText*/
        ctx2[4] || /*$$slots*/
        ctx2[9].labelText
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*labelText, $$slots*/
          528) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block99(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      32) {
        attr_dev(
          select,
          "id",
          /*id*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*name*/
      64) {
        attr_dev(
          select,
          "name",
          /*name*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*disabled*/
      4) {
        prop_dev(
          select,
          "disabled",
          /*disabled*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*value*/
      1) {
        select_option(
          select,
          /*value*/
          ctx2[0]
        );
      }
      const chevrondown_changes = {};
      if (dirty & /*iconDescription*/
      8) chevrondown_changes["aria-label"] = /*iconDescription*/
      ctx2[3];
      if (dirty & /*iconDescription*/
      8) chevrondown_changes.title = /*iconDescription*/
      ctx2[3];
      chevrondown.$set(chevrondown_changes);
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      256 && /*$$restProps*/
      ctx2[8]]));
      toggle_class(div, "bx--select", true);
      toggle_class(div, "bx--time-picker__select", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(default_slot, local);
      transition_in(chevrondown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      transition_out(chevrondown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
      ctx[17](null);
      destroy_component(chevrondown);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment172.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance172($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "disabled", "iconDescription", "labelText", "id", "name", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TimePickerSelect", slots, ["labelText", "default"]);
  const $$slots = compute_slots(slots);
  let { value = "" } = $$props;
  let { disabled = false } = $$props;
  let { iconDescription = "Open list of options" } = $$props;
  let { labelText = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  const selectedValue = writable(value);
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value2) => $$invalidate(10, $selectedValue = value2));
  setContext("TimePickerSelect", { selectedValue });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const change_handler = ({ target }) => {
    selectedValue.set(target.value);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("iconDescription" in $$new_props) $$invalidate(3, iconDescription = $$new_props.iconDescription);
    if ("labelText" in $$new_props) $$invalidate(4, labelText = $$new_props.labelText);
    if ("id" in $$new_props) $$invalidate(5, id = $$new_props.id);
    if ("name" in $$new_props) $$invalidate(6, name = $$new_props.name);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    disabled,
    iconDescription,
    labelText,
    id,
    name,
    ref,
    setContext,
    writable,
    ChevronDown: ChevronDown_default,
    selectedValue,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("iconDescription" in $$props) $$invalidate(3, iconDescription = $$new_props.iconDescription);
    if ("labelText" in $$props) $$invalidate(4, labelText = $$new_props.labelText);
    if ("id" in $$props) $$invalidate(5, id = $$new_props.id);
    if ("name" in $$props) $$invalidate(6, name = $$new_props.name);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selectedValue*/
    1024) {
      $: $$invalidate(0, value = $selectedValue);
    }
    if ($$self.$$.dirty & /*value*/
    1) {
      $: selectedValue.set(value);
    }
  };
  return [
    value,
    ref,
    disabled,
    iconDescription,
    labelText,
    id,
    name,
    selectedValue,
    $$restProps,
    $$slots,
    $selectedValue,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    select_binding,
    change_handler
  ];
}
var TimePickerSelect = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance172, create_fragment172, safe_not_equal, {
      value: 0,
      disabled: 2,
      iconDescription: 3,
      labelText: 4,
      id: 5,
      name: 6,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TimePickerSelect",
      options,
      id: create_fragment172.name
    });
  }
  get value() {
    throw new Error("<TimePickerSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TimePickerSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TimePickerSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TimePickerSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<TimePickerSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<TimePickerSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<TimePickerSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<TimePickerSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TimePickerSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TimePickerSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<TimePickerSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<TimePickerSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<TimePickerSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<TimePickerSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TimePickerSelect_default = TimePickerSelect;

// node_modules/carbon-components-svelte/src/Toggle/ToggleSkeleton.svelte
var file161 = "node_modules/carbon-components-svelte/src/Toggle/ToggleSkeleton.svelte";
var get_labelText_slot_changes17 = (dirty) => ({});
var get_labelText_slot_context17 = (ctx) => ({});
function create_if_block100(ctx) {
  let span;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[7].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_labelText_slot_context17
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block37(ctx);
  const block = {
    c: function create() {
      span = element("span");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--toggle__label-text", true);
      add_location(span, file161, 40, 6, 912);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_labelText_slot_changes17
            ),
            get_labelText_slot_context17
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & /*labelText*/
        2)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block100.name,
    type: "if",
    source: "(40:4) {#if labelText || $$slots.labelText}",
    ctx
  });
  return block;
}
function fallback_block37(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelText*/
      2) set_data_dev(
        t,
        /*labelText*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block37.name,
    type: "fallback",
    source: "(42:31)            ",
    ctx
  });
  return block;
}
function create_fragment173(ctx) {
  let div;
  let input;
  let t0;
  let label;
  let t1;
  let span0;
  let t2;
  let span1;
  let t3;
  let span2;
  let label_aria_label_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*labelText*/
    (ctx[1] || /*$$slots*/
    ctx[5].labelText) && create_if_block100(ctx)
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t0 = space();
      label = element("label");
      if (if_block) if_block.c();
      t1 = space();
      span0 = element("span");
      t2 = space();
      span1 = element("span");
      t3 = space();
      span2 = element("span");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", { type: true, id: true });
      t0 = claim_space(div_nodes);
      label = claim_element(div_nodes, "LABEL", { "aria-label": true, for: true });
      var label_nodes = children(label);
      if (if_block) if_block.l(label_nodes);
      t1 = claim_space(label_nodes);
      span0 = claim_element(label_nodes, "SPAN", {});
      children(span0).forEach(detach_dev);
      t2 = claim_space(label_nodes);
      span1 = claim_element(label_nodes, "SPAN", {});
      children(span1).forEach(detach_dev);
      t3 = claim_space(label_nodes);
      span2 = claim_element(label_nodes, "SPAN", {});
      children(span2).forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      attr_dev(
        input,
        "id",
        /*id*/
        ctx[2]
      );
      toggle_class(input, "bx--toggle", true);
      toggle_class(
        input,
        "bx--toggle--small",
        /*size*/
        ctx[0] === "sm"
      );
      toggle_class(input, "bx--skeleton", true);
      add_location(input, file161, 24, 2, 514);
      toggle_class(span0, "bx--toggle__text--left", true);
      add_location(span0, file161, 46, 4, 1055);
      toggle_class(span1, "bx--toggle__appearance", true);
      add_location(span1, file161, 47, 4, 1111);
      toggle_class(span2, "bx--toggle__text--right", true);
      add_location(span2, file161, 48, 4, 1167);
      attr_dev(label, "aria-label", label_aria_label_value = /*labelText*/
      ctx[1] ? void 0 : (
        /*$$props*/
        ctx[4]["aria-label"] || "Toggle is loading"
      ));
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[2]
      );
      toggle_class(label, "bx--toggle__label", true);
      toggle_class(label, "bx--skeleton", true);
      add_location(label, file161, 31, 2, 670);
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      add_location(div, file161, 16, 0, 397);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, label);
      if (if_block) if_block.m(label, null);
      append_hydration_dev(label, t1);
      append_hydration_dev(label, span0);
      append_hydration_dev(label, t2);
      append_hydration_dev(label, span1);
      append_hydration_dev(label, t3);
      append_hydration_dev(label, span2);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*id*/
      4) {
        attr_dev(
          input,
          "id",
          /*id*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*size*/
      1) {
        toggle_class(
          input,
          "bx--toggle--small",
          /*size*/
          ctx2[0] === "sm"
        );
      }
      if (
        /*labelText*/
        ctx2[1] || /*$$slots*/
        ctx2[5].labelText
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*labelText, $$slots*/
          34) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block100(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(label, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*labelText, $$props*/
      18 && label_aria_label_value !== (label_aria_label_value = /*labelText*/
      ctx2[1] ? void 0 : (
        /*$$props*/
        ctx2[4]["aria-label"] || "Toggle is loading"
      ))) {
        attr_dev(label, "aria-label", label_aria_label_value);
      }
      if (!current || dirty & /*id*/
      4) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[2]
        );
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      8 && /*$$restProps*/
      ctx2[3]]));
      toggle_class(div, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment173.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance173($$self, $$props, $$invalidate) {
  const omit_props_names = ["size", "labelText", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToggleSkeleton", slots, ["labelText"]);
  const $$slots = compute_slots(slots);
  let { size = "default" } = $$props;
  let { labelText = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("labelText" in $$new_props) $$invalidate(1, labelText = $$new_props.labelText);
    if ("id" in $$new_props) $$invalidate(2, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ size, labelText, id });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("labelText" in $$props) $$invalidate(1, labelText = $$new_props.labelText);
    if ("id" in $$props) $$invalidate(2, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    size,
    labelText,
    id,
    $$restProps,
    $$props,
    $$slots,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var ToggleSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance173, create_fragment173, safe_not_equal, { size: 0, labelText: 1, id: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToggleSkeleton",
      options,
      id: create_fragment173.name
    });
  }
  get size() {
    throw new Error("<ToggleSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ToggleSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<ToggleSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<ToggleSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ToggleSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ToggleSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToggleSkeleton_default = ToggleSkeleton;

// node_modules/carbon-components-svelte/src/icons/Information.svelte
var file162 = "node_modules/carbon-components-svelte/src/icons/Information.svelte";
function create_if_block101(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file162, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block101.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment174(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block101(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M17 22L17 14 13 14 13 16 15 16 15 22 12 22 12 24 20 24 20 22 17 22zM16 8a1.5 1.5 0 101.5 1.5A1.5 1.5 0 0016 8z");
      add_location(path0, file162, 24, 2, 579);
      attr_dev(path1, "d", "M16,30A14,14,0,1,1,30,16,14,14,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12,12,0,0,0,16,4Z");
      add_location(path1, file162, 26, 10, 714);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file162, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block101(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment174.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance174($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Information", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Information = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance174, create_fragment174, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Information",
      options,
      id: create_fragment174.name
    });
  }
  get size() {
    throw new Error("<Information>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Information>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Information>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Information>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Information_default = Information;

// node_modules/carbon-components-svelte/src/Tooltip/Tooltip.svelte
var file163 = "node_modules/carbon-components-svelte/src/Tooltip/Tooltip.svelte";
var get_triggerText_slot_changes_1 = (dirty) => ({});
var get_triggerText_slot_context_1 = (ctx) => ({});
var get_icon_slot_changes5 = (dirty) => ({});
var get_icon_slot_context5 = (ctx) => ({});
var get_triggerText_slot_changes = (dirty) => ({});
var get_triggerText_slot_context = (ctx) => ({});
function create_else_block32(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const triggerText_slot_template = (
    /*#slots*/
    ctx[21].triggerText
  );
  const triggerText_slot = create_slot(
    triggerText_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_triggerText_slot_context_1
  );
  const triggerText_slot_or_fallback = triggerText_slot || fallback_block_27(ctx);
  let div_levels = [
    /*buttonProps*/
    ctx[12],
    { "aria-describedby": (
      /*tooltipId*/
      ctx[9]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (triggerText_slot_or_fallback) triggerText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "aria-describedby": true });
      var div_nodes = children(div);
      if (triggerText_slot_or_fallback) triggerText_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file163, 225, 4, 5933);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (triggerText_slot_or_fallback) {
        triggerText_slot_or_fallback.m(div, null);
      }
      ctx[28](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "mousedown",
            /*onMousedown*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "focus",
            /*onFocus*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "blur",
            /*onBlur*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*onKeydown*/
            ctx[13],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (triggerText_slot) {
        if (triggerText_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            triggerText_slot,
            triggerText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              triggerText_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_triggerText_slot_changes_1
            ),
            get_triggerText_slot_context_1
          );
        }
      } else {
        if (triggerText_slot_or_fallback && triggerText_slot_or_fallback.p && (!current || dirty[0] & /*triggerText*/
        2048)) {
          triggerText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty[0] & /*buttonProps*/
        4096 && /*buttonProps*/
        ctx2[12],
        (!current || dirty[0] & /*tooltipId*/
        512) && { "aria-describedby": (
          /*tooltipId*/
          ctx2[9]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(triggerText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(triggerText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (triggerText_slot_or_fallback) triggerText_slot_or_fallback.d(detaching);
      ctx[28](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block32.name,
    type: "else",
    source: "(224:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_143(ctx) {
  let div1;
  let t;
  let div0;
  let current;
  let mounted;
  let dispose;
  const triggerText_slot_template = (
    /*#slots*/
    ctx[21].triggerText
  );
  const triggerText_slot = create_slot(
    triggerText_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_triggerText_slot_context
  );
  const triggerText_slot_or_fallback = triggerText_slot || fallback_block_116(ctx);
  const icon_slot_template = (
    /*#slots*/
    ctx[21].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_icon_slot_context5
  );
  const icon_slot_or_fallback = icon_slot || fallback_block38(ctx);
  let div0_levels = [
    /*buttonProps*/
    ctx[12],
    { "aria-describedby": (
      /*tooltipId*/
      ctx[9]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div_data = assign(div_data, div0_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (triggerText_slot_or_fallback) triggerText_slot_or_fallback.c();
      t = space();
      div0 = element("div");
      if (icon_slot_or_fallback) icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { id: true });
      var div1_nodes = children(div1);
      if (triggerText_slot_or_fallback) triggerText_slot_or_fallback.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { "aria-describedby": true });
      var div0_nodes = children(div0);
      if (icon_slot_or_fallback) icon_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div0, div_data);
      add_location(div0, file163, 210, 6, 5520);
      attr_dev(
        div1,
        "id",
        /*triggerId*/
        ctx[10]
      );
      toggle_class(div1, "bx--tooltip__label", true);
      add_location(div1, file163, 207, 4, 5322);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (triggerText_slot_or_fallback) {
        triggerText_slot_or_fallback.m(div1, null);
      }
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div0, null);
      }
      ctx[26](div0);
      ctx[27](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div0,
            "mousedown",
            /*onMousedown*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "focus",
            /*onFocus*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "keydown",
            /*onKeydown*/
            ctx[13],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (triggerText_slot) {
        if (triggerText_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            triggerText_slot,
            triggerText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              triggerText_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_triggerText_slot_changes
            ),
            get_triggerText_slot_context
          );
        }
      } else {
        if (triggerText_slot_or_fallback && triggerText_slot_or_fallback.p && (!current || dirty[0] & /*triggerText*/
        2048)) {
          triggerText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_icon_slot_changes5
            ),
            get_icon_slot_context5
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty[0] & /*icon, iconName*/
        384)) {
          icon_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      set_attributes(div0, div_data = get_spread_update(div0_levels, [
        dirty[0] & /*buttonProps*/
        4096 && /*buttonProps*/
        ctx2[12],
        (!current || dirty[0] & /*tooltipId*/
        512) && { "aria-describedby": (
          /*tooltipId*/
          ctx2[9]
        ) }
      ]));
      if (!current || dirty[0] & /*triggerId*/
      1024) {
        attr_dev(
          div1,
          "id",
          /*triggerId*/
          ctx2[10]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(triggerText_slot_or_fallback, local);
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(triggerText_slot_or_fallback, local);
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (triggerText_slot_or_fallback) triggerText_slot_or_fallback.d(detaching);
      if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
      ctx[26](null);
      ctx[27](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_143.name,
    type: "if",
    source: "(207:2) {#if !hideIcon}",
    ctx
  });
  return block;
}
function fallback_block_27(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*triggerText*/
        ctx[11]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*triggerText*/
        ctx[11]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*triggerText*/
      2048) set_data_dev(
        t,
        /*triggerText*/
        ctx2[11]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_27.name,
    type: "fallback",
    source: "(235:31) {triggerText}",
    ctx
  });
  return block;
}
function fallback_block_116(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*triggerText*/
        ctx[11]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*triggerText*/
        ctx[11]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*triggerText*/
      2048) set_data_dev(
        t,
        /*triggerText*/
        ctx2[11]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_116.name,
    type: "fallback",
    source: "(209:31) {triggerText}",
    ctx
  });
  return block;
}
function fallback_block38(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[7]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: { name: (
        /*iconName*/
        ctx2[8]
      ) },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*icon*/
      128 && switch_value !== (switch_value = /*icon*/
      ctx2[7])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*iconName*/
        256) switch_instance_changes.name = /*iconName*/
        ctx2[8];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block38.name,
    type: "fallback",
    source: "(219:26)            ",
    ctx
  });
  return block;
}
function create_if_block102(ctx) {
  let div1;
  let span;
  let t;
  let div0;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      span = element("span");
      t = space();
      div0 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        id: true,
        "data-floating-menu-direction": true
      });
      var div1_nodes = children(div1);
      span = claim_element(div1_nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { tabindex: true, role: true });
      var div0_nodes = children(div0);
      if (default_slot) default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--tooltip__caret", true);
      add_location(span, file163, 254, 6, 6920);
      attr_dev(div0, "tabindex", "-1");
      attr_dev(div0, "role", "dialog");
      toggle_class(div0, "bx--tooltip__content", true);
      add_location(div0, file163, 257, 6, 7110);
      attr_dev(
        div1,
        "id",
        /*tooltipId*/
        ctx[9]
      );
      attr_dev(
        div1,
        "data-floating-menu-direction",
        /*direction*/
        ctx[5]
      );
      toggle_class(div1, "bx--tooltip", true);
      toggle_class(
        div1,
        "bx--tooltip--shown",
        /*open*/
        ctx[0]
      );
      toggle_class(
        div1,
        "bx--tooltip--top",
        /*direction*/
        ctx[5] === "top"
      );
      toggle_class(
        div1,
        "bx--tooltip--right",
        /*direction*/
        ctx[5] === "right"
      );
      toggle_class(
        div1,
        "bx--tooltip--bottom",
        /*direction*/
        ctx[5] === "bottom"
      );
      toggle_class(
        div1,
        "bx--tooltip--left",
        /*direction*/
        ctx[5] === "left"
      );
      toggle_class(
        div1,
        "bx--tooltip--align-center",
        /*align*/
        ctx[4] === "center"
      );
      toggle_class(
        div1,
        "bx--tooltip--align-start",
        /*align*/
        ctx[4] === "start"
      );
      toggle_class(
        div1,
        "bx--tooltip--align-end",
        /*align*/
        ctx[4] === "end"
      );
      add_location(div1, file163, 239, 4, 6297);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, span);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[29](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div0, "click", stop_propagation(
            /*click_handler*/
            ctx[22]
          ), false, false, true, false),
          listen_dev(div0, "mousedown", stop_propagation(
            /*mousedown_handler*/
            ctx[23]
          ), false, false, true, false),
          listen_dev(
            div1,
            "keydown",
            /*onKeydown*/
            ctx[13],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*tooltipId*/
      512) {
        attr_dev(
          div1,
          "id",
          /*tooltipId*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*direction*/
      32) {
        attr_dev(
          div1,
          "data-floating-menu-direction",
          /*direction*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*open*/
      1) {
        toggle_class(
          div1,
          "bx--tooltip--shown",
          /*open*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*direction*/
      32) {
        toggle_class(
          div1,
          "bx--tooltip--top",
          /*direction*/
          ctx2[5] === "top"
        );
      }
      if (!current || dirty[0] & /*direction*/
      32) {
        toggle_class(
          div1,
          "bx--tooltip--right",
          /*direction*/
          ctx2[5] === "right"
        );
      }
      if (!current || dirty[0] & /*direction*/
      32) {
        toggle_class(
          div1,
          "bx--tooltip--bottom",
          /*direction*/
          ctx2[5] === "bottom"
        );
      }
      if (!current || dirty[0] & /*direction*/
      32) {
        toggle_class(
          div1,
          "bx--tooltip--left",
          /*direction*/
          ctx2[5] === "left"
        );
      }
      if (!current || dirty[0] & /*align*/
      16) {
        toggle_class(
          div1,
          "bx--tooltip--align-center",
          /*align*/
          ctx2[4] === "center"
        );
      }
      if (!current || dirty[0] & /*align*/
      16) {
        toggle_class(
          div1,
          "bx--tooltip--align-start",
          /*align*/
          ctx2[4] === "start"
        );
      }
      if (!current || dirty[0] & /*align*/
      16) {
        toggle_class(
          div1,
          "bx--tooltip--align-end",
          /*align*/
          ctx2[4] === "end"
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block102.name,
    type: "if",
    source: "(238:2) {#if open}",
    ctx
  });
  return block;
}
function create_fragment175(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_143, create_else_block32];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*hideIcon*/
    ctx2[6]) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*open*/
    ctx[0] && create_if_block102(ctx)
  );
  let div_levels = [
    /*$$restProps*/
    ctx[17]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1) if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      set_style(div, "position", `relative`);
      set_style(
        div,
        "z-index",
        /*open*/
        ctx[0] ? 1 : void 0
      );
      add_location(div, file163, 201, 0, 5205);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration_dev(div, t);
      if (if_block1) if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "mousedown",
            /*mousedown_handler_1*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "click",
            /*click_handler_1*/
            ctx[25],
            true,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t);
      }
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*open*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block102(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty[0] & /*$$restProps*/
      131072 && /*$$restProps*/
      ctx2[17]]));
      set_style(div, "position", `relative`);
      set_style(
        div,
        "z-index",
        /*open*/
        ctx2[0] ? 1 : void 0
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
      if (if_block1) if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment175.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance175($$self, $$props, $$invalidate) {
  let buttonProps;
  const omit_props_names = [
    "align",
    "direction",
    "open",
    "hideIcon",
    "icon",
    "iconDescription",
    "iconName",
    "tabindex",
    "tooltipId",
    "triggerId",
    "triggerText",
    "ref",
    "refTooltip",
    "refIcon"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tooltip", slots, ["triggerText", "icon", "default"]);
  let { align = "center" } = $$props;
  let { direction = "bottom" } = $$props;
  let { open = false } = $$props;
  let { hideIcon = false } = $$props;
  let { icon = Information_default } = $$props;
  let { iconDescription = "" } = $$props;
  let { iconName = "" } = $$props;
  let { tabindex = "0" } = $$props;
  let { tooltipId = "ccs-" + Math.random().toString(36) } = $$props;
  let { triggerId = "ccs-" + Math.random().toString(36) } = $$props;
  let { triggerText = "" } = $$props;
  let { ref = null } = $$props;
  let { refTooltip = null } = $$props;
  let { refIcon = null } = $$props;
  const dispatch = createEventDispatcher();
  const tooltipOpen = writable(open);
  setContext("Tooltip", { tooltipOpen });
  function onKeydown(e) {
    if (e.key === "Escape" || e.key === "Tab") {
      e.stopPropagation();
      if (e.key === "Escape") refIcon == null ? void 0 : refIcon.focus();
      $$invalidate(0, open = false);
    } else if (e.key === " " || e.key === "Enter") {
      e.stopPropagation();
      e.preventDefault();
      $$invalidate(0, open = true);
    }
  }
  function onBlur({ relatedTarget }) {
    if (refTooltip && !refTooltip.contains(relatedTarget)) {
      $$invalidate(0, open = false);
    }
  }
  function onFocus() {
    $$invalidate(0, open = true);
  }
  function onMousedown() {
    const shouldClose = open;
    setTimeout(() => {
      $$invalidate(0, open = shouldClose ? false : true);
    });
  }
  afterUpdate(() => {
    if (open) {
      const button = ref.getBoundingClientRect();
      const tooltip = refTooltip.getBoundingClientRect();
      let iconWidth = 16;
      let iconHeight = 16;
      if (refIcon) {
        const icon2 = refIcon.getBoundingClientRect();
        iconWidth = icon2.width;
        iconHeight = icon2.height;
      }
      let offsetX = 0;
      let offsetY = 0;
      switch (direction) {
        case "bottom":
          if (hideIcon) {
            offsetX = -1 * (tooltip.width / 2 - button.width / 2);
          } else {
            offsetX = -1 * (tooltip.width / 2 - button.width + iconWidth / 2);
          }
          offsetY = iconHeight / 2;
          break;
        case "right":
          offsetX = button.width + 6;
          offsetY = -1 * (tooltip.height / 2 + iconWidth / 2 - 3);
          break;
        case "left":
          if (hideIcon) {
            offsetX = -1 * (tooltip.width + 6 + 1);
          } else {
            offsetX = -1 * (tooltip.width - button.width + iconWidth + 8);
          }
          offsetY = -1 * (tooltip.height / 2 + button.height) - 2;
          break;
        case "top":
          if (hideIcon) {
            offsetX = -1 * (tooltip.width / 2 - button.width / 2);
          } else {
            offsetX = -1 * (tooltip.width / 2 - button.width + iconWidth / 2 + 1);
          }
          offsetY = -1 * (tooltip.height + button.height + iconWidth / 2 - 1);
          break;
      }
      $$invalidate(2, refTooltip.style.left = offsetX + "px", refTooltip);
      $$invalidate(2, refTooltip.style.marginTop = offsetY + "px", refTooltip);
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mousedown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const mousedown_handler_1 = ({ target }) => {
    if (open) {
      if (target.contains(refTooltip)) {
        if (refIcon) {
          refIcon.focus();
        } else if (ref) {
          ref.focus();
        }
      }
    }
  };
  const click_handler_13 = ({ target }) => {
    if (open && !ref.contains(target) && !refTooltip.contains(target)) {
      setTimeout(() => {
        $$invalidate(0, open = false);
      });
    }
  };
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refIcon = $$value;
      $$invalidate(3, refIcon);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function div1_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refTooltip = $$value;
      $$invalidate(2, refTooltip);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("align" in $$new_props) $$invalidate(4, align = $$new_props.align);
    if ("direction" in $$new_props) $$invalidate(5, direction = $$new_props.direction);
    if ("open" in $$new_props) $$invalidate(0, open = $$new_props.open);
    if ("hideIcon" in $$new_props) $$invalidate(6, hideIcon = $$new_props.hideIcon);
    if ("icon" in $$new_props) $$invalidate(7, icon = $$new_props.icon);
    if ("iconDescription" in $$new_props) $$invalidate(18, iconDescription = $$new_props.iconDescription);
    if ("iconName" in $$new_props) $$invalidate(8, iconName = $$new_props.iconName);
    if ("tabindex" in $$new_props) $$invalidate(19, tabindex = $$new_props.tabindex);
    if ("tooltipId" in $$new_props) $$invalidate(9, tooltipId = $$new_props.tooltipId);
    if ("triggerId" in $$new_props) $$invalidate(10, triggerId = $$new_props.triggerId);
    if ("triggerText" in $$new_props) $$invalidate(11, triggerText = $$new_props.triggerText);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("refTooltip" in $$new_props) $$invalidate(2, refTooltip = $$new_props.refTooltip);
    if ("refIcon" in $$new_props) $$invalidate(3, refIcon = $$new_props.refIcon);
    if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    align,
    direction,
    open,
    hideIcon,
    icon,
    iconDescription,
    iconName,
    tabindex,
    tooltipId,
    triggerId,
    triggerText,
    ref,
    refTooltip,
    refIcon,
    createEventDispatcher,
    afterUpdate,
    setContext,
    writable,
    Information: Information_default,
    dispatch,
    tooltipOpen,
    onKeydown,
    onBlur,
    onFocus,
    onMousedown,
    buttonProps
  });
  $$self.$inject_state = ($$new_props) => {
    if ("align" in $$props) $$invalidate(4, align = $$new_props.align);
    if ("direction" in $$props) $$invalidate(5, direction = $$new_props.direction);
    if ("open" in $$props) $$invalidate(0, open = $$new_props.open);
    if ("hideIcon" in $$props) $$invalidate(6, hideIcon = $$new_props.hideIcon);
    if ("icon" in $$props) $$invalidate(7, icon = $$new_props.icon);
    if ("iconDescription" in $$props) $$invalidate(18, iconDescription = $$new_props.iconDescription);
    if ("iconName" in $$props) $$invalidate(8, iconName = $$new_props.iconName);
    if ("tabindex" in $$props) $$invalidate(19, tabindex = $$new_props.tabindex);
    if ("tooltipId" in $$props) $$invalidate(9, tooltipId = $$new_props.tooltipId);
    if ("triggerId" in $$props) $$invalidate(10, triggerId = $$new_props.triggerId);
    if ("triggerText" in $$props) $$invalidate(11, triggerText = $$new_props.triggerText);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("refTooltip" in $$props) $$invalidate(2, refTooltip = $$new_props.refTooltip);
    if ("refIcon" in $$props) $$invalidate(3, refIcon = $$new_props.refIcon);
    if ("buttonProps" in $$props) $$invalidate(12, buttonProps = $$new_props.buttonProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*open*/
    1) {
      $: tooltipOpen.set(open);
    }
    if ($$self.$$.dirty[0] & /*open*/
    1) {
      $: dispatch(open ? "open" : "close");
    }
    $: $$invalidate(12, buttonProps = {
      role: "button",
      "aria-haspopup": "true",
      id: hideIcon ? triggerId : void 0,
      class: hideIcon ? "bx--tooltip__label" : "bx--tooltip__trigger",
      "aria-expanded": open,
      "aria-describedby": open ? tooltipId : void 0,
      "aria-labelledby": triggerText ? triggerId : void 0,
      "aria-label": triggerText ? void 0 : iconDescription,
      tabindex,
      style: hideIcon ? $$restProps.style : void 0
    });
  };
  return [
    open,
    ref,
    refTooltip,
    refIcon,
    align,
    direction,
    hideIcon,
    icon,
    iconName,
    tooltipId,
    triggerId,
    triggerText,
    buttonProps,
    onKeydown,
    onBlur,
    onFocus,
    onMousedown,
    $$restProps,
    iconDescription,
    tabindex,
    $$scope,
    slots,
    click_handler,
    mousedown_handler,
    mousedown_handler_1,
    click_handler_13,
    div0_binding,
    div1_binding,
    div_binding,
    div1_binding_1
  ];
}
var Tooltip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance175,
      create_fragment175,
      safe_not_equal,
      {
        align: 4,
        direction: 5,
        open: 0,
        hideIcon: 6,
        icon: 7,
        iconDescription: 18,
        iconName: 8,
        tabindex: 19,
        tooltipId: 9,
        triggerId: 10,
        triggerText: 11,
        ref: 1,
        refTooltip: 2,
        refIcon: 3
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tooltip",
      options,
      id: create_fragment175.name
    });
  }
  get align() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideIcon() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideIcon(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconName() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconName(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipId() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipId(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get triggerId() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set triggerId(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get triggerText() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set triggerText(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refTooltip() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set refTooltip(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refIcon() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set refIcon(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tooltip_default = Tooltip;

// node_modules/carbon-components-svelte/src/Tooltip/TooltipFooter.svelte
var file164 = "node_modules/carbon-components-svelte/src/Tooltip/TooltipFooter.svelte";
function create_fragment176(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--tooltip__footer", true);
      add_location(div, file164, 26, 0, 586);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[5](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[5](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment176.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance176($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TooltipFooter", slots, ["default"]);
  let { selectorPrimaryFocus = "a[href], button:not([disabled])" } = $$props;
  let ref = null;
  let open = false;
  const ctx = getContext("Tooltip");
  const unsubscribe = ctx.tooltipOpen.subscribe((tooltipOpen) => {
    $$invalidate(2, open = tooltipOpen);
  });
  onMount(() => {
    return () => {
      unsubscribe();
    };
  });
  const writable_props = ["selectorPrimaryFocus"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<TooltipFooter> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("selectorPrimaryFocus" in $$props2) $$invalidate(1, selectorPrimaryFocus = $$props2.selectorPrimaryFocus);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    selectorPrimaryFocus,
    getContext,
    onMount,
    ref,
    open,
    ctx,
    unsubscribe
  });
  $$self.$inject_state = ($$props2) => {
    if ("selectorPrimaryFocus" in $$props2) $$invalidate(1, selectorPrimaryFocus = $$props2.selectorPrimaryFocus);
    if ("ref" in $$props2) $$invalidate(0, ref = $$props2.ref);
    if ("open" in $$props2) $$invalidate(2, open = $$props2.open);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open, ref, selectorPrimaryFocus*/
    7) {
      $: if (open && ref) {
        const node = ref.querySelector(selectorPrimaryFocus);
        if (node) node.focus();
      }
    }
  };
  return [ref, selectorPrimaryFocus, open, $$scope, slots, div_binding];
}
var TooltipFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance176, create_fragment176, safe_not_equal, { selectorPrimaryFocus: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TooltipFooter",
      options,
      id: create_fragment176.name
    });
  }
  get selectorPrimaryFocus() {
    throw new Error("<TooltipFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectorPrimaryFocus(value) {
    throw new Error("<TooltipFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TooltipFooter_default = TooltipFooter;

// node_modules/carbon-components-svelte/src/TooltipDefinition/TooltipDefinition.svelte
var file165 = "node_modules/carbon-components-svelte/src/TooltipDefinition/TooltipDefinition.svelte";
var get_tooltip_slot_changes = (dirty) => ({});
var get_tooltip_slot_context = (ctx) => ({});
function fallback_block39(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*tooltipText*/
        ctx[2]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*tooltipText*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tooltipText*/
      4) set_data_dev(
        t,
        /*tooltipText*/
        ctx2[2]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block39.name,
    type: "fallback",
    source: "(83:25) {tooltipText}",
    ctx
  });
  return block;
}
function create_fragment177(ctx) {
  let span;
  let button;
  let t;
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const tooltip_slot_template = (
    /*#slots*/
    ctx[10].tooltip
  );
  const tooltip_slot = create_slot(
    tooltip_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_tooltip_slot_context
  );
  const tooltip_slot_or_fallback = tooltip_slot || fallback_block39(ctx);
  let span_levels = [
    /*$$restProps*/
    ctx[8]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      button = element("button");
      if (default_slot) default_slot.c();
      t = space();
      div = element("div");
      if (tooltip_slot_or_fallback) tooltip_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      button = claim_element(span_nodes, "BUTTON", { type: true, "aria-describedby": true });
      var button_nodes = children(button);
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      t = claim_space(span_nodes);
      div = claim_element(span_nodes, "DIV", { role: true, id: true });
      var div_nodes = children(div);
      if (tooltip_slot_or_fallback) tooltip_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "aria-describedby",
        /*id*/
        ctx[5]
      );
      toggle_class(button, "bx--tooltip--a11y", true);
      toggle_class(button, "bx--tooltip__trigger", true);
      toggle_class(button, "bx--tooltip__trigger--definition", true);
      toggle_class(button, "bx--tooltip--hidden", !/*open*/
      ctx[0]);
      toggle_class(
        button,
        "bx--tooltip--visible",
        /*open*/
        ctx[0]
      );
      toggle_class(
        button,
        "bx--tooltip--top",
        /*direction*/
        ctx[4] === "top"
      );
      toggle_class(
        button,
        "bx--tooltip--bottom",
        /*direction*/
        ctx[4] === "bottom"
      );
      toggle_class(
        button,
        "bx--tooltip--align-start",
        /*align*/
        ctx[3] === "start"
      );
      toggle_class(
        button,
        "bx--tooltip--align-center",
        /*align*/
        ctx[3] === "center"
      );
      toggle_class(
        button,
        "bx--tooltip--align-end",
        /*align*/
        ctx[3] === "end"
      );
      add_location(button, file165, 57, 2, 1205);
      attr_dev(div, "role", "tooltip");
      attr_dev(
        div,
        "id",
        /*id*/
        ctx[5]
      );
      toggle_class(div, "bx--assistive-text", true);
      add_location(div, file165, 81, 2, 1920);
      set_attributes(span, span_data);
      toggle_class(span, "bx--tooltip--definition", true);
      toggle_class(span, "bx--tooltip--a11y", true);
      add_location(span, file165, 50, 0, 1050);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, button);
      if (default_slot) {
        default_slot.m(button, null);
      }
      ctx[17](button);
      append_hydration_dev(span, t);
      append_hydration_dev(span, div);
      if (tooltip_slot_or_fallback) {
        tooltip_slot_or_fallback.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "keydown",
            /*keydown_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseover",
            /*mouseover_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "focus",
            /*focus_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "focus",
            /*show*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "blur",
            /*hide*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "mouseenter",
            /*show*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "mouseleave",
            /*hide*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      32) {
        attr_dev(
          button,
          "aria-describedby",
          /*id*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*open*/
      1) {
        toggle_class(button, "bx--tooltip--hidden", !/*open*/
        ctx2[0]);
      }
      if (!current || dirty & /*open*/
      1) {
        toggle_class(
          button,
          "bx--tooltip--visible",
          /*open*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*direction*/
      16) {
        toggle_class(
          button,
          "bx--tooltip--top",
          /*direction*/
          ctx2[4] === "top"
        );
      }
      if (!current || dirty & /*direction*/
      16) {
        toggle_class(
          button,
          "bx--tooltip--bottom",
          /*direction*/
          ctx2[4] === "bottom"
        );
      }
      if (!current || dirty & /*align*/
      8) {
        toggle_class(
          button,
          "bx--tooltip--align-start",
          /*align*/
          ctx2[3] === "start"
        );
      }
      if (!current || dirty & /*align*/
      8) {
        toggle_class(
          button,
          "bx--tooltip--align-center",
          /*align*/
          ctx2[3] === "center"
        );
      }
      if (!current || dirty & /*align*/
      8) {
        toggle_class(
          button,
          "bx--tooltip--align-end",
          /*align*/
          ctx2[3] === "end"
        );
      }
      if (tooltip_slot) {
        if (tooltip_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            tooltip_slot,
            tooltip_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              tooltip_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_tooltip_slot_changes
            ),
            get_tooltip_slot_context
          );
        }
      } else {
        if (tooltip_slot_or_fallback && tooltip_slot_or_fallback.p && (!current || dirty & /*tooltipText*/
        4)) {
          tooltip_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*id*/
      32) {
        attr_dev(
          div,
          "id",
          /*id*/
          ctx2[5]
        );
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [dirty & /*$$restProps*/
      256 && /*$$restProps*/
      ctx2[8]]));
      toggle_class(span, "bx--tooltip--definition", true);
      toggle_class(span, "bx--tooltip--a11y", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(tooltip_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(tooltip_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[17](null);
      if (tooltip_slot_or_fallback) tooltip_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment177.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance177($$self, $$props, $$invalidate) {
  const omit_props_names = ["tooltipText", "open", "align", "direction", "id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TooltipDefinition", slots, ["default", "tooltip"]);
  let { tooltipText = "" } = $$props;
  let { open = false } = $$props;
  let { align = "center" } = $$props;
  let { direction = "bottom" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  const hide = () => $$invalidate(0, open = false);
  const show = () => $$invalidate(0, open = true);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const keydown_handler = ({ key }) => {
    if (key === "Escape") hide();
  };
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("tooltipText" in $$new_props) $$invalidate(2, tooltipText = $$new_props.tooltipText);
    if ("open" in $$new_props) $$invalidate(0, open = $$new_props.open);
    if ("align" in $$new_props) $$invalidate(3, align = $$new_props.align);
    if ("direction" in $$new_props) $$invalidate(4, direction = $$new_props.direction);
    if ("id" in $$new_props) $$invalidate(5, id = $$new_props.id);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    tooltipText,
    open,
    align,
    direction,
    id,
    ref,
    createEventDispatcher,
    dispatch,
    hide,
    show
  });
  $$self.$inject_state = ($$new_props) => {
    if ("tooltipText" in $$props) $$invalidate(2, tooltipText = $$new_props.tooltipText);
    if ("open" in $$props) $$invalidate(0, open = $$new_props.open);
    if ("align" in $$props) $$invalidate(3, align = $$new_props.align);
    if ("direction" in $$props) $$invalidate(4, direction = $$new_props.direction);
    if ("id" in $$props) $$invalidate(5, id = $$new_props.id);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    1) {
      $: dispatch(open ? "open" : "close");
    }
  };
  return [
    open,
    ref,
    tooltipText,
    align,
    direction,
    id,
    hide,
    show,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    focus_handler,
    keydown_handler,
    button_binding
  ];
}
var TooltipDefinition = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance177, create_fragment177, safe_not_equal, {
      tooltipText: 2,
      open: 0,
      align: 3,
      direction: 4,
      id: 5,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TooltipDefinition",
      options,
      id: create_fragment177.name
    });
  }
  get tooltipText() {
    throw new Error("<TooltipDefinition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipText(value) {
    throw new Error("<TooltipDefinition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<TooltipDefinition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<TooltipDefinition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<TooltipDefinition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<TooltipDefinition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<TooltipDefinition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<TooltipDefinition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TooltipDefinition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TooltipDefinition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<TooltipDefinition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<TooltipDefinition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TooltipDefinition_default = TooltipDefinition;

// node_modules/carbon-components-svelte/src/TooltipIcon/TooltipIcon.svelte
var file166 = "node_modules/carbon-components-svelte/src/TooltipIcon/TooltipIcon.svelte";
var get_tooltipText_slot_changes = (dirty) => ({});
var get_tooltipText_slot_context = (ctx) => ({});
function fallback_block_117(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*tooltipText*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*tooltipText*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tooltipText*/
      2) set_data_dev(
        t,
        /*tooltipText*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_117.name,
    type: "fallback",
    source: "(77:29) {tooltipText}",
    ctx
  });
  return block;
}
function fallback_block40(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[2]
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*icon*/
      4 && switch_value !== (switch_value = /*icon*/
      ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block40.name,
    type: "fallback",
    source: "(79:8)      ",
    ctx
  });
  return block;
}
function create_fragment178(ctx) {
  let button;
  let span;
  let t;
  let current;
  let mounted;
  let dispose;
  const tooltipText_slot_template = (
    /*#slots*/
    ctx[10].tooltipText
  );
  const tooltipText_slot = create_slot(
    tooltipText_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_tooltipText_slot_context
  );
  const tooltipText_slot_or_fallback = tooltipText_slot || fallback_block_117(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block40(ctx);
  let button_levels = [
    { disabled: (
      /*disabled*/
      ctx[3]
    ) },
    { "aria-describedby": (
      /*id*/
      ctx[6]
    ) },
    /*$$restProps*/
    ctx[8]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      span = element("span");
      if (tooltipText_slot_or_fallback) tooltipText_slot_or_fallback.c();
      t = space();
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { "aria-describedby": true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { id: true });
      var span_nodes = children(span);
      if (tooltipText_slot_or_fallback) tooltipText_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      t = claim_space(button_nodes);
      if (default_slot_or_fallback) default_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        span,
        "id",
        /*id*/
        ctx[6]
      );
      toggle_class(span, "bx--assistive-text", true);
      add_location(span, file166, 75, 2, 1839);
      set_attributes(button, button_data);
      toggle_class(button, "bx--tooltip__trigger", true);
      toggle_class(button, "bx--tooltip--a11y", true);
      toggle_class(
        button,
        "bx--tooltip--hidden",
        /*hidden*/
        ctx[7] || /*disabled*/
        ctx[3]
      );
      toggle_class(
        button,
        "bx--tooltip--top",
        /*direction*/
        ctx[5] === "top"
      );
      toggle_class(
        button,
        "bx--tooltip--right",
        /*direction*/
        ctx[5] === "right"
      );
      toggle_class(
        button,
        "bx--tooltip--bottom",
        /*direction*/
        ctx[5] === "bottom"
      );
      toggle_class(
        button,
        "bx--tooltip--left",
        /*direction*/
        ctx[5] === "left"
      );
      toggle_class(
        button,
        "bx--tooltip--align-start",
        /*align*/
        ctx[4] === "start"
      );
      toggle_class(
        button,
        "bx--tooltip--align-center",
        /*align*/
        ctx[4] === "center"
      );
      toggle_class(
        button,
        "bx--tooltip--align-end",
        /*align*/
        ctx[4] === "end"
      );
      set_style(
        button,
        "cursor",
        /*disabled*/
        ctx[3] ? "not-allowed" : "default"
      );
      add_location(button, file166, 45, 0, 967);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, span);
      if (tooltipText_slot_or_fallback) {
        tooltipText_slot_or_fallback.m(span, null);
      }
      append_hydration_dev(button, t);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      if (button.autofocus) button.focus();
      ctx[17](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "keydown",
            /*keydown_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseover",
            /*mouseover_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "focus",
            /*focus_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "focus",
            /*focus_handler_1*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (tooltipText_slot) {
        if (tooltipText_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            tooltipText_slot,
            tooltipText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              tooltipText_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_tooltipText_slot_changes
            ),
            get_tooltipText_slot_context
          );
        }
      } else {
        if (tooltipText_slot_or_fallback && tooltipText_slot_or_fallback.p && (!current || dirty & /*tooltipText*/
        2)) {
          tooltipText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*id*/
      64) {
        attr_dev(
          span,
          "id",
          /*id*/
          ctx2[6]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*icon*/
        4)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        (!current || dirty & /*disabled*/
        8) && { disabled: (
          /*disabled*/
          ctx2[3]
        ) },
        (!current || dirty & /*id*/
        64) && { "aria-describedby": (
          /*id*/
          ctx2[6]
        ) },
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8]
      ]));
      toggle_class(button, "bx--tooltip__trigger", true);
      toggle_class(button, "bx--tooltip--a11y", true);
      toggle_class(
        button,
        "bx--tooltip--hidden",
        /*hidden*/
        ctx2[7] || /*disabled*/
        ctx2[3]
      );
      toggle_class(
        button,
        "bx--tooltip--top",
        /*direction*/
        ctx2[5] === "top"
      );
      toggle_class(
        button,
        "bx--tooltip--right",
        /*direction*/
        ctx2[5] === "right"
      );
      toggle_class(
        button,
        "bx--tooltip--bottom",
        /*direction*/
        ctx2[5] === "bottom"
      );
      toggle_class(
        button,
        "bx--tooltip--left",
        /*direction*/
        ctx2[5] === "left"
      );
      toggle_class(
        button,
        "bx--tooltip--align-start",
        /*align*/
        ctx2[4] === "start"
      );
      toggle_class(
        button,
        "bx--tooltip--align-center",
        /*align*/
        ctx2[4] === "center"
      );
      toggle_class(
        button,
        "bx--tooltip--align-end",
        /*align*/
        ctx2[4] === "end"
      );
      set_style(
        button,
        "cursor",
        /*disabled*/
        ctx2[3] ? "not-allowed" : "default"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(tooltipText_slot_or_fallback, local);
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tooltipText_slot_or_fallback, local);
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (tooltipText_slot_or_fallback) tooltipText_slot_or_fallback.d(detaching);
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      ctx[17](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment178.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance178($$self, $$props, $$invalidate) {
  const omit_props_names = ["tooltipText", "icon", "disabled", "align", "direction", "id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TooltipIcon", slots, ["tooltipText", "default"]);
  let { tooltipText = "" } = $$props;
  let { icon = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { align = "center" } = $$props;
  let { direction = "bottom" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  let hidden = false;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const keydown_handler = ({ key }) => {
    if (key === "Escape") {
      $$invalidate(7, hidden = true);
    }
  };
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const mouseenter_handler_1 = () => {
    if (disabled) return;
    $$invalidate(7, hidden = false);
  };
  const focus_handler_1 = () => {
    if (disabled) return;
    $$invalidate(7, hidden = false);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("tooltipText" in $$new_props) $$invalidate(1, tooltipText = $$new_props.tooltipText);
    if ("icon" in $$new_props) $$invalidate(2, icon = $$new_props.icon);
    if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
    if ("align" in $$new_props) $$invalidate(4, align = $$new_props.align);
    if ("direction" in $$new_props) $$invalidate(5, direction = $$new_props.direction);
    if ("id" in $$new_props) $$invalidate(6, id = $$new_props.id);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    tooltipText,
    icon,
    disabled,
    align,
    direction,
    id,
    ref,
    hidden
  });
  $$self.$inject_state = ($$new_props) => {
    if ("tooltipText" in $$props) $$invalidate(1, tooltipText = $$new_props.tooltipText);
    if ("icon" in $$props) $$invalidate(2, icon = $$new_props.icon);
    if ("disabled" in $$props) $$invalidate(3, disabled = $$new_props.disabled);
    if ("align" in $$props) $$invalidate(4, align = $$new_props.align);
    if ("direction" in $$props) $$invalidate(5, direction = $$new_props.direction);
    if ("id" in $$props) $$invalidate(6, id = $$new_props.id);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    if ("hidden" in $$props) $$invalidate(7, hidden = $$new_props.hidden);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    tooltipText,
    icon,
    disabled,
    align,
    direction,
    id,
    hidden,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    focus_handler,
    keydown_handler,
    button_binding,
    mouseenter_handler_1,
    focus_handler_1
  ];
}
var TooltipIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance178, create_fragment178, safe_not_equal, {
      tooltipText: 1,
      icon: 2,
      disabled: 3,
      align: 4,
      direction: 5,
      id: 6,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TooltipIcon",
      options,
      id: create_fragment178.name
    });
  }
  get tooltipText() {
    throw new Error("<TooltipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipText(value) {
    throw new Error("<TooltipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<TooltipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<TooltipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TooltipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TooltipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<TooltipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<TooltipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<TooltipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<TooltipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TooltipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TooltipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<TooltipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<TooltipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TooltipIcon_default = TooltipIcon;

// node_modules/carbon-components-svelte/src/icons/CaretDown.svelte
var file167 = "node_modules/carbon-components-svelte/src/icons/CaretDown.svelte";
function create_if_block103(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file167, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block103.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment179(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block103(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M24 12L16 22 8 12z");
      add_location(path, file167, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file167, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block103(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment179.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance179($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CaretDown", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var CaretDown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance179, create_fragment179, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CaretDown",
      options,
      id: create_fragment179.name
    });
  }
  get size() {
    throw new Error("<CaretDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CaretDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CaretDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CaretDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CaretDown_default = CaretDown;

// node_modules/carbon-components-svelte/src/TreeView/TreeViewNode.svelte
var file168 = "node_modules/carbon-components-svelte/src/TreeView/TreeViewNode.svelte";
var get_default_slot_changes13 = (dirty) => ({ node: dirty & /*node*/
128 });
var get_default_slot_context13 = (ctx) => ({ node: (
  /*node*/
  ctx[7]
) });
function fallback_block41(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*text*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*text*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text*/
      2) set_data_dev(
        t,
        /*text*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block41.name,
    type: "fallback",
    source: "(129:24)        ",
    ctx
  });
  return block;
}
function create_fragment180(ctx) {
  let li;
  let div;
  let switch_instance;
  let t;
  let li_tabindex_value;
  let li_aria_current_value;
  let li_aria_selected_value;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*icon*/
    ctx[3]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: { class: "bx--tree-node__icon" },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context13
  );
  const default_slot_or_fallback = default_slot || fallback_block41(ctx);
  const block = {
    c: function create() {
      li = element("li");
      div = element("div");
      if (switch_instance) create_component(switch_instance.$$.fragment);
      t = space();
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        role: true,
        id: true,
        tabindex: true,
        "aria-current": true,
        "aria-selected": true,
        "aria-disabled": true
      });
      var li_nodes = children(li);
      div = claim_element(li_nodes, "DIV", {});
      var div_nodes = children(div);
      if (switch_instance) claim_component(switch_instance.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      if (default_slot_or_fallback) default_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--tree-node__label", true);
      add_location(div, file168, 126, 2, 3270);
      attr_dev(li, "role", "treeitem");
      attr_dev(
        li,
        "id",
        /*id*/
        ctx[0]
      );
      attr_dev(li, "tabindex", li_tabindex_value = /*disabled*/
      ctx[2] ? void 0 : -1);
      attr_dev(li, "aria-current", li_aria_current_value = /*id*/
      ctx[0] === /*$activeNodeId*/
      ctx[8] || void 0);
      attr_dev(li, "aria-selected", li_aria_selected_value = /*disabled*/
      ctx[2] ? void 0 : (
        /*selected*/
        ctx[5]
      ));
      attr_dev(
        li,
        "aria-disabled",
        /*disabled*/
        ctx[2]
      );
      toggle_class(li, "bx--tree-node", true);
      toggle_class(li, "bx--tree-leaf-node", true);
      toggle_class(
        li,
        "bx--tree-node--active",
        /*id*/
        ctx[0] === /*$activeNodeId*/
        ctx[8]
      );
      toggle_class(
        li,
        "bx--tree-node--selected",
        /*selected*/
        ctx[5]
      );
      toggle_class(
        li,
        "bx--tree-node--disabled",
        /*disabled*/
        ctx[2]
      );
      toggle_class(
        li,
        "bx--tree-node--with-icon",
        /*icon*/
        ctx[3]
      );
      add_location(li, file168, 88, 0, 2229);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, div);
      if (switch_instance) mount_component(switch_instance, div, null);
      append_hydration_dev(div, t);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      ctx[17](div);
      ctx[18](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(li, "click", stop_propagation(
            /*click_handler*/
            ctx[19]
          ), false, false, true, false),
          listen_dev(
            li,
            "keydown",
            /*keydown_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "focus",
            /*focus_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*icon*/
      8 && switch_value !== (switch_value = /*icon*/
      ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, node*/
        32896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes13
            ),
            get_default_slot_context13
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*text*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*id*/
      1) {
        attr_dev(
          li,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*disabled*/
      4 && li_tabindex_value !== (li_tabindex_value = /*disabled*/
      ctx2[2] ? void 0 : -1)) {
        attr_dev(li, "tabindex", li_tabindex_value);
      }
      if (!current || dirty & /*id, $activeNodeId*/
      257 && li_aria_current_value !== (li_aria_current_value = /*id*/
      ctx2[0] === /*$activeNodeId*/
      ctx2[8] || void 0)) {
        attr_dev(li, "aria-current", li_aria_current_value);
      }
      if (!current || dirty & /*disabled, selected*/
      36 && li_aria_selected_value !== (li_aria_selected_value = /*disabled*/
      ctx2[2] ? void 0 : (
        /*selected*/
        ctx2[5]
      ))) {
        attr_dev(li, "aria-selected", li_aria_selected_value);
      }
      if (!current || dirty & /*disabled*/
      4) {
        attr_dev(
          li,
          "aria-disabled",
          /*disabled*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*id, $activeNodeId*/
      257) {
        toggle_class(
          li,
          "bx--tree-node--active",
          /*id*/
          ctx2[0] === /*$activeNodeId*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*selected*/
      32) {
        toggle_class(
          li,
          "bx--tree-node--selected",
          /*selected*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*disabled*/
      4) {
        toggle_class(
          li,
          "bx--tree-node--disabled",
          /*disabled*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*icon*/
      8) {
        toggle_class(
          li,
          "bx--tree-node--with-icon",
          /*icon*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (switch_instance) destroy_component(switch_instance);
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      ctx[17](null);
      ctx[18](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment180.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function computeTreeLeafDepth(node) {
  let depth = 0;
  if (node == null) return depth;
  let parentNode = node.parentNode;
  while (parentNode != null && parentNode.getAttribute("role") !== "tree") {
    parentNode = parentNode.parentNode;
    if (parentNode.tagName === "LI") depth++;
  }
  return depth;
}
function findParentTreeNode(node) {
  if (node.classList.contains("bx--tree-parent-node")) return node;
  if (node.classList.contains("bx--tree")) return null;
  return findParentTreeNode(node.parentNode);
}
function instance180($$self, $$props, $$invalidate) {
  let selected;
  let node;
  let $selectedNodeIds;
  let $activeNodeId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TreeViewNode", slots, ["default"]);
  let { leaf = false } = $$props;
  let { id = "" } = $$props;
  let { text: text2 = "" } = $$props;
  let { disabled = false } = $$props;
  let { icon = void 0 } = $$props;
  let ref = null;
  let refLabel = null;
  let prevActiveId = void 0;
  const { activeNodeId, selectedNodeIds, clickNode, selectNode, focusNode } = getContext("TreeView");
  validate_store(activeNodeId, "activeNodeId");
  component_subscribe($$self, activeNodeId, (value) => $$invalidate(8, $activeNodeId = value));
  validate_store(selectedNodeIds, "selectedNodeIds");
  component_subscribe($$self, selectedNodeIds, (value) => $$invalidate(14, $selectedNodeIds = value));
  const offset = () => computeTreeLeafDepth(refLabel) + (leaf && icon ? 2 : 2.5);
  afterUpdate(() => {
    if (id === $activeNodeId && prevActiveId !== $activeNodeId) {
      if (!$selectedNodeIds.includes(id)) selectNode(node);
    }
    prevActiveId = $activeNodeId;
  });
  const writable_props = ["leaf", "id", "text", "disabled", "icon"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<TreeViewNode> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refLabel = $$value;
      $$invalidate(4, refLabel);
    });
  }
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(6, ref);
    });
  }
  const click_handler = () => {
    if (disabled) return;
    clickNode(node);
  };
  const keydown_handler = (e) => {
    if (e.key === "ArrowLeft" || e.key === "ArrowRight" || e.key === "Enter") {
      e.stopPropagation();
    }
    if (e.key === "ArrowLeft") {
      const parentNode = findParentTreeNode(ref.parentNode);
      if (parentNode) parentNode.focus();
    }
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      if (disabled) return;
      clickNode(node);
    }
  };
  const focus_handler = () => {
    focusNode(node);
  };
  $$self.$$set = ($$props2) => {
    if ("leaf" in $$props2) $$invalidate(13, leaf = $$props2.leaf);
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("text" in $$props2) $$invalidate(1, text2 = $$props2.text);
    if ("disabled" in $$props2) $$invalidate(2, disabled = $$props2.disabled);
    if ("icon" in $$props2) $$invalidate(3, icon = $$props2.icon);
    if ("$$scope" in $$props2) $$invalidate(15, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    computeTreeLeafDepth,
    findParentTreeNode,
    leaf,
    id,
    text: text2,
    disabled,
    icon,
    afterUpdate,
    getContext,
    ref,
    refLabel,
    prevActiveId,
    activeNodeId,
    selectedNodeIds,
    clickNode,
    selectNode,
    focusNode,
    offset,
    selected,
    node,
    $selectedNodeIds,
    $activeNodeId
  });
  $$self.$inject_state = ($$props2) => {
    if ("leaf" in $$props2) $$invalidate(13, leaf = $$props2.leaf);
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("text" in $$props2) $$invalidate(1, text2 = $$props2.text);
    if ("disabled" in $$props2) $$invalidate(2, disabled = $$props2.disabled);
    if ("icon" in $$props2) $$invalidate(3, icon = $$props2.icon);
    if ("ref" in $$props2) $$invalidate(6, ref = $$props2.ref);
    if ("refLabel" in $$props2) $$invalidate(4, refLabel = $$props2.refLabel);
    if ("prevActiveId" in $$props2) prevActiveId = $$props2.prevActiveId;
    if ("selected" in $$props2) $$invalidate(5, selected = $$props2.selected);
    if ("node" in $$props2) $$invalidate(7, node = $$props2.node);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selectedNodeIds, id*/
    16385) {
      $: $$invalidate(5, selected = $selectedNodeIds.includes(id));
    }
    if ($$self.$$.dirty & /*id, text, leaf, disabled, selected*/
    8231) {
      $: $$invalidate(7, node = {
        id,
        text: text2,
        // A node cannot be expanded.
        expanded: false,
        leaf,
        disabled,
        selected
      });
    }
    if ($$self.$$.dirty & /*refLabel*/
    16) {
      $: if (refLabel) {
        $$invalidate(4, refLabel.style.marginLeft = `-${offset()}rem`, refLabel);
        $$invalidate(4, refLabel.style.paddingLeft = `${offset()}rem`, refLabel);
      }
    }
  };
  return [
    id,
    text2,
    disabled,
    icon,
    refLabel,
    selected,
    ref,
    node,
    $activeNodeId,
    activeNodeId,
    selectedNodeIds,
    clickNode,
    focusNode,
    leaf,
    $selectedNodeIds,
    $$scope,
    slots,
    div_binding,
    li_binding,
    click_handler,
    keydown_handler,
    focus_handler
  ];
}
var TreeViewNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance180, create_fragment180, safe_not_equal, {
      leaf: 13,
      id: 0,
      text: 1,
      disabled: 2,
      icon: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreeViewNode",
      options,
      id: create_fragment180.name
    });
  }
  get leaf() {
    throw new Error("<TreeViewNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set leaf(value) {
    throw new Error("<TreeViewNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TreeViewNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TreeViewNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<TreeViewNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<TreeViewNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TreeViewNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TreeViewNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<TreeViewNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<TreeViewNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TreeViewNode_default = TreeViewNode;

// node_modules/carbon-components-svelte/src/TreeView/TreeViewNodeList.svelte
var file169 = "node_modules/carbon-components-svelte/src/TreeView/TreeViewNodeList.svelte";
function get_each_context_14(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i];
  return child_ctx;
}
var get_default_slot_changes_4 = (dirty) => ({ node: dirty[0] & /*node*/
2048 });
var get_default_slot_context_4 = (ctx) => ({ node: (
  /*node*/
  ctx[11]
) });
var get_default_slot_changes_3 = (dirty) => ({ node: dirty[0] & /*node*/
2048 });
var get_default_slot_context_3 = (ctx) => ({ node: (
  /*node*/
  ctx[11]
) });
var get_default_slot_changes_2 = (dirty) => ({
  node: dirty[0] & /*node, $selectedNodeIds, id, disabled*/
  3084
});
var get_default_slot_context_2 = (ctx) => ({
  node: {
    .../*node*/
    ctx[11],
    selected: (
      /*selected*/
      ctx[35]
    ),
    disabled: (
      /*disabled*/
      ctx[3]
    )
  }
});
function get_each_context21(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i];
  return child_ctx;
}
var get_default_slot_changes_1 = (dirty) => ({ node: dirty[0] & /*node*/
2048 });
var get_default_slot_context_1 = (ctx) => ({ node: (
  /*node*/
  ctx[11]
) });
var get_default_slot_changes14 = (dirty) => ({ node: dirty[0] & /*node*/
2048 });
var get_default_slot_context14 = (ctx) => ({ node: (
  /*node*/
  ctx[11]
) });
function get_else_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = (
    /*$selectedNodeIds*/
    child_ctx[10].includes(
      /*id*/
      child_ctx[2]
    )
  );
  child_ctx[35] = constants_0;
  return child_ctx;
}
function create_else_block_15(ctx) {
  let li;
  let div;
  let span0;
  let caretdown;
  let t0;
  let span1;
  let switch_instance;
  let t1;
  let t2;
  let li_tabindex_value;
  let li_aria_current_value;
  let li_aria_selected_value;
  let current;
  let mounted;
  let dispose;
  caretdown = new CaretDown_default({
    props: {
      class: "bx--tree-parent-node__toggle-icon " + /*expanded*/
      (ctx[6] && "bx--tree-parent-node__toggle-icon--expanded")
    },
    $$inline: true
  });
  var switch_value = (
    /*icon*/
    ctx[4]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: { class: "bx--tree-node__icon" },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_default_slot_context_2
  );
  let if_block = (
    /*expanded*/
    ctx[6] && create_if_block_227(ctx)
  );
  const block = {
    c: function create() {
      li = element("li");
      div = element("div");
      span0 = element("span");
      create_component(caretdown.$$.fragment);
      t0 = space();
      span1 = element("span");
      if (switch_instance) create_component(switch_instance.$$.fragment);
      t1 = space();
      if (default_slot) default_slot.c();
      t2 = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        role: true,
        id: true,
        tabindex: true,
        "aria-current": true,
        "aria-selected": true,
        "aria-disabled": true,
        "aria-expanded": true
      });
      var li_nodes = children(li);
      div = claim_element(li_nodes, "DIV", {});
      var div_nodes = children(div);
      span0 = claim_element(div_nodes, "SPAN", { disabled: true });
      var span0_nodes = children(span0);
      claim_component(caretdown.$$.fragment, span0_nodes);
      span0_nodes.forEach(detach_dev);
      t0 = claim_space(div_nodes);
      span1 = claim_element(div_nodes, "SPAN", {});
      var span1_nodes = children(span1);
      if (switch_instance) claim_component(switch_instance.$$.fragment, span1_nodes);
      t1 = claim_space(span1_nodes);
      if (default_slot) default_slot.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      t2 = claim_space(li_nodes);
      if (if_block) if_block.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        span0,
        "disabled",
        /*disabled*/
        ctx[3]
      );
      toggle_class(span0, "bx--tree-parent-node__toggle", true);
      add_location(span0, file169, 142, 6, 3911);
      toggle_class(span1, "bx--tree-node__label__details", true);
      add_location(span1, file169, 157, 6, 4350);
      toggle_class(div, "bx--tree-node__label", true);
      add_location(div, file169, 139, 4, 3712);
      attr_dev(li, "role", "treeitem");
      attr_dev(
        li,
        "id",
        /*id*/
        ctx[2]
      );
      attr_dev(li, "tabindex", li_tabindex_value = /*disabled*/
      ctx[3] ? void 0 : -1);
      attr_dev(li, "aria-current", li_aria_current_value = /*id*/
      ctx[2] === /*$activeNodeId*/
      ctx[9] || void 0);
      attr_dev(li, "aria-selected", li_aria_selected_value = /*disabled*/
      ctx[3] ? void 0 : (
        /*selected*/
        ctx[35]
      ));
      attr_dev(
        li,
        "aria-disabled",
        /*disabled*/
        ctx[3]
      );
      attr_dev(
        li,
        "aria-expanded",
        /*expanded*/
        ctx[6]
      );
      toggle_class(li, "bx--tree-node", true);
      toggle_class(li, "bx--tree-parent-node", true);
      toggle_class(
        li,
        "bx--tree-node--active",
        /*id*/
        ctx[2] === /*$activeNodeId*/
        ctx[9]
      );
      toggle_class(
        li,
        "bx--tree-node--selected",
        /*selected*/
        ctx[35]
      );
      toggle_class(
        li,
        "bx--tree-node--disabled",
        /*disabled*/
        ctx[3]
      );
      toggle_class(
        li,
        "bx--tree-node--with-icon",
        /*icon*/
        ctx[4]
      );
      add_location(li, file169, 81, 2, 2186);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, div);
      append_hydration_dev(div, span0);
      mount_component(caretdown, span0, null);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, span1);
      if (switch_instance) mount_component(switch_instance, span1, null);
      append_hydration_dev(span1, t1);
      if (default_slot) {
        default_slot.m(span1, null);
      }
      ctx[23](div);
      append_hydration_dev(li, t2);
      if (if_block) if_block.m(li, null);
      ctx[24](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            span0,
            "click",
            /*click_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(li, "click", stop_propagation(
            /*click_handler_1*/
            ctx[25]
          ), false, false, true, false),
          listen_dev(
            li,
            "keydown",
            /*keydown_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "focus",
            /*focus_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const caretdown_changes = {};
      if (dirty[0] & /*expanded*/
      64) caretdown_changes.class = "bx--tree-parent-node__toggle-icon " + /*expanded*/
      (ctx2[6] && "bx--tree-parent-node__toggle-icon--expanded");
      caretdown.$set(caretdown_changes);
      if (!current || dirty[0] & /*disabled*/
      8) {
        attr_dev(
          span0,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (dirty[0] & /*icon*/
      16 && switch_value !== (switch_value = /*icon*/
      ctx2[4])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, span1, t1);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, node, $selectedNodeIds, id, disabled*/
        268438540)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_default_slot_changes_2
            ),
            get_default_slot_context_2
          );
        }
      }
      if (
        /*expanded*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*expanded*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_227(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(li, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*id*/
      4) {
        attr_dev(
          li,
          "id",
          /*id*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      8 && li_tabindex_value !== (li_tabindex_value = /*disabled*/
      ctx2[3] ? void 0 : -1)) {
        attr_dev(li, "tabindex", li_tabindex_value);
      }
      if (!current || dirty[0] & /*id, $activeNodeId*/
      516 && li_aria_current_value !== (li_aria_current_value = /*id*/
      ctx2[2] === /*$activeNodeId*/
      ctx2[9] || void 0)) {
        attr_dev(li, "aria-current", li_aria_current_value);
      }
      if (!current || dirty[0] & /*disabled, $selectedNodeIds, id*/
      1036 && li_aria_selected_value !== (li_aria_selected_value = /*disabled*/
      ctx2[3] ? void 0 : (
        /*selected*/
        ctx2[35]
      ))) {
        attr_dev(li, "aria-selected", li_aria_selected_value);
      }
      if (!current || dirty[0] & /*disabled*/
      8) {
        attr_dev(
          li,
          "aria-disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*expanded*/
      64) {
        attr_dev(
          li,
          "aria-expanded",
          /*expanded*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*id, $activeNodeId*/
      516) {
        toggle_class(
          li,
          "bx--tree-node--active",
          /*id*/
          ctx2[2] === /*$activeNodeId*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*$selectedNodeIds, id*/
      1028) {
        toggle_class(
          li,
          "bx--tree-node--selected",
          /*selected*/
          ctx2[35]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      8) {
        toggle_class(
          li,
          "bx--tree-node--disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*icon*/
      16) {
        toggle_class(
          li,
          "bx--tree-node--with-icon",
          /*icon*/
          ctx2[4]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(caretdown.$$.fragment, local);
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(caretdown.$$.fragment, local);
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      destroy_component(caretdown);
      if (switch_instance) destroy_component(switch_instance);
      if (default_slot) default_slot.d(detaching);
      ctx[23](null);
      if (if_block) if_block.d();
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_15.name,
    type: "else",
    source: "(79:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block104(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*children*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*child*/
    ctx2[32].id
  );
  validate_each_keys(ctx, each_value, get_each_context21, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context21(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block21(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*children, $$scope, node*/
      268437505) {
        each_value = ensure_array_like_dev(
          /*children*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context21, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block21, each_1_anchor, get_each_context21);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block104.name,
    type: "if",
    source: "(67:0) {#if root}",
    ctx
  });
  return block;
}
function create_if_block_227(ctx) {
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_1 = ensure_array_like_dev(
    /*children*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*child*/
    ctx2[32].id
  );
  validate_each_keys(ctx, each_value_1, get_each_context_14, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_14(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_14(key, child_ctx));
  }
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", { role: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "role", "group");
      toggle_class(ul, "bx--tree-node__children", true);
      add_location(ul, file169, 163, 6, 4581);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*children, $$scope, node*/
      268437505) {
        each_value_1 = ensure_array_like_dev(
          /*children*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_14, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, ul, outro_and_destroy_block, create_each_block_14, null, get_each_context_14);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_227.name,
    type: "if",
    source: "(163:4) {#if expanded}",
    ctx
  });
  return block;
}
function create_else_block_22(ctx) {
  let treeviewnode;
  let current;
  const treeviewnode_spread_levels = [
    { leaf: true },
    /*child*/
    ctx[32]
  ];
  let treeviewnode_props = {
    $$slots: {
      default: [
        create_default_slot_34,
        ({ node }) => ({ 11: node }),
        ({ node }) => [node ? 2048 : 0]
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < treeviewnode_spread_levels.length; i += 1) {
    treeviewnode_props = assign(treeviewnode_props, treeviewnode_spread_levels[i]);
  }
  treeviewnode = new TreeViewNode_default({
    props: treeviewnode_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(treeviewnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(treeviewnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(treeviewnode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const treeviewnode_changes = dirty[0] & /*children*/
      1 ? get_spread_update(treeviewnode_spread_levels, [treeviewnode_spread_levels[0], get_spread_object(
        /*child*/
        ctx2[32]
      )]) : {};
      if (dirty[0] & /*$$scope, node*/
      268437504) {
        treeviewnode_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeviewnode.$set(treeviewnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(treeviewnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treeviewnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(treeviewnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_22.name,
    type: "else",
    source: "(170:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block_320(ctx) {
  let treeviewnodelist;
  let current;
  const treeviewnodelist_spread_levels = [
    /*child*/
    ctx[32]
  ];
  let treeviewnodelist_props = {
    $$slots: {
      default: [
        create_default_slot_28,
        ({ node }) => ({ 11: node }),
        ({ node }) => [node ? 2048 : 0]
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < treeviewnodelist_spread_levels.length; i += 1) {
    treeviewnodelist_props = assign(treeviewnodelist_props, treeviewnodelist_spread_levels[i]);
  }
  treeviewnodelist = new TreeViewNodeList({
    props: treeviewnodelist_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(treeviewnodelist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(treeviewnodelist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(treeviewnodelist, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const treeviewnodelist_changes = dirty[0] & /*children*/
      1 ? get_spread_update(treeviewnodelist_spread_levels, [get_spread_object(
        /*child*/
        ctx2[32]
      )]) : {};
      if (dirty[0] & /*$$scope, node*/
      268437504) {
        treeviewnodelist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeviewnodelist.$set(treeviewnodelist_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(treeviewnodelist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treeviewnodelist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(treeviewnodelist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_320.name,
    type: "if",
    source: "(166:10) {#if Array.isArray(child.children)}",
    ctx
  });
  return block;
}
function fallback_block42(ctx) {
  let t_value = (
    /*node*/
    ctx[11].text + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*node*/
      2048 && t_value !== (t_value = /*node*/
      ctx2[11].text + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block42.name,
    type: "fallback",
    source: "(172:34) {node.text}",
    ctx
  });
  return block;
}
function create_default_slot_34(ctx) {
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_default_slot_context_4
  );
  const default_slot_or_fallback = default_slot || fallback_block42(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      t = space();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback) default_slot_or_fallback.l(nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, node*/
        268437504)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_default_slot_changes_4
            ),
            get_default_slot_context_4
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*node*/
        2048)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_34.name,
    type: "slot",
    source: "(171:12) <TreeViewNode leaf {...child} let:node>",
    ctx
  });
  return block;
}
function create_default_slot_28(ctx) {
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_default_slot_context_3
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
      t = space();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, node*/
        268437504)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_default_slot_changes_3
            ),
            get_default_slot_context_3
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_28.name,
    type: "slot",
    source: "(167:12) <svelte:self {...child} let:node>",
    ctx
  });
  return block;
}
function create_each_block_14(key_1, ctx) {
  let first;
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_320, create_else_block_22];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (dirty[0] & /*children*/
    1) show_if = null;
    if (show_if == null) show_if = !!Array.isArray(
      /*child*/
      ctx2[32].children
    );
    if (show_if) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_14.name,
    type: "each",
    source: "(165:8) {#each children as child (child.id)}",
    ctx
  });
  return block;
}
function create_else_block33(ctx) {
  let treeviewnode;
  let current;
  const treeviewnode_spread_levels = [
    { leaf: true },
    /*child*/
    ctx[32]
  ];
  let treeviewnode_props = {
    $$slots: {
      default: [
        create_default_slot_110,
        ({ node }) => ({ 11: node }),
        ({ node }) => [node ? 2048 : 0]
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < treeviewnode_spread_levels.length; i += 1) {
    treeviewnode_props = assign(treeviewnode_props, treeviewnode_spread_levels[i]);
  }
  treeviewnode = new TreeViewNode_default({
    props: treeviewnode_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(treeviewnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(treeviewnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(treeviewnode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const treeviewnode_changes = dirty[0] & /*children*/
      1 ? get_spread_update(treeviewnode_spread_levels, [treeviewnode_spread_levels[0], get_spread_object(
        /*child*/
        ctx2[32]
      )]) : {};
      if (dirty[0] & /*$$scope, node*/
      268437504) {
        treeviewnode_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeviewnode.$set(treeviewnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(treeviewnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treeviewnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(treeviewnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block33.name,
    type: "else",
    source: "(73:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_144(ctx) {
  let treeviewnodelist;
  let current;
  const treeviewnodelist_spread_levels = [
    /*child*/
    ctx[32]
  ];
  let treeviewnodelist_props = {
    $$slots: {
      default: [
        create_default_slot24,
        ({ node }) => ({ 11: node }),
        ({ node }) => [node ? 2048 : 0]
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < treeviewnodelist_spread_levels.length; i += 1) {
    treeviewnodelist_props = assign(treeviewnodelist_props, treeviewnodelist_spread_levels[i]);
  }
  treeviewnodelist = new TreeViewNodeList({
    props: treeviewnodelist_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(treeviewnodelist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(treeviewnodelist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(treeviewnodelist, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const treeviewnodelist_changes = dirty[0] & /*children*/
      1 ? get_spread_update(treeviewnodelist_spread_levels, [get_spread_object(
        /*child*/
        ctx2[32]
      )]) : {};
      if (dirty[0] & /*$$scope, node*/
      268437504) {
        treeviewnodelist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeviewnodelist.$set(treeviewnodelist_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(treeviewnodelist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treeviewnodelist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(treeviewnodelist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_144.name,
    type: "if",
    source: "(69:4) {#if Array.isArray(child.children)}",
    ctx
  });
  return block;
}
function create_default_slot_110(ctx) {
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_default_slot_context_1
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
      t = space();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, node*/
        268437504)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_default_slot_changes_1
            ),
            get_default_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_110.name,
    type: "slot",
    source: "(74:6) <TreeViewNode leaf {...child} let:node>",
    ctx
  });
  return block;
}
function create_default_slot24(ctx) {
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_default_slot_context14
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
      t = space();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, node*/
        268437504)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_default_slot_changes14
            ),
            get_default_slot_context14
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot24.name,
    type: "slot",
    source: "(70:6) <svelte:self {...child} let:node>",
    ctx
  });
  return block;
}
function create_each_block21(key_1, ctx) {
  let first;
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_144, create_else_block33];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty[0] & /*children*/
    1) show_if = null;
    if (show_if == null) show_if = !!Array.isArray(
      /*child*/
      ctx2[32].children
    );
    if (show_if) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block21.name,
    type: "each",
    source: "(68:2) {#each children as child (child.id)}",
    ctx
  });
  return block;
}
function create_fragment181(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block104, create_else_block_15];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*root*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  function select_block_ctx(ctx2, index) {
    if (index === 1) return get_else_ctx(ctx2);
    return ctx2;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(select_block_ctx(ctx2, current_block_type_index), dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx2, current_block_type_index));
          if_block.c();
        } else {
          if_block.p(select_block_ctx(ctx2, current_block_type_index), dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment181.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance181($$self, $$props, $$invalidate) {
  let parent2;
  let node;
  let expanded;
  let $expandedNodeIds;
  let $activeNodeId;
  let $selectedNodeIds;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TreeViewNodeList", slots, ["default"]);
  let { children: children2 = [] } = $$props;
  let { root = false } = $$props;
  let { id = "" } = $$props;
  let { text: text2 = "" } = $$props;
  let { disabled = false } = $$props;
  let { icon = void 0 } = $$props;
  let ref = null;
  let refLabel = null;
  let prevActiveId = void 0;
  const { activeNodeId, selectedNodeIds, expandedNodeIds, clickNode, selectNode, expandNode, focusNode, toggleNode } = getContext("TreeView");
  validate_store(activeNodeId, "activeNodeId");
  component_subscribe($$self, activeNodeId, (value) => $$invalidate(9, $activeNodeId = value));
  validate_store(selectedNodeIds, "selectedNodeIds");
  component_subscribe($$self, selectedNodeIds, (value) => $$invalidate(10, $selectedNodeIds = value));
  validate_store(expandedNodeIds, "expandedNodeIds");
  component_subscribe($$self, expandedNodeIds, (value) => $$invalidate(20, $expandedNodeIds = value));
  const offset = () => {
    const depth = computeTreeLeafDepth(refLabel);
    if (parent2) return depth + 1;
    if (icon) return depth + 2;
    return depth + 2.5;
  };
  afterUpdate(() => {
    if (id === $activeNodeId && prevActiveId !== $activeNodeId) {
      if (!$selectedNodeIds.includes(id)) selectNode(node);
    }
    prevActiveId = $activeNodeId;
  });
  const writable_props = ["children", "root", "id", "text", "disabled", "icon"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<TreeViewNodeList> was created with unknown prop '${key}'`);
  });
  const click_handler = () => {
    if (disabled) return;
    $$invalidate(6, expanded = !expanded);
    expandNode(node, expanded);
    toggleNode(node);
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refLabel = $$value;
      $$invalidate(5, refLabel);
    });
  }
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(8, ref);
    });
  }
  const click_handler_13 = () => {
    if (disabled) return;
    clickNode(node);
  };
  const keydown_handler = (e) => {
    var _a;
    if (e.key === "ArrowLeft" || e.key === "ArrowRight" || e.key === "Enter") {
      e.stopPropagation();
    }
    if (parent2 && e.key === "ArrowLeft") {
      $$invalidate(6, expanded = false);
      expandNode(node, false);
      toggleNode(node);
    }
    if (parent2 && e.key === "ArrowRight") {
      if (expanded) {
        (_a = ref.lastChild.firstElementChild) == null ? void 0 : _a.focus();
      } else {
        $$invalidate(6, expanded = true);
        expandNode(node, true);
        toggleNode(node);
      }
    }
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      if (disabled) return;
      $$invalidate(6, expanded = !expanded);
      toggleNode(node);
      clickNode(node);
      expandNode(node, expanded);
      ref.focus();
    }
  };
  const focus_handler = () => {
    focusNode(node);
  };
  $$self.$$set = ($$props2) => {
    if ("children" in $$props2) $$invalidate(0, children2 = $$props2.children);
    if ("root" in $$props2) $$invalidate(1, root = $$props2.root);
    if ("id" in $$props2) $$invalidate(2, id = $$props2.id);
    if ("text" in $$props2) $$invalidate(19, text2 = $$props2.text);
    if ("disabled" in $$props2) $$invalidate(3, disabled = $$props2.disabled);
    if ("icon" in $$props2) $$invalidate(4, icon = $$props2.icon);
    if ("$$scope" in $$props2) $$invalidate(28, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    children: children2,
    root,
    id,
    text: text2,
    disabled,
    icon,
    afterUpdate,
    getContext,
    CaretDown: CaretDown_default,
    TreeViewNode: TreeViewNode_default,
    computeTreeLeafDepth,
    ref,
    refLabel,
    prevActiveId,
    activeNodeId,
    selectedNodeIds,
    expandedNodeIds,
    clickNode,
    selectNode,
    expandNode,
    focusNode,
    toggleNode,
    offset,
    expanded,
    parent: parent2,
    node,
    $expandedNodeIds,
    $activeNodeId,
    $selectedNodeIds
  });
  $$self.$inject_state = ($$props2) => {
    if ("children" in $$props2) $$invalidate(0, children2 = $$props2.children);
    if ("root" in $$props2) $$invalidate(1, root = $$props2.root);
    if ("id" in $$props2) $$invalidate(2, id = $$props2.id);
    if ("text" in $$props2) $$invalidate(19, text2 = $$props2.text);
    if ("disabled" in $$props2) $$invalidate(3, disabled = $$props2.disabled);
    if ("icon" in $$props2) $$invalidate(4, icon = $$props2.icon);
    if ("ref" in $$props2) $$invalidate(8, ref = $$props2.ref);
    if ("refLabel" in $$props2) $$invalidate(5, refLabel = $$props2.refLabel);
    if ("prevActiveId" in $$props2) prevActiveId = $$props2.prevActiveId;
    if ("expanded" in $$props2) $$invalidate(6, expanded = $$props2.expanded);
    if ("parent" in $$props2) $$invalidate(7, parent2 = $$props2.parent);
    if ("node" in $$props2) $$invalidate(11, node = $$props2.node);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*children*/
    1) {
      $: $$invalidate(7, parent2 = Array.isArray(children2));
    }
    if ($$self.$$.dirty[0] & /*$expandedNodeIds, id*/
    1048580) {
      $: $$invalidate(6, expanded = $expandedNodeIds.includes(id));
    }
    if ($$self.$$.dirty[0] & /*id, text, expanded, parent*/
    524484) {
      $: $$invalidate(11, node = { id, text: text2, expanded, leaf: !parent2 });
    }
    if ($$self.$$.dirty[0] & /*refLabel*/
    32) {
      $: if (refLabel) {
        $$invalidate(5, refLabel.style.marginLeft = `-${offset()}rem`, refLabel);
        $$invalidate(5, refLabel.style.paddingLeft = `${offset()}rem`, refLabel);
      }
    }
  };
  return [
    children2,
    root,
    id,
    disabled,
    icon,
    refLabel,
    expanded,
    parent2,
    ref,
    $activeNodeId,
    $selectedNodeIds,
    node,
    activeNodeId,
    selectedNodeIds,
    expandedNodeIds,
    clickNode,
    expandNode,
    focusNode,
    toggleNode,
    text2,
    $expandedNodeIds,
    slots,
    click_handler,
    div_binding,
    li_binding,
    click_handler_13,
    keydown_handler,
    focus_handler,
    $$scope
  ];
}
var TreeViewNodeList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance181,
      create_fragment181,
      safe_not_equal,
      {
        children: 0,
        root: 1,
        id: 2,
        text: 19,
        disabled: 3,
        icon: 4
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreeViewNodeList",
      options,
      id: create_fragment181.name
    });
  }
  get children() {
    throw new Error("<TreeViewNodeList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<TreeViewNodeList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get root() {
    throw new Error("<TreeViewNodeList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error("<TreeViewNodeList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TreeViewNodeList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TreeViewNodeList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<TreeViewNodeList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<TreeViewNodeList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TreeViewNodeList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TreeViewNodeList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<TreeViewNodeList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<TreeViewNodeList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TreeViewNodeList_default = TreeViewNodeList;

// node_modules/carbon-components-svelte/src/TreeView/TreeView.svelte
var file170 = "node_modules/carbon-components-svelte/src/TreeView/TreeView.svelte";
var get_default_slot_changes15 = (dirty) => ({ node: dirty & /*node*/
268435456 });
var get_default_slot_context15 = (ctx) => ({ node: (
  /*node*/
  ctx[28]
) });
var get_labelText_slot_changes18 = (dirty) => ({});
var get_labelText_slot_context18 = (ctx) => ({});
function create_if_block105(ctx) {
  let label;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[17].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_labelText_slot_context18
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block_118(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { id: true });
      var label_nodes = children(label);
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "id",
        /*labelId*/
        ctx[6]
      );
      toggle_class(label, "bx--label", true);
      add_location(label, file170, 244, 2, 6424);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_labelText_slot_changes18
            ),
            get_labelText_slot_context18
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & /*labelText*/
        8)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (labelText_slot_or_fallback) labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block105.name,
    type: "if",
    source: "(243:0) {#if !hideLabel}",
    ctx
  });
  return block;
}
function fallback_block_118(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[3]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[3]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelText*/
      8) set_data_dev(
        t,
        /*labelText*/
        ctx2[3]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_118.name,
    type: "fallback",
    source: "(246:27) {labelText}",
    ctx
  });
  return block;
}
function fallback_block43(ctx) {
  let t_value = (
    /*node*/
    ctx[28].text + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*node*/
      268435456 && t_value !== (t_value = /*node*/
      ctx2[28].text + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block43.name,
    type: "fallback",
    source: "(265:24)        ",
    ctx
  });
  return block;
}
function create_default_slot25(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_default_slot_context15
  );
  const default_slot_or_fallback = default_slot || fallback_block43(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback) default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback) default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, node*/
        269484032)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_default_slot_changes15
            ),
            get_default_slot_context15
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*node*/
        268435456)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot25.name,
    type: "slot",
    source: '(264:2) <TreeViewNodeList root children=\\"{children}\\" let:node>',
    ctx
  });
  return block;
}
function create_fragment182(ctx) {
  let t;
  let ul;
  let treeviewnodelist;
  let ul_aria_label_value;
  let ul_aria_labelledby_value;
  let ul_aria_multiselectable_value;
  let current;
  let mounted;
  let dispose;
  let if_block = !/*hideLabel*/
  ctx[4] && create_if_block105(ctx);
  treeviewnodelist = new TreeViewNodeList_default({
    props: {
      root: true,
      children: (
        /*children*/
        ctx[1]
      ),
      $$slots: {
        default: [
          create_default_slot25,
          ({ node }) => ({ 28: node }),
          ({ node }) => node ? 268435456 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let ul_levels = [
    /*$$restProps*/
    ctx[8],
    { role: "tree" },
    {
      "aria-label": ul_aria_label_value = /*hideLabel*/
      ctx[4] ? (
        /*labelText*/
        ctx[3]
      ) : void 0
    },
    {
      "aria-labelledby": ul_aria_labelledby_value = !/*hideLabel*/
      ctx[4] ? (
        /*labelId*/
        ctx[6]
      ) : void 0
    },
    {
      "aria-multiselectable": ul_aria_multiselectable_value = /*selectedIds*/
      ctx[0].length > 1 || void 0
    }
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      t = space();
      ul = element("ul");
      create_component(treeviewnodelist.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      t = claim_space(nodes);
      ul = claim_element(nodes, "UL", {
        role: true,
        "aria-label": true,
        "aria-labelledby": true,
        "aria-multiselectable": true
      });
      var ul_nodes = children(ul);
      claim_component(treeviewnodelist.$$.fragment, ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--tree", true);
      toggle_class(
        ul,
        "bx--tree--default",
        /*size*/
        ctx[2] === "default"
      );
      toggle_class(
        ul,
        "bx--tree--compact",
        /*size*/
        ctx[2] === "compact"
      );
      add_location(ul, file170, 250, 0, 6610);
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, ul, anchor);
      mount_component(treeviewnodelist, ul, null);
      ctx[19](ul);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            ul,
            "keydown",
            /*keydown_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(ul, "keydown", stop_propagation(
            /*handleKeyDown*/
            ctx[7]
          ), false, false, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!/*hideLabel*/
      ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*hideLabel*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block105(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const treeviewnodelist_changes = {};
      if (dirty & /*children*/
      2) treeviewnodelist_changes.children = /*children*/
      ctx2[1];
      if (dirty & /*$$scope, node*/
      269484032) {
        treeviewnodelist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeviewnodelist.$set(treeviewnodelist_changes);
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8],
        { role: "tree" },
        (!current || dirty & /*hideLabel, labelText*/
        24 && ul_aria_label_value !== (ul_aria_label_value = /*hideLabel*/
        ctx2[4] ? (
          /*labelText*/
          ctx2[3]
        ) : void 0)) && { "aria-label": ul_aria_label_value },
        (!current || dirty & /*hideLabel*/
        16 && ul_aria_labelledby_value !== (ul_aria_labelledby_value = !/*hideLabel*/
        ctx2[4] ? (
          /*labelId*/
          ctx2[6]
        ) : void 0)) && {
          "aria-labelledby": ul_aria_labelledby_value
        },
        (!current || dirty & /*selectedIds*/
        1 && ul_aria_multiselectable_value !== (ul_aria_multiselectable_value = /*selectedIds*/
        ctx2[0].length > 1 || void 0)) && {
          "aria-multiselectable": ul_aria_multiselectable_value
        }
      ]));
      toggle_class(ul, "bx--tree", true);
      toggle_class(
        ul,
        "bx--tree--default",
        /*size*/
        ctx2[2] === "default"
      );
      toggle_class(
        ul,
        "bx--tree--compact",
        /*size*/
        ctx2[2] === "compact"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(treeviewnodelist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(treeviewnodelist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(ul);
      }
      if (if_block) if_block.d(detaching);
      destroy_component(treeviewnodelist);
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment182.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function findNodeById(node, id) {
  if (node === null) return null;
  if (node.id === id) return [node];
  if (!Array.isArray(node.children)) {
    return null;
  }
  for (const child of node.children) {
    const nodes = findNodeById(child, id);
    if (Array.isArray(nodes)) {
      nodes.unshift(node);
      return nodes;
    }
  }
  return null;
}
function instance182($$self, $$props, $$invalidate) {
  let nodes;
  let nodeIds;
  const omit_props_names = [
    "children",
    "activeId",
    "selectedIds",
    "expandedIds",
    "size",
    "labelText",
    "hideLabel",
    "expandAll",
    "collapseAll",
    "expandNodes",
    "collapseNodes",
    "showNode"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TreeView", slots, ["labelText", "default"]);
  let { children: children2 = [] } = $$props;
  let { activeId = "" } = $$props;
  let { selectedIds = [] } = $$props;
  let { expandedIds = [] } = $$props;
  let { size = "default" } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  function expandAll() {
    $$invalidate(10, expandedIds = [...nodeIds]);
  }
  function collapseAll() {
    $$invalidate(10, expandedIds = []);
  }
  function expandNodes(filterNode = (node) => false) {
    $$invalidate(10, expandedIds = nodes.filter((node) => {
      var _a;
      return filterNode(node) || ((_a = node.children) == null ? void 0 : _a.some((child) => filterNode(child) && child.children));
    }).map((node) => node.id));
  }
  function collapseNodes(filterNode = (node) => true) {
    $$invalidate(10, expandedIds = nodes.filter((node) => expandedIds.includes(node.id) && !filterNode(node)).map((node) => node.id));
  }
  function showNode(id) {
    for (const child of children2) {
      const nodes2 = findNodeById(child, id);
      if (nodes2) {
        const ids = nodes2.map((node) => node.id);
        const nodeIds2 = new Set(ids);
        expandNodes((node) => nodeIds2.has(node.id));
        const lastId = ids[ids.length - 1];
        $$invalidate(9, activeId = lastId);
        $$invalidate(0, selectedIds = [lastId]);
        tick().then(() => {
          var _a;
          (_a = ref == null ? void 0 : ref.querySelector(`[id="${lastId}"]`)) == null ? void 0 : _a.focus();
        });
        break;
      }
    }
  }
  const dispatch = createEventDispatcher();
  const labelId = `label-${Math.random().toString(36)}`;
  const activeNodeId = writable(activeId);
  const selectedNodeIds = writable(selectedIds);
  const expandedNodeIds = writable(expandedIds);
  let ref = null;
  let treeWalker = null;
  setContext("TreeView", {
    activeNodeId,
    selectedNodeIds,
    expandedNodeIds,
    clickNode: (node) => {
      $$invalidate(9, activeId = node.id);
      $$invalidate(0, selectedIds = [node.id]);
      dispatch("select", node);
    },
    selectNode: (node) => {
      $$invalidate(0, selectedIds = [node.id]);
    },
    expandNode: (node, expanded) => {
      if (expanded) {
        $$invalidate(10, expandedIds = [...expandedIds, node.id]);
      } else {
        $$invalidate(10, expandedIds = expandedIds.filter((_id) => _id !== node.id));
      }
    },
    focusNode: (node) => dispatch("focus", node),
    toggleNode: (node) => dispatch("toggle", node)
  });
  function handleKeyDown(e) {
    if (e.key === "ArrowUp" || e.key === "ArrowDown") e.preventDefault();
    treeWalker.currentNode = e.target;
    let node = null;
    if (e.key === "ArrowUp") node = treeWalker.previousNode();
    if (e.key === "ArrowDown") node = treeWalker.nextNode();
    if (node && node !== e.target) {
      node.tabIndex = "0";
      node.focus();
    }
  }
  onMount(() => {
    const firstFocusableNode = ref.querySelector("li.bx--tree-node:not(.bx--tree-node--disabled)");
    if (firstFocusableNode != null) {
      firstFocusableNode.tabIndex = "0";
    }
  });
  function traverse(children3) {
    let nodes2 = [];
    children3.forEach((node) => {
      nodes2.push(node);
      if (Array.isArray(node.children)) {
        nodes2 = [...nodes2, ...traverse(node.children)];
      }
    });
    return nodes2;
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(5, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("children" in $$new_props) $$invalidate(1, children2 = $$new_props.children);
    if ("activeId" in $$new_props) $$invalidate(9, activeId = $$new_props.activeId);
    if ("selectedIds" in $$new_props) $$invalidate(0, selectedIds = $$new_props.selectedIds);
    if ("expandedIds" in $$new_props) $$invalidate(10, expandedIds = $$new_props.expandedIds);
    if ("size" in $$new_props) $$invalidate(2, size = $$new_props.size);
    if ("labelText" in $$new_props) $$invalidate(3, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props) $$invalidate(4, hideLabel = $$new_props.hideLabel);
    if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    findNodeById,
    children: children2,
    activeId,
    selectedIds,
    expandedIds,
    size,
    labelText,
    hideLabel,
    expandAll,
    collapseAll,
    expandNodes,
    collapseNodes,
    showNode,
    createEventDispatcher,
    setContext,
    onMount,
    tick,
    writable,
    TreeViewNodeList: TreeViewNodeList_default,
    dispatch,
    labelId,
    activeNodeId,
    selectedNodeIds,
    expandedNodeIds,
    ref,
    treeWalker,
    handleKeyDown,
    traverse,
    nodes,
    nodeIds
  });
  $$self.$inject_state = ($$new_props) => {
    if ("children" in $$props) $$invalidate(1, children2 = $$new_props.children);
    if ("activeId" in $$props) $$invalidate(9, activeId = $$new_props.activeId);
    if ("selectedIds" in $$props) $$invalidate(0, selectedIds = $$new_props.selectedIds);
    if ("expandedIds" in $$props) $$invalidate(10, expandedIds = $$new_props.expandedIds);
    if ("size" in $$props) $$invalidate(2, size = $$new_props.size);
    if ("labelText" in $$props) $$invalidate(3, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props) $$invalidate(4, hideLabel = $$new_props.hideLabel);
    if ("ref" in $$props) $$invalidate(5, ref = $$new_props.ref);
    if ("treeWalker" in $$props) treeWalker = $$new_props.treeWalker;
    if ("nodes" in $$props) $$invalidate(16, nodes = $$new_props.nodes);
    if ("nodeIds" in $$props) nodeIds = $$new_props.nodeIds;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*children*/
    2) {
      $: $$invalidate(16, nodes = traverse(children2));
    }
    if ($$self.$$.dirty & /*nodes*/
    65536) {
      $: nodeIds = nodes.map((node) => node.id);
    }
    if ($$self.$$.dirty & /*activeId*/
    512) {
      $: activeNodeId.set(activeId);
    }
    if ($$self.$$.dirty & /*selectedIds*/
    1) {
      $: selectedNodeIds.set(selectedIds);
    }
    if ($$self.$$.dirty & /*expandedIds*/
    1024) {
      $: expandedNodeIds.set(expandedIds);
    }
    if ($$self.$$.dirty & /*ref*/
    32) {
      $: if (ref) {
        treeWalker = document.createTreeWalker(ref, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (node) => {
            if (node.classList.contains("bx--tree-node--disabled")) return NodeFilter.FILTER_REJECT;
            if (node.matches("li.bx--tree-node")) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
          }
        });
      }
    }
  };
  return [
    selectedIds,
    children2,
    size,
    labelText,
    hideLabel,
    ref,
    labelId,
    handleKeyDown,
    $$restProps,
    activeId,
    expandedIds,
    expandAll,
    collapseAll,
    expandNodes,
    collapseNodes,
    showNode,
    nodes,
    slots,
    keydown_handler,
    ul_binding,
    $$scope
  ];
}
var TreeView = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance182, create_fragment182, safe_not_equal, {
      children: 1,
      activeId: 9,
      selectedIds: 0,
      expandedIds: 10,
      size: 2,
      labelText: 3,
      hideLabel: 4,
      expandAll: 11,
      collapseAll: 12,
      expandNodes: 13,
      collapseNodes: 14,
      showNode: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreeView",
      options,
      id: create_fragment182.name
    });
  }
  get children() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeId() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeId(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedIds() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedIds(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandedIds() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandedIds(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandAll() {
    return this.$$.ctx[11];
  }
  set expandAll(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collapseAll() {
    return this.$$.ctx[12];
  }
  set collapseAll(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandNodes() {
    return this.$$.ctx[13];
  }
  set expandNodes(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collapseNodes() {
    return this.$$.ctx[14];
  }
  set collapseNodes(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showNode() {
    return this.$$.ctx[15];
  }
  set showNode(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TreeView_default = TreeView;

// node_modules/carbon-components-svelte/src/Truncate/Truncate.svelte
var file171 = "node_modules/carbon-components-svelte/src/Truncate/Truncate.svelte";
function create_fragment183(ctx) {
  let p;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let p_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let p_data = {};
  for (let i = 0; i < p_levels.length; i += 1) {
    p_data = assign(p_data, p_levels[i]);
  }
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      if (default_slot) default_slot.l(p_nodes);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(p, p_data);
      toggle_class(
        p,
        "bx--text-truncate--end",
        /*clamp*/
        ctx[0] === "end"
      );
      toggle_class(
        p,
        "bx--text-truncate--front",
        /*clamp*/
        ctx[0] === "front"
      );
      add_location(p, file171, 5, 0, 80);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
      toggle_class(
        p,
        "bx--text-truncate--end",
        /*clamp*/
        ctx2[0] === "end"
      );
      toggle_class(
        p,
        "bx--text-truncate--front",
        /*clamp*/
        ctx2[0] === "front"
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment183.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance183($$self, $$props, $$invalidate) {
  const omit_props_names = ["clamp"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Truncate", slots, ["default"]);
  let { clamp = "end" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("clamp" in $$new_props) $$invalidate(0, clamp = $$new_props.clamp);
    if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ clamp });
  $$self.$inject_state = ($$new_props) => {
    if ("clamp" in $$props) $$invalidate(0, clamp = $$new_props.clamp);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [clamp, $$restProps, $$scope, slots];
}
var Truncate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance183, create_fragment183, safe_not_equal, { clamp: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Truncate",
      options,
      id: create_fragment183.name
    });
  }
  get clamp() {
    throw new Error("<Truncate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clamp(value) {
    throw new Error("<Truncate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Truncate_default = Truncate;

// node_modules/carbon-components-svelte/src/Truncate/truncate.js
function truncate(node, options = {}) {
  const prefix = "bx--text-truncate--";
  function toggleClass(front = false) {
    const classes = [...node.classList].filter((name) => !name.startsWith(prefix)).join(" ");
    node.className = `${classes} ${prefix}${front ? "front" : "end"}`;
  }
  toggleClass(options.clamp === "front");
  return {
    update(options2) {
      toggleClass(options2.clamp === "front");
    }
  };
}
var truncate_default = truncate;

// node_modules/carbon-components-svelte/src/icons/Menu.svelte
var file172 = "node_modules/carbon-components-svelte/src/icons/Menu.svelte";
function create_if_block106(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file172, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block106.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment184(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block106(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 6H28V8H4zM4 24H28V26H4zM4 12H28V14H4zM4 18H28V20H4z");
      add_location(path, file172, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file172, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block106(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment184.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance184($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menu", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Menu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance184, create_fragment184, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu",
      options,
      id: create_fragment184.name
    });
  }
  get size() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Menu_default = Menu;

// node_modules/carbon-components-svelte/src/UIShell/navStore.js
var shouldRenderHamburgerMenu = writable(false);
var isSideNavCollapsed = writable(false);
var isSideNavRail = writable(false);

// node_modules/carbon-components-svelte/src/UIShell/HamburgerMenu.svelte
var file173 = "node_modules/carbon-components-svelte/src/UIShell/HamburgerMenu.svelte";
function create_fragment185(ctx) {
  let button;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*isOpen*/
    ctx[0] ? (
      /*iconClose*/
      ctx[4]
    ) : (
      /*iconMenu*/
      ctx[3]
    )
  );
  function switch_props(ctx2, dirty) {
    return { props: { size: 20 }, $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  let button_levels = [
    { type: "button" },
    { title: (
      /*ariaLabel*/
      ctx[2]
    ) },
    { "aria-label": (
      /*ariaLabel*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[5]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (switch_instance) create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        title: true,
        "aria-label": true
      });
      var button_nodes = children(button);
      if (switch_instance) claim_component(switch_instance.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      toggle_class(button, "bx--header__action", true);
      toggle_class(button, "bx--header__menu-trigger", true);
      toggle_class(button, "bx--header__menu-toggle", true);
      add_location(button, file173, 31, 0, 768);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (switch_instance) mount_component(switch_instance, button, null);
      if (button.autofocus) button.focus();
      ctx[7](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler_1*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*isOpen, iconClose, iconMenu*/
      25 && switch_value !== (switch_value = /*isOpen*/
      ctx2[0] ? (
        /*iconClose*/
        ctx2[4]
      ) : (
        /*iconMenu*/
        ctx2[3]
      ))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, button, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & /*ariaLabel*/
        4) && { title: (
          /*ariaLabel*/
          ctx2[2]
        ) },
        (!current || dirty & /*ariaLabel*/
        4) && { "aria-label": (
          /*ariaLabel*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      toggle_class(button, "bx--header__action", true);
      toggle_class(button, "bx--header__menu-trigger", true);
      toggle_class(button, "bx--header__menu-toggle", true);
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (switch_instance) destroy_component(switch_instance);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment185.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance185($$self, $$props, $$invalidate) {
  const omit_props_names = ["ariaLabel", "isOpen", "iconMenu", "iconClose", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HamburgerMenu", slots, []);
  let { ariaLabel = void 0 } = $$props;
  let { isOpen = false } = $$props;
  let { iconMenu = Menu_default } = $$props;
  let { iconClose = Close_default } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const click_handler_13 = () => $$invalidate(0, isOpen = !isOpen);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ariaLabel" in $$new_props) $$invalidate(2, ariaLabel = $$new_props.ariaLabel);
    if ("isOpen" in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("iconMenu" in $$new_props) $$invalidate(3, iconMenu = $$new_props.iconMenu);
    if ("iconClose" in $$new_props) $$invalidate(4, iconClose = $$new_props.iconClose);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    ariaLabel,
    isOpen,
    iconMenu,
    iconClose,
    ref,
    Close: Close_default,
    Menu: Menu_default
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ariaLabel" in $$props) $$invalidate(2, ariaLabel = $$new_props.ariaLabel);
    if ("isOpen" in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("iconMenu" in $$props) $$invalidate(3, iconMenu = $$new_props.iconMenu);
    if ("iconClose" in $$props) $$invalidate(4, iconClose = $$new_props.iconClose);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    isOpen,
    ref,
    ariaLabel,
    iconMenu,
    iconClose,
    $$restProps,
    click_handler,
    button_binding,
    click_handler_13
  ];
}
var HamburgerMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance185, create_fragment185, safe_not_equal, {
      ariaLabel: 2,
      isOpen: 0,
      iconMenu: 3,
      iconClose: 4,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HamburgerMenu",
      options,
      id: create_fragment185.name
    });
  }
  get ariaLabel() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconMenu() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconMenu(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconClose() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconClose(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HamburgerMenu_default = HamburgerMenu;

// node_modules/carbon-components-svelte/src/UIShell/Header.svelte
var file174 = "node_modules/carbon-components-svelte/src/UIShell/Header.svelte";
var get_platform_slot_changes = (dirty) => ({});
var get_platform_slot_context = (ctx) => ({});
var get_company_slot_changes = (dirty) => ({});
var get_company_slot_context = (ctx) => ({});
var get_skip_to_content_slot_changes = (dirty) => ({});
var get_skip_to_content_slot_context = (ctx) => ({});
function create_if_block_145(ctx) {
  let hamburgermenu;
  let updating_isOpen;
  let current;
  function hamburgermenu_isOpen_binding(value) {
    ctx[20](value);
  }
  let hamburgermenu_props = {
    iconClose: (
      /*iconClose*/
      ctx[8]
    ),
    iconMenu: (
      /*iconMenu*/
      ctx[7]
    )
  };
  if (
    /*isSideNavOpen*/
    ctx[0] !== void 0
  ) {
    hamburgermenu_props.isOpen = /*isSideNavOpen*/
    ctx[0];
  }
  hamburgermenu = new HamburgerMenu_default({
    props: hamburgermenu_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(hamburgermenu, "isOpen", hamburgermenu_isOpen_binding));
  const block = {
    c: function create() {
      create_component(hamburgermenu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hamburgermenu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hamburgermenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hamburgermenu_changes = {};
      if (dirty & /*iconClose*/
      256) hamburgermenu_changes.iconClose = /*iconClose*/
      ctx2[8];
      if (dirty & /*iconMenu*/
      128) hamburgermenu_changes.iconMenu = /*iconMenu*/
      ctx2[7];
      if (!updating_isOpen && dirty & /*isSideNavOpen*/
      1) {
        updating_isOpen = true;
        hamburgermenu_changes.isOpen = /*isSideNavOpen*/
        ctx2[0];
        add_flush_callback(() => updating_isOpen = false);
      }
      hamburgermenu.$set(hamburgermenu_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(hamburgermenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hamburgermenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hamburgermenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_145.name,
    type: "if",
    source: "(85:2) {#if ($shouldRenderHamburgerMenu && winWidth < expansionBreakpoint) || persistentHamburgerMenu}",
    ctx
  });
  return block;
}
function create_if_block107(ctx) {
  let span;
  let current;
  const company_slot_template = (
    /*#slots*/
    ctx[17].company
  );
  const company_slot = create_slot(
    company_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_company_slot_context
  );
  const company_slot_or_fallback = company_slot || fallback_block_119(ctx);
  const block = {
    c: function create() {
      span = element("span");
      if (company_slot_or_fallback) company_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if (company_slot_or_fallback) company_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--header__name--prefix", true);
      add_location(span, file174, 99, 6, 2667);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (company_slot_or_fallback) {
        company_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (company_slot) {
        if (company_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            company_slot,
            company_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              company_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_company_slot_changes
            ),
            get_company_slot_context
          );
        }
      } else {
        if (company_slot_or_fallback && company_slot_or_fallback.p && (!current || dirty & /*company*/
        8)) {
          company_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(company_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(company_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (company_slot_or_fallback) company_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block107.name,
    type: "if",
    source: "(99:4) {#if company || $$slots.company}",
    ctx
  });
  return block;
}
function fallback_block_119(ctx) {
  let t0;
  let t1;
  const block = {
    c: function create() {
      t0 = text(
        /*company*/
        ctx[3]
      );
      t1 = text(" ");
    },
    l: function claim(nodes) {
      t0 = claim_text(
        nodes,
        /*company*/
        ctx[3]
      );
      t1 = claim_text(nodes, " ");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*company*/
      8) set_data_dev(
        t0,
        /*company*/
        ctx2[3]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_119.name,
    type: "fallback",
    source: "(101:30) {company}",
    ctx
  });
  return block;
}
function fallback_block44(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*platformName*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*platformName*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*platformName*/
      16) set_data_dev(
        t,
        /*platformName*/
        ctx2[4]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block44.name,
    type: "fallback",
    source: "(104:26) {platformName}",
    ctx
  });
  return block;
}
function create_fragment186(ctx) {
  let header;
  let t0;
  let t1;
  let a;
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  add_render_callback(
    /*onwindowresize*/
    ctx[19]
  );
  const skip_to_content_slot_template = (
    /*#slots*/
    ctx[17]["skip-to-content"]
  );
  const skip_to_content_slot = create_slot(
    skip_to_content_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_skip_to_content_slot_context
  );
  let if_block0 = (
    /*$shouldRenderHamburgerMenu*/
    (ctx[11] && /*winWidth*/
    ctx[9] < /*expansionBreakpoint*/
    ctx[6] || /*persistentHamburgerMenu*/
    ctx[5]) && create_if_block_145(ctx)
  );
  let if_block1 = (
    /*company*/
    (ctx[3] || /*$$slots*/
    ctx[13].company) && create_if_block107(ctx)
  );
  const platform_slot_template = (
    /*#slots*/
    ctx[17].platform
  );
  const platform_slot = create_slot(
    platform_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_platform_slot_context
  );
  const platform_slot_or_fallback = platform_slot || fallback_block44(ctx);
  let a_levels = [
    { href: (
      /*href*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[12]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block = {
    c: function create() {
      header = element("header");
      if (skip_to_content_slot) skip_to_content_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      a = element("a");
      if (if_block1) if_block1.c();
      t2 = space();
      if (platform_slot_or_fallback) platform_slot_or_fallback.c();
      t3 = space();
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { "aria-label": true });
      var header_nodes = children(header);
      if (skip_to_content_slot) skip_to_content_slot.l(header_nodes);
      t0 = claim_space(header_nodes);
      if (if_block0) if_block0.l(header_nodes);
      t1 = claim_space(header_nodes);
      a = claim_element(header_nodes, "A", { href: true });
      var a_nodes = children(a);
      if (if_block1) if_block1.l(a_nodes);
      t2 = claim_space(a_nodes);
      if (platform_slot_or_fallback) platform_slot_or_fallback.l(a_nodes);
      a_nodes.forEach(detach_dev);
      t3 = claim_space(header_nodes);
      if (default_slot) default_slot.l(header_nodes);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      toggle_class(a, "bx--header__name", true);
      add_location(a, file174, 91, 2, 2507);
      attr_dev(
        header,
        "aria-label",
        /*ariaLabel*/
        ctx[10]
      );
      toggle_class(header, "bx--header", true);
      add_location(header, file174, 82, 0, 2185);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      if (skip_to_content_slot) {
        skip_to_content_slot.m(header, null);
      }
      append_hydration_dev(header, t0);
      if (if_block0) if_block0.m(header, null);
      append_hydration_dev(header, t1);
      append_hydration_dev(header, a);
      if (if_block1) if_block1.m(a, null);
      append_hydration_dev(a, t2);
      if (platform_slot_or_fallback) {
        platform_slot_or_fallback.m(a, null);
      }
      ctx[21](a);
      append_hydration_dev(header, t3);
      if (default_slot) {
        default_slot.m(header, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "resize",
            /*onwindowresize*/
            ctx[19]
          ),
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (skip_to_content_slot) {
        if (skip_to_content_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            skip_to_content_slot,
            skip_to_content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              skip_to_content_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_skip_to_content_slot_changes
            ),
            get_skip_to_content_slot_context
          );
        }
      }
      if (
        /*$shouldRenderHamburgerMenu*/
        ctx2[11] && /*winWidth*/
        ctx2[9] < /*expansionBreakpoint*/
        ctx2[6] || /*persistentHamburgerMenu*/
        ctx2[5]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$shouldRenderHamburgerMenu, winWidth, expansionBreakpoint, persistentHamburgerMenu*/
          2656) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_145(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(header, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*company*/
        ctx2[3] || /*$$slots*/
        ctx2[13].company
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*company, $$slots*/
          8200) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block107(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(a, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (platform_slot) {
        if (platform_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            platform_slot,
            platform_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              platform_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_platform_slot_changes
            ),
            get_platform_slot_context
          );
        }
      } else {
        if (platform_slot_or_fallback && platform_slot_or_fallback.p && (!current || dirty & /*platformName*/
        16)) {
          platform_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        4) && { href: (
          /*href*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12]
      ]));
      toggle_class(a, "bx--header__name", true);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*ariaLabel*/
      1024) {
        attr_dev(
          header,
          "aria-label",
          /*ariaLabel*/
          ctx2[10]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(skip_to_content_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(platform_slot_or_fallback, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(skip_to_content_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(platform_slot_or_fallback, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(header);
      }
      if (skip_to_content_slot) skip_to_content_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (platform_slot_or_fallback) platform_slot_or_fallback.d(detaching);
      ctx[21](null);
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment186.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance186($$self, $$props, $$invalidate) {
  let ariaLabel;
  const omit_props_names = [
    "expandedByDefault",
    "isSideNavOpen",
    "uiShellAriaLabel",
    "href",
    "company",
    "platformName",
    "persistentHamburgerMenu",
    "expansionBreakpoint",
    "ref",
    "iconMenu",
    "iconClose"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $shouldRenderHamburgerMenu;
  validate_store(shouldRenderHamburgerMenu, "shouldRenderHamburgerMenu");
  component_subscribe($$self, shouldRenderHamburgerMenu, ($$value) => $$invalidate(11, $shouldRenderHamburgerMenu = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Header", slots, ["skip-to-content", "company", "platform", "default"]);
  const $$slots = compute_slots(slots);
  let { expandedByDefault = true } = $$props;
  let { isSideNavOpen = false } = $$props;
  let { uiShellAriaLabel = void 0 } = $$props;
  let { href = void 0 } = $$props;
  let { company = void 0 } = $$props;
  let { platformName = "" } = $$props;
  let { persistentHamburgerMenu = false } = $$props;
  let { expansionBreakpoint = 1056 } = $$props;
  let { ref = null } = $$props;
  let { iconMenu = Menu_default } = $$props;
  let { iconClose = Close_default } = $$props;
  let winWidth = void 0;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function onwindowresize() {
    $$invalidate(9, winWidth = window.innerWidth);
  }
  function hamburgermenu_isOpen_binding(value) {
    isSideNavOpen = value;
    $$invalidate(0, isSideNavOpen), $$invalidate(14, expandedByDefault), $$invalidate(9, winWidth), $$invalidate(6, expansionBreakpoint), $$invalidate(5, persistentHamburgerMenu);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("expandedByDefault" in $$new_props) $$invalidate(14, expandedByDefault = $$new_props.expandedByDefault);
    if ("isSideNavOpen" in $$new_props) $$invalidate(0, isSideNavOpen = $$new_props.isSideNavOpen);
    if ("uiShellAriaLabel" in $$new_props) $$invalidate(15, uiShellAriaLabel = $$new_props.uiShellAriaLabel);
    if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
    if ("company" in $$new_props) $$invalidate(3, company = $$new_props.company);
    if ("platformName" in $$new_props) $$invalidate(4, platformName = $$new_props.platformName);
    if ("persistentHamburgerMenu" in $$new_props) $$invalidate(5, persistentHamburgerMenu = $$new_props.persistentHamburgerMenu);
    if ("expansionBreakpoint" in $$new_props) $$invalidate(6, expansionBreakpoint = $$new_props.expansionBreakpoint);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("iconMenu" in $$new_props) $$invalidate(7, iconMenu = $$new_props.iconMenu);
    if ("iconClose" in $$new_props) $$invalidate(8, iconClose = $$new_props.iconClose);
    if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    expandedByDefault,
    isSideNavOpen,
    uiShellAriaLabel,
    href,
    company,
    platformName,
    persistentHamburgerMenu,
    expansionBreakpoint,
    ref,
    iconMenu,
    iconClose,
    Close: Close_default,
    Menu: Menu_default,
    shouldRenderHamburgerMenu,
    HamburgerMenu: HamburgerMenu_default,
    winWidth,
    ariaLabel,
    $shouldRenderHamburgerMenu
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("expandedByDefault" in $$props) $$invalidate(14, expandedByDefault = $$new_props.expandedByDefault);
    if ("isSideNavOpen" in $$props) $$invalidate(0, isSideNavOpen = $$new_props.isSideNavOpen);
    if ("uiShellAriaLabel" in $$props) $$invalidate(15, uiShellAriaLabel = $$new_props.uiShellAriaLabel);
    if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
    if ("company" in $$props) $$invalidate(3, company = $$new_props.company);
    if ("platformName" in $$props) $$invalidate(4, platformName = $$new_props.platformName);
    if ("persistentHamburgerMenu" in $$props) $$invalidate(5, persistentHamburgerMenu = $$new_props.persistentHamburgerMenu);
    if ("expansionBreakpoint" in $$props) $$invalidate(6, expansionBreakpoint = $$new_props.expansionBreakpoint);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("iconMenu" in $$props) $$invalidate(7, iconMenu = $$new_props.iconMenu);
    if ("iconClose" in $$props) $$invalidate(8, iconClose = $$new_props.iconClose);
    if ("winWidth" in $$props) $$invalidate(9, winWidth = $$new_props.winWidth);
    if ("ariaLabel" in $$props) $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*expandedByDefault, winWidth, expansionBreakpoint, persistentHamburgerMenu*/
    16992) {
      $: $$invalidate(0, isSideNavOpen = expandedByDefault && winWidth >= expansionBreakpoint && !persistentHamburgerMenu);
    }
    $: $$invalidate(10, ariaLabel = company ? `${company} ` : "" + (uiShellAriaLabel || $$props["aria-label"] || platformName));
  };
  $$props = exclude_internal_props($$props);
  return [
    isSideNavOpen,
    ref,
    href,
    company,
    platformName,
    persistentHamburgerMenu,
    expansionBreakpoint,
    iconMenu,
    iconClose,
    winWidth,
    ariaLabel,
    $shouldRenderHamburgerMenu,
    $$restProps,
    $$slots,
    expandedByDefault,
    uiShellAriaLabel,
    $$scope,
    slots,
    click_handler,
    onwindowresize,
    hamburgermenu_isOpen_binding,
    a_binding
  ];
}
var Header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance186, create_fragment186, safe_not_equal, {
      expandedByDefault: 14,
      isSideNavOpen: 0,
      uiShellAriaLabel: 15,
      href: 2,
      company: 3,
      platformName: 4,
      persistentHamburgerMenu: 5,
      expansionBreakpoint: 6,
      ref: 1,
      iconMenu: 7,
      iconClose: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Header",
      options,
      id: create_fragment186.name
    });
  }
  get expandedByDefault() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandedByDefault(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isSideNavOpen() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSideNavOpen(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get uiShellAriaLabel() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set uiShellAriaLabel(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get company() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set company(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get platformName() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set platformName(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persistentHamburgerMenu() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persistentHamburgerMenu(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expansionBreakpoint() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expansionBreakpoint(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconMenu() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconMenu(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconClose() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconClose(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Header_default = Header;

// node_modules/carbon-components-svelte/src/icons/Switcher.svelte
var file175 = "node_modules/carbon-components-svelte/src/icons/Switcher.svelte";
function create_if_block108(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file175, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block108.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment187(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block108(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block) if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 4H18V8H14zM4 4H8V8H4zM24 4H28V8H24zM14 14H18V18H14zM4 14H8V18H4zM24 14H28V18H24zM14 24H18V28H14zM4 24H8V28H4zM24 24H28V28H24z");
      add_location(path, file175, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file175, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block108(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment187.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance187($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Switcher", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props) $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props) $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $: $$invalidate(2, attributes = {
      "aria-hidden": labelled ? void 0 : true,
      role: labelled ? "img" : void 0,
      focusable: Number($$props["tabindex"]) === 0 ? true : void 0
    });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Switcher = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance187, create_fragment187, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Switcher",
      options,
      id: create_fragment187.name
    });
  }
  get size() {
    throw new Error("<Switcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Switcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Switcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Switcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Switcher_default = Switcher;

// node_modules/carbon-components-svelte/src/UIShell/HeaderAction.svelte
var file176 = "node_modules/carbon-components-svelte/src/UIShell/HeaderAction.svelte";
function add_css(target) {
  append_styles(target, "svelte-cney1p", ".bx--header__action--text{display:inline-flex;align-items:center;width:auto;padding:0 1rem 2px 1rem;font-size:0.875rem;line-height:1.28572;letter-spacing:0.16px;color:#f4f4f4}.bx--header__action-text{margin-left:0.75rem}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyQWN0aW9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE2R0UsMEJBQ0UsbUJBQW9CLENBQ3BCLGtCQUFtQixDQUNuQixVQUFXLENBR1gsdUJBQXdCLENBR3hCLGtCQUFtQixDQUNuQixtQkFBb0IsQ0FDcEIscUJBQXNCLENBR3RCLGFBQ0YsQ0FFQSx5QkFDRSxtQkFDRiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiSGVhZGVyQWN0aW9uLnN2ZWx0ZSJdfQ== */");
}
var get_text_slot_changes = (dirty) => ({});
var get_text_slot_context = (ctx) => ({});
var get_icon_slot_changes6 = (dirty) => ({});
var get_icon_slot_context6 = (ctx) => ({});
var get_closeIcon_slot_changes = (dirty) => ({});
var get_closeIcon_slot_context = (ctx) => ({});
function create_else_block34(ctx) {
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[11].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_icon_slot_context6
  );
  const icon_slot_or_fallback = icon_slot || fallback_block_28(ctx);
  const block = {
    c: function create() {
      if (icon_slot_or_fallback) icon_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (icon_slot_or_fallback) icon_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_icon_slot_changes6
            ),
            get_icon_slot_context6
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*icon*/
        4)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block34.name,
    type: "else",
    source: "(85:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_228(ctx) {
  let current;
  const closeIcon_slot_template = (
    /*#slots*/
    ctx[11].closeIcon
  );
  const closeIcon_slot = create_slot(
    closeIcon_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_closeIcon_slot_context
  );
  const closeIcon_slot_or_fallback = closeIcon_slot || fallback_block_120(ctx);
  const block = {
    c: function create() {
      if (closeIcon_slot_or_fallback) closeIcon_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (closeIcon_slot_or_fallback) closeIcon_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (closeIcon_slot_or_fallback) {
        closeIcon_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (closeIcon_slot) {
        if (closeIcon_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            closeIcon_slot,
            closeIcon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              closeIcon_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_closeIcon_slot_changes
            ),
            get_closeIcon_slot_context
          );
        }
      } else {
        if (closeIcon_slot_or_fallback && closeIcon_slot_or_fallback.p && (!current || dirty & /*closeIcon*/
        8)) {
          closeIcon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(closeIcon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(closeIcon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (closeIcon_slot_or_fallback) closeIcon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_228.name,
    type: "if",
    source: "(81:2) {#if isOpen}",
    ctx
  });
  return block;
}
function fallback_block_28(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[2]
  );
  function switch_props(ctx2, dirty) {
    return { props: { size: 20 }, $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*icon*/
      4 && switch_value !== (switch_value = /*icon*/
      ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_28.name,
    type: "fallback",
    source: "(86:22)        ",
    ctx
  });
  return block;
}
function fallback_block_120(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*closeIcon*/
    ctx[3]
  );
  function switch_props(ctx2, dirty) {
    return { props: { size: 20 }, $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*closeIcon*/
      8 && switch_value !== (switch_value = /*closeIcon*/
      ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_120.name,
    type: "fallback",
    source: "(82:27)        ",
    ctx
  });
  return block;
}
function create_if_block_146(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*text*/
        ctx[4]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*text*/
        ctx[4]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--header__action-text", true);
      add_location(span, file176, 90, 14, 2238);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text*/
      16) set_data_dev(
        t,
        /*text*/
        ctx2[4]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_146.name,
    type: "if",
    source: "(91:4) {#if text}",
    ctx
  });
  return block;
}
function fallback_block45(ctx) {
  let if_block_anchor;
  let if_block = (
    /*text*/
    ctx[4] && create_if_block_146(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*text*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_146(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block45.name,
    type: "fallback",
    source: "(90:20)      ",
    ctx
  });
  return block;
}
function create_if_block109(ctx) {
  let div;
  let div_transition;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--header-panel", true);
      toggle_class(div, "bx--header-panel--expanded", true);
      set_style(div, "overflow-y", `auto`);
      add_location(div, file176, 94, 2, 2337);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[16](div);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            slide,
            {
              .../*transition*/
              ctx[5],
              duration: (
                /*transition*/
                ctx[5] === false ? 0 : (
                  /*transition*/
                  ctx[5].duration
                )
              )
            },
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          slide,
          {
            .../*transition*/
            ctx[5],
            duration: (
              /*transition*/
              ctx[5] === false ? 0 : (
                /*transition*/
                ctx[5].duration
              )
            )
          },
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[16](null);
      if (detaching && div_transition) div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block109.name,
    type: "if",
    source: "(94:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_fragment188(ctx) {
  let button;
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_228, create_else_block34];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isOpen*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const text_slot_template = (
    /*#slots*/
    ctx[11].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_text_slot_context
  );
  const text_slot_or_fallback = text_slot || fallback_block45(ctx);
  let button_levels = [
    { type: "button" },
    /*$$restProps*/
    ctx[9]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  let if_block1 = (
    /*isOpen*/
    ctx[0] && create_if_block109(ctx)
  );
  const block = {
    c: function create() {
      button = element("button");
      if_block0.c();
      t0 = space();
      if (text_slot_or_fallback) text_slot_or_fallback.c();
      t1 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if_block0.l(button_nodes);
      t0 = claim_space(button_nodes);
      if (text_slot_or_fallback) text_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      if_block1_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      toggle_class(button, "bx--header__action", true);
      toggle_class(
        button,
        "bx--header__action--active",
        /*isOpen*/
        ctx[0]
      );
      toggle_class(
        button,
        "bx--header__action--text",
        /*text*/
        ctx[4]
      );
      add_location(button, file176, 67, 0, 1678);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      append_hydration_dev(button, t0);
      if (text_slot_or_fallback) {
        text_slot_or_fallback.m(button, null);
      }
      if (button.autofocus) button.focus();
      ctx[14](button);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "click",
            /*click_handler_1*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(button, "click", stop_propagation(
            /*click_handler_2*/
            ctx[15]
          ), false, false, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(button, t0);
      }
      if (text_slot) {
        if (text_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_text_slot_changes
            ),
            get_text_slot_context
          );
        }
      } else {
        if (text_slot_or_fallback && text_slot_or_fallback.p && (!current || dirty & /*text*/
        16)) {
          text_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [{ type: "button" }, dirty & /*$$restProps*/
      512 && /*$$restProps*/
      ctx2[9]]));
      toggle_class(button, "bx--header__action", true);
      toggle_class(
        button,
        "bx--header__action--active",
        /*isOpen*/
        ctx2[0]
      );
      toggle_class(
        button,
        "bx--header__action--text",
        /*text*/
        ctx2[4]
      );
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block109(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(text_slot_or_fallback, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(text_slot_or_fallback, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
        detach_dev(t1);
        detach_dev(if_block1_anchor);
      }
      if_blocks[current_block_type_index].d();
      if (text_slot_or_fallback) text_slot_or_fallback.d(detaching);
      ctx[14](null);
      if (if_block1) if_block1.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment188.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance188($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "isOpen",
    "icon",
    "closeIcon",
    "text",
    "ref",
    "transition",
    "preventCloseOnClickOutside"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderAction", slots, ["closeIcon", "icon", "text", "default"]);
  let { isOpen = false } = $$props;
  let { icon = Switcher_default } = $$props;
  let { closeIcon = Close_default } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { ref = null } = $$props;
  let { transition = { duration: 200 } } = $$props;
  let { preventCloseOnClickOutside = false } = $$props;
  const dispatch = createEventDispatcher();
  let refPanel = null;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = ({ target }) => {
    if (isOpen && !ref.contains(target) && !refPanel.contains(target) && !preventCloseOnClickOutside) {
      $$invalidate(0, isOpen = false);
      dispatch("close");
    }
  };
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const click_handler_2 = () => {
    $$invalidate(0, isOpen = !isOpen);
    dispatch(isOpen ? "open" : "close");
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refPanel = $$value;
      $$invalidate(7, refPanel);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isOpen" in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("icon" in $$new_props) $$invalidate(2, icon = $$new_props.icon);
    if ("closeIcon" in $$new_props) $$invalidate(3, closeIcon = $$new_props.closeIcon);
    if ("text" in $$new_props) $$invalidate(4, text2 = $$new_props.text);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("transition" in $$new_props) $$invalidate(5, transition = $$new_props.transition);
    if ("preventCloseOnClickOutside" in $$new_props) $$invalidate(6, preventCloseOnClickOutside = $$new_props.preventCloseOnClickOutside);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    isOpen,
    icon,
    closeIcon,
    text: text2,
    ref,
    transition,
    preventCloseOnClickOutside,
    createEventDispatcher,
    slide,
    Close: Close_default,
    Switcher: Switcher_default,
    dispatch,
    refPanel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("isOpen" in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("icon" in $$props) $$invalidate(2, icon = $$new_props.icon);
    if ("closeIcon" in $$props) $$invalidate(3, closeIcon = $$new_props.closeIcon);
    if ("text" in $$props) $$invalidate(4, text2 = $$new_props.text);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("transition" in $$props) $$invalidate(5, transition = $$new_props.transition);
    if ("preventCloseOnClickOutside" in $$props) $$invalidate(6, preventCloseOnClickOutside = $$new_props.preventCloseOnClickOutside);
    if ("refPanel" in $$props) $$invalidate(7, refPanel = $$new_props.refPanel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    isOpen,
    ref,
    icon,
    closeIcon,
    text2,
    transition,
    preventCloseOnClickOutside,
    refPanel,
    dispatch,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    click_handler_13,
    button_binding,
    click_handler_2,
    div_binding
  ];
}
var HeaderAction = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance188,
      create_fragment188,
      safe_not_equal,
      {
        isOpen: 0,
        icon: 2,
        closeIcon: 3,
        text: 4,
        ref: 1,
        transition: 5,
        preventCloseOnClickOutside: 6
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderAction",
      options,
      id: create_fragment188.name
    });
  }
  get isOpen() {
    throw new Error("<HeaderAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<HeaderAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<HeaderAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<HeaderAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeIcon() {
    throw new Error("<HeaderAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeIcon(value) {
    throw new Error("<HeaderAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<HeaderAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<HeaderAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeaderAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeaderAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<HeaderAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<HeaderAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventCloseOnClickOutside() {
    throw new Error("<HeaderAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventCloseOnClickOutside(value) {
    throw new Error("<HeaderAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeaderAction_default = HeaderAction;

// node_modules/carbon-components-svelte/src/UIShell/HeaderActionLink.svelte
var file177 = "node_modules/carbon-components-svelte/src/UIShell/HeaderActionLink.svelte";
function add_css2(target) {
  append_styles(target, "svelte-yhhuz2", ".bx--header__action{display:flex;align-items:center;justify-content:center;padding-bottom:2px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyQWN0aW9uTGluay5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBbUNFLG9CQUNFLFlBQWEsQ0FDYixrQkFBbUIsQ0FDbkIsc0JBQXVCLENBRXZCLGtCQUNGIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJIZWFkZXJBY3Rpb25MaW5rLnN2ZWx0ZSJdfQ== */");
}
var get_icon_slot_changes7 = (dirty) => ({});
var get_icon_slot_context7 = (ctx) => ({});
function fallback_block46(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[3]
  );
  function switch_props(ctx2, dirty) {
    return { props: { size: 20 }, $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*icon*/
      8 && switch_value !== (switch_value = /*icon*/
      ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block46.name,
    type: "fallback",
    source: "(30:20)      ",
    ctx
  });
  return block;
}
function create_fragment189(ctx) {
  let a;
  let a_rel_value;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = (
    /*#slots*/
    ctx[6].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_icon_slot_context7
  );
  const icon_slot_or_fallback = icon_slot || fallback_block46(ctx);
  let a_levels = [
    { href: (
      /*href*/
      ctx[2]
    ) },
    {
      rel: a_rel_value = /*$$restProps*/
      ctx[4].target === "_blank" ? "noopener noreferrer" : void 0
    },
    /*$$restProps*/
    ctx[4]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (icon_slot_or_fallback) icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, rel: true });
      var a_nodes = children(a);
      if (icon_slot_or_fallback) icon_slot_or_fallback.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      toggle_class(a, "bx--header__action", true);
      toggle_class(
        a,
        "bx--header__action--active",
        /*linkIsActive*/
        ctx[1]
      );
      add_location(a, file177, 20, 0, 415);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(a, null);
      }
      ctx[8](a);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler*/
          ctx[7],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_icon_slot_changes7
            ),
            get_icon_slot_context7
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*icon*/
        8)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        4) && { href: (
          /*href*/
          ctx2[2]
        ) },
        (!current || dirty & /*$$restProps*/
        16 && a_rel_value !== (a_rel_value = /*$$restProps*/
        ctx2[4].target === "_blank" ? "noopener noreferrer" : void 0)) && { rel: a_rel_value },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
      toggle_class(a, "bx--header__action", true);
      toggle_class(
        a,
        "bx--header__action--active",
        /*linkIsActive*/
        ctx2[1]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
      ctx[8](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment189.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance189($$self, $$props, $$invalidate) {
  const omit_props_names = ["linkIsActive", "href", "icon", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderActionLink", slots, ["icon"]);
  let { linkIsActive = false } = $$props;
  let { href = void 0 } = $$props;
  let { icon = void 0 } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("linkIsActive" in $$new_props) $$invalidate(1, linkIsActive = $$new_props.linkIsActive);
    if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
    if ("icon" in $$new_props) $$invalidate(3, icon = $$new_props.icon);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ linkIsActive, href, icon, ref });
  $$self.$inject_state = ($$new_props) => {
    if ("linkIsActive" in $$props) $$invalidate(1, linkIsActive = $$new_props.linkIsActive);
    if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
    if ("icon" in $$props) $$invalidate(3, icon = $$new_props.icon);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    linkIsActive,
    href,
    icon,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    a_binding
  ];
}
var HeaderActionLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance189,
      create_fragment189,
      safe_not_equal,
      {
        linkIsActive: 1,
        href: 2,
        icon: 3,
        ref: 0
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderActionLink",
      options,
      id: create_fragment189.name
    });
  }
  get linkIsActive() {
    throw new Error("<HeaderActionLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set linkIsActive(value) {
    throw new Error("<HeaderActionLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<HeaderActionLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<HeaderActionLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<HeaderActionLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<HeaderActionLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeaderActionLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeaderActionLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeaderActionLink_default = HeaderActionLink;

// node_modules/carbon-components-svelte/src/UIShell/HeaderNav.svelte
var file178 = "node_modules/carbon-components-svelte/src/UIShell/HeaderNav.svelte";
function create_fragment190(ctx) {
  let nav;
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let ul_levels = [
    /*props*/
    ctx[0],
    { role: "menubar" }
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  let nav_levels = [
    /*props*/
    ctx[0],
    /*$$restProps*/
    ctx[1]
  ];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      ul = element("ul");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", {});
      var nav_nodes = children(nav);
      ul = claim_element(nav_nodes, "UL", { role: true });
      var ul_nodes = children(ul);
      if (default_slot) default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--header__menu-bar", true);
      add_location(ul, file178, 9, 2, 275);
      set_attributes(nav, nav_data);
      toggle_class(nav, "bx--header__nav", true);
      add_location(nav, file178, 7, 0, 132);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      append_hydration_dev(nav, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & /*props*/
      1 && /*props*/
      ctx2[0], { role: "menubar" }]));
      toggle_class(ul, "bx--header__menu-bar", true);
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        dirty & /*props*/
        1 && /*props*/
        ctx2[0],
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
      toggle_class(nav, "bx--header__nav", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(nav);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment190.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance190($$self, $$props, $$invalidate) {
  let props;
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderNav", slots, ["default"]);
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ props });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("props" in $$props) $$invalidate(0, props = $$new_props.props);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(0, props = {
      "aria-label": $$props["aria-label"],
      "aria-labelledby": $$props["aria-labelledby"]
    });
  };
  $$props = exclude_internal_props($$props);
  return [props, $$restProps, $$scope, slots];
}
var HeaderNav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance190, create_fragment190, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderNav",
      options,
      id: create_fragment190.name
    });
  }
};
var HeaderNav_default = HeaderNav;

// node_modules/carbon-components-svelte/src/UIShell/HeaderNavItem.svelte
var file179 = "node_modules/carbon-components-svelte/src/UIShell/HeaderNavItem.svelte";
function fallback_block47(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*text*/
        ctx[2]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*text*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text*/
      4) set_data_dev(
        t,
        /*text*/
        ctx2[2]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block47.name,
    type: "fallback",
    source: "(64:54) {text}",
    ctx
  });
  return block;
}
function create_fragment191(ctx) {
  let li;
  let a;
  let span;
  let a_rel_value;
  let a_aria_current_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block47(ctx);
  let a_levels = [
    { role: "menuitem" },
    { tabindex: "0" },
    { href: (
      /*href*/
      ctx[1]
    ) },
    {
      rel: a_rel_value = /*$$restProps*/
      ctx[7].target === "_blank" ? "noopener noreferrer" : void 0
    },
    {
      "aria-current": a_aria_current_value = /*isSelected*/
      ctx[3] ? "page" : void 0
    },
    /*$$restProps*/
    ctx[7]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      span = element("span");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { role: true });
      var li_nodes = children(li);
      a = claim_element(li_nodes, "A", {
        role: true,
        tabindex: true,
        href: true,
        rel: true,
        "aria-current": true
      });
      var a_nodes = children(a);
      span = claim_element(a_nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot_or_fallback) default_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--text-truncate--end", true);
      add_location(span, file179, 63, 4, 1382);
      set_attributes(a, a_data);
      toggle_class(a, "bx--header__menu-item", true);
      add_location(a, file179, 40, 2, 844);
      attr_dev(li, "role", "none");
      add_location(li, file179, 39, 0, 825);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, a);
      append_hydration_dev(a, span);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      ctx[18](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseover",
            /*mouseover_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keyup",
            /*keyup_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keydown",
            /*keydown_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "focus",
            /*focus_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "blur",
            /*blur_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "blur",
            /*blur_handler_1*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*text*/
        4)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        { role: "menuitem" },
        { tabindex: "0" },
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        (!current || dirty & /*$$restProps*/
        128 && a_rel_value !== (a_rel_value = /*$$restProps*/
        ctx2[7].target === "_blank" ? "noopener noreferrer" : void 0)) && { rel: a_rel_value },
        (!current || dirty & /*isSelected*/
        8 && a_aria_current_value !== (a_aria_current_value = /*isSelected*/
        ctx2[3] ? "page" : void 0)) && { "aria-current": a_aria_current_value },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      toggle_class(a, "bx--header__menu-item", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      ctx[18](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment191.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance191($$self, $$props, $$invalidate) {
  const omit_props_names = ["href", "text", "isSelected", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderNavItem", slots, ["default"]);
  let { href = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { isSelected = false } = $$props;
  let { ref = null } = $$props;
  const id = "ccs-" + Math.random().toString(36);
  const ctx = getContext("HeaderNavMenu");
  let selectedItemIds = [];
  const unsubSelectedItems = ctx == null ? void 0 : ctx.selectedItems.subscribe((_selectedItems) => {
    $$invalidate(4, selectedItemIds = Object.keys(_selectedItems));
  });
  onMount(() => {
    return () => {
      if (unsubSelectedItems) unsubSelectedItems();
    };
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const blur_handler_1 = () => {
    if (selectedItemIds.indexOf(id) === selectedItemIds.length - 1) {
      ctx == null ? void 0 : ctx.closeMenu();
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props) $$invalidate(1, href = $$new_props.href);
    if ("text" in $$new_props) $$invalidate(2, text2 = $$new_props.text);
    if ("isSelected" in $$new_props) $$invalidate(3, isSelected = $$new_props.isSelected);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    href,
    text: text2,
    isSelected,
    ref,
    getContext,
    onMount,
    id,
    ctx,
    selectedItemIds,
    unsubSelectedItems
  });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props) $$invalidate(1, href = $$new_props.href);
    if ("text" in $$props) $$invalidate(2, text2 = $$new_props.text);
    if ("isSelected" in $$props) $$invalidate(3, isSelected = $$new_props.isSelected);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    if ("selectedItemIds" in $$props) $$invalidate(4, selectedItemIds = $$new_props.selectedItemIds);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isSelected*/
    8) {
      $: ctx == null ? void 0 : ctx.updateSelectedItems({ id, isSelected });
    }
  };
  return [
    ref,
    href,
    text2,
    isSelected,
    selectedItemIds,
    id,
    ctx,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keyup_handler,
    keydown_handler,
    focus_handler,
    blur_handler,
    a_binding,
    blur_handler_1
  ];
}
var HeaderNavItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance191, create_fragment191, safe_not_equal, { href: 1, text: 2, isSelected: 3, ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderNavItem",
      options,
      id: create_fragment191.name
    });
  }
  get href() {
    throw new Error("<HeaderNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<HeaderNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<HeaderNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<HeaderNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isSelected() {
    throw new Error("<HeaderNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSelected(value) {
    throw new Error("<HeaderNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeaderNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeaderNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeaderNavItem_default = HeaderNavItem;

// node_modules/carbon-components-svelte/src/UIShell/HeaderNavMenu.svelte
var file180 = "node_modules/carbon-components-svelte/src/UIShell/HeaderNavMenu.svelte";
function create_fragment192(ctx) {
  let li;
  let a;
  let t0;
  let t1;
  let chevrondown;
  let t2;
  let ul;
  let current;
  let mounted;
  let dispose;
  chevrondown = new ChevronDown_default({
    props: { class: "bx--header__menu-arrow" },
    $$inline: true
  });
  let a_levels = [
    { role: "menuitem" },
    { tabindex: "0" },
    { "aria-haspopup": "menu" },
    { "aria-expanded": (
      /*expanded*/
      ctx[0]
    ) },
    { "aria-label": (
      /*text*/
      ctx[3]
    ) },
    { href: (
      /*href*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      t0 = text(
        /*text*/
        ctx[3]
      );
      t1 = space();
      create_component(chevrondown.$$.fragment);
      t2 = space();
      ul = element("ul");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { role: true });
      var li_nodes = children(li);
      a = claim_element(li_nodes, "A", {
        role: true,
        tabindex: true,
        "aria-haspopup": true,
        "aria-expanded": true,
        "aria-label": true,
        href: true
      });
      var a_nodes = children(a);
      t0 = claim_text(
        a_nodes,
        /*text*/
        ctx[3]
      );
      t1 = claim_space(a_nodes);
      claim_component(chevrondown.$$.fragment, a_nodes);
      a_nodes.forEach(detach_dev);
      t2 = claim_space(li_nodes);
      ul = claim_element(li_nodes, "UL", { role: true, "aria-label": true });
      var ul_nodes = children(ul);
      if (default_slot) default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      toggle_class(a, "bx--header__menu-item", true);
      toggle_class(a, "bx--header__menu-title", true);
      set_style(a, "z-index", 1);
      add_location(a, file180, 66, 2, 1358);
      attr_dev(ul, "role", "menu");
      attr_dev(
        ul,
        "aria-label",
        /*text*/
        ctx[3]
      );
      toggle_class(ul, "bx--header__menu", true);
      add_location(ul, file180, 97, 2, 2096);
      attr_dev(li, "role", "none");
      toggle_class(li, "bx--header__submenu", true);
      toggle_class(
        li,
        "bx--header__submenu--current",
        /*isCurrentSubmenu*/
        ctx[5]
      );
      add_location(li, file180, 49, 0, 996);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, a);
      append_hydration_dev(a, t0);
      append_hydration_dev(a, t1);
      mount_component(chevrondown, a, null);
      ctx[20](a);
      append_hydration_dev(li, t2);
      append_hydration_dev(li, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[22](ul);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "click",
            /*click_handler_1*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keydown",
            /*keydown_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keydown",
            /*keydown_handler_1*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(a, "click", prevent_default(
            /*click_handler*/
            ctx[12]
          ), false, true, false, false),
          listen_dev(
            a,
            "mouseover",
            /*mouseover_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keyup",
            /*keyup_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "focus",
            /*focus_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "blur",
            /*blur_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "click",
            /*click_handler_2*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keydown",
            /*keydown_handler_2*/
            ctx[24],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*text*/
      8) set_data_maybe_contenteditable_dev(
        t0,
        /*text*/
        ctx2[3],
        a_data["contenteditable"]
      );
      set_attributes(a, a_data = get_spread_update(a_levels, [
        { role: "menuitem" },
        { tabindex: "0" },
        { "aria-haspopup": "menu" },
        (!current || dirty & /*expanded*/
        1) && { "aria-expanded": (
          /*expanded*/
          ctx2[0]
        ) },
        (!current || dirty & /*text*/
        8) && { "aria-label": (
          /*text*/
          ctx2[3]
        ) },
        (!current || dirty & /*href*/
        4) && { href: (
          /*href*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      toggle_class(a, "bx--header__menu-item", true);
      toggle_class(a, "bx--header__menu-title", true);
      set_style(a, "z-index", 1);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*text*/
      8) {
        attr_dev(
          ul,
          "aria-label",
          /*text*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*isCurrentSubmenu*/
      32) {
        toggle_class(
          li,
          "bx--header__submenu--current",
          /*isCurrentSubmenu*/
          ctx2[5]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(chevrondown.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevrondown.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      destroy_component(chevrondown);
      ctx[20](null);
      if (default_slot) default_slot.d(detaching);
      ctx[22](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment192.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance192($$self, $$props, $$invalidate) {
  let isCurrentSubmenu;
  const omit_props_names = ["expanded", "href", "text", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedItems;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderNavMenu", slots, ["default"]);
  let { expanded = false } = $$props;
  let { href = "/" } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { ref = null } = $$props;
  const selectedItems = writable({});
  validate_store(selectedItems, "selectedItems");
  component_subscribe($$self, selectedItems, (value) => $$invalidate(8, $selectedItems = value));
  let menuRef = null;
  setContext("HeaderNavMenu", {
    selectedItems,
    updateSelectedItems(item) {
      selectedItems.update((_items) => ({ ..._items, [item.id]: item.isSelected }));
    },
    closeMenu() {
      $$invalidate(0, expanded = false);
    }
  });
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = ({ target }) => {
    if (!ref.contains(target)) {
      $$invalidate(0, expanded = false);
    }
  };
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const keydown_handler_12 = (e) => {
    if (e.key === " ") e.preventDefault();
    if (e.key === "Enter" || e.key === " ") {
      $$invalidate(0, expanded = !expanded);
    }
  };
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menuRef = $$value;
      $$invalidate(4, menuRef);
    });
  }
  const click_handler_2 = (e) => {
    if (!menuRef.contains(e.target)) {
      e.preventDefault();
    }
    $$invalidate(0, expanded = !expanded);
  };
  const keydown_handler_2 = (e) => {
    if (e.key === "Enter") {
      e.stopPropagation();
      $$invalidate(0, expanded = !expanded);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("expanded" in $$new_props) $$invalidate(0, expanded = $$new_props.expanded);
    if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
    if ("text" in $$new_props) $$invalidate(3, text2 = $$new_props.text);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    expanded,
    href,
    text: text2,
    ref,
    setContext,
    writable,
    ChevronDown: ChevronDown_default,
    selectedItems,
    menuRef,
    isCurrentSubmenu,
    $selectedItems
  });
  $$self.$inject_state = ($$new_props) => {
    if ("expanded" in $$props) $$invalidate(0, expanded = $$new_props.expanded);
    if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
    if ("text" in $$props) $$invalidate(3, text2 = $$new_props.text);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("menuRef" in $$props) $$invalidate(4, menuRef = $$new_props.menuRef);
    if ("isCurrentSubmenu" in $$props) $$invalidate(5, isCurrentSubmenu = $$new_props.isCurrentSubmenu);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selectedItems*/
    256) {
      $: $$invalidate(5, isCurrentSubmenu = Object.values($selectedItems).filter(Boolean).length > 0);
    }
  };
  return [
    expanded,
    ref,
    href,
    text2,
    menuRef,
    isCurrentSubmenu,
    selectedItems,
    $$restProps,
    $selectedItems,
    $$scope,
    slots,
    keydown_handler,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    click_handler_13,
    a_binding,
    keydown_handler_12,
    ul_binding,
    click_handler_2,
    keydown_handler_2
  ];
}
var HeaderNavMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance192, create_fragment192, safe_not_equal, { expanded: 0, href: 2, text: 3, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderNavMenu",
      options,
      id: create_fragment192.name
    });
  }
  get expanded() {
    throw new Error("<HeaderNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<HeaderNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<HeaderNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<HeaderNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<HeaderNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<HeaderNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeaderNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeaderNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeaderNavMenu_default = HeaderNavMenu;

// node_modules/carbon-components-svelte/src/UIShell/HeaderPanelDivider.svelte
var file181 = "node_modules/carbon-components-svelte/src/UIShell/HeaderPanelDivider.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1iihje3", ".bx--header-panel-divider{margin:2rem 1rem 0;font-size:0.75rem;line-height:1.3;letter-spacing:0.02rem;color:#c6c6c6}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyUGFuZWxEaXZpZGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFjRSwwQkFDRSxrQkFBbUIsQ0FDbkIsaUJBQWtCLENBQ2xCLGVBQWdCLENBQ2hCLHNCQUF1QixDQUN2QixhQUNGIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJIZWFkZXJQYW5lbERpdmlkZXIuc3ZlbHRlIl19 */");
}
function create_if_block110(ctx) {
  let li;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      if (default_slot) default_slot.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(li, "bx--header-panel-divider", true);
      add_location(li, file181, 1, 2, 24);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block110.name,
    type: "if",
    source: "(1:0) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment193(ctx) {
  let t;
  let hr;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[0].default && create_if_block110(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      t = space();
      hr = element("hr");
      this.h();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      t = claim_space(nodes);
      hr = claim_element(nodes, "HR", {});
      this.h();
    },
    h: function hydrate() {
      toggle_class(hr, "bx--switcher__item--divider", true);
      add_location(hr, file181, 5, 0, 96);
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, hr, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[0].default
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block110(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(hr);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment193.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance193($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderPanelDivider", slots, ["default"]);
  const $$slots = compute_slots(slots);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<HeaderPanelDivider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [$$slots, $$scope, slots];
}
var HeaderPanelDivider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance193, create_fragment193, safe_not_equal, {}, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderPanelDivider",
      options,
      id: create_fragment193.name
    });
  }
};
var HeaderPanelDivider_default = HeaderPanelDivider;

// node_modules/carbon-components-svelte/src/UIShell/HeaderPanelLink.svelte
var file182 = "node_modules/carbon-components-svelte/src/UIShell/HeaderPanelLink.svelte";
function create_fragment194(ctx) {
  let li;
  let a;
  let a_rel_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[1]
    ) },
    {
      rel: a_rel_value = /*$$restProps*/
      ctx[2].target === "_blank" ? "noopener noreferrer" : void 0
    },
    /*$$restProps*/
    ctx[2]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      a = claim_element(li_nodes, "A", { href: true, rel: true });
      var a_nodes = children(a);
      if (default_slot) default_slot.l(a_nodes);
      a_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      toggle_class(a, "bx--switcher__item-link", true);
      add_location(a, file182, 12, 2, 239);
      toggle_class(li, "bx--switcher__item", true);
      add_location(li, file182, 11, 0, 198);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, a);
      if (default_slot) {
        default_slot.m(a, null);
      }
      ctx[6](a);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        (!current || dirty & /*$$restProps*/
        4 && a_rel_value !== (a_rel_value = /*$$restProps*/
        ctx2[2].target === "_blank" ? "noopener noreferrer" : void 0)) && { rel: a_rel_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      toggle_class(a, "bx--switcher__item-link", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment194.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance194($$self, $$props, $$invalidate) {
  const omit_props_names = ["href", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderPanelLink", slots, ["default"]);
  let { href = void 0 } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props) $$invalidate(1, href = $$new_props.href);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ href, ref });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props) $$invalidate(1, href = $$new_props.href);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ref, href, $$restProps, $$scope, slots, click_handler, a_binding];
}
var HeaderPanelLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance194, create_fragment194, safe_not_equal, { href: 1, ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderPanelLink",
      options,
      id: create_fragment194.name
    });
  }
  get href() {
    throw new Error("<HeaderPanelLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<HeaderPanelLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeaderPanelLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeaderPanelLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeaderPanelLink_default = HeaderPanelLink;

// node_modules/carbon-components-svelte/src/UIShell/HeaderPanelLinks.svelte
var file183 = "node_modules/carbon-components-svelte/src/UIShell/HeaderPanelLinks.svelte";
function create_fragment195(ctx) {
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {});
      var ul_nodes = children(ul);
      if (default_slot) default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(ul, "bx--switcher__item", true);
      add_location(ul, file183, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment195.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance195($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderPanelLinks", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<HeaderPanelLinks> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var HeaderPanelLinks = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance195, create_fragment195, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderPanelLinks",
      options,
      id: create_fragment195.name
    });
  }
};
var HeaderPanelLinks_default = HeaderPanelLinks;

// node_modules/carbon-components-svelte/src/UIShell/HeaderUtilities.svelte
var file184 = "node_modules/carbon-components-svelte/src/UIShell/HeaderUtilities.svelte";
function create_fragment196(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--header__global", true);
      add_location(div, file184, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment196.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance196($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderUtilities", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<HeaderUtilities> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var HeaderUtilities = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance196, create_fragment196, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderUtilities",
      options,
      id: create_fragment196.name
    });
  }
};
var HeaderUtilities_default = HeaderUtilities;

// node_modules/carbon-components-svelte/src/UIShell/SideNav.svelte
var file185 = "node_modules/carbon-components-svelte/src/UIShell/SideNav.svelte";
function create_if_block111(ctx) {
  let div;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--side-nav__overlay", true);
      toggle_class(
        div,
        "bx--side-nav__overlay-active",
        /*isOpen*/
        ctx[0]
      );
      set_style(
        div,
        "z-index",
        /*isOpen*/
        ctx[0] ? 6e3 : void 0
      );
      add_location(div, file185, 59, 2, 1437);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler*/
          ctx[11],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*isOpen*/
      1) {
        toggle_class(
          div,
          "bx--side-nav__overlay-active",
          /*isOpen*/
          ctx2[0]
        );
      }
      if (dirty & /*isOpen*/
      1) {
        set_style(
          div,
          "z-index",
          /*isOpen*/
          ctx2[0] ? 6e3 : void 0
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block111.name,
    type: "if",
    source: "(57:0) {#if !fixed}",
    ctx
  });
  return block;
}
function create_fragment197(ctx) {
  let t;
  let nav;
  let nav_aria_hidden_value;
  let current;
  let mounted;
  let dispose;
  add_render_callback(
    /*onwindowresize*/
    ctx[10]
  );
  let if_block = !/*fixed*/
  ctx[1] && create_if_block111(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let nav_levels = [
    {
      "aria-hidden": nav_aria_hidden_value = !/*isOpen*/
      ctx[0]
    },
    { "aria-label": (
      /*ariaLabel*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      t = space();
      nav = element("nav");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      t = claim_space(nodes);
      nav = claim_element(nodes, "NAV", { "aria-hidden": true, "aria-label": true });
      var nav_nodes = children(nav);
      if (default_slot) default_slot.l(nav_nodes);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(nav, nav_data);
      toggle_class(nav, "bx--side-nav__navigation", true);
      toggle_class(nav, "bx--side-nav", true);
      toggle_class(nav, "bx--side-nav--ux", true);
      toggle_class(
        nav,
        "bx--side-nav--expanded",
        /*rail*/
        ctx[2] && /*winWidth*/
        ctx[5] >= /*expansionBreakpoint*/
        ctx[4] ? false : (
          /*isOpen*/
          ctx[0]
        )
      );
      toggle_class(nav, "bx--side-nav--collapsed", !/*isOpen*/
      ctx[0] && !/*rail*/
      ctx[2]);
      toggle_class(
        nav,
        "bx--side-nav--rail",
        /*rail*/
        ctx[2]
      );
      add_location(nav, file185, 69, 0, 1683);
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, nav, anchor);
      if (default_slot) {
        default_slot.m(nav, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "resize",
          /*onwindowresize*/
          ctx[10]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!/*fixed*/
      ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block111(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        (!current || dirty & /*isOpen*/
        1 && nav_aria_hidden_value !== (nav_aria_hidden_value = !/*isOpen*/
        ctx2[0])) && { "aria-hidden": nav_aria_hidden_value },
        (!current || dirty & /*ariaLabel*/
        8) && { "aria-label": (
          /*ariaLabel*/
          ctx2[3]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      toggle_class(nav, "bx--side-nav__navigation", true);
      toggle_class(nav, "bx--side-nav", true);
      toggle_class(nav, "bx--side-nav--ux", true);
      toggle_class(
        nav,
        "bx--side-nav--expanded",
        /*rail*/
        ctx2[2] && /*winWidth*/
        ctx2[5] >= /*expansionBreakpoint*/
        ctx2[4] ? false : (
          /*isOpen*/
          ctx2[0]
        )
      );
      toggle_class(nav, "bx--side-nav--collapsed", !/*isOpen*/
      ctx2[0] && !/*rail*/
      ctx2[2]);
      toggle_class(
        nav,
        "bx--side-nav--rail",
        /*rail*/
        ctx2[2]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(nav);
      }
      if (if_block) if_block.d(detaching);
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment197.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance197($$self, $$props, $$invalidate) {
  const omit_props_names = ["fixed", "rail", "ariaLabel", "isOpen", "expansionBreakpoint"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $isSideNavRail;
  let $isSideNavCollapsed;
  validate_store(isSideNavRail, "isSideNavRail");
  component_subscribe($$self, isSideNavRail, ($$value) => $$invalidate(12, $isSideNavRail = $$value));
  validate_store(isSideNavCollapsed, "isSideNavCollapsed");
  component_subscribe($$self, isSideNavCollapsed, ($$value) => $$invalidate(13, $isSideNavCollapsed = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SideNav", slots, ["default"]);
  let { fixed = false } = $$props;
  let { rail = false } = $$props;
  let { ariaLabel = void 0 } = $$props;
  let { isOpen = false } = $$props;
  let { expansionBreakpoint = 1056 } = $$props;
  const dispatch = createEventDispatcher();
  let winWidth = void 0;
  onMount(() => {
    shouldRenderHamburgerMenu.set(true);
    return () => shouldRenderHamburgerMenu.set(false);
  });
  function onwindowresize() {
    $$invalidate(5, winWidth = window.innerWidth);
  }
  const click_handler = () => {
    dispatch("click:overlay");
    $$invalidate(0, isOpen = false);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("fixed" in $$new_props) $$invalidate(1, fixed = $$new_props.fixed);
    if ("rail" in $$new_props) $$invalidate(2, rail = $$new_props.rail);
    if ("ariaLabel" in $$new_props) $$invalidate(3, ariaLabel = $$new_props.ariaLabel);
    if ("isOpen" in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("expansionBreakpoint" in $$new_props) $$invalidate(4, expansionBreakpoint = $$new_props.expansionBreakpoint);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    fixed,
    rail,
    ariaLabel,
    isOpen,
    expansionBreakpoint,
    onMount,
    createEventDispatcher,
    shouldRenderHamburgerMenu,
    isSideNavCollapsed,
    isSideNavRail,
    dispatch,
    winWidth,
    $isSideNavRail,
    $isSideNavCollapsed
  });
  $$self.$inject_state = ($$new_props) => {
    if ("fixed" in $$props) $$invalidate(1, fixed = $$new_props.fixed);
    if ("rail" in $$props) $$invalidate(2, rail = $$new_props.rail);
    if ("ariaLabel" in $$props) $$invalidate(3, ariaLabel = $$new_props.ariaLabel);
    if ("isOpen" in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("expansionBreakpoint" in $$props) $$invalidate(4, expansionBreakpoint = $$new_props.expansionBreakpoint);
    if ("winWidth" in $$props) $$invalidate(5, winWidth = $$new_props.winWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isOpen*/
    1) {
      $: dispatch(isOpen ? "open" : "close");
    }
    if ($$self.$$.dirty & /*isOpen*/
    1) {
      $: set_store_value(isSideNavCollapsed, $isSideNavCollapsed = !isOpen, $isSideNavCollapsed);
    }
    if ($$self.$$.dirty & /*rail*/
    4) {
      $: set_store_value(isSideNavRail, $isSideNavRail = rail, $isSideNavRail);
    }
  };
  return [
    isOpen,
    fixed,
    rail,
    ariaLabel,
    expansionBreakpoint,
    winWidth,
    dispatch,
    $$restProps,
    $$scope,
    slots,
    onwindowresize,
    click_handler
  ];
}
var SideNav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance197, create_fragment197, safe_not_equal, {
      fixed: 1,
      rail: 2,
      ariaLabel: 3,
      isOpen: 0,
      expansionBreakpoint: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SideNav",
      options,
      id: create_fragment197.name
    });
  }
  get fixed() {
    throw new Error("<SideNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixed(value) {
    throw new Error("<SideNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rail() {
    throw new Error("<SideNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rail(value) {
    throw new Error("<SideNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<SideNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<SideNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<SideNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<SideNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expansionBreakpoint() {
    throw new Error("<SideNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expansionBreakpoint(value) {
    throw new Error("<SideNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SideNav_default = SideNav;

// node_modules/carbon-components-svelte/src/UIShell/SideNavItems.svelte
var file186 = "node_modules/carbon-components-svelte/src/UIShell/SideNavItems.svelte";
function create_fragment198(ctx) {
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {});
      var ul_nodes = children(ul);
      if (default_slot) default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(ul, "bx--side-nav__items", true);
      add_location(ul, file186, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment198.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance198($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SideNavItems", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<SideNavItems> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var SideNavItems = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance198, create_fragment198, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SideNavItems",
      options,
      id: create_fragment198.name
    });
  }
};
var SideNavItems_default = SideNavItems;

// node_modules/carbon-components-svelte/src/UIShell/SideNavLink.svelte
var file187 = "node_modules/carbon-components-svelte/src/UIShell/SideNavLink.svelte";
var get_icon_slot_changes8 = (dirty) => ({});
var get_icon_slot_context8 = (ctx) => ({});
function create_if_block112(ctx) {
  let div;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[8].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_icon_slot_context8
  );
  const icon_slot_or_fallback = icon_slot || fallback_block_121(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback) icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (icon_slot_or_fallback) icon_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--side-nav__icon", true);
      toggle_class(div, "bx--side-nav__icon--small", true);
      add_location(div, file187, 38, 6, 885);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_icon_slot_changes8
            ),
            get_icon_slot_context8
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*icon*/
        16)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block112.name,
    type: "if",
    source: "(38:4) {#if $$slots.icon || icon}",
    ctx
  });
  return block;
}
function fallback_block_121(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[4]
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*icon*/
      16 && switch_value !== (switch_value = /*icon*/
      ctx2[4])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_121.name,
    type: "fallback",
    source: "(43:26)            ",
    ctx
  });
  return block;
}
function fallback_block48(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*text*/
        ctx[3]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*text*/
        ctx[3]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text*/
      8) set_data_dev(
        t,
        /*text*/
        ctx2[3]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block48.name,
    type: "fallback",
    source: "(49:12)          ",
    ctx
  });
  return block;
}
function create_fragment199(ctx) {
  let li;
  let a;
  let t;
  let span;
  let a_aria_current_value;
  let a_rel_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$$slots*/
    (ctx[6].icon || /*icon*/
    ctx[4]) && create_if_block112(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block48(ctx);
  let a_levels = [
    {
      "aria-current": a_aria_current_value = /*isSelected*/
      ctx[1] ? "page" : void 0
    },
    { href: (
      /*href*/
      ctx[2]
    ) },
    {
      rel: a_rel_value = /*$$restProps*/
      ctx[5].target === "_blank" ? "noopener noreferrer" : void 0
    },
    /*$$restProps*/
    ctx[5]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      if (if_block) if_block.c();
      t = space();
      span = element("span");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      a = claim_element(li_nodes, "A", {
        "aria-current": true,
        href: true,
        rel: true
      });
      var a_nodes = children(a);
      if (if_block) if_block.l(a_nodes);
      t = claim_space(a_nodes);
      span = claim_element(a_nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot_or_fallback) default_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--side-nav__link-text", true);
      add_location(span, file187, 47, 4, 1104);
      set_attributes(a, a_data);
      toggle_class(a, "bx--side-nav__link", true);
      toggle_class(
        a,
        "bx--side-nav__link--current",
        /*isSelected*/
        ctx[1]
      );
      add_location(a, file187, 27, 2, 543);
      toggle_class(li, "bx--side-nav__item", true);
      add_location(li, file187, 26, 0, 502);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, a);
      if (if_block) if_block.m(a, null);
      append_hydration_dev(a, t);
      append_hydration_dev(a, span);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      ctx[10](a);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler*/
          ctx[9],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[6].icon || /*icon*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots, icon*/
          80) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block112(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(a, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*text*/
        8)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*isSelected*/
        2 && a_aria_current_value !== (a_aria_current_value = /*isSelected*/
        ctx2[1] ? "page" : void 0)) && { "aria-current": a_aria_current_value },
        (!current || dirty & /*href*/
        4) && { href: (
          /*href*/
          ctx2[2]
        ) },
        (!current || dirty & /*$$restProps*/
        32 && a_rel_value !== (a_rel_value = /*$$restProps*/
        ctx2[5].target === "_blank" ? "noopener noreferrer" : void 0)) && { rel: a_rel_value },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      toggle_class(a, "bx--side-nav__link", true);
      toggle_class(
        a,
        "bx--side-nav__link--current",
        /*isSelected*/
        ctx2[1]
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (if_block) if_block.d();
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment199.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance199($$self, $$props, $$invalidate) {
  const omit_props_names = ["isSelected", "href", "text", "icon", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SideNavLink", slots, ["icon", "default"]);
  const $$slots = compute_slots(slots);
  let { isSelected = false } = $$props;
  let { href = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { icon = void 0 } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isSelected" in $$new_props) $$invalidate(1, isSelected = $$new_props.isSelected);
    if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
    if ("text" in $$new_props) $$invalidate(3, text2 = $$new_props.text);
    if ("icon" in $$new_props) $$invalidate(4, icon = $$new_props.icon);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ isSelected, href, text: text2, icon, ref });
  $$self.$inject_state = ($$new_props) => {
    if ("isSelected" in $$props) $$invalidate(1, isSelected = $$new_props.isSelected);
    if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
    if ("text" in $$props) $$invalidate(3, text2 = $$new_props.text);
    if ("icon" in $$props) $$invalidate(4, icon = $$new_props.icon);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    isSelected,
    href,
    text2,
    icon,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    click_handler,
    a_binding
  ];
}
var SideNavLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance199, create_fragment199, safe_not_equal, {
      isSelected: 1,
      href: 2,
      text: 3,
      icon: 4,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SideNavLink",
      options,
      id: create_fragment199.name
    });
  }
  get isSelected() {
    throw new Error("<SideNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSelected(value) {
    throw new Error("<SideNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<SideNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<SideNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<SideNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<SideNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<SideNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<SideNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<SideNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<SideNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SideNavLink_default = SideNavLink;

// node_modules/carbon-components-svelte/src/UIShell/SideNavMenu.svelte
var file188 = "node_modules/carbon-components-svelte/src/UIShell/SideNavMenu.svelte";
var get_icon_slot_changes9 = (dirty) => ({});
var get_icon_slot_context9 = (ctx) => ({});
function create_if_block113(ctx) {
  let div;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[7].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_icon_slot_context9
  );
  const icon_slot_or_fallback = icon_slot || fallback_block49(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback) icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (icon_slot_or_fallback) icon_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--side-nav__icon", true);
      add_location(div, file188, 35, 6, 797);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_icon_slot_changes9
            ),
            get_icon_slot_context9
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*icon*/
        8)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block113.name,
    type: "if",
    source: "(35:4) {#if $$slots.icon || icon}",
    ctx
  });
  return block;
}
function fallback_block49(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[3]
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*icon*/
      8 && switch_value !== (switch_value = /*icon*/
      ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block49.name,
    type: "fallback",
    source: "(37:26)            ",
    ctx
  });
  return block;
}
function create_fragment200(ctx) {
  let li;
  let button;
  let t0;
  let span;
  let t1;
  let t2;
  let div;
  let chevrondown;
  let t3;
  let ul;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$$slots*/
    (ctx[5].icon || /*icon*/
    ctx[3]) && create_if_block113(ctx)
  );
  chevrondown = new ChevronDown_default({ $$inline: true });
  let button_levels = [
    { type: "button" },
    { "aria-expanded": (
      /*expanded*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      li = element("li");
      button = element("button");
      if (if_block) if_block.c();
      t0 = space();
      span = element("span");
      t1 = text(
        /*text*/
        ctx[2]
      );
      t2 = space();
      div = element("div");
      create_component(chevrondown.$$.fragment);
      t3 = space();
      ul = element("ul");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      button = claim_element(li_nodes, "BUTTON", { type: true, "aria-expanded": true });
      var button_nodes = children(button);
      if (if_block) if_block.l(button_nodes);
      t0 = claim_space(button_nodes);
      span = claim_element(button_nodes, "SPAN", {});
      var span_nodes = children(span);
      t1 = claim_text(
        span_nodes,
        /*text*/
        ctx[2]
      );
      span_nodes.forEach(detach_dev);
      t2 = claim_space(button_nodes);
      div = claim_element(button_nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(chevrondown.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      t3 = claim_space(li_nodes);
      ul = claim_element(li_nodes, "UL", { role: true });
      var ul_nodes = children(ul);
      if (default_slot) default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--side-nav__submenu-title", true);
      add_location(span, file188, 41, 4, 952);
      toggle_class(div, "bx--side-nav__icon", true);
      toggle_class(div, "bx--side-nav__icon--small", true);
      toggle_class(div, "bx--side-nav__submenu-chevron", true);
      add_location(div, file188, 42, 4, 1019);
      set_attributes(button, button_data);
      toggle_class(button, "bx--side-nav__submenu", true);
      add_location(button, file188, 23, 2, 543);
      attr_dev(ul, "role", "menu");
      toggle_class(ul, "bx--side-nav__menu", true);
      set_style(
        ul,
        "max-height",
        /*expanded*/
        ctx[0] ? "none" : void 0
      );
      add_location(ul, file188, 51, 2, 1291);
      toggle_class(li, "bx--side-nav__item", true);
      toggle_class(
        li,
        "bx--side-nav__item--icon",
        /*icon*/
        ctx[3]
      );
      add_location(li, file188, 22, 0, 462);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, button);
      if (if_block) if_block.m(button, null);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, span);
      append_hydration_dev(span, t1);
      append_hydration_dev(button, t2);
      append_hydration_dev(button, div);
      mount_component(chevrondown, div, null);
      if (button.autofocus) button.focus();
      ctx[9](button);
      append_hydration_dev(li, t3);
      append_hydration_dev(li, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler_1*/
            ctx[10],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[5].icon || /*icon*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots, icon*/
          40) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block113(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(button, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*text*/
      4) set_data_dev(
        t1,
        /*text*/
        ctx2[2]
      );
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & /*expanded*/
        1) && { "aria-expanded": (
          /*expanded*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
      toggle_class(button, "bx--side-nav__submenu", true);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (dirty & /*expanded*/
      1) {
        set_style(
          ul,
          "max-height",
          /*expanded*/
          ctx2[0] ? "none" : void 0
        );
      }
      if (!current || dirty & /*icon*/
      8) {
        toggle_class(
          li,
          "bx--side-nav__item--icon",
          /*icon*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(chevrondown.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(chevrondown.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (if_block) if_block.d();
      destroy_component(chevrondown);
      ctx[9](null);
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment200.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance200($$self, $$props, $$invalidate) {
  const omit_props_names = ["expanded", "text", "icon", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SideNavMenu", slots, ["icon", "default"]);
  const $$slots = compute_slots(slots);
  let { expanded = false } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { icon = void 0 } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const click_handler_13 = () => {
    $$invalidate(0, expanded = !expanded);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("expanded" in $$new_props) $$invalidate(0, expanded = $$new_props.expanded);
    if ("text" in $$new_props) $$invalidate(2, text2 = $$new_props.text);
    if ("icon" in $$new_props) $$invalidate(3, icon = $$new_props.icon);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ expanded, text: text2, icon, ref, ChevronDown: ChevronDown_default });
  $$self.$inject_state = ($$new_props) => {
    if ("expanded" in $$props) $$invalidate(0, expanded = $$new_props.expanded);
    if ("text" in $$props) $$invalidate(2, text2 = $$new_props.text);
    if ("icon" in $$props) $$invalidate(3, icon = $$new_props.icon);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    expanded,
    ref,
    text2,
    icon,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    click_handler,
    button_binding,
    click_handler_13
  ];
}
var SideNavMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance200, create_fragment200, safe_not_equal, { expanded: 0, text: 2, icon: 3, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SideNavMenu",
      options,
      id: create_fragment200.name
    });
  }
  get expanded() {
    throw new Error("<SideNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<SideNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<SideNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<SideNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<SideNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<SideNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<SideNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<SideNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SideNavMenu_default = SideNavMenu;

// node_modules/carbon-components-svelte/src/UIShell/SideNavMenuItem.svelte
var file189 = "node_modules/carbon-components-svelte/src/UIShell/SideNavMenuItem.svelte";
function fallback_block50(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*text*/
        ctx[3]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*text*/
        ctx[3]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text*/
      8) set_data_dev(
        t,
        /*text*/
        ctx2[3]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block50.name,
    type: "fallback",
    source: "(30:55) {text}",
    ctx
  });
  return block;
}
function create_fragment201(ctx) {
  let li;
  let a;
  let span;
  let a_aria_current_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block50(ctx);
  let a_levels = [
    {
      "aria-current": a_aria_current_value = /*isSelected*/
      ctx[1] ? "page" : void 0
    },
    { href: (
      /*href*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[4]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      span = element("span");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      a = claim_element(li_nodes, "A", { "aria-current": true, href: true });
      var a_nodes = children(a);
      span = claim_element(a_nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot_or_fallback) default_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--side-nav__link-text", true);
      add_location(span, file189, 29, 4, 587);
      set_attributes(a, a_data);
      toggle_class(a, "bx--side-nav__link", true);
      add_location(a, file189, 21, 2, 411);
      toggle_class(li, "bx--side-nav__menu-item", true);
      add_location(li, file189, 20, 0, 365);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, a);
      append_hydration_dev(a, span);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      ctx[8](a);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler*/
          ctx[7],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*text*/
        8)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*isSelected*/
        2 && a_aria_current_value !== (a_aria_current_value = /*isSelected*/
        ctx2[1] ? "page" : void 0)) && { "aria-current": a_aria_current_value },
        (!current || dirty & /*href*/
        4) && { href: (
          /*href*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
      toggle_class(a, "bx--side-nav__link", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      ctx[8](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment201.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance201($$self, $$props, $$invalidate) {
  const omit_props_names = ["isSelected", "href", "text", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SideNavMenuItem", slots, ["default"]);
  let { isSelected = false } = $$props;
  let { href = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isSelected" in $$new_props) $$invalidate(1, isSelected = $$new_props.isSelected);
    if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
    if ("text" in $$new_props) $$invalidate(3, text2 = $$new_props.text);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ isSelected, href, text: text2, ref });
  $$self.$inject_state = ($$new_props) => {
    if ("isSelected" in $$props) $$invalidate(1, isSelected = $$new_props.isSelected);
    if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
    if ("text" in $$props) $$invalidate(3, text2 = $$new_props.text);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    isSelected,
    href,
    text2,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    a_binding
  ];
}
var SideNavMenuItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance201, create_fragment201, safe_not_equal, { isSelected: 1, href: 2, text: 3, ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SideNavMenuItem",
      options,
      id: create_fragment201.name
    });
  }
  get isSelected() {
    throw new Error("<SideNavMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSelected(value) {
    throw new Error("<SideNavMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<SideNavMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<SideNavMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<SideNavMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<SideNavMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<SideNavMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<SideNavMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SideNavMenuItem_default = SideNavMenuItem;

// node_modules/carbon-components-svelte/src/UIShell/Content.svelte
var file190 = "node_modules/carbon-components-svelte/src/UIShell/Content.svelte";
function create_fragment202(ctx) {
  let main;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let main_levels = [
    { id: (
      /*id*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[2]
  ];
  let main_data = {};
  for (let i = 0; i < main_levels.length; i += 1) {
    main_data = assign(main_data, main_levels[i]);
  }
  const block = {
    c: function create() {
      main = element("main");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      main = claim_element(nodes, "MAIN", { id: true });
      var main_nodes = children(main);
      if (default_slot) default_slot.l(main_nodes);
      main_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(main, main_data);
      toggle_class(main, "bx--content", true);
      set_style(
        main,
        "margin-left",
        /*unsetLeftMargin*/
        ctx[1] ? 0 : void 0
      );
      add_location(main, file190, 16, 0, 504);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, main, anchor);
      if (default_slot) {
        default_slot.m(main, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(main, main_data = get_spread_update(main_levels, [
        (!current || dirty & /*id*/
        1) && { id: (
          /*id*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      toggle_class(main, "bx--content", true);
      set_style(
        main,
        "margin-left",
        /*unsetLeftMargin*/
        ctx2[1] ? 0 : void 0
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(main);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment202.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance202($$self, $$props, $$invalidate) {
  let unsetLeftMargin;
  const omit_props_names = ["id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $isSideNavRail;
  let $isSideNavCollapsed;
  validate_store(isSideNavRail, "isSideNavRail");
  component_subscribe($$self, isSideNavRail, ($$value) => $$invalidate(3, $isSideNavRail = $$value));
  validate_store(isSideNavCollapsed, "isSideNavCollapsed");
  component_subscribe($$self, isSideNavCollapsed, ($$value) => $$invalidate(4, $isSideNavCollapsed = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Content", slots, ["default"]);
  let { id = "main-content" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    id,
    isSideNavCollapsed,
    isSideNavRail,
    unsetLeftMargin,
    $isSideNavRail,
    $isSideNavCollapsed
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
    if ("unsetLeftMargin" in $$props) $$invalidate(1, unsetLeftMargin = $$new_props.unsetLeftMargin);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$isSideNavCollapsed, $isSideNavRail*/
    24) {
      $: $$invalidate(1, unsetLeftMargin = $isSideNavCollapsed && !$isSideNavRail);
    }
  };
  return [
    id,
    unsetLeftMargin,
    $$restProps,
    $isSideNavRail,
    $isSideNavCollapsed,
    $$scope,
    slots
  ];
}
var Content = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance202, create_fragment202, safe_not_equal, { id: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Content",
      options,
      id: create_fragment202.name
    });
  }
  get id() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Content_default = Content;

// node_modules/carbon-components-svelte/src/UIShell/SkipToContent.svelte
var file191 = "node_modules/carbon-components-svelte/src/UIShell/SkipToContent.svelte";
function fallback_block51(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Skip to main content");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Skip to main content");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block51.name,
    type: "fallback",
    source: "(16:8) Skip to main content",
    ctx
  });
  return block;
}
function create_fragment203(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block51(ctx);
  let a_levels = [
    { href: (
      /*href*/
      ctx[0]
    ) },
    { tabindex: (
      /*tabindex*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[2]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, tabindex: true });
      var a_nodes = children(a);
      if (default_slot_or_fallback) default_slot_or_fallback.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      toggle_class(a, "bx--skip-to-content", true);
      add_location(a, file191, 8, 0, 155);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        1) && { href: (
          /*href*/
          ctx2[0]
        ) },
        (!current || dirty & /*tabindex*/
        2) && { tabindex: (
          /*tabindex*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      toggle_class(a, "bx--skip-to-content", true);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment203.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance203($$self, $$props, $$invalidate) {
  const omit_props_names = ["href", "tabindex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SkipToContent", slots, ["default"]);
  let { href = "#main-content" } = $$props;
  let { tabindex = "0" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props) $$invalidate(0, href = $$new_props.href);
    if ("tabindex" in $$new_props) $$invalidate(1, tabindex = $$new_props.tabindex);
    if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ href, tabindex });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props) $$invalidate(0, href = $$new_props.href);
    if ("tabindex" in $$props) $$invalidate(1, tabindex = $$new_props.tabindex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [href, tabindex, $$restProps, $$scope, slots, click_handler];
}
var SkipToContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance203, create_fragment203, safe_not_equal, { href: 0, tabindex: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SkipToContent",
      options,
      id: create_fragment203.name
    });
  }
  get href() {
    throw new Error("<SkipToContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<SkipToContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<SkipToContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<SkipToContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SkipToContent_default = SkipToContent;

// node_modules/carbon-components-svelte/src/UIShell/HeaderGlobalAction.svelte
function create_icon_slot(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[1]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: { slot: "icon", size: 20 },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*icon*/
      2 && switch_value !== (switch_value = /*icon*/
      ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_icon_slot.name,
    type: "slot",
    source: "(32:2) ",
    ctx
  });
  return block;
}
function create_fragment204(ctx) {
  let button;
  let updating_ref;
  let current;
  const button_spread_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*buttonClass*/
      ctx[2]
    ) }
  ];
  function button_ref_binding(value) {
    ctx[5](value);
  }
  let button_props = {
    $$slots: { icon: [create_icon_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button_spread_levels.length; i += 1) {
    button_props = assign(button_props, button_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[0] !== void 0
  ) {
    button_props.ref = /*ref*/
    ctx[0];
  }
  button = new Button_default({ props: button_props, $$inline: true });
  binding_callbacks.push(() => bind(button, "ref", button_ref_binding));
  button.$on(
    "click",
    /*click_handler*/
    ctx[6]
  );
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const button_changes = dirty & /*$$restProps, buttonClass*/
      12 ? get_spread_update(button_spread_levels, [
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        ),
        dirty & /*buttonClass*/
        4 && { class: (
          /*buttonClass*/
          ctx2[2]
        ) }
      ]) : {};
      if (dirty & /*$$scope, icon*/
      130) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref && dirty & /*ref*/
      1) {
        updating_ref = true;
        button_changes.ref = /*ref*/
        ctx2[0];
        add_flush_callback(() => updating_ref = false);
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment204.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance204($$self, $$props, $$invalidate) {
  let buttonClass;
  const omit_props_names = ["isActive", "icon", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderGlobalAction", slots, []);
  let { isActive = false } = $$props;
  let { icon = void 0 } = $$props;
  let { ref = null } = $$props;
  function button_ref_binding(value) {
    ref = value;
    $$invalidate(0, ref);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isActive" in $$new_props) $$invalidate(4, isActive = $$new_props.isActive);
    if ("icon" in $$new_props) $$invalidate(1, icon = $$new_props.icon);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({ isActive, icon, ref, Button: Button_default, buttonClass });
  $$self.$inject_state = ($$new_props) => {
    if ("isActive" in $$props) $$invalidate(4, isActive = $$new_props.isActive);
    if ("icon" in $$props) $$invalidate(1, icon = $$new_props.icon);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    if ("buttonClass" in $$props) $$invalidate(2, buttonClass = $$new_props.buttonClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(2, buttonClass = [
      "bx--header__action",
      isActive && " bx--header__action--active",
      $$restProps.class
    ].filter(Boolean).join(" "));
  };
  return [
    ref,
    icon,
    buttonClass,
    $$restProps,
    isActive,
    button_ref_binding,
    click_handler
  ];
}
var HeaderGlobalAction = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance204, create_fragment204, safe_not_equal, { isActive: 4, icon: 1, ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderGlobalAction",
      options,
      id: create_fragment204.name
    });
  }
  get isActive() {
    throw new Error("<HeaderGlobalAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isActive(value) {
    throw new Error("<HeaderGlobalAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<HeaderGlobalAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<HeaderGlobalAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeaderGlobalAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeaderGlobalAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeaderGlobalAction_default = HeaderGlobalAction;

// node_modules/carbon-components-svelte/src/UIShell/HeaderSearch.svelte
var file192 = "node_modules/carbon-components-svelte/src/UIShell/HeaderSearch.svelte";
function add_css4(target) {
  append_styles(target, "svelte-1pqr6j1", ".bx--header__search-label{position:absolute;width:1px;height:1px;margin:-1px;padding:0;overflow:hidden;white-space:nowrap;border:0;visibility:inherit;clip:rect(0, 0, 0, 0)}.bx--header__search{position:relative;display:flex;max-width:28rem;width:100%;margin-left:0.5rem;height:3rem;background-color:#393939;color:#fff;transition:max-width 0.11s cubic-bezier(0.2, 0, 0.38, 0.9),\n      background 0.11s cubic-bezier(0.2, 0, 0.38, 0.9)}.bx--header__search:not(.bx--header__search--active){max-width:3rem;background-color:#161616}.bx--header__search.bx--header__search--active{outline:2px solid #fff;outline-offset:-2px}.bx--header__search-menu{display:flex;flex-grow:1;border-bottom:1px solid #393939}.bx--header__search-input{width:100%;height:3rem;padding:0;font-size:1rem;font-weight:400;line-height:1.375rem;letter-spacing:0;color:#fff;caret-color:#fff;background-color:initial;border:none;outline:none;transition:opacity 0.11s cubic-bezier(0.2, 0, 0.38, 0.9)}.bx--header__search-input:not(.bx--header__search--active){opacity:0;pointer-events:none}.bx--header-search-button{display:flex;align-items:center;justify-content:center;width:3rem;height:100%;padding:0;flex-shrink:0;opacity:1;transition:background-color 0.11s cubic-bezier(0.2, 0, 0.38, 0.9),\n      opacity 0.11s cubic-bezier(0.2, 0, 0.38, 0.9)}.bx--header-search-button--disabled{border:none;pointer-events:none}.bx--header-search-button:hover{background-color:#4c4c4c}.bx--header-search-button--hidden{opacity:0;display:none}.bx--header-search-menu{position:absolute;z-index:10000;padding:1rem 0;left:0;right:0;top:3rem;background-color:#161616;border:1px solid #393939;border-top:none;box-shadow:0 4px 8px 0 rgba(0, 0, 0, 0.5)}.bx--header-search-menu-item{padding:6px 1rem;cursor:pointer;font-size:0.875rem;font-weight:600;line-height:1.29;letter-spacing:0.16px;transition:all 70ms cubic-bezier(0.2, 0, 0.38, 0.9);display:block;text-decoration:none;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#c6c6c6}.bx--header-search-menu-item--selected,.bx--header-search-menu-item:hover{background-color:#353535;color:#f4f4f4}.bx--header-search-menu-description{font-size:0.75rem;font-weight:400;line-height:1.34;letter-spacing:0.32px;text-transform:lowercase;color:#c6c6c6}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyU2VhcmNoLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUEwTUUsMEJBQ0UsaUJBQWtCLENBQ2xCLFNBQVUsQ0FDVixVQUFXLENBQ1gsV0FBWSxDQUNaLFNBQVUsQ0FDVixlQUFnQixDQUNoQixrQkFBbUIsQ0FDbkIsUUFBUyxDQUNULGtCQUFtQixDQUNuQixxQkFDRixDQUVBLG9CQUNFLGlCQUFrQixDQUNsQixZQUFhLENBQ2IsZUFBZ0IsQ0FDaEIsVUFBVyxDQUNYLGtCQUFtQixDQUNuQixXQUFZLENBQ1osd0JBQXlCLENBQ3pCLFVBQVcsQ0FDWDtzREFFRixDQUVBLHFEQUNFLGNBQWUsQ0FDZix3QkFDRixDQUVBLCtDQUNFLHNCQUF1QixDQUN2QixtQkFDRixDQUVBLHlCQUNFLFlBQWEsQ0FDYixXQUFZLENBQ1osK0JBQ0YsQ0FFQSwwQkFDRSxVQUFXLENBQ1gsV0FBWSxDQUNaLFNBQVUsQ0FDVixjQUFlLENBQ2YsZUFBZ0IsQ0FDaEIsb0JBQXFCLENBQ3JCLGdCQUFpQixDQUNqQixVQUFXLENBQ1gsZ0JBQWlCLENBQ2pCLHdCQUF5QixDQUN6QixXQUFZLENBQ1osWUFBYSxDQUNiLHdEQUNGLENBRUEsMkRBQ0UsU0FBVSxDQUNWLG1CQUNGLENBRUEsMEJBQ0UsWUFBYSxDQUNiLGtCQUFtQixDQUNuQixzQkFBdUIsQ0FDdkIsVUFBVyxDQUNYLFdBQVksQ0FDWixTQUFVLENBQ1YsYUFBYyxDQUNkLFNBQVUsQ0FDVjttREFFRixDQUVBLG9DQUNFLFdBQVksQ0FDWixtQkFDRixDQUVBLGdDQUNFLHdCQUNGLENBRUEsa0NBQ0UsU0FBVSxDQUNWLFlBQ0YsQ0FFQSx3QkFDRSxpQkFBa0IsQ0FDbEIsYUFBYyxDQUNkLGNBQWUsQ0FDZixNQUFPLENBQ1AsT0FBUSxDQUNSLFFBQVMsQ0FDVCx3QkFBeUIsQ0FDekIsd0JBQXlCLENBQ3pCLGVBQWdCLENBQ2hCLHlDQUNGLENBRUEsNkJBQ0UsZ0JBQWlCLENBQ2pCLGNBQWUsQ0FDZixrQkFBbUIsQ0FDbkIsZUFBZ0IsQ0FDaEIsZ0JBQWlCLENBQ2pCLHFCQUFzQixDQUN0QixtREFBb0QsQ0FDcEQsYUFBYyxDQUNkLG9CQUFxQixDQUNyQixrQkFBbUIsQ0FDbkIsZUFBZ0IsQ0FDaEIsc0JBQXVCLENBQ3ZCLGFBQ0YsQ0FFQSwwRUFFRSx3QkFBeUIsQ0FDekIsYUFDRixDQUVBLG9DQUNFLGlCQUFrQixDQUNsQixlQUFnQixDQUNoQixnQkFBaUIsQ0FDakIscUJBQXNCLENBQ3RCLHdCQUF5QixDQUN6QixhQUNGIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJIZWFkZXJTZWFyY2guc3ZlbHRlIl19 */");
}
function get_each_context22(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i];
  child_ctx[30] = i;
  return child_ctx;
}
var get_default_slot_changes16 = (dirty) => ({ result: dirty & /*results*/
16 });
var get_default_slot_context16 = (ctx) => ({
  result: (
    /*result*/
    ctx[28]
  ),
  index: (
    /*i*/
    ctx[30]
  )
});
function create_if_block114(ctx) {
  let ul;
  let current;
  let each_value = ensure_array_like_dev(
    /*results*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block22(get_each_context22(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {
        "aria-labelledby": true,
        role: true,
        id: true
      });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "aria-labelledby", "search-label");
      attr_dev(ul, "role", "menu");
      attr_dev(ul, "id", "search-menu");
      toggle_class(ul, "bx--header-search-menu", true);
      add_location(ul, file192, 165, 4, 4475);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*results, selectedId, selectedResultIndex, selectResult, $$scope*/
      4692) {
        each_value = ensure_array_like_dev(
          /*results*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context22(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block22(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block114.name,
    type: "if",
    source: "(164:2) {#if active && results.length > 0}",
    ctx
  });
  return block;
}
function create_if_block_147(ctx) {
  let span;
  let t0;
  let t1_value = (
    /*result*/
    ctx[28].description + ""
  );
  let t1;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text("– ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, "– ");
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--header-search-menu-description", true);
      add_location(span, file192, 189, 38, 5263);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*results*/
      16 && t1_value !== (t1_value = /*result*/
      ctx2[28].description + "")) set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_147.name,
    type: "if",
    source: "(190:14) {#if result.description}",
    ctx
  });
  return block;
}
function fallback_block52(ctx) {
  let t0_value = (
    /*result*/
    ctx[28].text + ""
  );
  let t0;
  let t1;
  let if_block_anchor;
  let if_block = (
    /*result*/
    ctx[28].description && create_if_block_147(ctx)
  );
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*results*/
      16 && t0_value !== (t0_value = /*result*/
      ctx2[28].text + "")) set_data_dev(t0, t0_value);
      if (
        /*result*/
        ctx2[28].description
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_147(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block52.name,
    type: "fallback",
    source: "(188:48)                ",
    ctx
  });
  return block;
}
function create_each_block22(ctx) {
  let li;
  let a;
  let a_id_value;
  let a_href_value;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context16
  );
  const default_slot_or_fallback = default_slot || fallback_block52(ctx);
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[26](
        /*i*/
        ctx[30]
      )
    );
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { role: true });
      var li_nodes = children(li);
      a = claim_element(li_nodes, "A", {
        tabindex: true,
        id: true,
        role: true,
        href: true
      });
      var a_nodes = children(a);
      if (default_slot_or_fallback) default_slot_or_fallback.l(a_nodes);
      a_nodes.forEach(detach_dev);
      t = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "tabindex", "-1");
      attr_dev(a, "id", a_id_value = "search-menuitem-" + /*i*/
      ctx[30]);
      attr_dev(a, "role", "menuitem");
      attr_dev(a, "href", a_href_value = /*result*/
      ctx[28].href);
      toggle_class(a, "bx--header-search-menu-item", true);
      toggle_class(
        a,
        "bx--header-search-menu-item--selected",
        /*selectedId*/
        ctx[6] === `search-menuitem-${/*i*/
        ctx[30]}`
      );
      add_location(a, file192, 173, 10, 4677);
      attr_dev(li, "role", "none");
      add_location(li, file192, 172, 8, 4650);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, a);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(a, null);
      }
      append_hydration_dev(li, t);
      current = true;
      if (!mounted) {
        dispose = listen_dev(a, "click", prevent_default(click_handler_2), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, results*/
        4112)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[12],
              dirty,
              get_default_slot_changes16
            ),
            get_default_slot_context16
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*results*/
        16)) {
          default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*results*/
      16 && a_href_value !== (a_href_value = /*result*/
      ctx[28].href)) {
        attr_dev(a, "href", a_href_value);
      }
      if (!current || dirty & /*selectedId*/
      64) {
        toggle_class(
          a,
          "bx--header-search-menu-item--selected",
          /*selectedId*/
          ctx[6] === `search-menuitem-${/*i*/
          ctx[30]}`
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block22.name,
    type: "each",
    source: "(172:6) {#each results as result, i}",
    ctx
  });
  return block;
}
function create_fragment205(ctx) {
  let div1;
  let label;
  let textContent = "Search";
  let t1;
  let div0;
  let button0;
  let iconsearch;
  let button0_tabindex_value;
  let t2;
  let input;
  let input_tabindex_value;
  let t3;
  let button1;
  let close;
  let button1_tabindex_value;
  let t4;
  let current;
  let mounted;
  let dispose;
  iconsearch = new IconSearch_default({
    props: { size: 20, title: "Search" },
    $$inline: true
  });
  let input_levels = [
    { type: "text" },
    { autocomplete: "off" },
    { placeholder: "Search..." },
    {
      tabindex: input_tabindex_value = /*active*/
      ctx[0] ? "0" : "-1"
    },
    /*$$restProps*/
    ctx[10],
    { id: "search-input" },
    { "aria-autocomplete": "list" },
    { "aria-controls": "search-menu" },
    {
      "aria-activedescendant": (
        /*selectedId*/
        ctx[6]
      )
    }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  close = new Close_default({
    props: { size: 20, title: "Close" },
    $$inline: true
  });
  let if_block = (
    /*active*/
    ctx[0] && /*results*/
    ctx[4].length > 0 && create_if_block114(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      label = element("label");
      label.textContent = textContent;
      t1 = space();
      div0 = element("div");
      button0 = element("button");
      create_component(iconsearch.$$.fragment);
      t2 = space();
      input = element("input");
      t3 = space();
      button1 = element("button");
      create_component(close.$$.fragment);
      t4 = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { role: true });
      var div1_nodes = children(div1);
      label = claim_element(div1_nodes, "LABEL", {
        for: true,
        id: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(label) !== "svelte-o4tzyn") label.textContent = textContent;
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { "aria-owns": true, "aria-haspopup": true });
      var div0_nodes = children(div0);
      button0 = claim_element(div0_nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        "aria-expanded": true,
        tabindex: true
      });
      var button0_nodes = children(button0);
      claim_component(iconsearch.$$.fragment, button0_nodes);
      button0_nodes.forEach(detach_dev);
      t2 = claim_space(div0_nodes);
      input = claim_element(div0_nodes, "INPUT", {
        type: true,
        autocomplete: true,
        placeholder: true,
        tabindex: true,
        id: true,
        "aria-autocomplete": true,
        "aria-controls": true,
        "aria-activedescendant": true
      });
      t3 = claim_space(div0_nodes);
      button1 = claim_element(div0_nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        tabindex: true
      });
      var button1_nodes = children(button1);
      claim_component(close.$$.fragment, button1_nodes);
      button1_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t4 = claim_space(div1_nodes);
      if (if_block) if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label, "for", "search-input");
      attr_dev(label, "id", "search-label");
      toggle_class(label, "bx--header__search-label", true);
      add_location(label, file192, 68, 2, 1766);
      attr_dev(button0, "type", "button");
      attr_dev(button0, "aria-label", "Search");
      attr_dev(
        button0,
        "aria-expanded",
        /*active*/
        ctx[0]
      );
      attr_dev(button0, "tabindex", button0_tabindex_value = /*active*/
      ctx[0] ? "-1" : "0");
      toggle_class(button0, "bx--header-search-button", true);
      toggle_class(button0, "bx--header__action", true);
      toggle_class(
        button0,
        "bx--header-search-button--disabled",
        /*active*/
        ctx[0]
      );
      add_location(button0, file192, 78, 4, 1991);
      set_attributes(input, input_data);
      toggle_class(input, "bx--header__search-input", true);
      toggle_class(
        input,
        "bx--header__search--active",
        /*active*/
        ctx[0]
      );
      add_location(input, file192, 92, 4, 2389);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "aria-label", "Clear search");
      attr_dev(button1, "tabindex", button1_tabindex_value = /*active*/
      ctx[0] ? "0" : "-1");
      toggle_class(button1, "bx--header__action", true);
      toggle_class(button1, "bx--header-search-button", true);
      toggle_class(button1, "bx--header-search-button--hidden", !/*active*/
      ctx[0]);
      add_location(button1, file192, 147, 4, 3963);
      attr_dev(div0, "aria-owns", "search-menu");
      attr_dev(div0, "aria-haspopup", "menu");
      toggle_class(div0, "bx--header__search-menu", true);
      add_location(div0, file192, 73, 2, 1882);
      attr_dev(div1, "role", "search");
      toggle_class(div1, "bx--header__search", true);
      toggle_class(
        div1,
        "bx--header__search--active",
        /*active*/
        ctx[0]
      );
      add_location(div1, file192, 62, 0, 1633);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, label);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, button0);
      mount_component(iconsearch, button0, null);
      append_hydration_dev(div0, t2);
      append_hydration_dev(div0, input);
      if (input.autofocus) input.focus();
      ctx[22](input);
      set_input_value(
        input,
        /*value*/
        ctx[3]
      );
      append_hydration_dev(div0, t3);
      append_hydration_dev(div0, button1);
      mount_component(close, button1, null);
      append_hydration_dev(div1, t4);
      if (if_block) if_block.m(div1, null);
      ctx[27](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "mouseup",
            /*mouseup_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button0,
            "click",
            /*click_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[23]
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_1*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "paste",
            /*paste_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_1*/
            ctx[25],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*active*/
      1) {
        attr_dev(
          button0,
          "aria-expanded",
          /*active*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*active*/
      1 && button0_tabindex_value !== (button0_tabindex_value = /*active*/
      ctx2[0] ? "-1" : "0")) {
        attr_dev(button0, "tabindex", button0_tabindex_value);
      }
      if (!current || dirty & /*active*/
      1) {
        toggle_class(
          button0,
          "bx--header-search-button--disabled",
          /*active*/
          ctx2[0]
        );
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        { autocomplete: "off" },
        { placeholder: "Search..." },
        (!current || dirty & /*active*/
        1 && input_tabindex_value !== (input_tabindex_value = /*active*/
        ctx2[0] ? "0" : "-1")) && { tabindex: input_tabindex_value },
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10],
        { id: "search-input" },
        { "aria-autocomplete": "list" },
        { "aria-controls": "search-menu" },
        (!current || dirty & /*selectedId*/
        64) && {
          "aria-activedescendant": (
            /*selectedId*/
            ctx2[6]
          )
        }
      ]));
      if (dirty & /*value*/
      8 && input.value !== /*value*/
      ctx2[3]) {
        set_input_value(
          input,
          /*value*/
          ctx2[3]
        );
      }
      toggle_class(input, "bx--header__search-input", true);
      toggle_class(
        input,
        "bx--header__search--active",
        /*active*/
        ctx2[0]
      );
      if (!current || dirty & /*active*/
      1 && button1_tabindex_value !== (button1_tabindex_value = /*active*/
      ctx2[0] ? "0" : "-1")) {
        attr_dev(button1, "tabindex", button1_tabindex_value);
      }
      if (!current || dirty & /*active*/
      1) {
        toggle_class(button1, "bx--header-search-button--hidden", !/*active*/
        ctx2[0]);
      }
      if (
        /*active*/
        ctx2[0] && /*results*/
        ctx2[4].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*active, results*/
          17) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block114(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*active*/
      1) {
        toggle_class(
          div1,
          "bx--header__search--active",
          /*active*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(iconsearch.$$.fragment, local);
      transition_in(close.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconsearch.$$.fragment, local);
      transition_out(close.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_component(iconsearch);
      ctx[22](null);
      destroy_component(close);
      if (if_block) if_block.d();
      ctx[27](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment205.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance205($$self, $$props, $$invalidate) {
  let selectedResult;
  let selectedId;
  const omit_props_names = ["value", "active", "ref", "results", "selectedResultIndex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderSearch", slots, ["default"]);
  let { value = "" } = $$props;
  let { active = false } = $$props;
  let { ref = null } = $$props;
  let { results = [] } = $$props;
  let { selectedResultIndex = 0 } = $$props;
  const dispatch = createEventDispatcher();
  let refSearch = null;
  function reset() {
    $$invalidate(0, active = false);
    $$invalidate(3, value = "");
    $$invalidate(2, selectedResultIndex = 0);
  }
  function selectResult() {
    dispatch("select", {
      value,
      selectedResultIndex,
      selectedResult
    });
    reset();
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const mouseup_handler = ({ target }) => {
    if (active && !refSearch.contains(target)) $$invalidate(0, active = false);
  };
  const click_handler = () => {
    $$invalidate(0, active = true);
  };
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(3, value);
  }
  const keydown_handler_12 = (e) => {
    switch (e.key) {
      case "Enter":
        selectResult();
        break;
      case "ArrowDown":
        e.preventDefault();
        if (selectedResultIndex === results.length - 1) {
          $$invalidate(2, selectedResultIndex = 0);
        } else {
          $$invalidate(2, selectedResultIndex += 1);
        }
        break;
      case "ArrowUp":
        e.preventDefault();
        if (selectedResultIndex === 0) {
          $$invalidate(2, selectedResultIndex = results.length - 1);
        } else {
          $$invalidate(2, selectedResultIndex -= 1);
        }
        break;
      case "Escape":
        if (value === "") {
          $$invalidate(0, active = false);
        }
        $$invalidate(3, value = "");
        $$invalidate(2, selectedResultIndex = 0);
        break;
    }
  };
  const click_handler_13 = () => {
    reset();
    dispatch("clear");
  };
  const click_handler_2 = async (i) => {
    $$invalidate(2, selectedResultIndex = i);
    await tick();
    selectResult();
  };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refSearch = $$value;
      $$invalidate(5, refSearch);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props) $$invalidate(3, value = $$new_props.value);
    if ("active" in $$new_props) $$invalidate(0, active = $$new_props.active);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    if ("results" in $$new_props) $$invalidate(4, results = $$new_props.results);
    if ("selectedResultIndex" in $$new_props) $$invalidate(2, selectedResultIndex = $$new_props.selectedResultIndex);
    if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    active,
    ref,
    results,
    selectedResultIndex,
    createEventDispatcher,
    tick,
    Close: Close_default,
    IconSearch: IconSearch_default,
    dispatch,
    refSearch,
    reset,
    selectResult,
    selectedResult,
    selectedId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props) $$invalidate(3, value = $$new_props.value);
    if ("active" in $$props) $$invalidate(0, active = $$new_props.active);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("results" in $$props) $$invalidate(4, results = $$new_props.results);
    if ("selectedResultIndex" in $$props) $$invalidate(2, selectedResultIndex = $$new_props.selectedResultIndex);
    if ("refSearch" in $$props) $$invalidate(5, refSearch = $$new_props.refSearch);
    if ("selectedResult" in $$props) $$invalidate(11, selectedResult = $$new_props.selectedResult);
    if ("selectedId" in $$props) $$invalidate(6, selectedId = $$new_props.selectedId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*active, ref*/
    3) {
      $: if (active && ref) ref.focus();
    }
    if ($$self.$$.dirty & /*active, ref*/
    3) {
      $: if (!active && ref) ref.blur();
    }
    if ($$self.$$.dirty & /*active*/
    1) {
      $: dispatch(active ? "active" : "inactive");
    }
    if ($$self.$$.dirty & /*results, selectedResultIndex*/
    20) {
      $: $$invalidate(11, selectedResult = results[selectedResultIndex]);
    }
    if ($$self.$$.dirty & /*selectedResult, selectedResultIndex*/
    2052) {
      $: $$invalidate(6, selectedId = selectedResult ? `search-menuitem-${selectedResultIndex}` : void 0);
    }
  };
  return [
    active,
    ref,
    selectedResultIndex,
    value,
    results,
    refSearch,
    selectedId,
    dispatch,
    reset,
    selectResult,
    $$restProps,
    selectedResult,
    $$scope,
    slots,
    change_handler,
    input_handler,
    focus_handler,
    blur_handler,
    keydown_handler,
    paste_handler,
    mouseup_handler,
    click_handler,
    input_binding,
    input_input_handler,
    keydown_handler_12,
    click_handler_13,
    click_handler_2,
    div1_binding
  ];
}
var HeaderSearch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance205,
      create_fragment205,
      safe_not_equal,
      {
        value: 3,
        active: 0,
        ref: 1,
        results: 4,
        selectedResultIndex: 2
      },
      add_css4
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderSearch",
      options,
      id: create_fragment205.name
    });
  }
  get value() {
    throw new Error("<HeaderSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<HeaderSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<HeaderSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<HeaderSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeaderSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeaderSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get results() {
    throw new Error("<HeaderSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set results(value) {
    throw new Error("<HeaderSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedResultIndex() {
    throw new Error("<HeaderSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedResultIndex(value) {
    throw new Error("<HeaderSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeaderSearch_default = HeaderSearch;

// node_modules/carbon-components-svelte/src/UIShell/SideNavDivider.svelte
var file193 = "node_modules/carbon-components-svelte/src/UIShell/SideNavDivider.svelte";
function create_fragment206(ctx) {
  let li;
  let li_levels = [
    { role: "separator" },
    /*$$restProps*/
    ctx[0]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { role: true });
      children(li).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(li, li_data);
      toggle_class(li, "bx--side-nav__divider", true);
      add_location(li, file193, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(li, li_data = get_spread_update(li_levels, [{ role: "separator" }, dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
      toggle_class(li, "bx--side-nav__divider", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment206.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance206($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SideNavDivider", slots, []);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
var SideNavDivider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance206, create_fragment206, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SideNavDivider",
      options,
      id: create_fragment206.name
    });
  }
};
var SideNavDivider_default = SideNavDivider;
export {
  Accordion_default as Accordion,
  AccordionItem_default as AccordionItem,
  AccordionSkeleton_default as AccordionSkeleton,
  AspectRatio_default as AspectRatio,
  Breadcrumb_default as Breadcrumb,
  BreadcrumbItem_default as BreadcrumbItem,
  BreadcrumbSkeleton_default as BreadcrumbSkeleton,
  Breakpoint_default as Breakpoint,
  Button_default as Button,
  ButtonSet_default as ButtonSet,
  ButtonSkeleton_default as ButtonSkeleton,
  Checkbox_default as Checkbox,
  CheckboxSkeleton_default as CheckboxSkeleton,
  ClickableTile_default as ClickableTile,
  CodeSnippet_default as CodeSnippet,
  CodeSnippetSkeleton_default as CodeSnippetSkeleton,
  Column_default as Column,
  ComboBox_default as ComboBox,
  ComposedModal_default as ComposedModal,
  Content_default as Content,
  ContentSwitcher_default as ContentSwitcher,
  ContextMenu_default as ContextMenu,
  ContextMenuDivider_default as ContextMenuDivider,
  ContextMenuGroup_default as ContextMenuGroup,
  ContextMenuOption_default as ContextMenuOption,
  ContextMenuRadioGroup_default as ContextMenuRadioGroup,
  CopyButton_default as CopyButton,
  DataTable_default as DataTable,
  DataTableSkeleton_default as DataTableSkeleton,
  DatePicker_default as DatePicker,
  DatePickerInput_default as DatePickerInput,
  DatePickerSkeleton_default as DatePickerSkeleton,
  Dropdown_default as Dropdown,
  DropdownSkeleton_default as DropdownSkeleton,
  ExpandableTile_default as ExpandableTile,
  FileUploader_default as FileUploader,
  FileUploaderButton_default as FileUploaderButton,
  FileUploaderDropContainer_default as FileUploaderDropContainer,
  FileUploaderItem_default as FileUploaderItem,
  FileUploaderSkeleton_default as FileUploaderSkeleton,
  Filename_default as Filename,
  FluidForm_default as FluidForm,
  Form_default as Form,
  FormGroup_default as FormGroup,
  FormItem_default as FormItem,
  FormLabel_default as FormLabel,
  Grid_default as Grid,
  Header_default as Header,
  HeaderAction_default as HeaderAction,
  HeaderActionLink_default as HeaderActionLink,
  HeaderGlobalAction_default as HeaderGlobalAction,
  HeaderNav_default as HeaderNav,
  HeaderNavItem_default as HeaderNavItem,
  HeaderNavMenu_default as HeaderNavMenu,
  HeaderPanelDivider_default as HeaderPanelDivider,
  HeaderPanelLink_default as HeaderPanelLink,
  HeaderPanelLinks_default as HeaderPanelLinks,
  HeaderSearch_default as HeaderSearch,
  HeaderUtilities_default as HeaderUtilities,
  ImageLoader_default as ImageLoader,
  InlineLoading_default as InlineLoading,
  InlineNotification_default as InlineNotification,
  Link_default as Link,
  ListBox_default as ListBox,
  ListBoxField_default as ListBoxField,
  ListBoxMenu_default as ListBoxMenu,
  ListBoxMenuIcon_default as ListBoxMenuIcon,
  ListBoxMenuItem_default as ListBoxMenuItem,
  ListBoxSelection_default as ListBoxSelection,
  ListItem_default as ListItem,
  Loading_default as Loading,
  LocalStorage_default as LocalStorage,
  Modal_default as Modal,
  ModalBody_default as ModalBody,
  ModalFooter_default as ModalFooter,
  ModalHeader_default as ModalHeader,
  MultiSelect_default as MultiSelect,
  NotificationActionButton_default as NotificationActionButton,
  NotificationButton_default as NotificationButton,
  NotificationIcon_default as NotificationIcon,
  NumberInput_default as NumberInput,
  NumberInputSkeleton_default as NumberInputSkeleton,
  OrderedList_default as OrderedList,
  OutboundLink_default as OutboundLink,
  OverflowMenu_default as OverflowMenu,
  OverflowMenuItem_default as OverflowMenuItem,
  Pagination_default as Pagination,
  PaginationNav_default as PaginationNav,
  PaginationSkeleton_default as PaginationSkeleton,
  PasswordInput_default as PasswordInput,
  Popover_default as Popover,
  ProgressBar_default as ProgressBar,
  ProgressIndicator_default as ProgressIndicator,
  ProgressIndicatorSkeleton_default as ProgressIndicatorSkeleton,
  ProgressStep_default as ProgressStep,
  RadioButton_default as RadioButton,
  RadioButtonGroup_default as RadioButtonGroup,
  RadioButtonSkeleton_default as RadioButtonSkeleton,
  RadioTile_default as RadioTile,
  RecursiveList_default as RecursiveList,
  Row_default as Row,
  Search_default as Search,
  SearchSkeleton_default as SearchSkeleton,
  Select_default as Select,
  SelectItem_default as SelectItem,
  SelectItemGroup_default as SelectItemGroup,
  SelectSkeleton_default as SelectSkeleton,
  SelectableTile_default as SelectableTile,
  SideNav_default as SideNav,
  SideNavDivider_default as SideNavDivider,
  SideNavItems_default as SideNavItems,
  SideNavLink_default as SideNavLink,
  SideNavMenu_default as SideNavMenu,
  SideNavMenuItem_default as SideNavMenuItem,
  SkeletonPlaceholder_default as SkeletonPlaceholder,
  SkeletonText_default as SkeletonText,
  SkipToContent_default as SkipToContent,
  Slider_default as Slider,
  SliderSkeleton_default as SliderSkeleton,
  StructuredList_default as StructuredList,
  StructuredListBody_default as StructuredListBody,
  StructuredListCell_default as StructuredListCell,
  StructuredListHead_default as StructuredListHead,
  StructuredListInput_default as StructuredListInput,
  StructuredListRow_default as StructuredListRow,
  StructuredListSkeleton_default as StructuredListSkeleton,
  Switch_default as Switch,
  Tab_default as Tab,
  TabContent_default as TabContent,
  Table_default as Table,
  TableBody_default as TableBody,
  TableCell_default as TableCell,
  TableContainer_default as TableContainer,
  TableHead_default as TableHead,
  TableHeader_default as TableHeader,
  TableRow_default as TableRow,
  Tabs_default as Tabs,
  TabsSkeleton_default as TabsSkeleton,
  Tag_default as Tag,
  TagSkeleton_default as TagSkeleton,
  TextArea_default as TextArea,
  TextAreaSkeleton_default as TextAreaSkeleton,
  TextInput_default as TextInput,
  TextInputSkeleton_default as TextInputSkeleton,
  Theme_default as Theme,
  Tile_default as Tile,
  TileGroup_default as TileGroup,
  TimePicker_default as TimePicker,
  TimePickerSelect_default as TimePickerSelect,
  ToastNotification_default as ToastNotification,
  Toggle_default as Toggle,
  ToggleSkeleton_default as ToggleSkeleton,
  Toolbar_default as Toolbar,
  ToolbarBatchActions_default as ToolbarBatchActions,
  ToolbarContent_default as ToolbarContent,
  ToolbarMenu_default as ToolbarMenu,
  ToolbarMenuItem_default as ToolbarMenuItem,
  ToolbarSearch_default as ToolbarSearch,
  Tooltip_default as Tooltip,
  TooltipDefinition_default as TooltipDefinition,
  TooltipFooter_default as TooltipFooter,
  TooltipIcon_default as TooltipIcon,
  TreeView_default as TreeView,
  Truncate_default as Truncate,
  UnorderedList_default as UnorderedList,
  breakpointObserver_default as breakpointObserver,
  breakpoints_default as breakpoints,
  truncate_default as truncate
};
//# sourceMappingURL=carbon-components-svelte.js.map
