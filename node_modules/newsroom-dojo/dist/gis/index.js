function t(t,h){return a(parseFloat(t[1]),parseFloat(t[0]),parseFloat(h[1]),parseFloat(h[0]))}function a(t,a,h,M){var n=s(M-a);t=s(t),h=s(h);return 6371e3*Math.acos(Math.sin(t)*Math.sin(h)+Math.cos(t)*Math.cos(h)*Math.cos(n))}function h(t,a,h){var M=Number(h)/6371e3,o=s(Number(a)),r=s(t[1]),i=s(t[0]),c=Math.asin(Math.sin(r)*Math.cos(M)+Math.cos(r)*Math.sin(M)*Math.cos(o)),e=i+Math.atan2(Math.sin(o)*Math.sin(M)*Math.cos(r),Math.cos(M)-Math.sin(r)*Math.sin(c));return[n(e=(e+3*Math.PI)%(2*Math.PI)-Math.PI),n(c)]}function M(t,a){var h=s(t[1]),M=s(t[0]),o=s(a[1]),r=s(a[0])-M,i=Math.log(Math.tan(o/2+Math.PI/4)/Math.tan(h/2+Math.PI/4));return Math.abs(r)>Math.PI&&(r=r>0?-(2*Math.PI-r):2*Math.PI+r),(n(Math.atan2(r,i))+360)%360}function n(t){return 180*t/Math.PI}function s(t){return t*Math.PI/180}function o(t,a,h,M,n,s,o){const r=o*Math.PI/180,i=t*Math.PI/180,c=s-n,e=h/c*360/(2*Math.PI),u=e/2*Math.log((1+Math.sin(r))/(1-Math.sin(r)));return{x:h/c*(a-n),y:M-(e/2*Math.log((1+Math.sin(i))/(1-Math.sin(i)))-u)}}export{t as calculateDistance,o as convertGeoToPixel,h as createCoord,M as getBearing,a as sphericalCosinus,n as toDeg,s as toRad};
